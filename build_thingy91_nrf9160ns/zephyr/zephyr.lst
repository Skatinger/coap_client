
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0000c000 <_vector_table>:
    c000:	20024ee0 	.word	0x20024ee0
    c004:	0000e0b9 	.word	0x0000e0b9
    c008:	0001bc99 	.word	0x0001bc99
    c00c:	0000e0e9 	.word	0x0000e0e9
    c010:	0000e0e9 	.word	0x0000e0e9
    c014:	0000e0e9 	.word	0x0000e0e9
    c018:	0000e0e9 	.word	0x0000e0e9
    c01c:	0000e0e9 	.word	0x0000e0e9
	...
    c02c:	0000e029 	.word	0x0000e029
    c030:	0000e0e9 	.word	0x0000e0e9
    c034:	00000000 	.word	0x00000000
    c038:	0000df85 	.word	0x0000df85
    c03c:	0001bc81 	.word	0x0001bc81

0000c040 <_irq_vector_table>:
    c040:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c050:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c060:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c070:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c080:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c090:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c0a0:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c0b0:	0000fe71 0001c6d7 0000e079 0000e079     q.......y...y...
    c0c0:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c0d0:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c0e0:	0000e079 0000e079 0001c6f5 0000e079     y...y.......y...
    c0f0:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c100:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c110:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c120:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c130:	0000e079 0000e079 0000e079 0000e079     y...y...y...y...
    c140:	0000e079                                y...

0000c144 <_vector_end>:
	...

0000c200 <m_firmware_info>:
    c200:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
    c210:	00012964 00000001 0000c000 0000c000     d)..............
    c220:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0000c240 <__aeabi_dmul>:
    c240:	b570      	push	{r4, r5, r6, lr}
    c242:	f04f 0cff 	mov.w	ip, #255	; 0xff
    c246:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    c24a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    c24e:	bf1d      	ittte	ne
    c250:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    c254:	ea94 0f0c 	teqne	r4, ip
    c258:	ea95 0f0c 	teqne	r5, ip
    c25c:	f000 f8de 	bleq	c41c <__aeabi_dmul+0x1dc>
    c260:	442c      	add	r4, r5
    c262:	ea81 0603 	eor.w	r6, r1, r3
    c266:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    c26a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    c26e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    c272:	bf18      	it	ne
    c274:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    c278:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c27c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    c280:	d038      	beq.n	c2f4 <__aeabi_dmul+0xb4>
    c282:	fba0 ce02 	umull	ip, lr, r0, r2
    c286:	f04f 0500 	mov.w	r5, #0
    c28a:	fbe1 e502 	umlal	lr, r5, r1, r2
    c28e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    c292:	fbe0 e503 	umlal	lr, r5, r0, r3
    c296:	f04f 0600 	mov.w	r6, #0
    c29a:	fbe1 5603 	umlal	r5, r6, r1, r3
    c29e:	f09c 0f00 	teq	ip, #0
    c2a2:	bf18      	it	ne
    c2a4:	f04e 0e01 	orrne.w	lr, lr, #1
    c2a8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    c2ac:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    c2b0:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    c2b4:	d204      	bcs.n	c2c0 <__aeabi_dmul+0x80>
    c2b6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    c2ba:	416d      	adcs	r5, r5
    c2bc:	eb46 0606 	adc.w	r6, r6, r6
    c2c0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    c2c4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    c2c8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    c2cc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    c2d0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    c2d4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    c2d8:	bf88      	it	hi
    c2da:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    c2de:	d81e      	bhi.n	c31e <__aeabi_dmul+0xde>
    c2e0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    c2e4:	bf08      	it	eq
    c2e6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    c2ea:	f150 0000 	adcs.w	r0, r0, #0
    c2ee:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c2f2:	bd70      	pop	{r4, r5, r6, pc}
    c2f4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    c2f8:	ea46 0101 	orr.w	r1, r6, r1
    c2fc:	ea40 0002 	orr.w	r0, r0, r2
    c300:	ea81 0103 	eor.w	r1, r1, r3
    c304:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    c308:	bfc2      	ittt	gt
    c30a:	ebd4 050c 	rsbsgt	r5, r4, ip
    c30e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    c312:	bd70      	popgt	{r4, r5, r6, pc}
    c314:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c318:	f04f 0e00 	mov.w	lr, #0
    c31c:	3c01      	subs	r4, #1
    c31e:	f300 80ab 	bgt.w	c478 <__aeabi_dmul+0x238>
    c322:	f114 0f36 	cmn.w	r4, #54	; 0x36
    c326:	bfde      	ittt	le
    c328:	2000      	movle	r0, #0
    c32a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    c32e:	bd70      	pople	{r4, r5, r6, pc}
    c330:	f1c4 0400 	rsb	r4, r4, #0
    c334:	3c20      	subs	r4, #32
    c336:	da35      	bge.n	c3a4 <__aeabi_dmul+0x164>
    c338:	340c      	adds	r4, #12
    c33a:	dc1b      	bgt.n	c374 <__aeabi_dmul+0x134>
    c33c:	f104 0414 	add.w	r4, r4, #20
    c340:	f1c4 0520 	rsb	r5, r4, #32
    c344:	fa00 f305 	lsl.w	r3, r0, r5
    c348:	fa20 f004 	lsr.w	r0, r0, r4
    c34c:	fa01 f205 	lsl.w	r2, r1, r5
    c350:	ea40 0002 	orr.w	r0, r0, r2
    c354:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    c358:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c35c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c360:	fa21 f604 	lsr.w	r6, r1, r4
    c364:	eb42 0106 	adc.w	r1, r2, r6
    c368:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c36c:	bf08      	it	eq
    c36e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c372:	bd70      	pop	{r4, r5, r6, pc}
    c374:	f1c4 040c 	rsb	r4, r4, #12
    c378:	f1c4 0520 	rsb	r5, r4, #32
    c37c:	fa00 f304 	lsl.w	r3, r0, r4
    c380:	fa20 f005 	lsr.w	r0, r0, r5
    c384:	fa01 f204 	lsl.w	r2, r1, r4
    c388:	ea40 0002 	orr.w	r0, r0, r2
    c38c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c390:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    c394:	f141 0100 	adc.w	r1, r1, #0
    c398:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c39c:	bf08      	it	eq
    c39e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c3a2:	bd70      	pop	{r4, r5, r6, pc}
    c3a4:	f1c4 0520 	rsb	r5, r4, #32
    c3a8:	fa00 f205 	lsl.w	r2, r0, r5
    c3ac:	ea4e 0e02 	orr.w	lr, lr, r2
    c3b0:	fa20 f304 	lsr.w	r3, r0, r4
    c3b4:	fa01 f205 	lsl.w	r2, r1, r5
    c3b8:	ea43 0302 	orr.w	r3, r3, r2
    c3bc:	fa21 f004 	lsr.w	r0, r1, r4
    c3c0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c3c4:	fa21 f204 	lsr.w	r2, r1, r4
    c3c8:	ea20 0002 	bic.w	r0, r0, r2
    c3cc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    c3d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    c3d4:	bf08      	it	eq
    c3d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    c3da:	bd70      	pop	{r4, r5, r6, pc}
    c3dc:	f094 0f00 	teq	r4, #0
    c3e0:	d10f      	bne.n	c402 <__aeabi_dmul+0x1c2>
    c3e2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    c3e6:	0040      	lsls	r0, r0, #1
    c3e8:	eb41 0101 	adc.w	r1, r1, r1
    c3ec:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    c3f0:	bf08      	it	eq
    c3f2:	3c01      	subeq	r4, #1
    c3f4:	d0f7      	beq.n	c3e6 <__aeabi_dmul+0x1a6>
    c3f6:	ea41 0106 	orr.w	r1, r1, r6
    c3fa:	f095 0f00 	teq	r5, #0
    c3fe:	bf18      	it	ne
    c400:	4770      	bxne	lr
    c402:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    c406:	0052      	lsls	r2, r2, #1
    c408:	eb43 0303 	adc.w	r3, r3, r3
    c40c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    c410:	bf08      	it	eq
    c412:	3d01      	subeq	r5, #1
    c414:	d0f7      	beq.n	c406 <__aeabi_dmul+0x1c6>
    c416:	ea43 0306 	orr.w	r3, r3, r6
    c41a:	4770      	bx	lr
    c41c:	ea94 0f0c 	teq	r4, ip
    c420:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    c424:	bf18      	it	ne
    c426:	ea95 0f0c 	teqne	r5, ip
    c42a:	d00c      	beq.n	c446 <__aeabi_dmul+0x206>
    c42c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c430:	bf18      	it	ne
    c432:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c436:	d1d1      	bne.n	c3dc <__aeabi_dmul+0x19c>
    c438:	ea81 0103 	eor.w	r1, r1, r3
    c43c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c440:	f04f 0000 	mov.w	r0, #0
    c444:	bd70      	pop	{r4, r5, r6, pc}
    c446:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    c44a:	bf06      	itte	eq
    c44c:	4610      	moveq	r0, r2
    c44e:	4619      	moveq	r1, r3
    c450:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    c454:	d019      	beq.n	c48a <__aeabi_dmul+0x24a>
    c456:	ea94 0f0c 	teq	r4, ip
    c45a:	d102      	bne.n	c462 <__aeabi_dmul+0x222>
    c45c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    c460:	d113      	bne.n	c48a <__aeabi_dmul+0x24a>
    c462:	ea95 0f0c 	teq	r5, ip
    c466:	d105      	bne.n	c474 <__aeabi_dmul+0x234>
    c468:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    c46c:	bf1c      	itt	ne
    c46e:	4610      	movne	r0, r2
    c470:	4619      	movne	r1, r3
    c472:	d10a      	bne.n	c48a <__aeabi_dmul+0x24a>
    c474:	ea81 0103 	eor.w	r1, r1, r3
    c478:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    c47c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c480:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c484:	f04f 0000 	mov.w	r0, #0
    c488:	bd70      	pop	{r4, r5, r6, pc}
    c48a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    c48e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    c492:	bd70      	pop	{r4, r5, r6, pc}

0000c494 <__aeabi_drsub>:
    c494:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    c498:	e002      	b.n	c4a0 <__adddf3>
    c49a:	bf00      	nop

0000c49c <__aeabi_dsub>:
    c49c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000c4a0 <__adddf3>:
    c4a0:	b530      	push	{r4, r5, lr}
    c4a2:	ea4f 0441 	mov.w	r4, r1, lsl #1
    c4a6:	ea4f 0543 	mov.w	r5, r3, lsl #1
    c4aa:	ea94 0f05 	teq	r4, r5
    c4ae:	bf08      	it	eq
    c4b0:	ea90 0f02 	teqeq	r0, r2
    c4b4:	bf1f      	itttt	ne
    c4b6:	ea54 0c00 	orrsne.w	ip, r4, r0
    c4ba:	ea55 0c02 	orrsne.w	ip, r5, r2
    c4be:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    c4c2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c4c6:	f000 80e2 	beq.w	c68e <__adddf3+0x1ee>
    c4ca:	ea4f 5454 	mov.w	r4, r4, lsr #21
    c4ce:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    c4d2:	bfb8      	it	lt
    c4d4:	426d      	neglt	r5, r5
    c4d6:	dd0c      	ble.n	c4f2 <__adddf3+0x52>
    c4d8:	442c      	add	r4, r5
    c4da:	ea80 0202 	eor.w	r2, r0, r2
    c4de:	ea81 0303 	eor.w	r3, r1, r3
    c4e2:	ea82 0000 	eor.w	r0, r2, r0
    c4e6:	ea83 0101 	eor.w	r1, r3, r1
    c4ea:	ea80 0202 	eor.w	r2, r0, r2
    c4ee:	ea81 0303 	eor.w	r3, r1, r3
    c4f2:	2d36      	cmp	r5, #54	; 0x36
    c4f4:	bf88      	it	hi
    c4f6:	bd30      	pophi	{r4, r5, pc}
    c4f8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    c4fc:	ea4f 3101 	mov.w	r1, r1, lsl #12
    c500:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    c504:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    c508:	d002      	beq.n	c510 <__adddf3+0x70>
    c50a:	4240      	negs	r0, r0
    c50c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c510:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    c514:	ea4f 3303 	mov.w	r3, r3, lsl #12
    c518:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    c51c:	d002      	beq.n	c524 <__adddf3+0x84>
    c51e:	4252      	negs	r2, r2
    c520:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    c524:	ea94 0f05 	teq	r4, r5
    c528:	f000 80a7 	beq.w	c67a <__adddf3+0x1da>
    c52c:	f1a4 0401 	sub.w	r4, r4, #1
    c530:	f1d5 0e20 	rsbs	lr, r5, #32
    c534:	db0d      	blt.n	c552 <__adddf3+0xb2>
    c536:	fa02 fc0e 	lsl.w	ip, r2, lr
    c53a:	fa22 f205 	lsr.w	r2, r2, r5
    c53e:	1880      	adds	r0, r0, r2
    c540:	f141 0100 	adc.w	r1, r1, #0
    c544:	fa03 f20e 	lsl.w	r2, r3, lr
    c548:	1880      	adds	r0, r0, r2
    c54a:	fa43 f305 	asr.w	r3, r3, r5
    c54e:	4159      	adcs	r1, r3
    c550:	e00e      	b.n	c570 <__adddf3+0xd0>
    c552:	f1a5 0520 	sub.w	r5, r5, #32
    c556:	f10e 0e20 	add.w	lr, lr, #32
    c55a:	2a01      	cmp	r2, #1
    c55c:	fa03 fc0e 	lsl.w	ip, r3, lr
    c560:	bf28      	it	cs
    c562:	f04c 0c02 	orrcs.w	ip, ip, #2
    c566:	fa43 f305 	asr.w	r3, r3, r5
    c56a:	18c0      	adds	r0, r0, r3
    c56c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    c570:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c574:	d507      	bpl.n	c586 <__adddf3+0xe6>
    c576:	f04f 0e00 	mov.w	lr, #0
    c57a:	f1dc 0c00 	rsbs	ip, ip, #0
    c57e:	eb7e 0000 	sbcs.w	r0, lr, r0
    c582:	eb6e 0101 	sbc.w	r1, lr, r1
    c586:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    c58a:	d31b      	bcc.n	c5c4 <__adddf3+0x124>
    c58c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    c590:	d30c      	bcc.n	c5ac <__adddf3+0x10c>
    c592:	0849      	lsrs	r1, r1, #1
    c594:	ea5f 0030 	movs.w	r0, r0, rrx
    c598:	ea4f 0c3c 	mov.w	ip, ip, rrx
    c59c:	f104 0401 	add.w	r4, r4, #1
    c5a0:	ea4f 5244 	mov.w	r2, r4, lsl #21
    c5a4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    c5a8:	f080 809a 	bcs.w	c6e0 <__adddf3+0x240>
    c5ac:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    c5b0:	bf08      	it	eq
    c5b2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    c5b6:	f150 0000 	adcs.w	r0, r0, #0
    c5ba:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    c5be:	ea41 0105 	orr.w	r1, r1, r5
    c5c2:	bd30      	pop	{r4, r5, pc}
    c5c4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    c5c8:	4140      	adcs	r0, r0
    c5ca:	eb41 0101 	adc.w	r1, r1, r1
    c5ce:	3c01      	subs	r4, #1
    c5d0:	bf28      	it	cs
    c5d2:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
    c5d6:	d2e9      	bcs.n	c5ac <__adddf3+0x10c>
    c5d8:	f091 0f00 	teq	r1, #0
    c5dc:	bf04      	itt	eq
    c5de:	4601      	moveq	r1, r0
    c5e0:	2000      	moveq	r0, #0
    c5e2:	fab1 f381 	clz	r3, r1
    c5e6:	bf08      	it	eq
    c5e8:	3320      	addeq	r3, #32
    c5ea:	f1a3 030b 	sub.w	r3, r3, #11
    c5ee:	f1b3 0220 	subs.w	r2, r3, #32
    c5f2:	da0c      	bge.n	c60e <__adddf3+0x16e>
    c5f4:	320c      	adds	r2, #12
    c5f6:	dd08      	ble.n	c60a <__adddf3+0x16a>
    c5f8:	f102 0c14 	add.w	ip, r2, #20
    c5fc:	f1c2 020c 	rsb	r2, r2, #12
    c600:	fa01 f00c 	lsl.w	r0, r1, ip
    c604:	fa21 f102 	lsr.w	r1, r1, r2
    c608:	e00c      	b.n	c624 <__adddf3+0x184>
    c60a:	f102 0214 	add.w	r2, r2, #20
    c60e:	bfd8      	it	le
    c610:	f1c2 0c20 	rsble	ip, r2, #32
    c614:	fa01 f102 	lsl.w	r1, r1, r2
    c618:	fa20 fc0c 	lsr.w	ip, r0, ip
    c61c:	bfdc      	itt	le
    c61e:	ea41 010c 	orrle.w	r1, r1, ip
    c622:	4090      	lslle	r0, r2
    c624:	1ae4      	subs	r4, r4, r3
    c626:	bfa2      	ittt	ge
    c628:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    c62c:	4329      	orrge	r1, r5
    c62e:	bd30      	popge	{r4, r5, pc}
    c630:	ea6f 0404 	mvn.w	r4, r4
    c634:	3c1f      	subs	r4, #31
    c636:	da1c      	bge.n	c672 <__adddf3+0x1d2>
    c638:	340c      	adds	r4, #12
    c63a:	dc0e      	bgt.n	c65a <__adddf3+0x1ba>
    c63c:	f104 0414 	add.w	r4, r4, #20
    c640:	f1c4 0220 	rsb	r2, r4, #32
    c644:	fa20 f004 	lsr.w	r0, r0, r4
    c648:	fa01 f302 	lsl.w	r3, r1, r2
    c64c:	ea40 0003 	orr.w	r0, r0, r3
    c650:	fa21 f304 	lsr.w	r3, r1, r4
    c654:	ea45 0103 	orr.w	r1, r5, r3
    c658:	bd30      	pop	{r4, r5, pc}
    c65a:	f1c4 040c 	rsb	r4, r4, #12
    c65e:	f1c4 0220 	rsb	r2, r4, #32
    c662:	fa20 f002 	lsr.w	r0, r0, r2
    c666:	fa01 f304 	lsl.w	r3, r1, r4
    c66a:	ea40 0003 	orr.w	r0, r0, r3
    c66e:	4629      	mov	r1, r5
    c670:	bd30      	pop	{r4, r5, pc}
    c672:	fa21 f004 	lsr.w	r0, r1, r4
    c676:	4629      	mov	r1, r5
    c678:	bd30      	pop	{r4, r5, pc}
    c67a:	f094 0f00 	teq	r4, #0
    c67e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    c682:	bf06      	itte	eq
    c684:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    c688:	3401      	addeq	r4, #1
    c68a:	3d01      	subne	r5, #1
    c68c:	e74e      	b.n	c52c <__adddf3+0x8c>
    c68e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c692:	bf18      	it	ne
    c694:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    c698:	d029      	beq.n	c6ee <__adddf3+0x24e>
    c69a:	ea94 0f05 	teq	r4, r5
    c69e:	bf08      	it	eq
    c6a0:	ea90 0f02 	teqeq	r0, r2
    c6a4:	d005      	beq.n	c6b2 <__adddf3+0x212>
    c6a6:	ea54 0c00 	orrs.w	ip, r4, r0
    c6aa:	bf04      	itt	eq
    c6ac:	4619      	moveq	r1, r3
    c6ae:	4610      	moveq	r0, r2
    c6b0:	bd30      	pop	{r4, r5, pc}
    c6b2:	ea91 0f03 	teq	r1, r3
    c6b6:	bf1e      	ittt	ne
    c6b8:	2100      	movne	r1, #0
    c6ba:	2000      	movne	r0, #0
    c6bc:	bd30      	popne	{r4, r5, pc}
    c6be:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    c6c2:	d105      	bne.n	c6d0 <__adddf3+0x230>
    c6c4:	0040      	lsls	r0, r0, #1
    c6c6:	4149      	adcs	r1, r1
    c6c8:	bf28      	it	cs
    c6ca:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    c6ce:	bd30      	pop	{r4, r5, pc}
    c6d0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    c6d4:	bf3c      	itt	cc
    c6d6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    c6da:	bd30      	popcc	{r4, r5, pc}
    c6dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c6e0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    c6e4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    c6e8:	f04f 0000 	mov.w	r0, #0
    c6ec:	bd30      	pop	{r4, r5, pc}
    c6ee:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    c6f2:	bf1a      	itte	ne
    c6f4:	4619      	movne	r1, r3
    c6f6:	4610      	movne	r0, r2
    c6f8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    c6fc:	bf1c      	itt	ne
    c6fe:	460b      	movne	r3, r1
    c700:	4602      	movne	r2, r0
    c702:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    c706:	bf06      	itte	eq
    c708:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    c70c:	ea91 0f03 	teqeq	r1, r3
    c710:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    c714:	bd30      	pop	{r4, r5, pc}
    c716:	bf00      	nop

0000c718 <__aeabi_ui2d>:
    c718:	f090 0f00 	teq	r0, #0
    c71c:	bf04      	itt	eq
    c71e:	2100      	moveq	r1, #0
    c720:	4770      	bxeq	lr
    c722:	b530      	push	{r4, r5, lr}
    c724:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c728:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c72c:	f04f 0500 	mov.w	r5, #0
    c730:	f04f 0100 	mov.w	r1, #0
    c734:	e750      	b.n	c5d8 <__adddf3+0x138>
    c736:	bf00      	nop

0000c738 <__aeabi_i2d>:
    c738:	f090 0f00 	teq	r0, #0
    c73c:	bf04      	itt	eq
    c73e:	2100      	moveq	r1, #0
    c740:	4770      	bxeq	lr
    c742:	b530      	push	{r4, r5, lr}
    c744:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c748:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c74c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    c750:	bf48      	it	mi
    c752:	4240      	negmi	r0, r0
    c754:	f04f 0100 	mov.w	r1, #0
    c758:	e73e      	b.n	c5d8 <__adddf3+0x138>
    c75a:	bf00      	nop

0000c75c <__aeabi_f2d>:
    c75c:	0042      	lsls	r2, r0, #1
    c75e:	ea4f 01e2 	mov.w	r1, r2, asr #3
    c762:	ea4f 0131 	mov.w	r1, r1, rrx
    c766:	ea4f 7002 	mov.w	r0, r2, lsl #28
    c76a:	bf1f      	itttt	ne
    c76c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    c770:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    c774:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    c778:	4770      	bxne	lr
    c77a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    c77e:	bf08      	it	eq
    c780:	4770      	bxeq	lr
    c782:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    c786:	bf04      	itt	eq
    c788:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    c78c:	4770      	bxeq	lr
    c78e:	b530      	push	{r4, r5, lr}
    c790:	f44f 7460 	mov.w	r4, #896	; 0x380
    c794:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    c798:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    c79c:	e71c      	b.n	c5d8 <__adddf3+0x138>
    c79e:	bf00      	nop

0000c7a0 <__aeabi_ul2d>:
    c7a0:	ea50 0201 	orrs.w	r2, r0, r1
    c7a4:	bf08      	it	eq
    c7a6:	4770      	bxeq	lr
    c7a8:	b530      	push	{r4, r5, lr}
    c7aa:	f04f 0500 	mov.w	r5, #0
    c7ae:	e00a      	b.n	c7c6 <__aeabi_l2d+0x16>

0000c7b0 <__aeabi_l2d>:
    c7b0:	ea50 0201 	orrs.w	r2, r0, r1
    c7b4:	bf08      	it	eq
    c7b6:	4770      	bxeq	lr
    c7b8:	b530      	push	{r4, r5, lr}
    c7ba:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    c7be:	d502      	bpl.n	c7c6 <__aeabi_l2d+0x16>
    c7c0:	4240      	negs	r0, r0
    c7c2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    c7c6:	f44f 6480 	mov.w	r4, #1024	; 0x400
    c7ca:	f104 0432 	add.w	r4, r4, #50	; 0x32
    c7ce:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    c7d2:	f43f aed8 	beq.w	c586 <__adddf3+0xe6>
    c7d6:	f04f 0203 	mov.w	r2, #3
    c7da:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c7de:	bf18      	it	ne
    c7e0:	3203      	addne	r2, #3
    c7e2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    c7e6:	bf18      	it	ne
    c7e8:	3203      	addne	r2, #3
    c7ea:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    c7ee:	f1c2 0320 	rsb	r3, r2, #32
    c7f2:	fa00 fc03 	lsl.w	ip, r0, r3
    c7f6:	fa20 f002 	lsr.w	r0, r0, r2
    c7fa:	fa01 fe03 	lsl.w	lr, r1, r3
    c7fe:	ea40 000e 	orr.w	r0, r0, lr
    c802:	fa21 f102 	lsr.w	r1, r1, r2
    c806:	4414      	add	r4, r2
    c808:	e6bd      	b.n	c586 <__adddf3+0xe6>
    c80a:	bf00      	nop

0000c80c <__aeabi_d2f>:
    c80c:	ea4f 0241 	mov.w	r2, r1, lsl #1
    c810:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    c814:	bf24      	itt	cs
    c816:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    c81a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    c81e:	d90d      	bls.n	c83c <__aeabi_d2f+0x30>
    c820:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    c824:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    c828:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    c82c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    c830:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    c834:	bf08      	it	eq
    c836:	f020 0001 	biceq.w	r0, r0, #1
    c83a:	4770      	bx	lr
    c83c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    c840:	d121      	bne.n	c886 <__aeabi_d2f+0x7a>
    c842:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    c846:	bfbc      	itt	lt
    c848:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    c84c:	4770      	bxlt	lr
    c84e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    c852:	ea4f 5252 	mov.w	r2, r2, lsr #21
    c856:	f1c2 0218 	rsb	r2, r2, #24
    c85a:	f1c2 0c20 	rsb	ip, r2, #32
    c85e:	fa10 f30c 	lsls.w	r3, r0, ip
    c862:	fa20 f002 	lsr.w	r0, r0, r2
    c866:	bf18      	it	ne
    c868:	f040 0001 	orrne.w	r0, r0, #1
    c86c:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    c870:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    c874:	fa03 fc0c 	lsl.w	ip, r3, ip
    c878:	ea40 000c 	orr.w	r0, r0, ip
    c87c:	fa23 f302 	lsr.w	r3, r3, r2
    c880:	ea4f 0343 	mov.w	r3, r3, lsl #1
    c884:	e7cc      	b.n	c820 <__aeabi_d2f+0x14>
    c886:	ea7f 5362 	mvns.w	r3, r2, asr #21
    c88a:	d107      	bne.n	c89c <__aeabi_d2f+0x90>
    c88c:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    c890:	bf1e      	ittt	ne
    c892:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    c896:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    c89a:	4770      	bxne	lr
    c89c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    c8a0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    c8a4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    c8a8:	4770      	bx	lr
    c8aa:	bf00      	nop

0000c8ac <__aeabi_uldivmod>:
    c8ac:	b953      	cbnz	r3, c8c4 <__aeabi_uldivmod+0x18>
    c8ae:	b94a      	cbnz	r2, c8c4 <__aeabi_uldivmod+0x18>
    c8b0:	2900      	cmp	r1, #0
    c8b2:	bf08      	it	eq
    c8b4:	2800      	cmpeq	r0, #0
    c8b6:	bf1c      	itt	ne
    c8b8:	f04f 31ff 	movne.w	r1, #4294967295
    c8bc:	f04f 30ff 	movne.w	r0, #4294967295
    c8c0:	f000 b96c 	b.w	cb9c <__aeabi_idiv0>
    c8c4:	f1ad 0c08 	sub.w	ip, sp, #8
    c8c8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c8cc:	f000 f806 	bl	c8dc <__udivmoddi4>
    c8d0:	f8dd e004 	ldr.w	lr, [sp, #4]
    c8d4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c8d8:	b004      	add	sp, #16
    c8da:	4770      	bx	lr

0000c8dc <__udivmoddi4>:
    c8dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c8e0:	9d08      	ldr	r5, [sp, #32]
    c8e2:	4604      	mov	r4, r0
    c8e4:	4688      	mov	r8, r1
    c8e6:	2b00      	cmp	r3, #0
    c8e8:	d17d      	bne.n	c9e6 <__udivmoddi4+0x10a>
    c8ea:	428a      	cmp	r2, r1
    c8ec:	4617      	mov	r7, r2
    c8ee:	d93f      	bls.n	c970 <__udivmoddi4+0x94>
    c8f0:	fab2 f282 	clz	r2, r2
    c8f4:	b142      	cbz	r2, c908 <__udivmoddi4+0x2c>
    c8f6:	f1c2 0020 	rsb	r0, r2, #32
    c8fa:	4091      	lsls	r1, r2
    c8fc:	4097      	lsls	r7, r2
    c8fe:	fa24 f000 	lsr.w	r0, r4, r0
    c902:	4094      	lsls	r4, r2
    c904:	ea40 0801 	orr.w	r8, r0, r1
    c908:	ea4f 4c17 	mov.w	ip, r7, lsr #16
    c90c:	0c23      	lsrs	r3, r4, #16
    c90e:	fa1f fe87 	uxth.w	lr, r7
    c912:	fbb8 f6fc 	udiv	r6, r8, ip
    c916:	fb0c 8116 	mls	r1, ip, r6, r8
    c91a:	fb06 f00e 	mul.w	r0, r6, lr
    c91e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    c922:	4298      	cmp	r0, r3
    c924:	d905      	bls.n	c932 <__udivmoddi4+0x56>
    c926:	18fb      	adds	r3, r7, r3
    c928:	d202      	bcs.n	c930 <__udivmoddi4+0x54>
    c92a:	4298      	cmp	r0, r3
    c92c:	f200 8124 	bhi.w	cb78 <__udivmoddi4+0x29c>
    c930:	3e01      	subs	r6, #1
    c932:	1a19      	subs	r1, r3, r0
    c934:	b2a3      	uxth	r3, r4
    c936:	fbb1 f0fc 	udiv	r0, r1, ip
    c93a:	fb0c 1110 	mls	r1, ip, r0, r1
    c93e:	fb00 fe0e 	mul.w	lr, r0, lr
    c942:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c946:	45a6      	cmp	lr, r4
    c948:	d905      	bls.n	c956 <__udivmoddi4+0x7a>
    c94a:	193c      	adds	r4, r7, r4
    c94c:	d202      	bcs.n	c954 <__udivmoddi4+0x78>
    c94e:	45a6      	cmp	lr, r4
    c950:	f200 810f 	bhi.w	cb72 <__udivmoddi4+0x296>
    c954:	3801      	subs	r0, #1
    c956:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
    c95a:	eba4 040e 	sub.w	r4, r4, lr
    c95e:	2600      	movs	r6, #0
    c960:	b11d      	cbz	r5, c96a <__udivmoddi4+0x8e>
    c962:	40d4      	lsrs	r4, r2
    c964:	2300      	movs	r3, #0
    c966:	e9c5 4300 	strd	r4, r3, [r5]
    c96a:	4631      	mov	r1, r6
    c96c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c970:	b902      	cbnz	r2, c974 <__udivmoddi4+0x98>
    c972:	deff      	udf	#255	; 0xff
    c974:	fab2 f282 	clz	r2, r2
    c978:	2a00      	cmp	r2, #0
    c97a:	d150      	bne.n	ca1e <__udivmoddi4+0x142>
    c97c:	1bcb      	subs	r3, r1, r7
    c97e:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    c982:	fa1f f887 	uxth.w	r8, r7
    c986:	2601      	movs	r6, #1
    c988:	0c21      	lsrs	r1, r4, #16
    c98a:	fbb3 fcfe 	udiv	ip, r3, lr
    c98e:	fb0e 301c 	mls	r0, lr, ip, r3
    c992:	460b      	mov	r3, r1
    c994:	fb08 f90c 	mul.w	r9, r8, ip
    c998:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    c99c:	4589      	cmp	r9, r1
    c99e:	d90a      	bls.n	c9b6 <__udivmoddi4+0xda>
    c9a0:	1879      	adds	r1, r7, r1
    c9a2:	bf2c      	ite	cs
    c9a4:	2301      	movcs	r3, #1
    c9a6:	2300      	movcc	r3, #0
    c9a8:	4589      	cmp	r9, r1
    c9aa:	d902      	bls.n	c9b2 <__udivmoddi4+0xd6>
    c9ac:	2b00      	cmp	r3, #0
    c9ae:	f000 80d9 	beq.w	cb64 <__udivmoddi4+0x288>
    c9b2:	f10c 3cff 	add.w	ip, ip, #4294967295
    c9b6:	eba1 0109 	sub.w	r1, r1, r9
    c9ba:	b2a3      	uxth	r3, r4
    c9bc:	fbb1 f0fe 	udiv	r0, r1, lr
    c9c0:	fb0e 1110 	mls	r1, lr, r0, r1
    c9c4:	fb08 f800 	mul.w	r8, r8, r0
    c9c8:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c9cc:	45a0      	cmp	r8, r4
    c9ce:	d905      	bls.n	c9dc <__udivmoddi4+0x100>
    c9d0:	193c      	adds	r4, r7, r4
    c9d2:	d202      	bcs.n	c9da <__udivmoddi4+0xfe>
    c9d4:	45a0      	cmp	r8, r4
    c9d6:	f200 80c9 	bhi.w	cb6c <__udivmoddi4+0x290>
    c9da:	3801      	subs	r0, #1
    c9dc:	eba4 0408 	sub.w	r4, r4, r8
    c9e0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c9e4:	e7bc      	b.n	c960 <__udivmoddi4+0x84>
    c9e6:	428b      	cmp	r3, r1
    c9e8:	d909      	bls.n	c9fe <__udivmoddi4+0x122>
    c9ea:	2d00      	cmp	r5, #0
    c9ec:	f000 80b1 	beq.w	cb52 <__udivmoddi4+0x276>
    c9f0:	2600      	movs	r6, #0
    c9f2:	e9c5 0100 	strd	r0, r1, [r5]
    c9f6:	4630      	mov	r0, r6
    c9f8:	4631      	mov	r1, r6
    c9fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c9fe:	fab3 f683 	clz	r6, r3
    ca02:	2e00      	cmp	r6, #0
    ca04:	d146      	bne.n	ca94 <__udivmoddi4+0x1b8>
    ca06:	428b      	cmp	r3, r1
    ca08:	f0c0 80a6 	bcc.w	cb58 <__udivmoddi4+0x27c>
    ca0c:	4282      	cmp	r2, r0
    ca0e:	f240 80a3 	bls.w	cb58 <__udivmoddi4+0x27c>
    ca12:	4630      	mov	r0, r6
    ca14:	2d00      	cmp	r5, #0
    ca16:	d0a8      	beq.n	c96a <__udivmoddi4+0x8e>
    ca18:	e9c5 4800 	strd	r4, r8, [r5]
    ca1c:	e7a5      	b.n	c96a <__udivmoddi4+0x8e>
    ca1e:	4097      	lsls	r7, r2
    ca20:	f1c2 0320 	rsb	r3, r2, #32
    ca24:	fa01 f002 	lsl.w	r0, r1, r2
    ca28:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    ca2c:	40d9      	lsrs	r1, r3
    ca2e:	fa24 f303 	lsr.w	r3, r4, r3
    ca32:	fa1f f887 	uxth.w	r8, r7
    ca36:	4094      	lsls	r4, r2
    ca38:	4303      	orrs	r3, r0
    ca3a:	fbb1 f0fe 	udiv	r0, r1, lr
    ca3e:	0c1e      	lsrs	r6, r3, #16
    ca40:	fb0e 1110 	mls	r1, lr, r0, r1
    ca44:	fb00 fc08 	mul.w	ip, r0, r8
    ca48:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
    ca4c:	458c      	cmp	ip, r1
    ca4e:	d909      	bls.n	ca64 <__udivmoddi4+0x188>
    ca50:	1879      	adds	r1, r7, r1
    ca52:	bf2c      	ite	cs
    ca54:	2601      	movcs	r6, #1
    ca56:	2600      	movcc	r6, #0
    ca58:	458c      	cmp	ip, r1
    ca5a:	d902      	bls.n	ca62 <__udivmoddi4+0x186>
    ca5c:	2e00      	cmp	r6, #0
    ca5e:	f000 8093 	beq.w	cb88 <__udivmoddi4+0x2ac>
    ca62:	3801      	subs	r0, #1
    ca64:	eba1 010c 	sub.w	r1, r1, ip
    ca68:	b29b      	uxth	r3, r3
    ca6a:	fbb1 f6fe 	udiv	r6, r1, lr
    ca6e:	fb0e 1116 	mls	r1, lr, r6, r1
    ca72:	fb06 fc08 	mul.w	ip, r6, r8
    ca76:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    ca7a:	458c      	cmp	ip, r1
    ca7c:	d905      	bls.n	ca8a <__udivmoddi4+0x1ae>
    ca7e:	1879      	adds	r1, r7, r1
    ca80:	d202      	bcs.n	ca88 <__udivmoddi4+0x1ac>
    ca82:	458c      	cmp	ip, r1
    ca84:	f200 8087 	bhi.w	cb96 <__udivmoddi4+0x2ba>
    ca88:	3e01      	subs	r6, #1
    ca8a:	eba1 030c 	sub.w	r3, r1, ip
    ca8e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
    ca92:	e779      	b.n	c988 <__udivmoddi4+0xac>
    ca94:	f1c6 0720 	rsb	r7, r6, #32
    ca98:	fa03 f406 	lsl.w	r4, r3, r6
    ca9c:	fa02 fc06 	lsl.w	ip, r2, r6
    caa0:	fa01 fe06 	lsl.w	lr, r1, r6
    caa4:	40fa      	lsrs	r2, r7
    caa6:	fa20 f807 	lsr.w	r8, r0, r7
    caaa:	40f9      	lsrs	r1, r7
    caac:	fa00 f306 	lsl.w	r3, r0, r6
    cab0:	4322      	orrs	r2, r4
    cab2:	ea48 040e 	orr.w	r4, r8, lr
    cab6:	ea4f 4812 	mov.w	r8, r2, lsr #16
    caba:	ea4f 4e14 	mov.w	lr, r4, lsr #16
    cabe:	fa1f f982 	uxth.w	r9, r2
    cac2:	fbb1 faf8 	udiv	sl, r1, r8
    cac6:	fb08 111a 	mls	r1, r8, sl, r1
    caca:	fb0a f009 	mul.w	r0, sl, r9
    cace:	ea4e 4e01 	orr.w	lr, lr, r1, lsl #16
    cad2:	4570      	cmp	r0, lr
    cad4:	d90a      	bls.n	caec <__udivmoddi4+0x210>
    cad6:	eb12 0e0e 	adds.w	lr, r2, lr
    cada:	bf2c      	ite	cs
    cadc:	2101      	movcs	r1, #1
    cade:	2100      	movcc	r1, #0
    cae0:	4570      	cmp	r0, lr
    cae2:	d901      	bls.n	cae8 <__udivmoddi4+0x20c>
    cae4:	2900      	cmp	r1, #0
    cae6:	d052      	beq.n	cb8e <__udivmoddi4+0x2b2>
    cae8:	f10a 3aff 	add.w	sl, sl, #4294967295
    caec:	ebae 0e00 	sub.w	lr, lr, r0
    caf0:	b2a4      	uxth	r4, r4
    caf2:	fbbe f0f8 	udiv	r0, lr, r8
    caf6:	fb08 ee10 	mls	lr, r8, r0, lr
    cafa:	fb00 f909 	mul.w	r9, r0, r9
    cafe:	ea44 4e0e 	orr.w	lr, r4, lr, lsl #16
    cb02:	45f1      	cmp	r9, lr
    cb04:	d905      	bls.n	cb12 <__udivmoddi4+0x236>
    cb06:	eb12 0e0e 	adds.w	lr, r2, lr
    cb0a:	d201      	bcs.n	cb10 <__udivmoddi4+0x234>
    cb0c:	45f1      	cmp	r9, lr
    cb0e:	d838      	bhi.n	cb82 <__udivmoddi4+0x2a6>
    cb10:	3801      	subs	r0, #1
    cb12:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    cb16:	ebae 0e09 	sub.w	lr, lr, r9
    cb1a:	fba0 890c 	umull	r8, r9, r0, ip
    cb1e:	45ce      	cmp	lr, r9
    cb20:	4641      	mov	r1, r8
    cb22:	464c      	mov	r4, r9
    cb24:	d302      	bcc.n	cb2c <__udivmoddi4+0x250>
    cb26:	d106      	bne.n	cb36 <__udivmoddi4+0x25a>
    cb28:	4543      	cmp	r3, r8
    cb2a:	d204      	bcs.n	cb36 <__udivmoddi4+0x25a>
    cb2c:	3801      	subs	r0, #1
    cb2e:	ebb8 010c 	subs.w	r1, r8, ip
    cb32:	eb69 0402 	sbc.w	r4, r9, r2
    cb36:	b315      	cbz	r5, cb7e <__udivmoddi4+0x2a2>
    cb38:	1a5a      	subs	r2, r3, r1
    cb3a:	eb6e 0e04 	sbc.w	lr, lr, r4
    cb3e:	40f2      	lsrs	r2, r6
    cb40:	fa0e f707 	lsl.w	r7, lr, r7
    cb44:	fa2e f306 	lsr.w	r3, lr, r6
    cb48:	2600      	movs	r6, #0
    cb4a:	4317      	orrs	r7, r2
    cb4c:	e9c5 7300 	strd	r7, r3, [r5]
    cb50:	e70b      	b.n	c96a <__udivmoddi4+0x8e>
    cb52:	462e      	mov	r6, r5
    cb54:	4628      	mov	r0, r5
    cb56:	e708      	b.n	c96a <__udivmoddi4+0x8e>
    cb58:	1a84      	subs	r4, r0, r2
    cb5a:	eb61 0103 	sbc.w	r1, r1, r3
    cb5e:	2001      	movs	r0, #1
    cb60:	4688      	mov	r8, r1
    cb62:	e757      	b.n	ca14 <__udivmoddi4+0x138>
    cb64:	f1ac 0c02 	sub.w	ip, ip, #2
    cb68:	4439      	add	r1, r7
    cb6a:	e724      	b.n	c9b6 <__udivmoddi4+0xda>
    cb6c:	3802      	subs	r0, #2
    cb6e:	443c      	add	r4, r7
    cb70:	e734      	b.n	c9dc <__udivmoddi4+0x100>
    cb72:	3802      	subs	r0, #2
    cb74:	443c      	add	r4, r7
    cb76:	e6ee      	b.n	c956 <__udivmoddi4+0x7a>
    cb78:	3e02      	subs	r6, #2
    cb7a:	443b      	add	r3, r7
    cb7c:	e6d9      	b.n	c932 <__udivmoddi4+0x56>
    cb7e:	462e      	mov	r6, r5
    cb80:	e6f3      	b.n	c96a <__udivmoddi4+0x8e>
    cb82:	3802      	subs	r0, #2
    cb84:	4496      	add	lr, r2
    cb86:	e7c4      	b.n	cb12 <__udivmoddi4+0x236>
    cb88:	3802      	subs	r0, #2
    cb8a:	4439      	add	r1, r7
    cb8c:	e76a      	b.n	ca64 <__udivmoddi4+0x188>
    cb8e:	f1aa 0a02 	sub.w	sl, sl, #2
    cb92:	4496      	add	lr, r2
    cb94:	e7aa      	b.n	caec <__udivmoddi4+0x210>
    cb96:	3e02      	subs	r6, #2
    cb98:	4439      	add	r1, r7
    cb9a:	e776      	b.n	ca8a <__udivmoddi4+0x1ae>

0000cb9c <__aeabi_idiv0>:
    cb9c:	4770      	bx	lr
    cb9e:	bf00      	nop

0000cba0 <at_handler>:

	return err;
}

static void at_handler(void *context, const char *response)
{
    cba0:	b5f0      	push	{r4, r5, r6, r7, lr}
    cba2:	ed2d 8b02 	vpush	{d8}
	int err;
	bool notify = false;
	enum lte_lc_notif_type notif_type;
	struct lte_lc_evt evt;

	if (response == NULL) {
    cba6:	460c      	mov	r4, r1
{
    cba8:	b08d      	sub	sp, #52	; 0x34
	if (response == NULL) {
    cbaa:	2900      	cmp	r1, #0
    cbac:	f000 80b2 	beq.w	cd14 <at_handler+0x174>
	for (size_t i = 0; i < ARRAY_SIZE(at_notifs); i++) {
    cbb0:	2500      	movs	r5, #0
    cbb2:	4e9f      	ldr	r6, [pc, #636]	; (ce30 <at_handler+0x290>)
		if (strncmp(at_notifs[i], notif,
    cbb4:	f856 7b04 	ldr.w	r7, [r6], #4
    cbb8:	4638      	mov	r0, r7
    cbba:	f00f f9e1 	bl	1bf80 <strlen>
    cbbe:	4621      	mov	r1, r4
    cbc0:	4602      	mov	r2, r0
    cbc2:	4638      	mov	r0, r7
    cbc4:	f00f f9ef 	bl	1bfa6 <strncmp>
    cbc8:	2800      	cmp	r0, #0
    cbca:	f040 809f 	bne.w	cd0c <at_handler+0x16c>
	/* Only proceed with parsing if notification is relevant */
	if (!is_relevant_notif(response, &notif_type)) {
		return;
	}

	switch (notif_type) {
    cbce:	2d01      	cmp	r5, #1
			*type = i;
    cbd0:	b2eb      	uxtb	r3, r5
	switch (notif_type) {
    cbd2:	f000 80a3 	beq.w	cd1c <at_handler+0x17c>
    cbd6:	2b02      	cmp	r3, #2
    cbd8:	f000 80cb 	beq.w	cd72 <at_handler+0x1d2>
	size_t len = sizeof(str_buf) - 1;
    cbdc:	2609      	movs	r6, #9
	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
    cbde:	210a      	movs	r1, #10
    cbe0:	a807      	add	r0, sp, #28
	size_t len = sizeof(str_buf) - 1;
    cbe2:	9602      	str	r6, [sp, #8]
	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
    cbe4:	f010 f94e 	bl	1ce84 <at_params_list_init>
	if (err) {
    cbe8:	4605      	mov	r5, r0
    cbea:	2800      	cmp	r0, #0
    cbec:	f040 8092 	bne.w	cd14 <at_handler+0x174>
	err = at_parser_params_from_str(notification,
    cbf0:	4601      	mov	r1, r0
    cbf2:	aa07      	add	r2, sp, #28
    cbf4:	4620      	mov	r0, r4
    cbf6:	f010 f91d 	bl	1ce34 <at_parser_params_from_str>
	if (err) {
    cbfa:	4604      	mov	r4, r0
    cbfc:	2800      	cmp	r0, #0
    cbfe:	d135      	bne.n	cc6c <at_handler+0xcc>
	err = at_params_int_get(&resp_list,
    cc00:	2101      	movs	r1, #1
    cc02:	aa01      	add	r2, sp, #4
    cc04:	a807      	add	r0, sp, #28
    cc06:	f010 f9f5 	bl	1cff4 <at_params_int_get>
	if (err) {
    cc0a:	4604      	mov	r4, r0
    cc0c:	bb70      	cbnz	r0, cc6c <at_handler+0xcc>
	err = at_params_string_get(&resp_list,
    cc0e:	2102      	movs	r1, #2
    cc10:	ab02      	add	r3, sp, #8
    cc12:	aa09      	add	r2, sp, #36	; 0x24
    cc14:	a807      	add	r0, sp, #28
	*reg_status = status;
    cc16:	f89d 5004 	ldrb.w	r5, [sp, #4]
	err = at_params_string_get(&resp_list,
    cc1a:	f010 f9fe 	bl	1d01a <at_params_string_get>
	if (err) {
    cc1e:	4604      	mov	r4, r0
    cc20:	bb20      	cbnz	r0, cc6c <at_handler+0xcc>
	str_buf[len] = '\0';
    cc22:	9b02      	ldr	r3, [sp, #8]
    cc24:	aa0c      	add	r2, sp, #48	; 0x30
    cc26:	4413      	add	r3, r2
	cell->tac = strtoul(str_buf, NULL, 16);
    cc28:	4601      	mov	r1, r0
	str_buf[len] = '\0';
    cc2a:	f803 0c0c 	strb.w	r0, [r3, #-12]
	cell->tac = strtoul(str_buf, NULL, 16);
    cc2e:	2210      	movs	r2, #16
    cc30:	a809      	add	r0, sp, #36	; 0x24
    cc32:	f00f f8fe 	bl	1be32 <strtoul>
	err = at_params_string_get(&resp_list,
    cc36:	2103      	movs	r1, #3
	cell->tac = strtoul(str_buf, NULL, 16);
    cc38:	9004      	str	r0, [sp, #16]
	err = at_params_string_get(&resp_list,
    cc3a:	ab02      	add	r3, sp, #8
    cc3c:	aa09      	add	r2, sp, #36	; 0x24
    cc3e:	a807      	add	r0, sp, #28
	len = sizeof(str_buf) - 1;
    cc40:	9602      	str	r6, [sp, #8]
	err = at_params_string_get(&resp_list,
    cc42:	f010 f9ea 	bl	1d01a <at_params_string_get>
	if (err) {
    cc46:	4604      	mov	r4, r0
    cc48:	b980      	cbnz	r0, cc6c <at_handler+0xcc>
	str_buf[len] = '\0';
    cc4a:	9b02      	ldr	r3, [sp, #8]
    cc4c:	aa0c      	add	r2, sp, #48	; 0x30
    cc4e:	4413      	add	r3, r2
	cell->id = strtoul(str_buf, NULL, 16);
    cc50:	4601      	mov	r1, r0
	str_buf[len] = '\0';
    cc52:	f803 0c0c 	strb.w	r0, [r3, #-12]
	cell->id = strtoul(str_buf, NULL, 16);
    cc56:	2210      	movs	r2, #16
    cc58:	a809      	add	r0, sp, #36	; 0x24
    cc5a:	f00f f8ea 	bl	1be32 <strtoul>
	err = parse_psm_cfg(&resp_list, true, psm_cfg);
    cc5e:	2101      	movs	r1, #1
	cell->id = strtoul(str_buf, NULL, 16);
    cc60:	9003      	str	r0, [sp, #12]
	err = parse_psm_cfg(&resp_list, true, psm_cfg);
    cc62:	aa05      	add	r2, sp, #20
    cc64:	a807      	add	r0, sp, #28
    cc66:	f004 fae5 	bl	11234 <parse_psm_cfg>
    cc6a:	4604      	mov	r4, r0
	at_params_list_free(&resp_list);
    cc6c:	a807      	add	r0, sp, #28
    cc6e:	f010 f935 	bl	1cedc <at_params_list_free>
		struct lte_lc_psm_cfg psm_cfg;

		LOG_DBG("+CEREG notification: %s", log_strdup(response));

		err = parse_cereg(response, &reg_status, &cell, &psm_cfg);
		if (err) {
    cc72:	2c00      	cmp	r4, #0
    cc74:	d14e      	bne.n	cd14 <at_handler+0x174>
			LOG_ERR("Failed to parse notification (error %d): %s",
				err, log_strdup(response));
			return;
		}

		if ((reg_status == LTE_LC_NW_REG_REGISTERED_HOME) ||
    cc76:	f005 03fb 	and.w	r3, r5, #251	; 0xfb
    cc7a:	2b01      	cmp	r3, #1
    cc7c:	d102      	bne.n	cc84 <at_handler+0xe4>
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    cc7e:	486d      	ldr	r0, [pc, #436]	; (ce34 <at_handler+0x294>)
    cc80:	f00d ff26 	bl	1aad0 <z_impl_k_sem_give>
		    (reg_status == LTE_LC_NW_REG_REGISTERED_ROAMING)) {
			k_sem_give(&link);
		}

		if (!evt_handler) {
    cc84:	4c6c      	ldr	r4, [pc, #432]	; (ce38 <at_handler+0x298>)
    cc86:	6823      	ldr	r3, [r4, #0]
    cc88:	2b00      	cmp	r3, #0
    cc8a:	d043      	beq.n	cd14 <at_handler+0x174>
			return;
		}

		/* Network registration status event */
		if (reg_status != prev_reg_status) {
    cc8c:	4a6b      	ldr	r2, [pc, #428]	; (ce3c <at_handler+0x29c>)
    cc8e:	7811      	ldrb	r1, [r2, #0]
    cc90:	42a9      	cmp	r1, r5
    cc92:	d007      	beq.n	cca4 <at_handler+0x104>
			prev_reg_status = reg_status;
    cc94:	7015      	strb	r5, [r2, #0]
			evt.type = LTE_LC_EVT_NW_REG_STATUS;
    cc96:	2200      	movs	r2, #0
			evt.nw_reg_status = reg_status;
    cc98:	f88d 5028 	strb.w	r5, [sp, #40]	; 0x28
			evt.type = LTE_LC_EVT_NW_REG_STATUS;
    cc9c:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24

			evt_handler(&evt);
    cca0:	a809      	add	r0, sp, #36	; 0x24
    cca2:	4798      	blx	r3
		}

		/* Cell update event */
		if (memcmp(&cell, &prev_cell, sizeof(struct lte_lc_cell))) {
    cca4:	2208      	movs	r2, #8
    cca6:	4966      	ldr	r1, [pc, #408]	; (ce40 <at_handler+0x2a0>)
    cca8:	a803      	add	r0, sp, #12
    ccaa:	f00f f98b 	bl	1bfc4 <memcmp>
    ccae:	b178      	cbz	r0, ccd0 <at_handler+0x130>
			evt.type = LTE_LC_EVT_CELL_UPDATE;
    ccb0:	2304      	movs	r3, #4

			memcpy(&prev_cell, &cell, sizeof(struct lte_lc_cell));
    ccb2:	2208      	movs	r2, #8
    ccb4:	a903      	add	r1, sp, #12
    ccb6:	4862      	ldr	r0, [pc, #392]	; (ce40 <at_handler+0x2a0>)
			evt.type = LTE_LC_EVT_CELL_UPDATE;
    ccb8:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
			memcpy(&prev_cell, &cell, sizeof(struct lte_lc_cell));
    ccbc:	f00f f992 	bl	1bfe4 <memcpy>
			memcpy(&evt.cell, &cell, sizeof(struct lte_lc_cell));
    ccc0:	2208      	movs	r2, #8
    ccc2:	a903      	add	r1, sp, #12
    ccc4:	a80a      	add	r0, sp, #40	; 0x28
    ccc6:	f00f f98d 	bl	1bfe4 <memcpy>
			evt_handler(&evt);
    ccca:	6823      	ldr	r3, [r4, #0]
    cccc:	a809      	add	r0, sp, #36	; 0x24
    ccce:	4798      	blx	r3
		}

		/* PSM configuration update event */
		if (memcmp(&psm_cfg, &prev_psm_cfg,
    ccd0:	2208      	movs	r2, #8
    ccd2:	495c      	ldr	r1, [pc, #368]	; (ce44 <at_handler+0x2a4>)
    ccd4:	a805      	add	r0, sp, #20
    ccd6:	f00f f975 	bl	1bfc4 <memcmp>
    ccda:	b178      	cbz	r0, ccfc <at_handler+0x15c>
			   sizeof(struct lte_lc_psm_cfg))) {
			evt.type = LTE_LC_EVT_PSM_UPDATE;
    ccdc:	2301      	movs	r3, #1

			memcpy(&prev_psm_cfg, &psm_cfg,
    ccde:	2208      	movs	r2, #8
    cce0:	a905      	add	r1, sp, #20
    cce2:	4858      	ldr	r0, [pc, #352]	; (ce44 <at_handler+0x2a4>)
			evt.type = LTE_LC_EVT_PSM_UPDATE;
    cce4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
			memcpy(&prev_psm_cfg, &psm_cfg,
    cce8:	f00f f97c 	bl	1bfe4 <memcpy>
			       sizeof(struct lte_lc_psm_cfg));
			memcpy(&evt.psm_cfg, &psm_cfg,
    ccec:	2208      	movs	r2, #8
    ccee:	a905      	add	r1, sp, #20
    ccf0:	a80a      	add	r0, sp, #40	; 0x28
    ccf2:	f00f f977 	bl	1bfe4 <memcpy>
			       sizeof(struct lte_lc_psm_cfg));
			evt_handler(&evt);
    ccf6:	6823      	ldr	r3, [r4, #0]
    ccf8:	a809      	add	r0, sp, #36	; 0x24
    ccfa:	4798      	blx	r3
	bool notify = false;
    ccfc:	2300      	movs	r3, #0
	default:
		LOG_ERR("Unrecognized notification type: %d", notif_type);
		break;
	}

	if (evt_handler && notify) {
    ccfe:	4a4e      	ldr	r2, [pc, #312]	; (ce38 <at_handler+0x298>)
    cd00:	6812      	ldr	r2, [r2, #0]
    cd02:	b13a      	cbz	r2, cd14 <at_handler+0x174>
    cd04:	b133      	cbz	r3, cd14 <at_handler+0x174>
		evt_handler(&evt);
    cd06:	a809      	add	r0, sp, #36	; 0x24
    cd08:	4790      	blx	r2
    cd0a:	e003      	b.n	cd14 <at_handler+0x174>
	for (size_t i = 0; i < ARRAY_SIZE(at_notifs); i++) {
    cd0c:	3501      	adds	r5, #1
    cd0e:	2d03      	cmp	r5, #3
    cd10:	f47f af50 	bne.w	cbb4 <at_handler+0x14>
	}
}
    cd14:	b00d      	add	sp, #52	; 0x34
    cd16:	ecbd 8b02 	vpop	{d8}
    cd1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			  size_t mode_index)
{
	int err, temp_mode;
	struct at_param_list resp_list = {0};

	err = at_params_list_init(&resp_list, AT_CSCON_PARAMS_COUNT_MAX);
    cd1c:	2104      	movs	r1, #4
	struct at_param_list resp_list = {0};
    cd1e:	e9cd 0007 	strd	r0, r0, [sp, #28]
	err = at_params_list_init(&resp_list, AT_CSCON_PARAMS_COUNT_MAX);
    cd22:	a807      	add	r0, sp, #28
    cd24:	f010 f8ae 	bl	1ce84 <at_params_list_init>
	if (err) {
    cd28:	4601      	mov	r1, r0
    cd2a:	2800      	cmp	r0, #0
    cd2c:	d1f2      	bne.n	cd14 <at_handler+0x174>
		LOG_ERR("Could not init AT params list, error: %d", err);
		return err;
	}

	/* Parse CSCON response and populate AT parameter list */
	err = at_parser_params_from_str(at_response,
    cd2e:	4620      	mov	r0, r4
    cd30:	aa07      	add	r2, sp, #28
    cd32:	f010 f87f 	bl	1ce34 <at_parser_params_from_str>
					NULL,
					&resp_list);
	if (err) {
    cd36:	4604      	mov	r4, r0
    cd38:	b950      	cbnz	r0, cd50 <at_handler+0x1b0>
		LOG_ERR("Could not parse +CSCON response, error: %d", err);
		goto clean_exit;
	}

	/* Get the RRC mode from the response */
	err = at_params_int_get(&resp_list, mode_index, &temp_mode);
    cd3a:	4629      	mov	r1, r5
    cd3c:	aa05      	add	r2, sp, #20
    cd3e:	a807      	add	r0, sp, #28
    cd40:	f010 f958 	bl	1cff4 <at_params_int_get>
	if (err) {
    cd44:	4604      	mov	r4, r0
    cd46:	b918      	cbnz	r0, cd50 <at_handler+0x1b0>
		LOG_ERR("Could not get signalling mode, error: %d", err);
		goto clean_exit;
	}

	/* Check if the parsed value maps to a valid registration status */
	if (temp_mode == 0) {
    cd48:	9b05      	ldr	r3, [sp, #20]
    cd4a:	b95b      	cbnz	r3, cd64 <at_handler+0x1c4>
		*mode = LTE_LC_RRC_MODE_IDLE;
    cd4c:	f88d 0028 	strb.w	r0, [sp, #40]	; 0x28
		LOG_ERR("Invalid signalling mode: %d", temp_mode);
		err = -EINVAL;
	}

clean_exit:
	at_params_list_free(&resp_list);
    cd50:	a807      	add	r0, sp, #28
    cd52:	f010 f8c3 	bl	1cedc <at_params_list_free>
		if (err) {
    cd56:	2c00      	cmp	r4, #0
    cd58:	d1dc      	bne.n	cd14 <at_handler+0x174>
		evt.type = LTE_LC_EVT_RRC_UPDATE;
    cd5a:	2303      	movs	r3, #3
		evt.type = LTE_LC_EVT_EDRX_UPDATE;
    cd5c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
		notify = true;
    cd60:	2301      	movs	r3, #1
		break;
    cd62:	e7cc      	b.n	ccfe <at_handler+0x15e>
	} else if (temp_mode == 1) {
    cd64:	2b01      	cmp	r3, #1
		err = -EINVAL;
    cd66:	bf14      	ite	ne
    cd68:	f06f 0415 	mvnne.w	r4, #21
		*mode = LTE_LC_RRC_MODE_CONNECTED;
    cd6c:	f88d 5028 	strbeq.w	r5, [sp, #40]	; 0x28
    cd70:	e7ee      	b.n	cd50 <at_handler+0x1b0>
{
	int err;
	u8_t idx;
	struct at_param_list resp_list = {0};
	char tmp_buf[5];
	size_t len = sizeof(tmp_buf) - 1;
    cd72:	2304      	movs	r3, #4
	struct at_param_list resp_list = {0};
    cd74:	e9cd 0007 	strd	r0, r0, [sp, #28]
	err = lte_lc_system_mode_get(&sys_mode);
    cd78:	a809      	add	r0, sp, #36	; 0x24
	size_t len = sizeof(tmp_buf) - 1;
    cd7a:	9303      	str	r3, [sp, #12]
	err = lte_lc_system_mode_get(&sys_mode);
    cd7c:	f004 fb6c 	bl	11458 <lte_lc_system_mode_get>
	if (err) {
    cd80:	2800      	cmp	r0, #0
    cd82:	d1c7      	bne.n	cd14 <at_handler+0x174>
	switch (sys_mode) {
    cd84:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
    cd88:	3b01      	subs	r3, #1
    cd8a:	2b04      	cmp	r3, #4
    cd8c:	d8c2      	bhi.n	cd14 <at_handler+0x174>
    cd8e:	a201      	add	r2, pc, #4	; (adr r2, cd94 <at_handler+0x1f4>)
    cd90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    cd94:	0000cdf7 	.word	0x0000cdf7
    cd98:	0000cda9 	.word	0x0000cda9
    cd9c:	0000cd15 	.word	0x0000cd15
    cda0:	0000cdf7 	.word	0x0000cdf7
    cda4:	0000cda9 	.word	0x0000cda9
		*ptw_multiplier = 2.56;
    cda8:	ed9f 8a27 	vldr	s16, [pc, #156]	; ce48 <at_handler+0x2a8>
	err = get_ptw_multiplier(&ptw_multiplier);
	if (err) {
		return err;
	}

	err = at_params_list_init(&resp_list, AT_CEDRXP_PARAMS_COUNT_MAX);
    cdac:	2105      	movs	r1, #5
    cdae:	a807      	add	r0, sp, #28
    cdb0:	f010 f868 	bl	1ce84 <at_params_list_init>
	if (err) {
    cdb4:	4601      	mov	r1, r0
    cdb6:	2800      	cmp	r0, #0
    cdb8:	d1ac      	bne.n	cd14 <at_handler+0x174>
		LOG_ERR("Could not init AT params list, error: %d", err);
		return err;
	}

	/* Parse CEDRXP response and populate AT parameter list */
	err = at_parser_params_from_str(at_response,
    cdba:	4620      	mov	r0, r4
    cdbc:	aa07      	add	r2, sp, #28
    cdbe:	f010 f839 	bl	1ce34 <at_parser_params_from_str>
					NULL,
					&resp_list);
	if (err) {
    cdc2:	4604      	mov	r4, r0
    cdc4:	bb58      	cbnz	r0, ce1e <at_handler+0x27e>
		LOG_ERR("Could not parse +CEDRXP response, error: %d", err);
		goto clean_exit;
	}

	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_EDRX_INDEX,
    cdc6:	2103      	movs	r1, #3
    cdc8:	ab03      	add	r3, sp, #12
    cdca:	aa05      	add	r2, sp, #20
    cdcc:	a807      	add	r0, sp, #28
    cdce:	f010 f924 	bl	1d01a <at_params_string_get>
				   tmp_buf, &len);
	if (err) {
    cdd2:	4604      	mov	r4, r0
    cdd4:	bb18      	cbnz	r0, ce1e <at_handler+0x27e>
		LOG_ERR("Failed to get eDRX configuration, error: %d", err);
		goto clean_exit;
	}

	tmp_buf[len] = '\0';
    cdd6:	9b03      	ldr	r3, [sp, #12]
    cdd8:	aa0c      	add	r2, sp, #48	; 0x30
    cdda:	4413      	add	r3, r2
	 * special case of idx == 0 for LTE-M, where the value is 5.12 seconds.
	 * The variable idx is used to map to the entry of index idx in
	 * Figure 10.5.5.32/3GPP TS 24.008, table for eDRX in S1 mode, and
	 * note 4 and 5 are taken into account.
	 */
	idx = strtoul(tmp_buf, NULL, 2);
    cddc:	4601      	mov	r1, r0
	tmp_buf[len] = '\0';
    cdde:	f803 0c1c 	strb.w	r0, [r3, #-28]
	idx = strtoul(tmp_buf, NULL, 2);
    cde2:	2202      	movs	r2, #2
    cde4:	a805      	add	r0, sp, #20
    cde6:	f00f f824 	bl	1be32 <strtoul>
	if ((edrx_value == NULL) || (idx > ARRAY_SIZE(edrx_lookup_ltem) - 1)) {
    cdea:	b2c5      	uxtb	r5, r0
    cdec:	2d0f      	cmp	r5, #15
    cdee:	d905      	bls.n	cdfc <at_handler+0x25c>
	 * for paging time window (both for LTE-M and NB1).
	 */
	idx = strtoul(tmp_buf, NULL, 2);
	if (idx > 15) {
		LOG_ERR("Invalid PTW lookup index: %d", idx);
		err = -EINVAL;
    cdf0:	f06f 0415 	mvn.w	r4, #21
    cdf4:	e013      	b.n	ce1e <at_handler+0x27e>
		*ptw_multiplier = 1.28;
    cdf6:	ed9f 8a15 	vldr	s16, [pc, #84]	; ce4c <at_handler+0x2ac>
    cdfa:	e7d7      	b.n	cdac <at_handler+0x20c>
	err = lte_lc_system_mode_get(&sys_mode);
    cdfc:	a802      	add	r0, sp, #8
    cdfe:	f004 fb2b 	bl	11458 <lte_lc_system_mode_get>
	if (err) {
    ce02:	4604      	mov	r4, r0
    ce04:	b958      	cbnz	r0, ce1e <at_handler+0x27e>
	switch (sys_mode) {
    ce06:	f89d 3008 	ldrb.w	r3, [sp, #8]
    ce0a:	3b01      	subs	r3, #1
    ce0c:	2b04      	cmp	r3, #4
    ce0e:	d804      	bhi.n	ce1a <at_handler+0x27a>
    ce10:	e8df f003 	tbb	[pc, r3]
    ce14:	1e034e1e 	.word	0x1e034e1e
    ce18:	4e          	.byte	0x4e
    ce19:	00          	.byte	0x00
		return -ENOTCONN;
    ce1a:	f06f 0438 	mvn.w	r4, #56	; 0x38
		(int)(100 * (cfg->edrx - (int)cfg->edrx)),
		(int)cfg->ptw,
		(int)(100 * (cfg->ptw - (int)cfg->ptw)));

clean_exit:
	at_params_list_free(&resp_list);
    ce1e:	a807      	add	r0, sp, #28
    ce20:	f010 f85c 	bl	1cedc <at_params_list_free>
		if (err) {
    ce24:	2c00      	cmp	r4, #0
    ce26:	f47f af75 	bne.w	cd14 <at_handler+0x174>
		evt.type = LTE_LC_EVT_EDRX_UPDATE;
    ce2a:	2302      	movs	r3, #2
    ce2c:	e796      	b.n	cd5c <at_handler+0x1bc>
    ce2e:	bf00      	nop
    ce30:	0001dd68 	.word	0x0001dd68
    ce34:	20020530 	.word	0x20020530
    ce38:	2002052c 	.word	0x2002052c
    ce3c:	20023666 	.word	0x20023666
    ce40:	20020548 	.word	0x20020548
    ce44:	20020550 	.word	0x20020550
    ce48:	4023d70a 	.word	0x4023d70a
    ce4c:	3fa3d70a 	.word	0x3fa3d70a
		multiplier = edrx_lookup_ltem[idx];
    ce50:	4b1b      	ldr	r3, [pc, #108]	; (cec0 <at_handler+0x320>)
		multiplier = edrx_lookup_nbiot[idx];
    ce52:	f833 0015 	ldrh.w	r0, [r3, r5, lsl #1]
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
    ce56:	b368      	cbz	r0, ceb4 <at_handler+0x314>
    ce58:	f7ff fc6e 	bl	c738 <__aeabi_i2d>
    ce5c:	a316      	add	r3, pc, #88	; (adr r3, ceb8 <at_handler+0x318>)
    ce5e:	e9d3 2300 	ldrd	r2, r3, [r3]
    ce62:	f7ff f9ed 	bl	c240 <__aeabi_dmul>
    ce66:	f7ff fcd1 	bl	c80c <__aeabi_d2f>
	len = sizeof(tmp_buf) - 1;
    ce6a:	2104      	movs	r1, #4
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
    ce6c:	900a      	str	r0, [sp, #40]	; 0x28
	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_PTW_INDEX,
    ce6e:	ab03      	add	r3, sp, #12
    ce70:	aa05      	add	r2, sp, #20
    ce72:	a807      	add	r0, sp, #28
	len = sizeof(tmp_buf) - 1;
    ce74:	9103      	str	r1, [sp, #12]
	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_PTW_INDEX,
    ce76:	f010 f8d0 	bl	1d01a <at_params_string_get>
	if (err) {
    ce7a:	4604      	mov	r4, r0
    ce7c:	2800      	cmp	r0, #0
    ce7e:	d1ce      	bne.n	ce1e <at_handler+0x27e>
	tmp_buf[len] = '\0';
    ce80:	9b03      	ldr	r3, [sp, #12]
    ce82:	aa0c      	add	r2, sp, #48	; 0x30
    ce84:	4413      	add	r3, r2
    ce86:	f803 0c1c 	strb.w	r0, [r3, #-28]
	idx = strtoul(tmp_buf, NULL, 2);
    ce8a:	4601      	mov	r1, r0
    ce8c:	2202      	movs	r2, #2
    ce8e:	a805      	add	r0, sp, #20
    ce90:	f00e ffcf 	bl	1be32 <strtoul>
	if (idx > 15) {
    ce94:	b2c3      	uxtb	r3, r0
    ce96:	2b0f      	cmp	r3, #15
    ce98:	d8aa      	bhi.n	cdf0 <at_handler+0x250>
	idx += 1;
    ce9a:	3001      	adds	r0, #1
	cfg->ptw = idx * ptw_multiplier;
    ce9c:	b2c0      	uxtb	r0, r0
    ce9e:	ee07 0a90 	vmov	s15, r0
    cea2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    cea6:	ee67 7a88 	vmul.f32	s15, s15, s16
    ceaa:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
clean_exit:
    ceae:	e7b6      	b.n	ce1e <at_handler+0x27e>
		multiplier = edrx_lookup_nbiot[idx];
    ceb0:	4b04      	ldr	r3, [pc, #16]	; (cec4 <at_handler+0x324>)
    ceb2:	e7ce      	b.n	ce52 <at_handler+0x2b2>
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
    ceb4:	4804      	ldr	r0, [pc, #16]	; (cec8 <at_handler+0x328>)
    ceb6:	e7d8      	b.n	ce6a <at_handler+0x2ca>
    ceb8:	47ae147b 	.word	0x47ae147b
    cebc:	40247ae1 	.word	0x40247ae1
    cec0:	0001e0f8 	.word	0x0001e0f8
    cec4:	0001e118 	.word	0x0001e118
    cec8:	40a3d70a 	.word	0x40a3d70a

0000cecc <bsd_recoverable_error_handler>:

#if defined(CONFIG_BSD_LIBRARY)

/**@brief Recoverable BSD library error. */
void bsd_recoverable_error_handler(uint32_t err)
{
    cecc:	4601      	mov	r1, r0
	printk("bsdlib recoverable error: %u\n", (unsigned int)err);
    cece:	4801      	ldr	r0, [pc, #4]	; (ced4 <bsd_recoverable_error_handler+0x8>)
    ced0:	f00e b8e9 	b.w	1b0a6 <printk>
    ced4:	0001e138 	.word	0x0001e138

0000ced8 <main>:

	return 0;
}

void main(void)
{
    ced8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct addrinfo hints = {
    cedc:	2401      	movs	r4, #1
    cede:	2602      	movs	r6, #2
{
    cee0:	b0a3      	sub	sp, #140	; 0x8c
	s64_t next_msg_time = APP_COAP_SEND_INTERVAL_MS;
	int err, received;

	printk("The nRF CoAP client sample started\n");
    cee2:	48b5      	ldr	r0, [pc, #724]	; (d1b8 <main+0x2e0>)
    cee4:	f00e f8df 	bl	1b0a6 <printk>
		printk("LTE Link Connecting ...\n");
    cee8:	48b4      	ldr	r0, [pc, #720]	; (d1bc <main+0x2e4>)
    ceea:	f00e f8dc 	bl	1b0a6 <printk>
	struct addrinfo hints = {
    ceee:	af0e      	add	r7, sp, #56	; 0x38
		err = lte_lc_init_and_connect();
    cef0:	f010 f8cb 	bl	1d08a <lte_lc_init_and_connect>
		printk("LTE Link Connected!\n");
    cef4:	48b2      	ldr	r0, [pc, #712]	; (d1c0 <main+0x2e8>)
    cef6:	f00e f8d6 	bl	1b0a6 <printk>
	struct addrinfo hints = {
    cefa:	2250      	movs	r2, #80	; 0x50
    cefc:	2100      	movs	r1, #0
    cefe:	4638      	mov	r0, r7
    cf00:	f00f f89b 	bl	1c03a <memset>

static inline int getaddrinfo(const char *host, const char *service,
			      const struct zsock_addrinfo *hints,
			      struct zsock_addrinfo **res)
{
	return zsock_getaddrinfo(host, service, hints, res);
    cf04:	2100      	movs	r1, #0
    cf06:	463a      	mov	r2, r7
    cf08:	48ae      	ldr	r0, [pc, #696]	; (d1c4 <main+0x2ec>)
    cf0a:	ab08      	add	r3, sp, #32
    cf0c:	e9cd 4610 	strd	r4, r6, [sp, #64]	; 0x40
    cf10:	f00e fe0c 	bl	1bb2c <zsock_getaddrinfo>
	if (err != 0) {
    cf14:	4601      	mov	r1, r0
    cf16:	b140      	cbz	r0, cf2a <main+0x52>
		printk("ERROR: getaddrinfo failed %d\n", err);
    cf18:	48ab      	ldr	r0, [pc, #684]	; (d1c8 <main+0x2f0>)
    cf1a:	f00e f8c4 	bl	1b0a6 <printk>

	modem_configure();

	if (server_resolve() != 0) {
		printk("Failed to resolve server name\n");
    cf1e:	48ab      	ldr	r0, [pc, #684]	; (d1cc <main+0x2f4>)
		return;
	}

	if (client_init() != 0) {
		printk("Failed to initialize CoAP client\n");
    cf20:	f00e f8c1 	bl	1b0a6 <printk>
			break;
		}
	}

	(void)close(sock);
}
    cf24:	b023      	add	sp, #140	; 0x8c
    cf26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (result == NULL) {
    cf2a:	9b08      	ldr	r3, [sp, #32]
    cf2c:	b91b      	cbnz	r3, cf36 <main+0x5e>
		printk("ERROR: Address not found\n");
    cf2e:	48a8      	ldr	r0, [pc, #672]	; (d1d0 <main+0x2f8>)
    cf30:	f00e f8b9 	bl	1b0a6 <printk>
		return -ENOENT;
    cf34:	e7f3      	b.n	cf1e <main+0x46>
		((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;
    cf36:	699b      	ldr	r3, [r3, #24]
	server4->sin_addr.s_addr =
    cf38:	4da6      	ldr	r5, [pc, #664]	; (d1d4 <main+0x2fc>)
		((struct sockaddr_in *)result->ai_addr)->sin_addr.s_addr;
    cf3a:	685b      	ldr	r3, [r3, #4]
	server4->sin_family = AF_INET;
    cf3c:	802c      	strh	r4, [r5, #0]
	server4->sin_addr.s_addr =
    cf3e:	606b      	str	r3, [r5, #4]
	server4->sin_port = htons(CONFIG_COAP_SERVER_PORT);
    cf40:	f243 3316 	movw	r3, #13078	; 0x3316
    cf44:	806b      	strh	r3, [r5, #2]
	if (z_syscall_trap()) {
		return (char *) arch_syscall_invoke4(*(uintptr_t *)&family, *(uintptr_t *)&src, *(uintptr_t *)&dst, *(uintptr_t *)&size, K_SYSCALL_NET_ADDR_NTOP);
	}
#endif
	compiler_barrier();
	return z_impl_net_addr_ntop(family, src, dst, size);
    cf46:	2310      	movs	r3, #16
    cf48:	aa0a      	add	r2, sp, #40	; 0x28
    cf4a:	1d29      	adds	r1, r5, #4
    cf4c:	4620      	mov	r0, r4
    cf4e:	f002 f93f 	bl	f1d0 <z_impl_net_addr_ntop>
	printk("IPv4 Address found %s\n", ipv4_addr);
    cf52:	a90a      	add	r1, sp, #40	; 0x28
    cf54:	48a0      	ldr	r0, [pc, #640]	; (d1d8 <main+0x300>)
    cf56:	f00e f8a6 	bl	1b0a6 <printk>
}

static inline void freeaddrinfo(struct zsock_addrinfo *ai)
{
	zsock_freeaddrinfo(ai);
    cf5a:	9808      	ldr	r0, [sp, #32]
    cf5c:	f00e fde8 	bl	1bb30 <zsock_freeaddrinfo>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&family, *(uintptr_t *)&type, *(uintptr_t *)&proto, K_SYSCALL_ZSOCK_SOCKET);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_socket(family, type, proto);
    cf60:	2211      	movs	r2, #17
    cf62:	4631      	mov	r1, r6
    cf64:	4620      	mov	r0, r4
    cf66:	f000 fc43 	bl	d7f0 <z_impl_zsock_socket>
	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    cf6a:	4e9c      	ldr	r6, [pc, #624]	; (d1dc <main+0x304>)
	if (sock < 0) {
    cf6c:	2800      	cmp	r0, #0
	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    cf6e:	6030      	str	r0, [r6, #0]
	if (sock < 0) {
    cf70:	da0c      	bge.n	cf8c <main+0xb4>
		printk("Failed to create CoAP socket: %d.\n", errno);
    cf72:	f00e f873 	bl	1b05c <z_errno>
    cf76:	6801      	ldr	r1, [r0, #0]
    cf78:	4899      	ldr	r0, [pc, #612]	; (d1e0 <main+0x308>)
		printk("Connect failed : %d\n", errno);
    cf7a:	f00e f894 	bl	1b0a6 <printk>
		return -errno;
    cf7e:	f00e f86d 	bl	1b05c <z_errno>
    cf82:	6803      	ldr	r3, [r0, #0]
    cf84:	425b      	negs	r3, r3
	if (client_init() != 0) {
    cf86:	b1a3      	cbz	r3, cfb2 <main+0xda>
		printk("Failed to initialize CoAP client\n");
    cf88:	4896      	ldr	r0, [pc, #600]	; (d1e4 <main+0x30c>)
    cf8a:	e7c9      	b.n	cf20 <main+0x48>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sock, *(uintptr_t *)&addr, *(uintptr_t *)&addrlen, K_SYSCALL_ZSOCK_CONNECT);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_connect(sock, addr, addrlen);
    cf8c:	2208      	movs	r2, #8
    cf8e:	4629      	mov	r1, r5
    cf90:	f00e fdf6 	bl	1bb80 <z_impl_zsock_connect>
	if (err < 0) {
    cf94:	2800      	cmp	r0, #0
    cf96:	da04      	bge.n	cfa2 <main+0xca>
		printk("Connect failed : %d\n", errno);
    cf98:	f00e f860 	bl	1b05c <z_errno>
    cf9c:	6801      	ldr	r1, [r0, #0]
    cf9e:	4892      	ldr	r0, [pc, #584]	; (d1e8 <main+0x310>)
    cfa0:	e7eb      	b.n	cf7a <main+0xa2>
	fds.fd = sock;
    cfa2:	4b92      	ldr	r3, [pc, #584]	; (d1ec <main+0x314>)
    cfa4:	6832      	ldr	r2, [r6, #0]
	fds.events = POLLIN;
    cfa6:	809c      	strh	r4, [r3, #4]
	fds.fd = sock;
    cfa8:	601a      	str	r2, [r3, #0]
	next_token = sys_rand32_get();
    cfaa:	f002 f9f7 	bl	f39c <sys_rand32_get>
    cfae:	4b90      	ldr	r3, [pc, #576]	; (d1f0 <main+0x318>)
    cfb0:	8018      	strh	r0, [r3, #0]
	return z_impl_k_uptime_ticks();
    cfb2:	f010 fb5e 	bl	1d672 <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
    cfb6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    cfba:	460a      	mov	r2, r1
    cfbc:	fba0 0103 	umull	r0, r1, r0, r3
    cfc0:	fb03 1102 	mla	r1, r3, r2, r1
    cfc4:	0bc4      	lsrs	r4, r0, #15
	next_token++;
    cfc6:	f8df 8228 	ldr.w	r8, [pc, #552]	; d1f0 <main+0x318>
        printf("lmao it works\n");
    cfca:	f8df a268 	ldr.w	sl, [pc, #616]	; d234 <main+0x35c>
	err = coap_packet_init(&request, coap_buf, sizeof(coap_buf),
    cfce:	f8df 9268 	ldr.w	r9, [pc, #616]	; d238 <main+0x360>
    cfd2:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
    cfd6:	0bcd      	lsrs	r5, r1, #15
    cfd8:	f010 fb4b 	bl	1d672 <z_impl_k_uptime_ticks>
    cfdc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    cfe0:	460a      	mov	r2, r1
    cfe2:	fba0 0103 	umull	r0, r1, r0, r3
    cfe6:	fb03 1102 	mla	r1, r3, r2, r1
    cfea:	0bc2      	lsrs	r2, r0, #15
    cfec:	ea42 4241 	orr.w	r2, r2, r1, lsl #17
    cff0:	0bcb      	lsrs	r3, r1, #15
		if (k_uptime_get() >= next_msg_time) {
    cff2:	42a2      	cmp	r2, r4
    cff4:	41ab      	sbcs	r3, r5
    cff6:	f04f 0b00 	mov.w	fp, #0
    cffa:	db4c      	blt.n	d096 <main+0x1be>
	next_token++;
    cffc:	f8b8 3000 	ldrh.w	r3, [r8]
        printf("lmao it works\n");
    d000:	4650      	mov	r0, sl
	next_token++;
    d002:	3301      	adds	r3, #1
    d004:	f8a8 3000 	strh.w	r3, [r8]
        printf("lmao it works\n");
    d008:	f002 f842 	bl	f090 <printf>
	err = coap_packet_init(&request, coap_buf, sizeof(coap_buf),
    d00c:	f000 fbe8 	bl	d7e0 <coap_next_id>
    d010:	2301      	movs	r3, #1
    d012:	2202      	movs	r2, #2
    d014:	4649      	mov	r1, r9
    d016:	e9cd 3200 	strd	r3, r2, [sp]
    d01a:	9004      	str	r0, [sp, #16]
    d01c:	f44f 62a0 	mov.w	r2, #1280	; 0x500
    d020:	4638      	mov	r0, r7
    d022:	e9cd 8302 	strd	r8, r3, [sp, #8]
    d026:	f00e fbfc 	bl	1b822 <coap_packet_init>
	if (err < 0) {
    d02a:	1e01      	subs	r1, r0, #0
    d02c:	da09      	bge.n	d042 <main+0x16a>
		printk("Failed to create CoAP request, %d\n", err);
    d02e:	4871      	ldr	r0, [pc, #452]	; (d1f4 <main+0x31c>)
		printk("Failed to encode CoAP option, %d\n", err);
    d030:	f00e f839 	bl	1b0a6 <printk>
				printk("Failed to send GET request, exit...\n");
    d034:	4870      	ldr	r0, [pc, #448]	; (d1f8 <main+0x320>)
			printk("Invalid response, exit...\n");
    d036:	f00e f836 	bl	1b0a6 <printk>
	(void)close(sock);
    d03a:	6830      	ldr	r0, [r6, #0]
	return z_impl_zsock_close(sock);
    d03c:	f00e fd8b 	bl	1bb56 <z_impl_zsock_close>
	return zsock_close(sock);
    d040:	e770      	b.n	cf24 <main+0x4c>
					strlen(CONFIG_COAP_RESOURCE));
    d042:	486e      	ldr	r0, [pc, #440]	; (d1fc <main+0x324>)
    d044:	f00e ff9c 	bl	1bf80 <strlen>
	err = coap_packet_append_option(&request, COAP_OPTION_URI_PATH,
    d048:	210b      	movs	r1, #11
    d04a:	b283      	uxth	r3, r0
    d04c:	4a6b      	ldr	r2, [pc, #428]	; (d1fc <main+0x324>)
    d04e:	4638      	mov	r0, r7
    d050:	f00e fc31 	bl	1b8b6 <coap_packet_append_option>
	if (err < 0) {
    d054:	1e01      	subs	r1, r0, #0
    d056:	da01      	bge.n	d05c <main+0x184>
		printk("Failed to encode CoAP option, %d\n", err);
    d058:	4869      	ldr	r0, [pc, #420]	; (d200 <main+0x328>)
    d05a:	e7e9      	b.n	d030 <main+0x158>
	err = send(sock, request.data, request.offset, 0);
    d05c:	6830      	ldr	r0, [r6, #0]
    d05e:	990e      	ldr	r1, [sp, #56]	; 0x38
    d060:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
	if (z_syscall_trap()) {
		return (ssize_t) arch_syscall_invoke6(*(uintptr_t *)&sock, *(uintptr_t *)&buf, *(uintptr_t *)&len, *(uintptr_t *)&flags, *(uintptr_t *)&dest_addr, *(uintptr_t *)&addrlen, K_SYSCALL_ZSOCK_SENDTO);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
    d064:	465b      	mov	r3, fp
    d066:	e9cd bb00 	strd	fp, fp, [sp]
    d06a:	f00e fd9b 	bl	1bba4 <z_impl_zsock_sendto>
	if (err < 0) {
    d06e:	2800      	cmp	r0, #0
    d070:	da52      	bge.n	d118 <main+0x240>
		printk("Failed to send CoAP request, %d\n", errno);
    d072:	f00d fff3 	bl	1b05c <z_errno>
    d076:	6801      	ldr	r1, [r0, #0]
    d078:	4862      	ldr	r0, [pc, #392]	; (d204 <main+0x32c>)
    d07a:	f00e f814 	bl	1b0a6 <printk>
		return -errno;
    d07e:	f00d ffed 	bl	1b05c <z_errno>
    d082:	6803      	ldr	r3, [r0, #0]
			if (client_get_send() != 0) {
    d084:	2b00      	cmp	r3, #0
    d086:	d1d5      	bne.n	d034 <main+0x15c>
			next_msg_time += APP_COAP_SEND_INTERVAL_MS;
    d088:	f241 3388 	movw	r3, #5000	; 0x1388
    d08c:	18e4      	adds	r4, r4, r3
    d08e:	f04f 0300 	mov.w	r3, #0
    d092:	eb43 0505 	adc.w	r5, r3, r5
    d096:	f010 faec 	bl	1d672 <z_impl_k_uptime_ticks>
    d09a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    d09e:	460a      	mov	r2, r1
    d0a0:	fba0 0103 	umull	r0, r1, r0, r3
    d0a4:	fb03 1102 	mla	r1, r3, r2, r1
    d0a8:	0bc3      	lsrs	r3, r0, #15
    d0aa:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
    d0ae:	0bca      	lsrs	r2, r1, #15
		s64_t remaining = next_msg_time - k_uptime_get();
    d0b0:	1ae3      	subs	r3, r4, r3
    d0b2:	eb65 0202 	sbc.w	r2, r5, r2
		err = wait(remaining);
    d0b6:	2b00      	cmp	r3, #0
    d0b8:	4618      	mov	r0, r3
    d0ba:	f172 0300 	sbcs.w	r3, r2, #0
    d0be:	bfb8      	it	lt
    d0c0:	2000      	movlt	r0, #0
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&fds, *(uintptr_t *)&nfds, *(uintptr_t *)&timeout, K_SYSCALL_ZSOCK_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_poll(fds, nfds, timeout);
    d0c2:	f8df b128 	ldr.w	fp, [pc, #296]	; d1ec <main+0x314>
    d0c6:	4602      	mov	r2, r0
    d0c8:	2101      	movs	r1, #1
    d0ca:	4658      	mov	r0, fp
    d0cc:	f000 fbb6 	bl	d83c <z_impl_zsock_poll>
	if (ret < 0) {
    d0d0:	2800      	cmp	r0, #0
    d0d2:	da27      	bge.n	d124 <main+0x24c>
		printk("poll error: %d\n", errno);
    d0d4:	f00d ffc2 	bl	1b05c <z_errno>
    d0d8:	6801      	ldr	r1, [r0, #0]
    d0da:	484b      	ldr	r0, [pc, #300]	; (d208 <main+0x330>)
    d0dc:	f00d ffe3 	bl	1b0a6 <printk>
		return -errno;
    d0e0:	f00d ffbc 	bl	1b05c <z_errno>
    d0e4:	6803      	ldr	r3, [r0, #0]
    d0e6:	425b      	negs	r3, r3
		if (err < 0) {
    d0e8:	2b00      	cmp	r3, #0
    d0ea:	db2d      	blt.n	d148 <main+0x270>
		received = recv(sock, coap_buf, sizeof(coap_buf), MSG_DONTWAIT);
    d0ec:	6830      	ldr	r0, [r6, #0]
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
    d0ee:	f04f 0b00 	mov.w	fp, #0
    d0f2:	f44f 62a0 	mov.w	r2, #1280	; 0x500
    d0f6:	2340      	movs	r3, #64	; 0x40
    d0f8:	4649      	mov	r1, r9
    d0fa:	e9cd bb00 	strd	fp, fp, [sp]
    d0fe:	f00e fd6a 	bl	1bbd6 <z_impl_zsock_recvfrom>
		if (received < 0) {
    d102:	1e02      	subs	r2, r0, #0
    d104:	da2a      	bge.n	d15c <main+0x284>
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
    d106:	f00d ffa9 	bl	1b05c <z_errno>
    d10a:	6803      	ldr	r3, [r0, #0]
    d10c:	2b0b      	cmp	r3, #11
    d10e:	d11e      	bne.n	d14e <main+0x276>
				printk("socket EAGAIN\n");
    d110:	483e      	ldr	r0, [pc, #248]	; (d20c <main+0x334>)
			printk("Empty datagram\n");
    d112:	f00d ffc8 	bl	1b0a6 <printk>
			continue;
    d116:	e75f      	b.n	cfd8 <main+0x100>
	printk("CoAP request sent: token 0x%04x\n", next_token);
    d118:	f8b8 1000 	ldrh.w	r1, [r8]
    d11c:	483c      	ldr	r0, [pc, #240]	; (d210 <main+0x338>)
    d11e:	f00d ffc2 	bl	1b0a6 <printk>
	return 0;
    d122:	e7b1      	b.n	d088 <main+0x1b0>
	if (ret == 0) {
    d124:	f43f af58 	beq.w	cfd8 <main+0x100>
	if ((fds.revents & POLLERR) == POLLERR) {
    d128:	f8bb 3006 	ldrh.w	r3, [fp, #6]
    d12c:	0719      	lsls	r1, r3, #28
    d12e:	d504      	bpl.n	d13a <main+0x262>
		printk("wait: POLLERR\n");
    d130:	4838      	ldr	r0, [pc, #224]	; (d214 <main+0x33c>)
		printk("wait: POLLNVAL\n");
    d132:	f00d ffb8 	bl	1b0a6 <printk>
			printk("Poll error, exit...\n");
    d136:	4838      	ldr	r0, [pc, #224]	; (d218 <main+0x340>)
    d138:	e77d      	b.n	d036 <main+0x15e>
	if ((fds.revents & POLLNVAL) == POLLNVAL) {
    d13a:	069a      	lsls	r2, r3, #26
    d13c:	d501      	bpl.n	d142 <main+0x26a>
		printk("wait: POLLNVAL\n");
    d13e:	4837      	ldr	r0, [pc, #220]	; (d21c <main+0x344>)
    d140:	e7f7      	b.n	d132 <main+0x25a>
	if ((fds.revents & POLLIN) != POLLIN) {
    d142:	07db      	lsls	r3, r3, #31
    d144:	d4d2      	bmi.n	d0ec <main+0x214>
    d146:	e747      	b.n	cfd8 <main+0x100>
			if (err == -EAGAIN) {
    d148:	330b      	adds	r3, #11
    d14a:	d1f4      	bne.n	d136 <main+0x25e>
    d14c:	e744      	b.n	cfd8 <main+0x100>
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
    d14e:	f00d ff85 	bl	1b05c <z_errno>
    d152:	6803      	ldr	r3, [r0, #0]
    d154:	2b0b      	cmp	r3, #11
    d156:	d0db      	beq.n	d110 <main+0x238>
				printk("Socket error, exit...\n");
    d158:	4831      	ldr	r0, [pc, #196]	; (d220 <main+0x348>)
    d15a:	e76c      	b.n	d036 <main+0x15e>
		if (received == 0) {
    d15c:	d101      	bne.n	d162 <main+0x28a>
			printk("Empty datagram\n");
    d15e:	4831      	ldr	r0, [pc, #196]	; (d224 <main+0x34c>)
    d160:	e7d7      	b.n	d112 <main+0x23a>
	err = coap_packet_parse(&reply, buf, received, NULL, 0);
    d162:	4649      	mov	r1, r9
    d164:	465b      	mov	r3, fp
    d166:	f8cd b000 	str.w	fp, [sp]
    d16a:	b292      	uxth	r2, r2
    d16c:	a80a      	add	r0, sp, #40	; 0x28
    d16e:	f00e fc32 	bl	1b9d6 <coap_packet_parse>
	if (err < 0) {
    d172:	1e01      	subs	r1, r0, #0
    d174:	da04      	bge.n	d180 <main+0x2a8>
		printk("Malformed response received: %d\n", err);
    d176:	482c      	ldr	r0, [pc, #176]	; (d228 <main+0x350>)
    d178:	f00d ff95 	bl	1b0a6 <printk>
			printk("Invalid response, exit...\n");
    d17c:	482b      	ldr	r0, [pc, #172]	; (d22c <main+0x354>)
    d17e:	e75a      	b.n	d036 <main+0x15e>
	payload = coap_packet_get_payload(&reply, &payload_len);
    d180:	f10d 011e 	add.w	r1, sp, #30
    d184:	a80a      	add	r0, sp, #40	; 0x28
    d186:	f00e fcbb 	bl	1bb00 <coap_packet_get_payload>
	token_len = coap_header_get_token(&reply, token);
    d18a:	a908      	add	r1, sp, #32
	payload = coap_packet_get_payload(&reply, &payload_len);
    d18c:	4683      	mov	fp, r0
	token_len = coap_header_get_token(&reply, token);
    d18e:	a80a      	add	r0, sp, #40	; 0x28
    d190:	f00e fc7a 	bl	1ba88 <coap_header_get_token>
	if ((token_len != sizeof(next_token)) &&
    d194:	2802      	cmp	r0, #2
    d196:	d051      	beq.n	d23c <main+0x364>
	    (memcmp(&next_token, token, sizeof(next_token)) != 0)) {
    d198:	2202      	movs	r2, #2
    d19a:	4640      	mov	r0, r8
    d19c:	a908      	add	r1, sp, #32
    d19e:	f00e ff11 	bl	1bfc4 <memcmp>
	if ((token_len != sizeof(next_token)) &&
    d1a2:	2800      	cmp	r0, #0
    d1a4:	d04a      	beq.n	d23c <main+0x364>
		printk("Invalid token received: 0x%02x%02x\n",
    d1a6:	f89d 2020 	ldrb.w	r2, [sp, #32]
    d1aa:	f89d 1021 	ldrb.w	r1, [sp, #33]	; 0x21
    d1ae:	4820      	ldr	r0, [pc, #128]	; (d230 <main+0x358>)
    d1b0:	f00d ff79 	bl	1b0a6 <printk>
		if (err < 0) {
    d1b4:	e710      	b.n	cfd8 <main+0x100>
    d1b6:	bf00      	nop
    d1b8:	0001e156 	.word	0x0001e156
    d1bc:	0001e17a 	.word	0x0001e17a
    d1c0:	0001e193 	.word	0x0001e193
    d1c4:	0001e1a8 	.word	0x0001e1a8
    d1c8:	0001e1c0 	.word	0x0001e1c0
    d1cc:	0001e20f 	.word	0x0001e20f
    d1d0:	0001e1de 	.word	0x0001e1de
    d1d4:	2002207a 	.word	0x2002207a
    d1d8:	0001e1f8 	.word	0x0001e1f8
    d1dc:	20020290 	.word	0x20020290
    d1e0:	0001e22e 	.word	0x0001e22e
    d1e4:	0001e266 	.word	0x0001e266
    d1e8:	0001e251 	.word	0x0001e251
    d1ec:	20020288 	.word	0x20020288
    d1f0:	20022078 	.word	0x20022078
    d1f4:	0001e297 	.word	0x0001e297
    d1f8:	0001e322 	.word	0x0001e322
    d1fc:	0001e2ba 	.word	0x0001e2ba
    d200:	0001e2be 	.word	0x0001e2be
    d204:	0001e2e0 	.word	0x0001e2e0
    d208:	0001e347 	.word	0x0001e347
    d20c:	0001e38b 	.word	0x0001e38b
    d210:	0001e301 	.word	0x0001e301
    d214:	0001e357 	.word	0x0001e357
    d218:	0001e376 	.word	0x0001e376
    d21c:	0001e366 	.word	0x0001e366
    d220:	0001e39a 	.word	0x0001e39a
    d224:	0001e3b1 	.word	0x0001e3b1
    d228:	0001e3c1 	.word	0x0001e3c1
    d22c:	0001e3e2 	.word	0x0001e3e2
    d230:	0001e3fd 	.word	0x0001e3fd
    d234:	0001e288 	.word	0x0001e288
    d238:	2002209e 	.word	0x2002209e
	snprintf(temp_buf, MAX(payload_len, sizeof(temp_buf)), "%s", payload);
    d23c:	f8bd 101e 	ldrh.w	r1, [sp, #30]
    d240:	465b      	mov	r3, fp
    d242:	2910      	cmp	r1, #16
    d244:	bf38      	it	cc
    d246:	2110      	movcc	r1, #16
    d248:	4a08      	ldr	r2, [pc, #32]	; (d26c <main+0x394>)
    d24a:	4638      	mov	r0, r7
    d24c:	f001 fef0 	bl	f030 <snprintf>
	       coap_header_get_code(&reply), token[1], token[0], temp_buf);
    d250:	a80a      	add	r0, sp, #40	; 0x28
    d252:	f00e fc2b 	bl	1baac <coap_header_get_code>
	printk("CoAP response: code: 0x%x, token 0x%02x%02x, payload: %s\n",
    d256:	f89d 3020 	ldrb.w	r3, [sp, #32]
	       coap_header_get_code(&reply), token[1], token[0], temp_buf);
    d25a:	4601      	mov	r1, r0
	printk("CoAP response: code: 0x%x, token 0x%02x%02x, payload: %s\n",
    d25c:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    d260:	4803      	ldr	r0, [pc, #12]	; (d270 <main+0x398>)
    d262:	9700      	str	r7, [sp, #0]
    d264:	f00d ff1f 	bl	1b0a6 <printk>
		if (err < 0) {
    d268:	e6b6      	b.n	cfd8 <main+0x100>
    d26a:	bf00      	nop
    d26c:	0001e5ad 	.word	0x0001e5ad
    d270:	0001e421 	.word	0x0001e421

0000d274 <_check_fd>:
	return -1;
}

static int _check_fd(int fd)
{
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    d274:	2803      	cmp	r0, #3
{
    d276:	b508      	push	{r3, lr}
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
    d278:	d906      	bls.n	d288 <_check_fd+0x14>
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
    d27a:	f00c fd9d 	bl	19db8 <z_impl_z_errno>
	}

	fd = k_array_index_sanitize(fd, ARRAY_SIZE(fdtable));

	if (fdtable[fd].obj == NULL) {
		errno = EBADF;
    d27e:	2309      	movs	r3, #9
    d280:	6003      	str	r3, [r0, #0]
    d282:	f04f 30ff 	mov.w	r0, #4294967295
		return -1;
	}

	return 0;
}
    d286:	bd08      	pop	{r3, pc}
	if (fdtable[fd].obj == NULL) {
    d288:	4b03      	ldr	r3, [pc, #12]	; (d298 <_check_fd+0x24>)
    d28a:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
    d28e:	2b00      	cmp	r3, #0
    d290:	d0f3      	beq.n	d27a <_check_fd+0x6>
	return 0;
    d292:	2000      	movs	r0, #0
    d294:	e7f7      	b.n	d286 <_check_fd+0x12>
    d296:	bf00      	nop
    d298:	20020294 	.word	0x20020294

0000d29c <z_get_fd_obj>:

void *z_get_fd_obj(int fd, const struct fd_op_vtable *vtable, int err)
{
    d29c:	b570      	push	{r4, r5, r6, lr}
    d29e:	4604      	mov	r4, r0
    d2a0:	460d      	mov	r5, r1
    d2a2:	4616      	mov	r6, r2
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
    d2a4:	f7ff ffe6 	bl	d274 <_check_fd>
    d2a8:	2800      	cmp	r0, #0
    d2aa:	db09      	blt.n	d2c0 <z_get_fd_obj+0x24>
		return NULL;
	}

	fd_entry = &fdtable[fd];

	if (vtable != NULL && fd_entry->vtable != vtable) {
    d2ac:	4b07      	ldr	r3, [pc, #28]	; (d2cc <z_get_fd_obj+0x30>)
    d2ae:	b14d      	cbz	r5, d2c4 <z_get_fd_obj+0x28>
    d2b0:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
    d2b4:	6852      	ldr	r2, [r2, #4]
    d2b6:	42aa      	cmp	r2, r5
    d2b8:	d004      	beq.n	d2c4 <z_get_fd_obj+0x28>
    d2ba:	f00c fd7d 	bl	19db8 <z_impl_z_errno>
		errno = err;
    d2be:	6006      	str	r6, [r0, #0]
		return NULL;
    d2c0:	2000      	movs	r0, #0
    d2c2:	e001      	b.n	d2c8 <z_get_fd_obj+0x2c>
		return NULL;
	}

	return fd_entry->obj;
    d2c4:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
}
    d2c8:	bd70      	pop	{r4, r5, r6, pc}
    d2ca:	bf00      	nop
    d2cc:	20020294 	.word	0x20020294

0000d2d0 <z_get_fd_obj_and_vtable>:

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable)
{
    d2d0:	b538      	push	{r3, r4, r5, lr}
    d2d2:	4604      	mov	r4, r0
    d2d4:	460d      	mov	r5, r1
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
    d2d6:	f7ff ffcd 	bl	d274 <_check_fd>
    d2da:	2800      	cmp	r0, #0
		return NULL;
	}

	fd_entry = &fdtable[fd];
	*vtable = fd_entry->vtable;
    d2dc:	bfa9      	itett	ge
    d2de:	4b05      	ldrge	r3, [pc, #20]	; (d2f4 <z_get_fd_obj_and_vtable+0x24>)
		return NULL;
    d2e0:	2000      	movlt	r0, #0
	*vtable = fd_entry->vtable;
    d2e2:	eb03 02c4 	addge.w	r2, r3, r4, lsl #3
    d2e6:	6852      	ldrge	r2, [r2, #4]

	return fd_entry->obj;
    d2e8:	bfa4      	itt	ge
    d2ea:	f853 0034 	ldrge.w	r0, [r3, r4, lsl #3]
	*vtable = fd_entry->vtable;
    d2ee:	602a      	strge	r2, [r5, #0]
}
    d2f0:	bd38      	pop	{r3, r4, r5, pc}
    d2f2:	bf00      	nop
    d2f4:	20020294 	.word	0x20020294

0000d2f8 <z_reserve_fd>:

int z_reserve_fd(void)
{
    d2f8:	b510      	push	{r4, lr}
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    d2fa:	2400      	movs	r4, #0
	return z_impl_k_mutex_lock(mutex, timeout);
    d2fc:	f04f 33ff 	mov.w	r3, #4294967295
    d300:	f04f 32ff 	mov.w	r2, #4294967295
    d304:	480c      	ldr	r0, [pc, #48]	; (d338 <z_reserve_fd+0x40>)
    d306:	f00c ffa1 	bl	1a24c <z_impl_k_mutex_lock>
		if (fdtable[fd].obj == NULL) {
    d30a:	4b0c      	ldr	r3, [pc, #48]	; (d33c <z_reserve_fd+0x44>)
    d30c:	f853 2034 	ldr.w	r2, [r3, r4, lsl #3]
    d310:	b16a      	cbz	r2, d32e <z_reserve_fd+0x36>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
    d312:	3401      	adds	r4, #1
    d314:	2c04      	cmp	r4, #4
    d316:	d1f9      	bne.n	d30c <z_reserve_fd+0x14>
    d318:	f00c fd4e 	bl	19db8 <z_impl_z_errno>
	errno = ENFILE;
    d31c:	2317      	movs	r3, #23
	return -1;
    d31e:	f04f 34ff 	mov.w	r4, #4294967295
	errno = ENFILE;
    d322:	6003      	str	r3, [r0, #0]
	return z_impl_k_mutex_unlock(mutex);
    d324:	4804      	ldr	r0, [pc, #16]	; (d338 <z_reserve_fd+0x40>)
    d326:	f00d f809 	bl	1a33c <z_impl_k_mutex_unlock>
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
    d32a:	4620      	mov	r0, r4
    d32c:	bd10      	pop	{r4, pc}
		fdtable[fd].obj = FD_OBJ_RESERVED;
    d32e:	2201      	movs	r2, #1
    d330:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
    d334:	e7f6      	b.n	d324 <z_reserve_fd+0x2c>
    d336:	bf00      	nop
    d338:	200201d8 	.word	0x200201d8
    d33c:	20020294 	.word	0x20020294

0000d340 <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = obj;
    d340:	4b03      	ldr	r3, [pc, #12]	; (d350 <z_finalize_fd+0x10>)
    d342:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
	fdtable[fd].vtable = vtable;
    d346:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    d34a:	6042      	str	r2, [r0, #4]
}
    d34c:	4770      	bx	lr
    d34e:	bf00      	nop
    d350:	20020294 	.word	0x20020294

0000d354 <z_free_fd>:

void z_free_fd(int fd)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = NULL;
    d354:	2200      	movs	r2, #0
    d356:	4b02      	ldr	r3, [pc, #8]	; (d360 <z_free_fd+0xc>)
    d358:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
}
    d35c:	4770      	bx	lr
    d35e:	bf00      	nop
    d360:	20020294 	.word	0x20020294

0000d364 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    d364:	680b      	ldr	r3, [r1, #0]
    d366:	3301      	adds	r3, #1
    d368:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    d36a:	4b01      	ldr	r3, [pc, #4]	; (d370 <char_out+0xc>)
    d36c:	681b      	ldr	r3, [r3, #0]
    d36e:	4718      	bx	r3
    d370:	20020000 	.word	0x20020000

0000d374 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
    d374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d378:	ed2d 8b02 	vpush	{d8}
    d37c:	b083      	sub	sp, #12
    d37e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    d380:	469a      	mov	sl, r3
    d382:	2c01      	cmp	r4, #1
    d384:	bfb8      	it	lt
    d386:	2401      	movlt	r4, #1
    d388:	2b01      	cmp	r3, #1
    d38a:	bf0c      	ite	eq
    d38c:	2330      	moveq	r3, #48	; 0x30
    d38e:	2320      	movne	r3, #32
    d390:	4615      	mov	r5, r2
    d392:	4606      	mov	r6, r0
    d394:	ee08 3a10 	vmov	s16, r3
    d398:	2701      	movs	r7, #1
    d39a:	f04f 080a 	mov.w	r8, #10
    d39e:	2200      	movs	r2, #0
    d3a0:	f8df b074 	ldr.w	fp, [pc, #116]	; d418 <_printk_dec_ulong+0xa4>
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
    d3a4:	fbb5 f9fb 	udiv	r9, r5, fp
    d3a8:	b90a      	cbnz	r2, d3ae <_printk_dec_ulong+0x3a>
    d3aa:	45ab      	cmp	fp, r5
    d3ac:	d820      	bhi.n	d3f0 <_printk_dec_ulong+0x7c>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
    d3ae:	f109 0030 	add.w	r0, r9, #48	; 0x30
    d3b2:	9100      	str	r1, [sp, #0]
    d3b4:	47b0      	blx	r6
			found_largest_digit = 1;
    d3b6:	2201      	movs	r2, #1
			digits++;
    d3b8:	3701      	adds	r7, #1
		} else if (remaining <= min_width
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
    d3ba:	9900      	ldr	r1, [sp, #0]
		}
		remaining--;
		remainder %= pos;
		pos /= 10;
    d3bc:	230a      	movs	r3, #10
		remaining--;
    d3be:	f108 38ff 	add.w	r8, r8, #4294967295
	while (pos >= 10) {
    d3c2:	f1b8 0f01 	cmp.w	r8, #1
		remainder %= pos;
    d3c6:	fb0b 5519 	mls	r5, fp, r9, r5
		pos /= 10;
    d3ca:	fbbb fbf3 	udiv	fp, fp, r3
	while (pos >= 10) {
    d3ce:	d1e9      	bne.n	d3a4 <_printk_dec_ulong+0x30>
	}
	out((int)(remainder + 48), ctx);
    d3d0:	f105 0030 	add.w	r0, r5, #48	; 0x30
    d3d4:	9100      	str	r1, [sp, #0]
    d3d6:	47b0      	blx	r6

	if (padding == PAD_SPACE_AFTER) {
    d3d8:	f1ba 0f03 	cmp.w	sl, #3
    d3dc:	9900      	ldr	r1, [sp, #0]
    d3de:	d102      	bne.n	d3e6 <_printk_dec_ulong+0x72>
		remaining = min_width - digits;
    d3e0:	1be4      	subs	r4, r4, r7
		while (remaining-- > 0) {
    d3e2:	2c00      	cmp	r4, #0
    d3e4:	dc11      	bgt.n	d40a <_printk_dec_ulong+0x96>
			out(' ', ctx);
		}
	}
}
    d3e6:	b003      	add	sp, #12
    d3e8:	ecbd 8b02 	vpop	{d8}
    d3ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
    d3f0:	4544      	cmp	r4, r8
    d3f2:	dbe3      	blt.n	d3bc <_printk_dec_ulong+0x48>
				&& padding < PAD_SPACE_AFTER) {
    d3f4:	f1ba 0f02 	cmp.w	sl, #2
    d3f8:	d8e0      	bhi.n	d3bc <_printk_dec_ulong+0x48>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    d3fa:	ee18 0a10 	vmov	r0, s16
    d3fe:	e9cd 1200 	strd	r1, r2, [sp]
			digits++;
    d402:	3701      	adds	r7, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
    d404:	47b0      	blx	r6
			digits++;
    d406:	9a01      	ldr	r2, [sp, #4]
    d408:	e7d7      	b.n	d3ba <_printk_dec_ulong+0x46>
			out(' ', ctx);
    d40a:	2020      	movs	r0, #32
    d40c:	9100      	str	r1, [sp, #0]
    d40e:	3c01      	subs	r4, #1
    d410:	47b0      	blx	r6
    d412:	9900      	ldr	r1, [sp, #0]
    d414:	e7e5      	b.n	d3e2 <_printk_dec_ulong+0x6e>
    d416:	bf00      	nop
    d418:	3b9aca00 	.word	0x3b9aca00

0000d41c <__printk_hook_install>:
	_char_out = fn;
    d41c:	4b01      	ldr	r3, [pc, #4]	; (d424 <__printk_hook_install+0x8>)
    d41e:	6018      	str	r0, [r3, #0]
}
    d420:	4770      	bx	lr
    d422:	bf00      	nop
    d424:	20020000 	.word	0x20020000

0000d428 <z_vprintk>:
{
    d428:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
    d42c:	2700      	movs	r7, #0
{
    d42e:	4605      	mov	r5, r0
    d430:	468b      	mov	fp, r1
	int min_width = -1;
    d432:	f04f 39ff 	mov.w	r9, #4294967295
	enum pad_type padding = PAD_NONE;
    d436:	46b8      	mov	r8, r7
{
    d438:	461c      	mov	r4, r3
    d43a:	b08d      	sub	sp, #52	; 0x34
    d43c:	1e53      	subs	r3, r2, #1
    d43e:	9303      	str	r3, [sp, #12]
			might_format = 0;
    d440:	2600      	movs	r6, #0
					break;
    d442:	e005      	b.n	d450 <z_vprintk+0x28>
		if (!might_format) {
    d444:	b96e      	cbnz	r6, d462 <z_vprintk+0x3a>
			if (*fmt != '%') {
    d446:	2825      	cmp	r0, #37	; 0x25
    d448:	f000 8171 	beq.w	d72e <z_vprintk+0x306>
				out((int)*fmt, ctx);
    d44c:	4659      	mov	r1, fp
    d44e:	47a8      	blx	r5
	while (*fmt) {
    d450:	9b03      	ldr	r3, [sp, #12]
    d452:	f813 0f01 	ldrb.w	r0, [r3, #1]!
    d456:	9303      	str	r3, [sp, #12]
    d458:	2800      	cmp	r0, #0
    d45a:	d1f3      	bne.n	d444 <z_vprintk+0x1c>
}
    d45c:	b00d      	add	sp, #52	; 0x34
    d45e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
    d462:	287a      	cmp	r0, #122	; 0x7a
    d464:	d80a      	bhi.n	d47c <z_vprintk+0x54>
    d466:	2862      	cmp	r0, #98	; 0x62
    d468:	d810      	bhi.n	d48c <z_vprintk+0x64>
    d46a:	2830      	cmp	r0, #48	; 0x30
    d46c:	d054      	beq.n	d518 <z_vprintk+0xf0>
    d46e:	d845      	bhi.n	d4fc <z_vprintk+0xd4>
    d470:	2825      	cmp	r0, #37	; 0x25
    d472:	f000 815a 	beq.w	d72a <z_vprintk+0x302>
    d476:	282d      	cmp	r0, #45	; 0x2d
    d478:	f000 815f 	beq.w	d73a <z_vprintk+0x312>
					out((int)'%', ctx);
    d47c:	4659      	mov	r1, fp
    d47e:	2025      	movs	r0, #37	; 0x25
    d480:	47a8      	blx	r5
					out((int)*fmt, ctx);
    d482:	4659      	mov	r1, fp
    d484:	9b03      	ldr	r3, [sp, #12]
    d486:	7818      	ldrb	r0, [r3, #0]
    d488:	47a8      	blx	r5
    d48a:	e7d9      	b.n	d440 <z_vprintk+0x18>
    d48c:	f1a0 0363 	sub.w	r3, r0, #99	; 0x63
    d490:	2b17      	cmp	r3, #23
    d492:	d8f3      	bhi.n	d47c <z_vprintk+0x54>
    d494:	a201      	add	r2, pc, #4	; (adr r2, d49c <z_vprintk+0x74>)
    d496:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    d49a:	bf00      	nop
    d49c:	0000d723 	.word	0x0000d723
    d4a0:	0000d567 	.word	0x0000d567
    d4a4:	0000d47d 	.word	0x0000d47d
    d4a8:	0000d47d 	.word	0x0000d47d
    d4ac:	0000d47d 	.word	0x0000d47d
    d4b0:	0000d549 	.word	0x0000d549
    d4b4:	0000d567 	.word	0x0000d567
    d4b8:	0000d47d 	.word	0x0000d47d
    d4bc:	0000d47d 	.word	0x0000d47d
    d4c0:	0000d549 	.word	0x0000d549
    d4c4:	0000d47d 	.word	0x0000d47d
    d4c8:	0000d47d 	.word	0x0000d47d
    d4cc:	0000d47d 	.word	0x0000d47d
    d4d0:	0000d609 	.word	0x0000d609
    d4d4:	0000d47d 	.word	0x0000d47d
    d4d8:	0000d47d 	.word	0x0000d47d
    d4dc:	0000d6f3 	.word	0x0000d6f3
    d4e0:	0000d47d 	.word	0x0000d47d
    d4e4:	0000d5d7 	.word	0x0000d5d7
    d4e8:	0000d47d 	.word	0x0000d47d
    d4ec:	0000d47d 	.word	0x0000d47d
    d4f0:	0000d505 	.word	0x0000d505
    d4f4:	0000d47d 	.word	0x0000d47d
    d4f8:	0000d549 	.word	0x0000d549
			switch (*fmt) {
    d4fc:	2839      	cmp	r0, #57	; 0x39
    d4fe:	d91a      	bls.n	d536 <z_vprintk+0x10e>
    d500:	2858      	cmp	r0, #88	; 0x58
    d502:	d1bb      	bne.n	d47c <z_vprintk+0x54>
				if (*fmt == 'p') {
    d504:	9b03      	ldr	r3, [sp, #12]
    d506:	781b      	ldrb	r3, [r3, #0]
    d508:	2b70      	cmp	r3, #112	; 0x70
    d50a:	f040 8088 	bne.w	d61e <z_vprintk+0x1f6>
					x = va_arg(ap, unsigned int);
    d50e:	f854 3b04 	ldr.w	r3, [r4], #4
    d512:	2200      	movs	r2, #0
    d514:	9306      	str	r3, [sp, #24]
    d516:	e090      	b.n	d63a <z_vprintk+0x212>
				if (min_width < 0 && padding == PAD_NONE) {
    d518:	f1b9 0f00 	cmp.w	r9, #0
    d51c:	da0e      	bge.n	d53c <z_vprintk+0x114>
    d51e:	f1b8 0f00 	cmp.w	r8, #0
    d522:	f000 810d 	beq.w	d740 <z_vprintk+0x318>
					min_width = *fmt - '0';
    d526:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
    d52a:	f1b8 0f00 	cmp.w	r8, #0
    d52e:	bf08      	it	eq
    d530:	f04f 0802 	moveq.w	r8, #2
    d534:	e78c      	b.n	d450 <z_vprintk+0x28>
				if (min_width < 0) {
    d536:	f1b9 0f00 	cmp.w	r9, #0
    d53a:	dbf4      	blt.n	d526 <z_vprintk+0xfe>
					min_width = 10 * min_width + *fmt - '0';
    d53c:	230a      	movs	r3, #10
    d53e:	fb03 0909 	mla	r9, r3, r9, r0
    d542:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
    d546:	e7f0      	b.n	d52a <z_vprintk+0x102>
				if (*fmt == 'h' && length_mod == 'h') {
    d548:	2868      	cmp	r0, #104	; 0x68
    d54a:	d103      	bne.n	d554 <z_vprintk+0x12c>
    d54c:	2f68      	cmp	r7, #104	; 0x68
    d54e:	d106      	bne.n	d55e <z_vprintk+0x136>
					length_mod = 'H';
    d550:	2748      	movs	r7, #72	; 0x48
    d552:	e77d      	b.n	d450 <z_vprintk+0x28>
				} else if (*fmt == 'l' && length_mod == 'l') {
    d554:	286c      	cmp	r0, #108	; 0x6c
    d556:	d102      	bne.n	d55e <z_vprintk+0x136>
    d558:	2f6c      	cmp	r7, #108	; 0x6c
    d55a:	f000 80f4 	beq.w	d746 <z_vprintk+0x31e>
				} else if (length_mod == 0) {
    d55e:	2f00      	cmp	r7, #0
    d560:	d18c      	bne.n	d47c <z_vprintk+0x54>
    d562:	4607      	mov	r7, r0
    d564:	e774      	b.n	d450 <z_vprintk+0x28>
				if (length_mod == 'z') {
    d566:	2f7a      	cmp	r7, #122	; 0x7a
    d568:	d102      	bne.n	d570 <z_vprintk+0x148>
					d = va_arg(ap, int);
    d56a:	f854 6b04 	ldr.w	r6, [r4], #4
    d56e:	e021      	b.n	d5b4 <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
    d570:	2f6c      	cmp	r7, #108	; 0x6c
    d572:	d0fa      	beq.n	d56a <z_vprintk+0x142>
				} else if (length_mod == 'L') {
    d574:	2f4c      	cmp	r7, #76	; 0x4c
    d576:	d1f8      	bne.n	d56a <z_vprintk+0x142>
					long long lld = va_arg(ap, long long);
    d578:	3407      	adds	r4, #7
    d57a:	f024 0407 	bic.w	r4, r4, #7
    d57e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    d582:	e9cd 2304 	strd	r2, r3, [sp, #16]
					if (lld > __LONG_MAX__ ||
    d586:	9b04      	ldr	r3, [sp, #16]
    d588:	f04f 30ff 	mov.w	r0, #4294967295
    d58c:	f113 4100 	adds.w	r1, r3, #2147483648	; 0x80000000
    d590:	9b05      	ldr	r3, [sp, #20]
    d592:	9108      	str	r1, [sp, #32]
    d594:	f143 0100 	adc.w	r1, r3, #0
    d598:	9109      	str	r1, [sp, #36]	; 0x24
    d59a:	2100      	movs	r1, #0
    d59c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    d5a0:	4299      	cmp	r1, r3
    d5a2:	bf08      	it	eq
    d5a4:	4290      	cmpeq	r0, r2
    d5a6:	d204      	bcs.n	d5b2 <z_vprintk+0x18a>
						print_err(out, ctx);
    d5a8:	4659      	mov	r1, fp
    d5aa:	4628      	mov	r0, r5
    d5ac:	f00d fd5a 	bl	1b064 <print_err>
						break;
    d5b0:	e746      	b.n	d440 <z_vprintk+0x18>
					d = lld;
    d5b2:	9e04      	ldr	r6, [sp, #16]
				if (d < 0) {
    d5b4:	2e00      	cmp	r6, #0
    d5b6:	da05      	bge.n	d5c4 <z_vprintk+0x19c>
					out((int)'-', ctx);
    d5b8:	4659      	mov	r1, fp
    d5ba:	202d      	movs	r0, #45	; 0x2d
    d5bc:	47a8      	blx	r5
					d = -d;
    d5be:	4276      	negs	r6, r6
					min_width--;
    d5c0:	f109 39ff 	add.w	r9, r9, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
    d5c4:	4643      	mov	r3, r8
    d5c6:	4632      	mov	r2, r6
    d5c8:	f8cd 9000 	str.w	r9, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
    d5cc:	4659      	mov	r1, fp
    d5ce:	4628      	mov	r0, r5
    d5d0:	f7ff fed0 	bl	d374 <_printk_dec_ulong>
				break;
    d5d4:	e734      	b.n	d440 <z_vprintk+0x18>
				if (length_mod == 'z') {
    d5d6:	2f7a      	cmp	r7, #122	; 0x7a
    d5d8:	d102      	bne.n	d5e0 <z_vprintk+0x1b8>
					u = va_arg(ap, unsigned int);
    d5da:	f854 2b04 	ldr.w	r2, [r4], #4
    d5de:	e00f      	b.n	d600 <z_vprintk+0x1d8>
				} else if (length_mod == 'l') {
    d5e0:	2f6c      	cmp	r7, #108	; 0x6c
    d5e2:	d0fa      	beq.n	d5da <z_vprintk+0x1b2>
				} else if (length_mod == 'L') {
    d5e4:	2f4c      	cmp	r7, #76	; 0x4c
    d5e6:	d1f8      	bne.n	d5da <z_vprintk+0x1b2>
					if (llu > ~0UL) {
    d5e8:	2100      	movs	r1, #0
    d5ea:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
    d5ee:	3407      	adds	r4, #7
    d5f0:	f024 0407 	bic.w	r4, r4, #7
    d5f4:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
    d5f8:	4299      	cmp	r1, r3
    d5fa:	bf08      	it	eq
    d5fc:	4290      	cmpeq	r0, r2
    d5fe:	d3d3      	bcc.n	d5a8 <z_vprintk+0x180>
				_printk_dec_ulong(out, ctx, u, padding,
    d600:	4643      	mov	r3, r8
    d602:	f8cd 9000 	str.w	r9, [sp]
    d606:	e7e1      	b.n	d5cc <z_vprintk+0x1a4>
				out('0', ctx);
    d608:	4659      	mov	r1, fp
    d60a:	2030      	movs	r0, #48	; 0x30
    d60c:	47a8      	blx	r5
				out('x', ctx);
    d60e:	4659      	mov	r1, fp
    d610:	2078      	movs	r0, #120	; 0x78
    d612:	47a8      	blx	r5
					min_width = 8;
    d614:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
    d618:	f04f 0801 	mov.w	r8, #1
    d61c:	e772      	b.n	d504 <z_vprintk+0xdc>
				} else if (length_mod == 'l') {
    d61e:	2f6c      	cmp	r7, #108	; 0x6c
    d620:	f43f af75 	beq.w	d50e <z_vprintk+0xe6>
				} else if (length_mod == 'L') {
    d624:	2f4c      	cmp	r7, #76	; 0x4c
    d626:	f47f af72 	bne.w	d50e <z_vprintk+0xe6>
					x = va_arg(ap, unsigned long long);
    d62a:	1de3      	adds	r3, r4, #7
    d62c:	f023 0307 	bic.w	r3, r3, #7
    d630:	461c      	mov	r4, r3
    d632:	f854 2b08 	ldr.w	r2, [r4], #8
    d636:	9206      	str	r2, [sp, #24]
    d638:	685a      	ldr	r2, [r3, #4]
	int digits = 0;
    d63a:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
    d63c:	2310      	movs	r3, #16
	int shift = sizeof(num) * 8;
    d63e:	f04f 0a40 	mov.w	sl, #64	; 0x40
	int digits = 0;
    d642:	9104      	str	r1, [sp, #16]
	int found_largest_digit = 0;
    d644:	9107      	str	r1, [sp, #28]
		shift -= 4;
    d646:	f1aa 0a04 	sub.w	sl, sl, #4
		nibble = (num >> shift) & 0xf;
    d64a:	9906      	ldr	r1, [sp, #24]
    d64c:	f1ca 0e20 	rsb	lr, sl, #32
    d650:	f1aa 0c20 	sub.w	ip, sl, #32
    d654:	fa21 f00a 	lsr.w	r0, r1, sl
    d658:	fa02 fe0e 	lsl.w	lr, r2, lr
    d65c:	ea40 000e 	orr.w	r0, r0, lr
    d660:	fa22 fc0c 	lsr.w	ip, r2, ip
    d664:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
    d668:	f010 000f 	ands.w	r0, r0, #15
    d66c:	d107      	bne.n	d67e <z_vprintk+0x256>
    d66e:	9907      	ldr	r1, [sp, #28]
    d670:	b911      	cbnz	r1, d678 <z_vprintk+0x250>
    d672:	f1ba 0f00 	cmp.w	sl, #0
    d676:	d125      	bne.n	d6c4 <z_vprintk+0x29c>
			nibble += nibble > 9 ? 87 : 48;
    d678:	f04f 0c30 	mov.w	ip, #48	; 0x30
    d67c:	e005      	b.n	d68a <z_vprintk+0x262>
    d67e:	2809      	cmp	r0, #9
    d680:	bf8c      	ite	hi
    d682:	f04f 0c57 	movhi.w	ip, #87	; 0x57
    d686:	f04f 0c30 	movls.w	ip, #48	; 0x30
    d68a:	4460      	add	r0, ip
			out((int)nibble, ctx);
    d68c:	4659      	mov	r1, fp
    d68e:	b240      	sxtb	r0, r0
    d690:	920a      	str	r2, [sp, #40]	; 0x28
    d692:	9307      	str	r3, [sp, #28]
    d694:	47a8      	blx	r5
			digits++;
    d696:	9b04      	ldr	r3, [sp, #16]
	while (shift >= 4) {
    d698:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			digits++;
    d69a:	3301      	adds	r3, #1
    d69c:	9304      	str	r3, [sp, #16]
	while (shift >= 4) {
    d69e:	9b07      	ldr	r3, [sp, #28]
    d6a0:	f1ba 0f00 	cmp.w	sl, #0
    d6a4:	d123      	bne.n	d6ee <z_vprintk+0x2c6>
	if (padding == PAD_SPACE_AFTER) {
    d6a6:	f1b8 0f03 	cmp.w	r8, #3
    d6aa:	f47f aec9 	bne.w	d440 <z_vprintk+0x18>
		remaining = min_width * 2 - digits;
    d6ae:	9b04      	ldr	r3, [sp, #16]
    d6b0:	ebc3 0649 	rsb	r6, r3, r9, lsl #1
		while (remaining-- > 0) {
    d6b4:	2e00      	cmp	r6, #0
    d6b6:	f77f aec3 	ble.w	d440 <z_vprintk+0x18>
			out(' ', ctx);
    d6ba:	4659      	mov	r1, fp
    d6bc:	2020      	movs	r0, #32
    d6be:	47a8      	blx	r5
    d6c0:	3e01      	subs	r6, #1
    d6c2:	e7f7      	b.n	d6b4 <z_vprintk+0x28c>
		if (remaining-- <= min_width) {
    d6c4:	1e59      	subs	r1, r3, #1
    d6c6:	4599      	cmp	r9, r3
    d6c8:	910a      	str	r1, [sp, #40]	; 0x28
    d6ca:	db07      	blt.n	d6dc <z_vprintk+0x2b4>
			if (padding == PAD_ZERO_BEFORE) {
    d6cc:	f1b8 0f01 	cmp.w	r8, #1
    d6d0:	d106      	bne.n	d6e0 <z_vprintk+0x2b8>
				out('0', ctx);
    d6d2:	4659      	mov	r1, fp
    d6d4:	2030      	movs	r0, #48	; 0x30
    d6d6:	920b      	str	r2, [sp, #44]	; 0x2c
				out(' ', ctx);
    d6d8:	47a8      	blx	r5
    d6da:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
			nibble += nibble > 9 ? 87 : 48;
    d6dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d6de:	e7b2      	b.n	d646 <z_vprintk+0x21e>
			} else if (padding == PAD_SPACE_BEFORE) {
    d6e0:	f1b8 0f02 	cmp.w	r8, #2
    d6e4:	d1fa      	bne.n	d6dc <z_vprintk+0x2b4>
				out(' ', ctx);
    d6e6:	4659      	mov	r1, fp
    d6e8:	2020      	movs	r0, #32
    d6ea:	920b      	str	r2, [sp, #44]	; 0x2c
    d6ec:	e7f4      	b.n	d6d8 <z_vprintk+0x2b0>
			found_largest_digit = 1;
    d6ee:	9607      	str	r6, [sp, #28]
    d6f0:	e7a9      	b.n	d646 <z_vprintk+0x21e>
				char *s = va_arg(ap, char *);
    d6f2:	f854 6b04 	ldr.w	r6, [r4], #4
				while (*s) {
    d6f6:	46b2      	mov	sl, r6
    d6f8:	4653      	mov	r3, sl
    d6fa:	f81a 0b01 	ldrb.w	r0, [sl], #1
    d6fe:	b968      	cbnz	r0, d71c <z_vprintk+0x2f4>
				if (padding == PAD_SPACE_AFTER) {
    d700:	f1b8 0f03 	cmp.w	r8, #3
    d704:	d121      	bne.n	d74a <z_vprintk+0x322>
					int remaining = min_width - (s - start);
    d706:	1b9e      	subs	r6, r3, r6
    d708:	eba9 0606 	sub.w	r6, r9, r6
					while (remaining-- > 0) {
    d70c:	2e00      	cmp	r6, #0
    d70e:	f77f ae97 	ble.w	d440 <z_vprintk+0x18>
						out(' ', ctx);
    d712:	4659      	mov	r1, fp
    d714:	2020      	movs	r0, #32
    d716:	47a8      	blx	r5
    d718:	3e01      	subs	r6, #1
    d71a:	e7f7      	b.n	d70c <z_vprintk+0x2e4>
					out((int)(*s++), ctx);
    d71c:	4659      	mov	r1, fp
    d71e:	47a8      	blx	r5
    d720:	e7ea      	b.n	d6f8 <z_vprintk+0x2d0>
				out(c, ctx);
    d722:	4659      	mov	r1, fp
    d724:	f854 0b04 	ldr.w	r0, [r4], #4
    d728:	e6ae      	b.n	d488 <z_vprintk+0x60>
				out((int)'%', ctx);
    d72a:	4659      	mov	r1, fp
    d72c:	e6ac      	b.n	d488 <z_vprintk+0x60>
				length_mod = 0;
    d72e:	4637      	mov	r7, r6
				padding = PAD_NONE;
    d730:	46b0      	mov	r8, r6
				min_width = -1;
    d732:	f04f 39ff 	mov.w	r9, #4294967295
				might_format = 1;
    d736:	2601      	movs	r6, #1
    d738:	e68a      	b.n	d450 <z_vprintk+0x28>
			switch (*fmt) {
    d73a:	f04f 0803 	mov.w	r8, #3
    d73e:	e687      	b.n	d450 <z_vprintk+0x28>
					padding = PAD_ZERO_BEFORE;
    d740:	f04f 0801 	mov.w	r8, #1
    d744:	e684      	b.n	d450 <z_vprintk+0x28>
					length_mod = 'L';
    d746:	274c      	movs	r7, #76	; 0x4c
    d748:	e682      	b.n	d450 <z_vprintk+0x28>
			might_format = 0;
    d74a:	4606      	mov	r6, r0
		++fmt;
    d74c:	e680      	b.n	d450 <z_vprintk+0x28>
    d74e:	bf00      	nop

0000d750 <vprintk>:
{
    d750:	b507      	push	{r0, r1, r2, lr}
    d752:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    d754:	2100      	movs	r1, #0
{
    d756:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    d758:	9101      	str	r1, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
    d75a:	4803      	ldr	r0, [pc, #12]	; (d768 <vprintk+0x18>)
    d75c:	a901      	add	r1, sp, #4
    d75e:	f7ff fe63 	bl	d428 <z_vprintk>
}
    d762:	b003      	add	sp, #12
    d764:	f85d fb04 	ldr.w	pc, [sp], #4
    d768:	0000d365 	.word	0x0000d365

0000d76c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
    d76c:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
    d76e:	2500      	movs	r5, #0
{
    d770:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
    d772:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
    d776:	4604      	mov	r4, r0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    d778:	a901      	add	r1, sp, #4
    d77a:	4805      	ldr	r0, [pc, #20]	; (d790 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
    d77c:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
    d77e:	f7ff fe53 	bl	d428 <z_vprintk>

	if (ctx.count < ctx.max) {
    d782:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
    d786:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
    d788:	bfb8      	it	lt
    d78a:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
    d78c:	b005      	add	sp, #20
    d78e:	bd30      	pop	{r4, r5, pc}
    d790:	0001b081 	.word	0x0001b081

0000d794 <nordicsemi_nrf91_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
    d794:	f04f 0220 	mov.w	r2, #32
    d798:	f3ef 8311 	mrs	r3, BASEPRI
    d79c:	f382 8811 	msr	BASEPRI, r2
    d7a0:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    d7a4:	2101      	movs	r1, #1
    d7a6:	4a04      	ldr	r2, [pc, #16]	; (d7b8 <nordicsemi_nrf91_init+0x24>)
    d7a8:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    d7ac:	f383 8811 	msr	BASEPRI, r3
    d7b0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    d7b4:	2000      	movs	r0, #0
    d7b6:	4770      	bx	lr
    d7b8:	40039000 	.word	0x40039000

0000d7bc <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    d7bc:	b120      	cbz	r0, d7c8 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    d7be:	4b03      	ldr	r3, [pc, #12]	; (d7cc <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    d7c0:	0180      	lsls	r0, r0, #6
    d7c2:	f043 0301 	orr.w	r3, r3, #1
    d7c6:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    d7c8:	4770      	bx	lr
    d7ca:	bf00      	nop
    d7cc:	0001dc00 	.word	0x0001dc00

0000d7d0 <net_coap_init>:
 * use and should therefore not be exposed to applications.
 *
 * @return N/A
 */
void net_coap_init(void)
{
    d7d0:	b508      	push	{r3, lr}
	/* Initialize message_id to a random number */
	message_id = (u16_t)sys_rand32_get();
    d7d2:	f001 fde3 	bl	f39c <sys_rand32_get>
    d7d6:	4b01      	ldr	r3, [pc, #4]	; (d7dc <net_coap_init+0xc>)
    d7d8:	8018      	strh	r0, [r3, #0]
}
    d7da:	bd08      	pop	{r3, pc}
    d7dc:	20022092 	.word	0x20022092

0000d7e0 <coap_next_id>:

u16_t coap_next_id(void)
{
	return message_id++;
    d7e0:	4b02      	ldr	r3, [pc, #8]	; (d7ec <coap_next_id+0xc>)
    d7e2:	8818      	ldrh	r0, [r3, #0]
    d7e4:	1c42      	adds	r2, r0, #1
    d7e6:	801a      	strh	r2, [r3, #0]
}
    d7e8:	4770      	bx	lr
    d7ea:	bf00      	nop
    d7ec:	20022092 	.word	0x20022092

0000d7f0 <z_impl_zsock_socket>:

	return fd;
}

int z_impl_zsock_socket(int family, int type, int proto)
{
    d7f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    d7f2:	4605      	mov	r5, r0
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
    d7f4:	4c0f      	ldr	r4, [pc, #60]	; (d834 <z_impl_zsock_socket+0x44>)
    d7f6:	4e10      	ldr	r6, [pc, #64]	; (d838 <z_impl_zsock_socket+0x48>)
    d7f8:	42b4      	cmp	r4, r6
    d7fa:	d307      	bcc.n	d80c <z_impl_zsock_socket+0x1c>

	if (IS_ENABLED(CONFIG_NET_NATIVE)) {
		return zsock_socket_internal(family, type, proto);
	}

	errno = EAFNOSUPPORT;
    d7fc:	f00e f99a 	bl	1bb34 <z_errno>
    d800:	232f      	movs	r3, #47	; 0x2f
    d802:	6003      	str	r3, [r0, #0]
	return -1;
}
    d804:	f04f 30ff 	mov.w	r0, #4294967295
    d808:	b002      	add	sp, #8
    d80a:	bd70      	pop	{r4, r5, r6, pc}
		if (sock_family->family != family &&
    d80c:	6823      	ldr	r3, [r4, #0]
    d80e:	42ab      	cmp	r3, r5
    d810:	d000      	beq.n	d814 <z_impl_zsock_socket+0x24>
    d812:	b96b      	cbnz	r3, d830 <z_impl_zsock_socket+0x40>
		if (!sock_family->is_supported(family, type, proto)) {
    d814:	4628      	mov	r0, r5
    d816:	6863      	ldr	r3, [r4, #4]
    d818:	e9cd 1200 	strd	r1, r2, [sp]
    d81c:	4798      	blx	r3
    d81e:	e9dd 1200 	ldrd	r1, r2, [sp]
    d822:	b128      	cbz	r0, d830 <z_impl_zsock_socket+0x40>
		return sock_family->handler(family, type, proto);
    d824:	4628      	mov	r0, r5
    d826:	68a3      	ldr	r3, [r4, #8]
}
    d828:	b002      	add	sp, #8
    d82a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return sock_family->handler(family, type, proto);
    d82e:	4718      	bx	r3
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
    d830:	340c      	adds	r4, #12
    d832:	e7e1      	b.n	d7f8 <z_impl_zsock_socket+0x8>
    d834:	0001db9c 	.word	0x0001db9c
    d838:	0001dba8 	.word	0x0001dba8

0000d83c <z_impl_zsock_poll>:

	return timeout - elapsed;
}

int z_impl_zsock_poll(struct zsock_pollfd *fds, int nfds, int poll_timeout)
{
    d83c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct k_poll_event *pev_end = poll_events + ARRAY_SIZE(poll_events);
	const struct fd_op_vtable *vtable;
	k_timeout_t timeout;
	u64_t end;

	if (poll_timeout < 0) {
    d840:	1e16      	subs	r6, r2, #0
{
    d842:	4680      	mov	r8, r0
    d844:	4689      	mov	r9, r1
    d846:	b099      	sub	sp, #100	; 0x64
	if (poll_timeout < 0) {
    d848:	db4e      	blt.n	d8e8 <z_impl_zsock_poll+0xac>
			return (u32_t)((t * to_hz + off) / from_hz);
    d84a:	f44f 4400 	mov.w	r4, #32768	; 0x8000
    d84e:	f240 30e7 	movw	r0, #999	; 0x3e7
    d852:	2100      	movs	r1, #0
    d854:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    d858:	fbc4 0106 	smlal	r0, r1, r4, r6
    d85c:	2300      	movs	r3, #0
    d85e:	f7ff f825 	bl	c8ac <__aeabi_uldivmod>
		timeout = K_FOREVER;
		poll_timeout = SYS_FOREVER_MS;
	} else {
		timeout = K_MSEC(poll_timeout);
    d862:	2500      	movs	r5, #0
    d864:	4604      	mov	r4, r0
	}

	end = z_timeout_end_calc(timeout);
    d866:	4620      	mov	r0, r4
    d868:	4629      	mov	r1, r5
    d86a:	f00f ff04 	bl	1d676 <z_timeout_end_calc>

	pev = poll_events;
	for (pfd = fds, i = nfds; i--; pfd++) {
    d86e:	464f      	mov	r7, r9
    d870:	46c3      	mov	fp, r8
	end = z_timeout_end_calc(timeout);
    d872:	e9cd 0103 	strd	r0, r1, [sp, #12]
	pev = poll_events;
    d876:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
    d87a:	f8cd a01c 	str.w	sl, [sp, #28]
	for (pfd = fds, i = nfds; i--; pfd++) {
    d87e:	2f00      	cmp	r7, #0
    d880:	d139      	bne.n	d8f6 <z_impl_zsock_poll+0xba>
			errno = -result;
			return -1;
		}
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
    d882:	ea54 0305 	orrs.w	r3, r4, r5
    d886:	d011      	beq.n	d8ac <z_impl_zsock_poll+0x70>
    d888:	1c6a      	adds	r2, r5, #1
    d88a:	bf08      	it	eq
    d88c:	f1b4 3fff 	cmpeq.w	r4, #4294967295
    d890:	d00c      	beq.n	d8ac <z_impl_zsock_poll+0x70>
	    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
		s64_t remaining = end - z_tick_get();
    d892:	f00d fb69 	bl	1af68 <z_tick_get>
    d896:	9b03      	ldr	r3, [sp, #12]
    d898:	1a1c      	subs	r4, r3, r0
    d89a:	9b04      	ldr	r3, [sp, #16]
    d89c:	eb63 0501 	sbc.w	r5, r3, r1
    d8a0:	2c00      	cmp	r4, #0
    d8a2:	f175 0300 	sbcs.w	r3, r5, #0
    d8a6:	bfbc      	itt	lt
    d8a8:	2400      	movlt	r4, #0
    d8aa:	2500      	movlt	r5, #0
			timeout = Z_TIMEOUT_TICKS(remaining);
		}
	}

	do {
		ret = k_poll(poll_events, pev - poll_events, timeout);
    d8ac:	9907      	ldr	r1, [sp, #28]
    d8ae:	4b52      	ldr	r3, [pc, #328]	; (d9f8 <z_impl_zsock_poll+0x1bc>)
    d8b0:	eba1 010a 	sub.w	r1, r1, sl
    d8b4:	1089      	asrs	r1, r1, #2
    d8b6:	4359      	muls	r1, r3
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
    d8b8:	462b      	mov	r3, r5
    d8ba:	4622      	mov	r2, r4
    d8bc:	4650      	mov	r0, sl
    d8be:	f00d fb6d 	bl	1af9c <z_impl_k_poll>
		/* EAGAIN when timeout expired, EINTR when cancelled (i.e. EOF) */
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
    d8c2:	f100 030b 	add.w	r3, r0, #11
    d8c6:	2b0b      	cmp	r3, #11
    d8c8:	4606      	mov	r6, r0
    d8ca:	d806      	bhi.n	d8da <z_impl_zsock_poll+0x9e>
    d8cc:	f640 0781 	movw	r7, #2177	; 0x881
    d8d0:	40df      	lsrs	r7, r3
    d8d2:	43ff      	mvns	r7, r7
    d8d4:	f017 0701 	ands.w	r7, r7, #1
    d8d8:	d044      	beq.n	d964 <z_impl_zsock_poll+0x128>
			errno = -ret;
    d8da:	f00e f92b 	bl	1bb34 <z_errno>
    d8de:	4276      	negs	r6, r6
    d8e0:	6006      	str	r6, [r0, #0]
			return -1;
    d8e2:	f04f 36ff 	mov.w	r6, #4294967295
    d8e6:	e02b      	b.n	d940 <z_impl_zsock_poll+0x104>
		timeout = K_FOREVER;
    d8e8:	f04f 34ff 	mov.w	r4, #4294967295
    d8ec:	f04f 35ff 	mov.w	r5, #4294967295
		poll_timeout = SYS_FOREVER_MS;
    d8f0:	f04f 36ff 	mov.w	r6, #4294967295
    d8f4:	e7b7      	b.n	d866 <z_impl_zsock_poll+0x2a>
		if (pfd->fd < 0) {
    d8f6:	f8db 0000 	ldr.w	r0, [fp]
    d8fa:	2800      	cmp	r0, #0
    d8fc:	db2e      	blt.n	d95c <z_impl_zsock_poll+0x120>
		ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    d8fe:	a908      	add	r1, sp, #32
    d900:	f7ff fce6 	bl	d2d0 <z_get_fd_obj_and_vtable>
		if (ctx == NULL) {
    d904:	4601      	mov	r1, r0
    d906:	b348      	cbz	r0, d95c <z_impl_zsock_poll+0x120>
		result = z_fdtable_call_ioctl(vtable, ctx,
    d908:	ab18      	add	r3, sp, #96	; 0x60
    d90a:	9301      	str	r3, [sp, #4]
    d90c:	ab07      	add	r3, sp, #28
    d90e:	f240 1203 	movw	r2, #259	; 0x103
    d912:	9300      	str	r3, [sp, #0]
    d914:	9005      	str	r0, [sp, #20]
    d916:	465b      	mov	r3, fp
    d918:	9808      	ldr	r0, [sp, #32]
    d91a:	f00e f90d 	bl	1bb38 <z_fdtable_call_ioctl>
		if (result == -EALREADY) {
    d91e:	f110 0f45 	cmn.w	r0, #69	; 0x45
		result = z_fdtable_call_ioctl(vtable, ctx,
    d922:	4602      	mov	r2, r0
		if (result == -EALREADY) {
    d924:	d018      	beq.n	d958 <z_impl_zsock_poll+0x11c>
		} else if (result == -EXDEV) {
    d926:	f110 0f12 	cmn.w	r0, #18
    d92a:	9905      	ldr	r1, [sp, #20]
    d92c:	d10c      	bne.n	d948 <z_impl_zsock_poll+0x10c>
			return z_fdtable_call_ioctl(vtable, ctx,
    d92e:	e9cd 9600 	strd	r9, r6, [sp]
    d932:	4643      	mov	r3, r8
    d934:	f240 1205 	movw	r2, #261	; 0x105
    d938:	9808      	ldr	r0, [sp, #32]
    d93a:	f00e f8fd 	bl	1bb38 <z_fdtable_call_ioctl>
    d93e:	4606      	mov	r6, r0
			}
		}
	} while (retry);

	return ret;
}
    d940:	4630      	mov	r0, r6
    d942:	b019      	add	sp, #100	; 0x64
    d944:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (result != 0) {
    d948:	b140      	cbz	r0, d95c <z_impl_zsock_poll+0x120>
    d94a:	9203      	str	r2, [sp, #12]
				errno = -result;
    d94c:	f00e f8f2 	bl	1bb34 <z_errno>
    d950:	9a03      	ldr	r2, [sp, #12]
    d952:	4252      	negs	r2, r2
    d954:	6002      	str	r2, [r0, #0]
				return -1;
    d956:	e7c4      	b.n	d8e2 <z_impl_zsock_poll+0xa6>
			timeout = K_NO_WAIT;
    d958:	2400      	movs	r4, #0
    d95a:	2500      	movs	r5, #0
	for (pfd = fds, i = nfds; i--; pfd++) {
    d95c:	f10b 0b08 	add.w	fp, fp, #8
    d960:	3f01      	subs	r7, #1
    d962:	e78c      	b.n	d87e <z_impl_zsock_poll+0x42>
		for (pfd = fds, i = nfds; i--; pfd++) {
    d964:	46cb      	mov	fp, r9
    d966:	4643      	mov	r3, r8
		ret = 0;
    d968:	463e      	mov	r6, r7
		pev = poll_events;
    d96a:	f8cd a01c 	str.w	sl, [sp, #28]
		for (pfd = fds, i = nfds; i--; pfd++) {
    d96e:	f1bb 0f00 	cmp.w	fp, #0
    d972:	d117      	bne.n	d9a4 <z_impl_zsock_poll+0x168>
		if (retry) {
    d974:	2f00      	cmp	r7, #0
    d976:	d0e3      	beq.n	d940 <z_impl_zsock_poll+0x104>
			if (ret > 0) {
    d978:	2e00      	cmp	r6, #0
    d97a:	dce1      	bgt.n	d940 <z_impl_zsock_poll+0x104>
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    d97c:	ea54 0305 	orrs.w	r3, r4, r5
    d980:	d0de      	beq.n	d940 <z_impl_zsock_poll+0x104>
			if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    d982:	1c6b      	adds	r3, r5, #1
    d984:	bf08      	it	eq
    d986:	f1b4 3fff 	cmpeq.w	r4, #4294967295
    d98a:	d08f      	beq.n	d8ac <z_impl_zsock_poll+0x70>
				s64_t remaining = end - z_tick_get();
    d98c:	f00d faec 	bl	1af68 <z_tick_get>
    d990:	9b03      	ldr	r3, [sp, #12]
    d992:	1a1c      	subs	r4, r3, r0
    d994:	9b04      	ldr	r3, [sp, #16]
    d996:	eb63 0501 	sbc.w	r5, r3, r1
				if (remaining <= 0) {
    d99a:	2c01      	cmp	r4, #1
    d99c:	f175 0300 	sbcs.w	r3, r5, #0
    d9a0:	da84      	bge.n	d8ac <z_impl_zsock_poll+0x70>
    d9a2:	e7cd      	b.n	d940 <z_impl_zsock_poll+0x104>
			pfd->revents = 0;
    d9a4:	f04f 0200 	mov.w	r2, #0
			if (pfd->fd < 0) {
    d9a8:	6818      	ldr	r0, [r3, #0]
			pfd->revents = 0;
    d9aa:	80da      	strh	r2, [r3, #6]
			if (pfd->fd < 0) {
    d9ac:	2800      	cmp	r0, #0
    d9ae:	db1d      	blt.n	d9ec <z_impl_zsock_poll+0x1b0>
			ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
    d9b0:	a908      	add	r1, sp, #32
    d9b2:	9305      	str	r3, [sp, #20]
    d9b4:	f7ff fc8c 	bl	d2d0 <z_get_fd_obj_and_vtable>
			if (ctx == NULL) {
    d9b8:	9b05      	ldr	r3, [sp, #20]
    d9ba:	4601      	mov	r1, r0
    d9bc:	b918      	cbnz	r0, d9c6 <z_impl_zsock_poll+0x18a>
				pfd->revents = ZSOCK_POLLNVAL;
    d9be:	2220      	movs	r2, #32
    d9c0:	80da      	strh	r2, [r3, #6]
				ret++;
    d9c2:	3601      	adds	r6, #1
    d9c4:	e012      	b.n	d9ec <z_impl_zsock_poll+0x1b0>
			result = z_fdtable_call_ioctl(vtable, ctx,
    d9c6:	aa07      	add	r2, sp, #28
    d9c8:	9200      	str	r2, [sp, #0]
    d9ca:	9808      	ldr	r0, [sp, #32]
    d9cc:	f44f 7282 	mov.w	r2, #260	; 0x104
    d9d0:	9305      	str	r3, [sp, #20]
    d9d2:	f00e f8b1 	bl	1bb38 <z_fdtable_call_ioctl>
			if (result == -EAGAIN) {
    d9d6:	f110 0f0b 	cmn.w	r0, #11
			result = z_fdtable_call_ioctl(vtable, ctx,
    d9da:	4602      	mov	r2, r0
			if (result == -EAGAIN) {
    d9dc:	9b05      	ldr	r3, [sp, #20]
    d9de:	d009      	beq.n	d9f4 <z_impl_zsock_poll+0x1b8>
			} else if (result != 0) {
    d9e0:	2800      	cmp	r0, #0
    d9e2:	d1b2      	bne.n	d94a <z_impl_zsock_poll+0x10e>
			if (pfd->revents != 0) {
    d9e4:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
    d9e8:	2a00      	cmp	r2, #0
    d9ea:	d1ea      	bne.n	d9c2 <z_impl_zsock_poll+0x186>
		for (pfd = fds, i = nfds; i--; pfd++) {
    d9ec:	3308      	adds	r3, #8
    d9ee:	f10b 3bff 	add.w	fp, fp, #4294967295
    d9f2:	e7bc      	b.n	d96e <z_impl_zsock_poll+0x132>
				retry = true;
    d9f4:	2701      	movs	r7, #1
    d9f6:	e7f9      	b.n	d9ec <z_impl_zsock_poll+0x1b0>
    d9f8:	cccccccd 	.word	0xcccccccd

0000d9fc <socket_offload_dns_register>:
void socket_offload_dns_register(const struct socket_dns_offload *ops)
{
	__ASSERT_NO_MSG(ops);
	__ASSERT_NO_MSG(dns_offload == NULL);

	dns_offload = ops;
    d9fc:	4b01      	ldr	r3, [pc, #4]	; (da04 <socket_offload_dns_register+0x8>)
    d9fe:	6018      	str	r0, [r3, #0]
}
    da00:	4770      	bx	lr
    da02:	bf00      	nop
    da04:	200202b4 	.word	0x200202b4

0000da08 <socket_offload_getaddrinfo>:

int socket_offload_getaddrinfo(const char *node, const char *service,
			       const struct zsock_addrinfo *hints,
			       struct zsock_addrinfo **res)
{
    da08:	b410      	push	{r4}
	__ASSERT_NO_MSG(dns_offload);
	__ASSERT_NO_MSG(dns_offload->getaddrinfo);

	return dns_offload->getaddrinfo(node, service, hints, res);
    da0a:	4c03      	ldr	r4, [pc, #12]	; (da18 <socket_offload_getaddrinfo+0x10>)
    da0c:	6824      	ldr	r4, [r4, #0]
    da0e:	6824      	ldr	r4, [r4, #0]
    da10:	46a4      	mov	ip, r4
}
    da12:	f85d 4b04 	ldr.w	r4, [sp], #4
	return dns_offload->getaddrinfo(node, service, hints, res);
    da16:	4760      	bx	ip
    da18:	200202b4 	.word	0x200202b4

0000da1c <socket_offload_freeaddrinfo>:
void socket_offload_freeaddrinfo(struct zsock_addrinfo *res)
{
	__ASSERT_NO_MSG(dns_offload);
	__ASSERT_NO_MSG(dns_offload->freeaddrinfo);

	return dns_offload->freeaddrinfo(res);
    da1c:	4b01      	ldr	r3, [pc, #4]	; (da24 <socket_offload_freeaddrinfo+0x8>)
    da1e:	681b      	ldr	r3, [r3, #0]
    da20:	685b      	ldr	r3, [r3, #4]
    da22:	4718      	bx	r3
    da24:	200202b4 	.word	0x200202b4

0000da28 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
    da28:	b508      	push	{r3, lr}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    da2a:	4806      	ldr	r0, [pc, #24]	; (da44 <uart_console_init+0x1c>)
    da2c:	f00c f9a0 	bl	19d70 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    da30:	4b05      	ldr	r3, [pc, #20]	; (da48 <uart_console_init+0x20>)
    da32:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
    da34:	4805      	ldr	r0, [pc, #20]	; (da4c <uart_console_init+0x24>)
    da36:	f001 faeb 	bl	f010 <__stdout_hook_install>
	__printk_hook_install(console_out);
    da3a:	4804      	ldr	r0, [pc, #16]	; (da4c <uart_console_init+0x24>)
    da3c:	f7ff fcee 	bl	d41c <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
    da40:	2000      	movs	r0, #0
    da42:	bd08      	pop	{r3, pc}
    da44:	0001e45b 	.word	0x0001e45b
    da48:	200202b8 	.word	0x200202b8
    da4c:	0000da51 	.word	0x0000da51

0000da50 <console_out>:
	if ('\n' == c) {
    da50:	280a      	cmp	r0, #10
{
    da52:	b538      	push	{r3, r4, r5, lr}
    da54:	4604      	mov	r4, r0
    da56:	4d07      	ldr	r5, [pc, #28]	; (da74 <console_out+0x24>)
	if ('\n' == c) {
    da58:	d104      	bne.n	da64 <console_out+0x14>
    da5a:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
    da5c:	6883      	ldr	r3, [r0, #8]
    da5e:	210d      	movs	r1, #13
    da60:	685b      	ldr	r3, [r3, #4]
    da62:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    da64:	6828      	ldr	r0, [r5, #0]
    da66:	6883      	ldr	r3, [r0, #8]
    da68:	b2e1      	uxtb	r1, r4
    da6a:	685b      	ldr	r3, [r3, #4]
    da6c:	4798      	blx	r3
}
    da6e:	4620      	mov	r0, r4
    da70:	bd38      	pop	{r3, r4, r5, pc}
    da72:	bf00      	nop
    da74:	200202b8 	.word	0x200202b8

0000da78 <clock_async_start>:
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
    da78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct nrf_clock_control_sub_data *clk_data;
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
	config = get_sub_config(dev, type);
    da7c:	6846      	ldr	r6, [r0, #4]
	clk_data = get_sub_data(dev, type);
    da7e:	f8d0 e00c 	ldr.w	lr, [r0, #12]
    da82:	b2cf      	uxtb	r7, r1
			((data != NULL) && (data->cb != NULL)));

	/* if node is in the list it means that it is scheduled for
	 * the second time.
	 */
	if ((data != NULL)
    da84:	b14a      	cbz	r2, da9a <clock_async_start+0x22>
	sys_snode_t *item = sys_slist_peek_head(list);
    da86:	230c      	movs	r3, #12
    da88:	437b      	muls	r3, r7
    da8a:	f85e 3003 	ldr.w	r3, [lr, r3]
		if (item == node) {
    da8e:	429a      	cmp	r2, r3
    da90:	d053      	beq.n	db3a <clock_async_start+0xc2>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    da92:	b113      	cbz	r3, da9a <clock_async_start+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    da94:	681b      	ldr	r3, [r3, #0]
	} while (item);
    da96:	2b00      	cmp	r3, #0
    da98:	d1f9      	bne.n	da8e <clock_async_start+0x16>
	__asm__ volatile(
    da9a:	f04f 0320 	mov.w	r3, #32
    da9e:	f3ef 8c11 	mrs	ip, BASEPRI
    daa2:	f383 8811 	msr	BASEPRI, r3
    daa6:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
    daaa:	250c      	movs	r5, #12
    daac:	437d      	muls	r5, r7
    daae:	eb0e 0305 	add.w	r3, lr, r5
    dab2:	7a1c      	ldrb	r4, [r3, #8]
    dab4:	3401      	adds	r4, #1
    dab6:	b2e4      	uxtb	r4, r4
    dab8:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
    daba:	f38c 8811 	msr	BASEPRI, ip
    dabe:	f3bf 8f6f 	isb	sy
	__ASSERT_NO_MSG(clk_data->ref > 0);
	irq_unlock(key);

	if (data) {
    dac2:	b352      	cbz	r2, db1a <clock_async_start+0xa2>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
    dac4:	f04f 0803 	mov.w	r8, #3
    dac8:	f8df c078 	ldr.w	ip, [pc, #120]	; db44 <clock_async_start+0xcc>
    dacc:	f8cc 8308 	str.w	r8, [ip, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
    dad0:	f893 c009 	ldrb.w	ip, [r3, #9]
		if (!already_started) {
    dad4:	f1bc 0f00 	cmp.w	ip, #0
    dad8:	d115      	bne.n	db06 <clock_async_start+0x8e>
	__asm__ volatile(
    dada:	f04f 0820 	mov.w	r8, #32
    dade:	f3ef 8911 	mrs	r9, BASEPRI
    dae2:	f388 8811 	msr	BASEPRI, r8
    dae6:	f3bf 8f6f 	isb	sy
	parent->next = child;
    daea:	f8c2 c000 	str.w	ip, [r2]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    daee:	f8d3 8004 	ldr.w	r8, [r3, #4]
    daf2:	f1b8 0f00 	cmp.w	r8, #0
    daf6:	d11c      	bne.n	db32 <clock_async_start+0xba>
	list->tail = node;
    daf8:	605a      	str	r2, [r3, #4]
	list->head = node;
    dafa:	f84e 2005 	str.w	r2, [lr, r5]
	__asm__ volatile(
    dafe:	f389 8811 	msr	BASEPRI, r9
    db02:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
    db06:	2503      	movs	r5, #3
    db08:	4b0e      	ldr	r3, [pc, #56]	; (db44 <clock_async_start+0xcc>)
    db0a:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
    db0e:	f1bc 0f00 	cmp.w	ip, #0
    db12:	d002      	beq.n	db1a <clock_async_start+0xa2>
			data->cb(dev, subsys, data->user_data);
    db14:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
    db18:	4798      	blx	r3
		}
	}

	if (ref == 1) {
    db1a:	2c01      	cmp	r4, #1
    db1c:	d107      	bne.n	db2e <clock_async_start+0xb6>
		if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			(subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
			anomaly_132_workaround();
		}

		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
    db1e:	eb06 0687 	add.w	r6, r6, r7, lsl #2
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    db22:	78b3      	ldrb	r3, [r6, #2]
    db24:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    db28:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
    db2c:	601c      	str	r4, [r3, #0]
	}

	return 0;
    db2e:	2000      	movs	r0, #0
    db30:	e005      	b.n	db3e <clock_async_start+0xc6>
	parent->next = child;
    db32:	f8c8 2000 	str.w	r2, [r8]
	list->tail = node;
    db36:	605a      	str	r2, [r3, #4]
}
    db38:	e7e1      	b.n	dafe <clock_async_start+0x86>
		return -EBUSY;
    db3a:	f06f 000f 	mvn.w	r0, #15
}
    db3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    db42:	bf00      	nop
    db44:	40005000 	.word	0x40005000

0000db48 <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
    db48:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    db4a:	2200      	movs	r2, #0
{
    db4c:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    db4e:	2101      	movs	r1, #1
    db50:	2005      	movs	r0, #5
    db52:	f000 f983 	bl	de5c <z_arm_irq_priority_set>
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_IRQN(0));
    db56:	2005      	movs	r0, #5
    db58:	f000 f970 	bl	de3c <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
    db5c:	2202      	movs	r2, #2
    db5e:	4b07      	ldr	r3, [pc, #28]	; (db7c <clk_init+0x34>)
	list->head = NULL;
    db60:	2000      	movs	r0, #0
    db62:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
    db66:	2203      	movs	r2, #3
    db68:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
    db6c:	68e3      	ldr	r3, [r4, #12]
	list->tail = NULL;
    db6e:	e9c3 0000 	strd	r0, r0, [r3]
    db72:	68e3      	ldr	r3, [r4, #12]
    db74:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
    db78:	bd10      	pop	{r4, pc}
    db7a:	bf00      	nop
    db7c:	40005000 	.word	0x40005000

0000db80 <clkstarted_handle.constprop.0>:
DEVICE_AND_API_INIT(clock_nrf, DT_INST_LABEL(0),
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
    db80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
    db82:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    db84:	4f11      	ldr	r7, [pc, #68]	; (dbcc <clkstarted_handle.constprop.0+0x4c>)
static void clkstarted_handle(struct device *dev,
    db86:	4605      	mov	r5, r0
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    db88:	68fb      	ldr	r3, [r7, #12]
	sub_data->started = true;
    db8a:	fb04 3400 	mla	r4, r4, r0, r3
    db8e:	2301      	movs	r3, #1
    db90:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
    db92:	f04f 0320 	mov.w	r3, #32
    db96:	f3ef 8111 	mrs	r1, BASEPRI
    db9a:	f383 8811 	msr	BASEPRI, r3
    db9e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
    dba2:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
    dba4:	b12b      	cbz	r3, dbb2 <clkstarted_handle.constprop.0+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    dba6:	6866      	ldr	r6, [r4, #4]
    dba8:	681a      	ldr	r2, [r3, #0]
    dbaa:	42b3      	cmp	r3, r6
	list->head = node;
    dbac:	6022      	str	r2, [r4, #0]
	list->tail = node;
    dbae:	bf08      	it	eq
    dbb0:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
    dbb2:	f381 8811 	msr	BASEPRI, r1
    dbb6:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
    dbba:	b903      	cbnz	r3, dbbe <clkstarted_handle.constprop.0+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
    dbbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
    dbbe:	4629      	mov	r1, r5
    dbc0:	e9d3 6201 	ldrd	r6, r2, [r3, #4]
    dbc4:	4638      	mov	r0, r7
    dbc6:	47b0      	blx	r6
    dbc8:	e7e3      	b.n	db92 <clkstarted_handle.constprop.0+0x12>
    dbca:	bf00      	nop
    dbcc:	20020100 	.word	0x20020100

0000dbd0 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
    dbd0:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    dbd2:	4b10      	ldr	r3, [pc, #64]	; (dc14 <nrf_power_clock_isr+0x44>)
    dbd4:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    dbd6:	b162      	cbz	r2, dbf2 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
    dbd8:	4a0f      	ldr	r2, [pc, #60]	; (dc18 <nrf_power_clock_isr+0x48>)
    dbda:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    dbde:	07d1      	lsls	r1, r2, #31
    dbe0:	d507      	bpl.n	dbf2 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    dbe2:	2200      	movs	r2, #0
    dbe4:	601a      	str	r2, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    dbe6:	4b0d      	ldr	r3, [pc, #52]	; (dc1c <nrf_power_clock_isr+0x4c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
    dbe8:	68db      	ldr	r3, [r3, #12]
    dbea:	7a58      	ldrb	r0, [r3, #9]
    dbec:	b908      	cbnz	r0, dbf2 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    dbee:	f7ff ffc7 	bl	db80 <clkstarted_handle.constprop.0>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    dbf2:	4b0b      	ldr	r3, [pc, #44]	; (dc20 <nrf_power_clock_isr+0x50>)
    dbf4:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
    dbf6:	b15a      	cbz	r2, dc10 <nrf_power_clock_isr+0x40>
    return p_reg->INTENSET & mask;
    dbf8:	4a07      	ldr	r2, [pc, #28]	; (dc18 <nrf_power_clock_isr+0x48>)
    dbfa:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
    dbfe:	0792      	lsls	r2, r2, #30
    dc00:	d506      	bpl.n	dc10 <nrf_power_clock_isr+0x40>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    dc02:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    dc04:	2001      	movs	r0, #1
    dc06:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
    dc08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    dc0c:	f7ff bfb8 	b.w	db80 <clkstarted_handle.constprop.0>
}
    dc10:	bd08      	pop	{r3, pc}
    dc12:	bf00      	nop
    dc14:	40005100 	.word	0x40005100
    dc18:	40005000 	.word	0x40005000
    dc1c:	20020100 	.word	0x20020100
    dc20:	40005104 	.word	0x40005104

0000dc24 <handle_next_tick_case>:
 * counter progresses during that time it means that 1 tick elapsed and
 * interrupt is set pending.
 */
static void handle_next_tick_case(u32_t t)
{
	set_comparator(t + 2);
    dc24:	1c82      	adds	r2, r0, #2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    dc26:	4b08      	ldr	r3, [pc, #32]	; (dc48 <handle_next_tick_case+0x24>)
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    dc28:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    dc2c:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    dc30:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	while (t != counter()) {
    dc34:	4290      	cmp	r0, r2
    dc36:	d100      	bne.n	dc3a <handle_next_tick_case+0x16>
		 * generated. Trigger interrupt.
		 */
		t = counter();
		set_comparator(t + 2);
	}
}
    dc38:	4770      	bx	lr
    dc3a:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		set_comparator(t + 2);
    dc3e:	1c82      	adds	r2, r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    dc40:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    dc44:	e7f2      	b.n	dc2c <handle_next_tick_case+0x8>
    dc46:	bf00      	nop
    dc48:	40015000 	.word	0x40015000

0000dc4c <rtc1_nrf_isr>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dc4c:	2200      	movs	r2, #0
    dc4e:	4b06      	ldr	r3, [pc, #24]	; (dc68 <rtc1_nrf_isr+0x1c>)
    dc50:	601a      	str	r2, [r3, #0]
{
	ARG_UNUSED(arg);
	event_clear();

	u32_t t = get_comparator();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
    dc52:	4a06      	ldr	r2, [pc, #24]	; (dc6c <rtc1_nrf_isr+0x20>)
    return p_reg->CC[ch];
    dc54:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
    dc58:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    dc5a:	1ac0      	subs	r0, r0, r3
    dc5c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    dc60:	4403      	add	r3, r0
    dc62:	6013      	str	r3, [r2, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
    dc64:	f00d b92c 	b.w	1aec0 <z_clock_announce>
    dc68:	40015140 	.word	0x40015140
    dc6c:	200202d4 	.word	0x200202d4

0000dc70 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
    dc70:	b538      	push	{r3, r4, r5, lr}
    dc72:	4814      	ldr	r0, [pc, #80]	; (dcc4 <z_clock_driver_init+0x54>)
    dc74:	f00c f87c 	bl	19d70 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
    dc78:	b300      	cbz	r0, dcbc <z_clock_driver_init+0x4c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
    dc7a:	6883      	ldr	r3, [r0, #8]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
    dc7c:	2400      	movs	r4, #0
    dc7e:	2101      	movs	r1, #1
    dc80:	681b      	ldr	r3, [r3, #0]
    dc82:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    dc84:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    dc88:	4d0f      	ldr	r5, [pc, #60]	; (dcc8 <z_clock_driver_init+0x58>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dc8a:	4b10      	ldr	r3, [pc, #64]	; (dccc <z_clock_driver_init+0x5c>)
    p_reg->PRESCALER = val;
    dc8c:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dc90:	601c      	str	r4, [r3, #0]
    dc92:	4b0f      	ldr	r3, [pc, #60]	; (dcd0 <z_clock_driver_init+0x60>)
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
    dc94:	2101      	movs	r1, #1
    dc96:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    p_reg->INTENSET = mask;
    dc9a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    dc9e:	4622      	mov	r2, r4
    dca0:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    dca4:	2015      	movs	r0, #21
    dca6:	f000 f8d9 	bl	de5c <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
    dcaa:	2015      	movs	r0, #21
    dcac:	f000 f8c6 	bl	de3c <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    dcb0:	2301      	movs	r3, #1

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
    dcb2:	4620      	mov	r0, r4
    dcb4:	4a07      	ldr	r2, [pc, #28]	; (dcd4 <z_clock_driver_init+0x64>)
    dcb6:	6013      	str	r3, [r2, #0]
    dcb8:	602b      	str	r3, [r5, #0]
}
    dcba:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    dcbc:	f04f 30ff 	mov.w	r0, #4294967295
    dcc0:	e7fb      	b.n	dcba <z_clock_driver_init+0x4a>
    dcc2:	bf00      	nop
    dcc4:	0001e462 	.word	0x0001e462
    dcc8:	40015000 	.word	0x40015000
    dccc:	40015140 	.word	0x40015140
    dcd0:	e000e100 	.word	0xe000e100
    dcd4:	40015008 	.word	0x40015008

0000dcd8 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
    dcd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     return p_reg->COUNTER;
    dcda:	4b2c      	ldr	r3, [pc, #176]	; (dd8c <z_clock_set_timeout+0xb4>)

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    dcdc:	4c2c      	ldr	r4, [pc, #176]	; (dd90 <z_clock_set_timeout+0xb8>)
    dcde:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	u32_t unannounced = counter_sub(counter(), last_count);
    dce2:	4b2c      	ldr	r3, [pc, #176]	; (dd94 <z_clock_set_timeout+0xbc>)
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    dce4:	f1b0 3fff 	cmp.w	r0, #4294967295
    dce8:	bf08      	it	eq
    dcea:	4620      	moveq	r0, r4
	u32_t unannounced = counter_sub(counter(), last_count);
    dcec:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
    dcee:	1a52      	subs	r2, r2, r1
    dcf0:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    dcf4:	0212      	lsls	r2, r2, #8
    dcf6:	d436      	bmi.n	dd66 <z_clock_set_timeout+0x8e>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
    dcf8:	3801      	subs	r0, #1
    dcfa:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
    dcfe:	42a0      	cmp	r0, r4
    dd00:	bfa8      	it	ge
    dd02:	4620      	movge	r0, r4
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    dd04:	3301      	adds	r3, #1
    dd06:	4418      	add	r0, r3
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
    dd08:	42a0      	cmp	r0, r4
    dd0a:	bf94      	ite	ls
    dd0c:	180c      	addls	r4, r1, r0
    dd0e:	190c      	addhi	r4, r1, r4
    p_reg->INTENCLR = mask;
    dd10:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dd14:	2700      	movs	r7, #0
    p_reg->INTENCLR = mask;
    dd16:	4b1d      	ldr	r3, [pc, #116]	; (dd8c <z_clock_set_timeout+0xb4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dd18:	4e1f      	ldr	r6, [pc, #124]	; (dd98 <z_clock_set_timeout+0xc0>)
    p_reg->INTENCLR = mask;
    dd1a:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
     return p_reg->COUNTER;
    dd1e:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
    return p_reg->CC[ch];
    dd22:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    dd26:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	return (a - b) & COUNTER_MAX;
    dd2a:	1a52      	subs	r2, r2, r1
    dd2c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
	if (counter_sub(prev_val, now) == 1) {
    dd30:	2a01      	cmp	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dd32:	6037      	str	r7, [r6, #0]
    p_reg->CC[ch] = cc_val;
    dd34:	f8c3 5540 	str.w	r5, [r3, #1344]	; 0x540
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    dd38:	461d      	mov	r5, r3
    dd3a:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
    dd3e:	d103      	bne.n	dd48 <z_clock_set_timeout+0x70>
	z_impl_k_busy_wait(usec_to_wait);
    dd40:	200f      	movs	r0, #15
    dd42:	f00f fc4c 	bl	1d5de <z_impl_k_busy_wait>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    dd46:	6037      	str	r7, [r6, #0]
    dd48:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    dd4c:	4b13      	ldr	r3, [pc, #76]	; (dd9c <z_clock_set_timeout+0xc4>)
    dd4e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     return p_reg->COUNTER;
    dd52:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    dd56:	1a23      	subs	r3, r4, r0
    dd58:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (diff == 1) {
    dd5c:	2b01      	cmp	r3, #1
    dd5e:	d104      	bne.n	dd6a <z_clock_set_timeout+0x92>
		handle_next_tick_case(t);
    dd60:	f7ff ff60 	bl	dc24 <handle_next_tick_case>
    dd64:	e00b      	b.n	dd7e <z_clock_set_timeout+0xa6>
		ticks = 0;
    dd66:	2000      	movs	r0, #0
    dd68:	e7cc      	b.n	dd04 <z_clock_set_timeout+0x2c>
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
    dd6a:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    dd6e:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
     return p_reg->COUNTER;
    dd72:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    dd76:	1a24      	subs	r4, r4, r0
    dd78:	3c02      	subs	r4, #2
	if (diff > MAX_TICKS) {
    dd7a:	0223      	lsls	r3, r4, #8
    dd7c:	d4f0      	bmi.n	dd60 <z_clock_set_timeout+0x88>
    p_reg->INTENSET = mask;
    dd7e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    dd82:	4b02      	ldr	r3, [pc, #8]	; (dd8c <z_clock_set_timeout+0xb4>)
    dd84:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	set_protected_absolute_ticks(cyc);
}
    dd88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dd8a:	bf00      	nop
    dd8c:	40015000 	.word	0x40015000
    dd90:	007fffff 	.word	0x007fffff
    dd94:	200202d4 	.word	0x200202d4
    dd98:	40015140 	.word	0x40015140
    dd9c:	e000e100 	.word	0xe000e100

0000dda0 <z_clock_elapsed>:
	__asm__ volatile(
    dda0:	f04f 0220 	mov.w	r2, #32
    dda4:	f3ef 8311 	mrs	r3, BASEPRI
    dda8:	f382 8811 	msr	BASEPRI, r2
    ddac:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
    ddb0:	4a06      	ldr	r2, [pc, #24]	; (ddcc <z_clock_elapsed+0x2c>)
    ddb2:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    ddb6:	4a06      	ldr	r2, [pc, #24]	; (ddd0 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    ddb8:	6812      	ldr	r2, [r2, #0]
    ddba:	1a80      	subs	r0, r0, r2
    ddbc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    ddc0:	f383 8811 	msr	BASEPRI, r3
    ddc4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    ddc8:	4770      	bx	lr
    ddca:	bf00      	nop
    ddcc:	40015000 	.word	0x40015000
    ddd0:	200202d4 	.word	0x200202d4

0000ddd4 <z_timer_cycle_get_32>:
	__asm__ volatile(
    ddd4:	f04f 0320 	mov.w	r3, #32
    ddd8:	f3ef 8211 	mrs	r2, BASEPRI
    dddc:	f383 8811 	msr	BASEPRI, r3
    dde0:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
    dde4:	4906      	ldr	r1, [pc, #24]	; (de00 <z_timer_cycle_get_32+0x2c>)
    dde6:	4b07      	ldr	r3, [pc, #28]	; (de04 <z_timer_cycle_get_32+0x30>)
    dde8:	6808      	ldr	r0, [r1, #0]
    ddea:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
    ddee:	f382 8811 	msr	BASEPRI, r2
    ddf2:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
    ddf6:	1a1b      	subs	r3, r3, r0
    ddf8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
    ddfc:	4418      	add	r0, r3
    ddfe:	4770      	bx	lr
    de00:	200202d4 	.word	0x200202d4
    de04:	40015000 	.word	0x40015000

0000de08 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
    de08:	4a09      	ldr	r2, [pc, #36]	; (de30 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    de0a:	490a      	ldr	r1, [pc, #40]	; (de34 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    de0c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    de0e:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    de10:	66d8      	str	r0, [r3, #108]	; 0x6c
	_current->arch.swap_return_value = _k_neg_eagain;
    de12:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    de14:	4908      	ldr	r1, [pc, #32]	; (de38 <arch_swap+0x30>)
    de16:	684b      	ldr	r3, [r1, #4]
    de18:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    de1c:	604b      	str	r3, [r1, #4]
    de1e:	2300      	movs	r3, #0
    de20:	f383 8811 	msr	BASEPRI, r3
    de24:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    de28:	6893      	ldr	r3, [r2, #8]
}
    de2a:	6f18      	ldr	r0, [r3, #112]	; 0x70
    de2c:	4770      	bx	lr
    de2e:	bf00      	nop
    de30:	20021f64 	.word	0x20021f64
    de34:	0001e0ec 	.word	0x0001e0ec
    de38:	e000ed00 	.word	0xe000ed00

0000de3c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    de3c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    de3e:	2b00      	cmp	r3, #0
    de40:	db08      	blt.n	de54 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    de42:	2201      	movs	r2, #1
    de44:	f000 001f 	and.w	r0, r0, #31
    de48:	fa02 f000 	lsl.w	r0, r2, r0
    de4c:	4a02      	ldr	r2, [pc, #8]	; (de58 <arch_irq_enable+0x1c>)
    de4e:	095b      	lsrs	r3, r3, #5
    de50:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    de54:	4770      	bx	lr
    de56:	bf00      	nop
    de58:	e000e100 	.word	0xe000e100

0000de5c <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    de5c:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    de5e:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    de60:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de64:	bfac      	ite	ge
    de66:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de6a:	4b06      	ldrlt	r3, [pc, #24]	; (de84 <z_arm_irq_priority_set+0x28>)
    de6c:	ea4f 1141 	mov.w	r1, r1, lsl #5
    de70:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de72:	bfab      	itete	ge
    de74:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de78:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de7c:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    de80:	5419      	strblt	r1, [r3, r0]
}
    de82:	4770      	bx	lr
    de84:	e000ed14 	.word	0xe000ed14

0000de88 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
    de88:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
    de8a:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
    de8c:	4b04      	ldr	r3, [pc, #16]	; (dea0 <_arch_isr_direct_pm+0x18>)
    de8e:	6a18      	ldr	r0, [r3, #32]
    de90:	b118      	cbz	r0, de9a <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
    de92:	2200      	movs	r2, #0
    de94:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
    de96:	f00f f955 	bl	1d144 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
    de9a:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
    de9c:	bd08      	pop	{r3, pc}
    de9e:	bf00      	nop
    dea0:	20021f64 	.word	0x20021f64

0000dea4 <arch_new_thread>:
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
	thread->stack_info.size = stack_size;
    dea4:	e9c0 1218 	strd	r1, r2, [r0, #96]	; 0x60
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
    dea8:	440a      	add	r2, r1
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
    deaa:	3a20      	subs	r2, #32
    deac:	f022 0207 	bic.w	r2, r2, #7
#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
    deb0:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
    deb2:	9b00      	ldr	r3, [sp, #0]
	pInitCtx->basic.pc &= 0xfffffffe;
    deb4:	4908      	ldr	r1, [pc, #32]	; (ded8 <arch_new_thread+0x34>)
	pInitCtx->basic.a2 = (u32_t)parameter1;
    deb6:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
    deb8:	9b01      	ldr	r3, [sp, #4]
	pInitCtx->basic.pc &= 0xfffffffe;
    deba:	f021 0101 	bic.w	r1, r1, #1
	pInitCtx->basic.a3 = (u32_t)parameter2;
    debe:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    dec0:	9b02      	ldr	r3, [sp, #8]
	pInitCtx->basic.pc &= 0xfffffffe;
    dec2:	6191      	str	r1, [r2, #24]
	pInitCtx->basic.a4 = (u32_t)parameter3;
    dec4:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
    dec6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    deca:	61d3      	str	r3, [r2, #28]
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;

	thread->arch.basepri = 0;
    decc:	2300      	movs	r3, #0
	thread->callee_saved.psp = (u32_t)pInitCtx;
    dece:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    ded0:	66c3      	str	r3, [r0, #108]	; 0x6c

#if defined(CONFIG_USERSPACE) || defined(CONFIG_FPU_SHARING)
	thread->arch.mode = 0;
    ded2:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    ded6:	4770      	bx	lr
    ded8:	0001b0db 	.word	0x0001b0db

0000dedc <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
    dedc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    dede:	461d      	mov	r5, r3
    dee0:	4606      	mov	r6, r0
    dee2:	460c      	mov	r4, r1
    dee4:	4617      	mov	r7, r2
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
#else
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    dee6:	2300      	movs	r3, #0
    dee8:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    deec:	f3ef 8314 	mrs	r3, CONTROL
	 * initialized at thread creation for threads that make use of the FP).
	 */
	__set_FPSCR(0);
#if defined(CONFIG_FPU_SHARING)
	/* In Sharing mode clearing FPSCR may set the CONTROL.FPCA flag. */
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    def0:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    def4:	f383 8814 	msr	CONTROL, r3
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
    def8:	f3bf 8f6f 	isb	sy
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    defc:	f000 fa20 	bl	e340 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);

	_current = main_thread;
    df00:	4b08      	ldr	r3, [pc, #32]	; (df24 <arch_switch_to_main_thread+0x48>)
	start_of_main_stack =
    df02:	19e2      	adds	r2, r4, r7
	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
    df04:	f022 0407 	bic.w	r4, r2, #7
	_current = main_thread;
    df08:	609e      	str	r6, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    df0a:	4628      	mov	r0, r5
    df0c:	f384 8809 	msr	PSP, r4
    df10:	2100      	movs	r1, #0
    df12:	b663      	cpsie	if
    df14:	f381 8811 	msr	BASEPRI, r1
    df18:	f3bf 8f6f 	isb	sy
    df1c:	2200      	movs	r2, #0
    df1e:	2300      	movs	r3, #0
    df20:	f00d f8db 	bl	1b0da <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    df24:	20021f64 	.word	0x20021f64

0000df28 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    df28:	4a14      	ldr	r2, [pc, #80]	; (df7c <z_arm_prep_c+0x54>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    df2a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    df2c:	4b14      	ldr	r3, [pc, #80]	; (df80 <z_arm_prep_c+0x58>)
    df2e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    df32:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    df34:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    df38:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    df3c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    df40:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    df44:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
    df48:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    df4c:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
    df50:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
    df54:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
    df58:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
    df5c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    df60:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
    df64:	2300      	movs	r3, #0
    df66:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    df6a:	f00b ff45 	bl	19df8 <z_bss_zero>
	z_data_copy();
    df6e:	f00b ff4d 	bl	19e0c <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    df72:	f000 f9b3 	bl	e2dc <z_arm_interrupt_init>
	z_cstart();
    df76:	f00b ff87 	bl	19e88 <z_cstart>
    df7a:	bf00      	nop
    df7c:	0000c000 	.word	0x0000c000
    df80:	e000ed00 	.word	0xe000ed00

0000df84 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    df84:	4926      	ldr	r1, [pc, #152]	; (e020 <in_fp_endif+0x20>)
    ldr r2, [r1, #_kernel_offset_to_current]
    df86:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    df88:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    df8c:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    df8e:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    df92:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    ldr r0, =0x10 /* EXC_RETURN.F_Type Mask */
    df96:	f04f 0010 	mov.w	r0, #16
    tst lr, r0    /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
    df9a:	ea1e 0f00 	tst.w	lr, r0
    beq out_fp_active
    df9e:	d004      	beq.n	dfaa <out_fp_active>
    /* FP context inactive: clear FP state */
    ldr r0, [r2, #_thread_offset_to_mode]
    dfa0:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    bic r0, #0x4 /* _current->arch.mode &= ~(CONTROL_FPCA_Msk) */
    dfa4:	f020 0004 	bic.w	r0, r0, #4
    b out_fp_endif
    dfa8:	e007      	b.n	dfba <out_fp_endif>

0000dfaa <out_fp_active>:

out_fp_active:
    /* FP context active: set FP state and store callee-saved registers */
    add r0, r2, #_thread_offset_to_preempt_float
    dfaa:	f102 0074 	add.w	r0, r2, #116	; 0x74
    vstmia r0, {s16-s31}
    dfae:	ec80 8a10 	vstmia	r0, {s16-s31}
    ldr r0, [r2, #_thread_offset_to_mode]
    dfb2:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    orrs r0, r0, #0x4 /* _current->arch.mode |= CONTROL_FPCA_Msk */
    dfb6:	f050 0004 	orrs.w	r0, r0, #4

0000dfba <out_fp_endif>:

out_fp_endif:
    str r0, [r2, #_thread_offset_to_mode]
    dfba:	f8c2 00b4 	str.w	r0, [r2, #180]	; 0xb4

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    dfbe:	2020      	movs	r0, #32
    msr BASEPRI, r0
    dfc0:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    dfc4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    dfc8:	4f16      	ldr	r7, [pc, #88]	; (e024 <in_fp_endif+0x24>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    dfca:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    dfce:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    dfd0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    dfd2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    dfd4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
    dfd6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    dfd8:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    dfda:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    ldr r0, [r2, #_thread_offset_to_mode]
    dfde:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    tst r0, #0x04 /* thread.arch.mode & CONTROL.FPCA Msk */
    dfe2:	f010 0f04 	tst.w	r0, #4
    bne in_fp_active
    dfe6:	d105      	bne.n	dff4 <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
    dfe8:	2300      	movs	r3, #0
    vmsr fpscr, r3
    dfea:	eee1 3a10 	vmsr	fpscr, r3
    orrs lr, lr, #0x10 /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
    dfee:	f05e 0e10 	orrs.w	lr, lr, #16
    b in_fp_endif
    dff2:	e005      	b.n	e000 <in_fp_endif>

0000dff4 <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    bic lr, #0x10 /* EXC_RETURN | (~EXC_RETURN.F_Type_Msk) */
    dff4:	f02e 0e10 	bic.w	lr, lr, #16
    add r0, r2, #_thread_offset_to_preempt_float
    dff8:	f102 0074 	add.w	r0, r2, #116	; 0x74
    vldmia r0, {s16-s31}
    dffc:	ec90 8a10 	vldmia	r0, {s16-s31}

0000e000 <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
    e000:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #0x4 /* CONTROL.FPCA Msk */
    e004:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
    e008:	f383 8814 	msr	CONTROL, r3
    isb
    e00c:	f3bf 8f6f 	isb	sy
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    e010:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    e014:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    e018:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    e01c:	4770      	bx	lr
    e01e:	0000      	.short	0x0000
    ldr r1, =_kernel
    e020:	20021f64 	.word	0x20021f64
    ldr v4, =_SCS_ICSR
    e024:	e000ed04 	.word	0xe000ed04

0000e028 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    e028:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    e02c:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    e02e:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    e032:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    e036:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    e038:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    e03c:	2902      	cmp	r1, #2
    beq _oops
    e03e:	d0ff      	beq.n	e040 <_oops>

0000e040 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    e040:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    e042:	f00d fe25 	bl	1bc90 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    e046:	bd01      	pop	{r0, pc}

0000e048 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    e048:	4901      	ldr	r1, [pc, #4]	; (e050 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    e04a:	2210      	movs	r2, #16
	str	r2, [r1]
    e04c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    e04e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    e050:	e000ed10 	.word	0xe000ed10

0000e054 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    e054:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    e056:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    e058:	f380 8811 	msr	BASEPRI, r0
	isb
    e05c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    e060:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    e064:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    e066:	b662      	cpsie	i
	isb
    e068:	f3bf 8f6f 	isb	sy

	bx	lr
    e06c:	4770      	bx	lr
    e06e:	bf00      	nop

0000e070 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    e070:	bf30      	wfi
    b z_SysNmiOnReset
    e072:	f7ff bffd 	b.w	e070 <z_SysNmiOnReset>
    e076:	bf00      	nop

0000e078 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    e078:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    e07a:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    e07c:	4a0b      	ldr	r2, [pc, #44]	; (e0ac <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    e07e:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    e080:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    e082:	bf1e      	ittt	ne
	movne	r1, #0
    e084:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    e086:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
    e088:	f00f f85c 	blne	1d144 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    e08c:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    e08e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    e092:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    e096:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    e09a:	4905      	ldr	r1, [pc, #20]	; (e0b0 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    e09c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    e09e:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
    e0a0:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    e0a2:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    e0a6:	4903      	ldr	r1, [pc, #12]	; (e0b4 <_isr_wrapper+0x3c>)
	bx r1
    e0a8:	4708      	bx	r1
    e0aa:	0000      	.short	0x0000
	ldr r2, =_kernel
    e0ac:	20021f64 	.word	0x20021f64
	ldr r1, =_sw_isr_table
    e0b0:	0001d994 	.word	0x0001d994
	ldr r1, =z_arm_int_exit
    e0b4:	0000e0fd 	.word	0x0000e0fd

0000e0b8 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    e0b8:	f00d fa92 	bl	1b5e0 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    e0bc:	2020      	movs	r0, #32
    msr BASEPRI, r0
    e0be:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    e0c2:	4808      	ldr	r0, [pc, #32]	; (e0e4 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
    e0c4:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    e0c8:	1840      	adds	r0, r0, r1
    msr PSP, r0
    e0ca:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    e0ce:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    e0d2:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    e0d4:	4308      	orrs	r0, r1
    msr CONTROL, r0
    e0d6:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    e0da:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    e0de:	f7ff ff23 	bl	df28 <z_arm_prep_c>
    e0e2:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
    e0e4:	20025020 	.word	0x20025020

0000e0e8 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    e0e8:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    e0ec:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
    e0f0:	4672      	mov	r2, lr

	push {r0, lr}
    e0f2:	b501      	push	{r0, lr}

	bl z_arm_fault
    e0f4:	f000 f85c 	bl	e1b0 <z_arm_fault>

	pop {r0, pc}
    e0f8:	bd01      	pop	{r0, pc}
    e0fa:	bf00      	nop

0000e0fc <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    e0fc:	4b04      	ldr	r3, [pc, #16]	; (e110 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    e0fe:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    e100:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
    e102:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    e104:	d003      	beq.n	e10e <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    e106:	4903      	ldr	r1, [pc, #12]	; (e114 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    e108:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    e10c:	600a      	str	r2, [r1, #0]

0000e10e <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    e10e:	4770      	bx	lr
	ldr r3, =_kernel
    e110:	20021f64 	.word	0x20021f64
	ldr r1, =_SCS_ICSR
    e114:	e000ed04 	.word	0xe000ed04

0000e118 <mem_manage_fault.isra.0>:
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    e118:	4b0c      	ldr	r3, [pc, #48]	; (e14c <mem_manage_fault.isra.0+0x34>)
    e11a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    e11c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    e11e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e120:	0792      	lsls	r2, r2, #30
    e122:	d508      	bpl.n	e136 <mem_manage_fault.isra.0+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
    e124:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    e126:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e128:	0612      	lsls	r2, r2, #24
    e12a:	d504      	bpl.n	e136 <mem_manage_fault.isra.0+0x1e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    e12c:	b118      	cbz	r0, e136 <mem_manage_fault.isra.0+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    e12e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e130:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    e134:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    e136:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    e138:	4b04      	ldr	r3, [pc, #16]	; (e14c <mem_manage_fault.isra.0+0x34>)
    e13a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    e13c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
    e13e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    e140:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e142:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    e146:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    e148:	7008      	strb	r0, [r1, #0]

	return reason;
}
    e14a:	4770      	bx	lr
    e14c:	e000ed00 	.word	0xe000ed00

0000e150 <bus_fault.isra.0>:
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    e150:	4b0d      	ldr	r3, [pc, #52]	; (e188 <bus_fault.isra.0+0x38>)
    e152:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    e154:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    e156:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e158:	0592      	lsls	r2, r2, #22
    e15a:	d508      	bpl.n	e16e <bus_fault.isra.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    e15c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    e15e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e160:	0412      	lsls	r2, r2, #16
    e162:	d504      	bpl.n	e16e <bus_fault.isra.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    e164:	b118      	cbz	r0, e16e <bus_fault.isra.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    e166:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e168:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    e16c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    e16e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    e170:	4b05      	ldr	r3, [pc, #20]	; (e188 <bus_fault.isra.0+0x38>)
    e172:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    e174:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e176:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    e178:	bf58      	it	pl
    e17a:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    e17c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e17e:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    e182:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    e184:	7008      	strb	r0, [r1, #0]

	return reason;
}
    e186:	4770      	bx	lr
    e188:	e000ed00 	.word	0xe000ed00

0000e18c <usage_fault.isra.0>:
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    e18c:	4b07      	ldr	r3, [pc, #28]	; (e1ac <usage_fault.isra.0+0x20>)

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;

	return reason;
}
    e18e:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    e190:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    e192:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    e194:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    e196:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    e198:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    e19a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    e19c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    e19e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    e1a0:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    e1a4:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    e1a8:	629a      	str	r2, [r3, #40]	; 0x28
}
    e1aa:	4770      	bx	lr
    e1ac:	e000ed00 	.word	0xe000ed00

0000e1b0 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
    e1b0:	b570      	push	{r4, r5, r6, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    e1b2:	4b3a      	ldr	r3, [pc, #232]	; (e29c <z_arm_fault+0xec>)
    e1b4:	2500      	movs	r5, #0
    e1b6:	685b      	ldr	r3, [r3, #4]
{
    e1b8:	b09c      	sub	sp, #112	; 0x70
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    e1ba:	f3c3 0308 	ubfx	r3, r3, #0, #9
    e1be:	f385 8811 	msr	BASEPRI, r5
    e1c2:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    e1c6:	f002 447f 	and.w	r4, r2, #4278190080	; 0xff000000
    e1ca:	f1b4 4f7f 	cmp.w	r4, #4278190080	; 0xff000000
    e1ce:	d119      	bne.n	e204 <z_arm_fault+0x54>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
    e1d0:	07d6      	lsls	r6, r2, #31
    e1d2:	d417      	bmi.n	e204 <z_arm_fault+0x54>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
    e1d4:	0655      	lsls	r5, r2, #25
    e1d6:	d404      	bmi.n	e1e2 <z_arm_fault+0x32>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    e1d8:	0714      	lsls	r4, r2, #28
    e1da:	d405      	bmi.n	e1e8 <z_arm_fault+0x38>
			ptr_esf = (z_arch_esf_t *)msp;
    e1dc:	4606      	mov	r6, r0
			*nested_exc = true;
    e1de:	2501      	movs	r5, #1
    e1e0:	e004      	b.n	e1ec <z_arm_fault+0x3c>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
    e1e2:	f012 0504 	ands.w	r5, r2, #4
    e1e6:	d00b      	beq.n	e200 <z_arm_fault+0x50>
			ptr_esf = (z_arch_esf_t *)psp;
    e1e8:	460e      	mov	r6, r1
	*nested_exc = false;
    e1ea:	2500      	movs	r5, #0
	*recoverable = false;
    e1ec:	2200      	movs	r2, #0
    e1ee:	3b03      	subs	r3, #3
    e1f0:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    e1f4:	2b03      	cmp	r3, #3
    e1f6:	d849      	bhi.n	e28c <z_arm_fault+0xdc>
    e1f8:	e8df f003 	tbb	[pc, r3]
    e1fc:	3d444006 	.word	0x3d444006
			ptr_esf = (z_arch_esf_t *)msp;
    e200:	4606      	mov	r6, r0
	if (!alternative_state_exc) {
    e202:	e7f3      	b.n	e1ec <z_arm_fault+0x3c>
		return NULL;
    e204:	462e      	mov	r6, r5
    e206:	e7f1      	b.n	e1ec <z_arm_fault+0x3c>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    e208:	4b24      	ldr	r3, [pc, #144]	; (e29c <z_arm_fault+0xec>)
    e20a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    e20c:	0792      	lsls	r2, r2, #30
    e20e:	d43d      	bmi.n	e28c <z_arm_fault+0xdc>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    e210:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    e212:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
    e216:	d008      	beq.n	e22a <z_arm_fault+0x7a>
		if (SCB_MMFSR != 0) {
    e218:	3328      	adds	r3, #40	; 0x28
    e21a:	781b      	ldrb	r3, [r3, #0]
    e21c:	b1eb      	cbz	r3, e25a <z_arm_fault+0xaa>
			reason = mem_manage_fault(esf, 1, recoverable);
    e21e:	2001      	movs	r0, #1
    e220:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    e224:	f7ff ff78 	bl	e118 <mem_manage_fault.isra.0>
		reason = usage_fault(esf);
    e228:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    e22a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e22e:	b993      	cbnz	r3, e256 <z_arm_fault+0xa6>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    e230:	2268      	movs	r2, #104	; 0x68
    e232:	4631      	mov	r1, r6
    e234:	a802      	add	r0, sp, #8
    e236:	f00d fed5 	bl	1bfe4 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    e23a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e23c:	b345      	cbz	r5, e290 <z_arm_fault+0xe0>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    e23e:	f3c3 0208 	ubfx	r2, r3, #0, #9
    e242:	b922      	cbnz	r2, e24e <z_arm_fault+0x9e>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    e244:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    e248:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    e24c:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    e24e:	4620      	mov	r0, r4
    e250:	a902      	add	r1, sp, #8
    e252:	f00d fd1b 	bl	1bc8c <z_arm_fatal_error>
}
    e256:	b01c      	add	sp, #112	; 0x70
    e258:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    e25a:	4b11      	ldr	r3, [pc, #68]	; (e2a0 <z_arm_fault+0xf0>)
    e25c:	781b      	ldrb	r3, [r3, #0]
    e25e:	b12b      	cbz	r3, e26c <z_arm_fault+0xbc>
			reason = bus_fault(esf, 1, recoverable);
    e260:	2001      	movs	r0, #1
    e262:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    e266:	f7ff ff73 	bl	e150 <bus_fault.isra.0>
    e26a:	e7dd      	b.n	e228 <z_arm_fault+0x78>
		} else if (SCB_UFSR != 0) {
    e26c:	4b0d      	ldr	r3, [pc, #52]	; (e2a4 <z_arm_fault+0xf4>)
    e26e:	8818      	ldrh	r0, [r3, #0]
    e270:	b284      	uxth	r4, r0
    e272:	2c00      	cmp	r4, #0
    e274:	d0d9      	beq.n	e22a <z_arm_fault+0x7a>
		reason = usage_fault(esf);
    e276:	f7ff ff89 	bl	e18c <usage_fault.isra.0>
    e27a:	e7d5      	b.n	e228 <z_arm_fault+0x78>
		reason = mem_manage_fault(esf, 0, recoverable);
    e27c:	2000      	movs	r0, #0
    e27e:	f10d 0107 	add.w	r1, sp, #7
    e282:	e7cf      	b.n	e224 <z_arm_fault+0x74>
		reason = bus_fault(esf, 0, recoverable);
    e284:	2000      	movs	r0, #0
    e286:	f10d 0107 	add.w	r1, sp, #7
    e28a:	e7ec      	b.n	e266 <z_arm_fault+0xb6>
	u32_t reason = K_ERR_CPU_EXCEPTION;
    e28c:	2400      	movs	r4, #0
    e28e:	e7cc      	b.n	e22a <z_arm_fault+0x7a>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    e290:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    e294:	f023 0301 	bic.w	r3, r3, #1
    e298:	e7d8      	b.n	e24c <z_arm_fault+0x9c>
    e29a:	bf00      	nop
    e29c:	e000ed00 	.word	0xe000ed00
    e2a0:	e000ed29 	.word	0xe000ed29
    e2a4:	e000ed2a 	.word	0xe000ed2a

0000e2a8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    e2a8:	4a02      	ldr	r2, [pc, #8]	; (e2b4 <z_arm_fault_init+0xc>)
    e2aa:	6953      	ldr	r3, [r2, #20]
    e2ac:	f043 0310 	orr.w	r3, r3, #16
    e2b0:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    e2b2:	4770      	bx	lr
    e2b4:	e000ed00 	.word	0xe000ed00

0000e2b8 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
    e2b8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    e2bc:	4905      	ldr	r1, [pc, #20]	; (e2d4 <sys_arch_reboot+0x1c>)
    e2be:	4b06      	ldr	r3, [pc, #24]	; (e2d8 <sys_arch_reboot+0x20>)
    e2c0:	68ca      	ldr	r2, [r1, #12]
    e2c2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    e2c6:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    e2c8:	60cb      	str	r3, [r1, #12]
    e2ca:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    e2ce:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    e2d0:	e7fd      	b.n	e2ce <sys_arch_reboot+0x16>
    e2d2:	bf00      	nop
    e2d4:	e000ed00 	.word	0xe000ed00
    e2d8:	05fa0004 	.word	0x05fa0004

0000e2dc <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    e2dc:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    e2de:	2120      	movs	r1, #32
    e2e0:	4803      	ldr	r0, [pc, #12]	; (e2f0 <z_arm_interrupt_init+0x14>)
    e2e2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    e2e4:	3301      	adds	r3, #1
    e2e6:	2b41      	cmp	r3, #65	; 0x41
    e2e8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    e2ec:	d1f9      	bne.n	e2e2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    e2ee:	4770      	bx	lr
    e2f0:	e000e100 	.word	0xe000e100

0000e2f4 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
    e2f4:	b538      	push	{r3, r4, r5, lr}
    e2f6:	4604      	mov	r4, r0
	__asm__ volatile(
    e2f8:	f04f 0320 	mov.w	r3, #32
    e2fc:	f3ef 8511 	mrs	r5, BASEPRI
    e300:	f383 8811 	msr	BASEPRI, r3
    e304:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
    e308:	f00c fa40 	bl	1a78c <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
    e30c:	4b0a      	ldr	r3, [pc, #40]	; (e338 <z_impl_k_thread_abort+0x44>)
    e30e:	689b      	ldr	r3, [r3, #8]
    e310:	42a3      	cmp	r3, r4
    e312:	d10b      	bne.n	e32c <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
    e314:	4b09      	ldr	r3, [pc, #36]	; (e33c <z_impl_k_thread_abort+0x48>)
    e316:	685a      	ldr	r2, [r3, #4]
    e318:	f3c2 0208 	ubfx	r2, r2, #0, #9
    e31c:	b912      	cbnz	r2, e324 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
    e31e:	4628      	mov	r0, r5
    e320:	f7ff fd72 	bl	de08 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    e324:	685a      	ldr	r2, [r3, #4]
    e326:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
    e32a:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
    e32c:	4628      	mov	r0, r5
}
    e32e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
    e332:	f00f b84e 	b.w	1d3d2 <z_reschedule_irqlock>
    e336:	bf00      	nop
    e338:	20021f64 	.word	0x20021f64
    e33c:	e000ed00 	.word	0xe000ed00

0000e340 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    e340:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
    e342:	4b0e      	ldr	r3, [pc, #56]	; (e37c <z_arm_configure_static_mpu_regions+0x3c>)
{
    e344:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
    e346:	9302      	str	r3, [sp, #8]
    e348:	4b0d      	ldr	r3, [pc, #52]	; (e380 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    e34a:	4c0e      	ldr	r4, [pc, #56]	; (e384 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
    e34c:	9303      	str	r3, [sp, #12]
    e34e:	4b0e      	ldr	r3, [pc, #56]	; (e388 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    e350:	4a0e      	ldr	r2, [pc, #56]	; (e38c <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
    e352:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
    e354:	ab02      	add	r3, sp, #8
    e356:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    e358:	a801      	add	r0, sp, #4
    e35a:	4623      	mov	r3, r4
    e35c:	2101      	movs	r1, #1
    e35e:	f000 f907 	bl	e570 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
    e362:	2300      	movs	r3, #0
    e364:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    e366:	4b0a      	ldr	r3, [pc, #40]	; (e390 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    e368:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    e36a:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    e36c:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
    e36e:	9305      	str	r3, [sp, #20]
    e370:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    e372:	f000 f907 	bl	e584 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    e376:	b008      	add	sp, #32
    e378:	bd10      	pop	{r4, pc}
    e37a:	bf00      	nop
    e37c:	20020000 	.word	0x20020000
    e380:	00000000 	.word	0x00000000
    e384:	20040000 	.word	0x20040000
    e388:	00010006 	.word	0x00010006
    e38c:	20020000 	.word	0x20020000
    e390:	20020280 	.word	0x20020280

0000e394 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
    e394:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    e396:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    e398:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    e39a:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
    e39e:	f004 031f 	and.w	r3, r4, #31
    e3a2:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    e3a4:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    e3a6:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    e3a8:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    e3ac:	4904      	ldr	r1, [pc, #16]	; (e3c0 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    e3ae:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    e3b2:	f043 0301 	orr.w	r3, r3, #1
    e3b6:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    e3b8:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    e3ba:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    e3bc:	bd10      	pop	{r4, pc}
    e3be:	bf00      	nop
    e3c0:	e000ed90 	.word	0xe000ed90

0000e3c4 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
    e3c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e3c8:	4607      	mov	r7, r0
    e3ca:	4688      	mov	r8, r1
    e3cc:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    e3ce:	2600      	movs	r6, #0
	MPU->RNR = index;
    e3d0:	4d4a      	ldr	r5, [pc, #296]	; (e4fc <mpu_configure_regions_and_partition.constprop.0+0x138>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
    e3d2:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    e3d4:	4546      	cmp	r6, r8
    e3d6:	da0b      	bge.n	e3f0 <mpu_configure_regions_and_partition.constprop.0+0x2c>
		if (regions[i]->size == 0U) {
    e3d8:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
    e3dc:	f8d3 9004 	ldr.w	r9, [r3, #4]
    e3e0:	f1b9 0f00 	cmp.w	r9, #0
    e3e4:	d03a      	beq.n	e45c <mpu_configure_regions_and_partition.constprop.0+0x98>
		&&
    e3e6:	f1b9 0f1f 	cmp.w	r9, #31
    e3ea:	d805      	bhi.n	e3f8 <mpu_configure_regions_and_partition.constprop.0+0x34>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    e3ec:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    e3f0:	4620      	mov	r0, r4
    e3f2:	b005      	add	sp, #20
    e3f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    e3f8:	f019 0f1f 	tst.w	r9, #31
    e3fc:	d1f6      	bne.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
		((part->start &
    e3fe:	f8d3 a000 	ldr.w	sl, [r3]
		&&
    e402:	f01a 0f1f 	tst.w	sl, #31
    e406:	d1f1      	bne.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    e408:	4650      	mov	r0, sl
    e40a:	f00d fc6c 	bl	1bce6 <arm_cmse_mpu_region_get>
    e40e:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    e410:	eb09 000a 	add.w	r0, r9, sl
    e414:	3801      	subs	r0, #1
    e416:	f00d fc66 	bl	1bce6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    e41a:	4583      	cmp	fp, r0
    e41c:	d1e6      	bne.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
		if ((u_reg_index == -EINVAL) ||
    e41e:	f11b 0f16 	cmn.w	fp, #22
    e422:	d0e3      	beq.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
			(u_reg_index > (reg_index - 1))) {
    e424:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    e426:	455b      	cmp	r3, fp
    e428:	dbe0      	blt.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
	MPU->RNR = index;
    e42a:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    e42e:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
    e430:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    e434:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    e436:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    e43a:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    e43e:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    e442:	e9d1 3200 	ldrd	r3, r2, [r1]
    e446:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
    e448:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
    e44a:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
    e44e:	d118      	bne.n	e482 <mpu_configure_regions_and_partition.constprop.0+0xbe>
    e450:	45ca      	cmp	sl, r9
    e452:	d105      	bne.n	e460 <mpu_configure_regions_and_partition.constprop.0+0x9c>
			mpu_configure_region(u_reg_index, regions[i]);
    e454:	fa5f f08b 	uxtb.w	r0, fp
    e458:	f00d fc25 	bl	1bca6 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    e45c:	3601      	adds	r6, #1
    e45e:	e7b9      	b.n	e3d4 <mpu_configure_regions_and_partition.constprop.0+0x10>
	MPU->RNR = index;
    e460:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    e464:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    e466:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    e46a:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    e46e:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    e470:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
    e472:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
    e474:	f00d fc17 	bl	1bca6 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    e478:	f110 0f16 	cmn.w	r0, #22
    e47c:	d0b6      	beq.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
			reg_index++;
    e47e:	1c44      	adds	r4, r0, #1
    e480:	e7ec      	b.n	e45c <mpu_configure_regions_and_partition.constprop.0+0x98>
	MPU->RNR = index;
    e482:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    e486:	692a      	ldr	r2, [r5, #16]
    e488:	3b01      	subs	r3, #1
    e48a:	f023 031f 	bic.w	r3, r3, #31
    e48e:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    e492:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
    e494:	45ca      	cmp	sl, r9
    e496:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    e498:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
    e49a:	d0eb      	beq.n	e474 <mpu_configure_regions_and_partition.constprop.0+0xb0>
				mpu_configure_region(reg_index, regions[i]);
    e49c:	f00d fc03 	bl	1bca6 <mpu_configure_region>
			if (reg_index == -EINVAL) {
    e4a0:	f110 0f16 	cmn.w	r0, #22
    e4a4:	d0a2      	beq.n	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
	MPU->RNR = index;
    e4a6:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    e4aa:	68ea      	ldr	r2, [r5, #12]
    e4ac:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
    e4b0:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
    e4b4:	f362 0304 	bfi	r3, r2, #0, #5
    e4b8:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    e4bc:	692b      	ldr	r3, [r5, #16]
    e4be:	f89d 2008 	ldrb.w	r2, [sp, #8]
    e4c2:	085b      	lsrs	r3, r3, #1
    e4c4:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
    e4c8:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    e4cc:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
    e4d0:	e9d3 1300 	ldrd	r1, r3, [r3]
    e4d4:	440b      	add	r3, r1
    e4d6:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
    e4d8:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
    e4dc:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
    e4de:	4453      	add	r3, sl
    e4e0:	eba3 0309 	sub.w	r3, r3, r9
    e4e4:	b2c0      	uxtb	r0, r0
    e4e6:	f023 031f 	bic.w	r3, r3, #31

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
    e4ea:	280f      	cmp	r0, #15
			fill_region.attr.r_limit =
    e4ec:	9303      	str	r3, [sp, #12]
    e4ee:	f63f af7d 	bhi.w	e3ec <mpu_configure_regions_and_partition.constprop.0+0x28>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    e4f2:	4669      	mov	r1, sp
    e4f4:	f7ff ff4e 	bl	e394 <region_init>
    e4f8:	e7c1      	b.n	e47e <mpu_configure_regions_and_partition.constprop.0+0xba>
    e4fa:	bf00      	nop
    e4fc:	e000ed90 	.word	0xe000ed90

0000e500 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    e500:	2205      	movs	r2, #5
    e502:	4b03      	ldr	r3, [pc, #12]	; (e510 <arm_core_mpu_enable+0x10>)
    e504:	605a      	str	r2, [r3, #4]
    e506:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e50a:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    e50e:	4770      	bx	lr
    e510:	e000ed90 	.word	0xe000ed90

0000e514 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    e514:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    e518:	2200      	movs	r2, #0
    e51a:	4b01      	ldr	r3, [pc, #4]	; (e520 <arm_core_mpu_disable+0xc>)
    e51c:	605a      	str	r2, [r3, #4]
}
    e51e:	4770      	bx	lr
    e520:	e000ed90 	.word	0xe000ed90

0000e524 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
    e524:	b538      	push	{r3, r4, r5, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    e526:	4c0e      	ldr	r4, [pc, #56]	; (e560 <arm_mpu_init+0x3c>)
    e528:	6825      	ldr	r5, [r4, #0]
    e52a:	2d10      	cmp	r5, #16
    e52c:	d814      	bhi.n	e558 <arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    e52e:	f7ff fff1 	bl	e514 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    e532:	2000      	movs	r0, #0
	MPU->MAIR0 =
    e534:	4b0b      	ldr	r3, [pc, #44]	; (e564 <arm_mpu_init+0x40>)
    e536:	4a0c      	ldr	r2, [pc, #48]	; (e568 <arm_mpu_init+0x44>)
    e538:	631a      	str	r2, [r3, #48]	; 0x30
    e53a:	4285      	cmp	r5, r0
    e53c:	d105      	bne.n	e54a <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    e53e:	4b0b      	ldr	r3, [pc, #44]	; (e56c <arm_mpu_init+0x48>)
    e540:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    e542:	f7ff ffdd 	bl	e500 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    e546:	2000      	movs	r0, #0
}
    e548:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    e54a:	6861      	ldr	r1, [r4, #4]
    e54c:	eb01 1100 	add.w	r1, r1, r0, lsl #4
    e550:	f7ff ff20 	bl	e394 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    e554:	3001      	adds	r0, #1
    e556:	e7f0      	b.n	e53a <arm_mpu_init+0x16>
		return -1;
    e558:	f04f 30ff 	mov.w	r0, #4294967295
    e55c:	e7f4      	b.n	e548 <arm_mpu_init+0x24>
    e55e:	bf00      	nop
    e560:	0001dc1c 	.word	0x0001dc1c
    e564:	e000ed90 	.word	0xe000ed90
    e568:	0044ffaa 	.word	0x0044ffaa
    e56c:	2002259e 	.word	0x2002259e

0000e570 <arm_core_mpu_configure_static_mpu_regions>:
{
    e570:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    e572:	4c03      	ldr	r4, [pc, #12]	; (e580 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    e574:	7822      	ldrb	r2, [r4, #0]
    e576:	f7ff ff25 	bl	e3c4 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    e57a:	7020      	strb	r0, [r4, #0]
}
    e57c:	bd10      	pop	{r4, pc}
    e57e:	bf00      	nop
    e580:	2002259e 	.word	0x2002259e

0000e584 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    e584:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e588:	4d26      	ldr	r5, [pc, #152]	; (e624 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
    e58a:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    e58c:	4606      	mov	r6, r0
    e58e:	f04f 0800 	mov.w	r8, #0
    e592:	46ab      	mov	fp, r5
	MPU->RNR = index;
    e594:	4f24      	ldr	r7, [pc, #144]	; (e628 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    e596:	45d0      	cmp	r8, sl
    e598:	da1b      	bge.n	e5d2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    e59a:	f8d6 9004 	ldr.w	r9, [r6, #4]
    e59e:	f1b9 0f00 	cmp.w	r9, #0
    e5a2:	d039      	beq.n	e618 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    e5a4:	6831      	ldr	r1, [r6, #0]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    e5a6:	4608      	mov	r0, r1
    e5a8:	9101      	str	r1, [sp, #4]
    e5aa:	f00d fb9c 	bl	1bce6 <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    e5ae:	9901      	ldr	r1, [sp, #4]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
    e5b0:	4604      	mov	r4, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    e5b2:	eb09 0001 	add.w	r0, r9, r1
    e5b6:	3801      	subs	r0, #1
    e5b8:	f00d fb95 	bl	1bce6 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    e5bc:	4284      	cmp	r4, r0
    e5be:	f04f 0214 	mov.w	r2, #20
    e5c2:	4b1a      	ldr	r3, [pc, #104]	; (e62c <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
    e5c4:	d008      	beq.n	e5d8 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
    e5c6:	f06f 0315 	mvn.w	r3, #21
    e5ca:	fb02 f808 	mul.w	r8, r2, r8
    e5ce:	f84b 3008 	str.w	r3, [fp, r8]
}
    e5d2:	b003      	add	sp, #12
    e5d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    e5d8:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
    e5dc:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
    e5de:	d0f8      	beq.n	e5d2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    e5e0:	7819      	ldrb	r1, [r3, #0]
    e5e2:	42a1      	cmp	r1, r4
    e5e4:	ddf5      	ble.n	e5d2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
    e5e6:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
    e5ea:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
    e5ec:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
    e5ee:	68fc      	ldr	r4, [r7, #12]
    e5f0:	f100 0108 	add.w	r1, r0, #8
    e5f4:	7b00      	ldrb	r0, [r0, #12]
    e5f6:	f364 0004 	bfi	r0, r4, #0, #5
    e5fa:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    e5fc:	6938      	ldr	r0, [r7, #16]
    e5fe:	790c      	ldrb	r4, [r1, #4]
    e600:	0840      	lsrs	r0, r0, #1
    e602:	f360 1447 	bfi	r4, r0, #5, #3
    e606:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    e608:	68f9      	ldr	r1, [r7, #12]
    e60a:	f021 011f 	bic.w	r1, r1, #31
    e60e:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    e610:	6939      	ldr	r1, [r7, #16]
    e612:	f021 011f 	bic.w	r1, r1, #31
    e616:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    e618:	f108 0801 	add.w	r8, r8, #1
    e61c:	3514      	adds	r5, #20
    e61e:	360c      	adds	r6, #12
    e620:	e7b9      	b.n	e596 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
    e622:	bf00      	nop
    e624:	200202d8 	.word	0x200202d8
    e628:	e000ed90 	.word	0xe000ed90
    e62c:	2002259e 	.word	0x2002259e

0000e630 <z_prf>:
	*sptr = p;
	return i;
}

int z_prf(int (*func)(), void *dest, const char *format, va_list vargs)
{
    e630:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e634:	461e      	mov	r6, r3
	struct zero_padding zero;
	VALTYPE val;

#define PUTC(c)	do { if ((*func)(c, dest) == EOF) return EOF; } while (false)

	count = 0;
    e636:	2300      	movs	r3, #0
{
    e638:	4689      	mov	r9, r1
    e63a:	b0a1      	sub	sp, #132	; 0x84
    e63c:	9003      	str	r0, [sp, #12]
	count = 0;
    e63e:	9302      	str	r3, [sp, #8]

	while ((c = *format++)) {
    e640:	4613      	mov	r3, r2
    e642:	f813 0b01 	ldrb.w	r0, [r3], #1
    e646:	9306      	str	r3, [sp, #24]
    e648:	b158      	cbz	r0, e662 <z_prf+0x32>
		if (c != '%') {
    e64a:	2825      	cmp	r0, #37	; 0x25
    e64c:	f000 8081 	beq.w	e752 <z_prf+0x122>
			PUTC(c);
    e650:	4649      	mov	r1, r9
    e652:	9b03      	ldr	r3, [sp, #12]
    e654:	4798      	blx	r3
    e656:	3001      	adds	r0, #1
    e658:	f040 844b 	bne.w	eef2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x492>
    e65c:	f04f 33ff 	mov.w	r3, #4294967295
    e660:	9302      	str	r3, [sp, #8]
		}
	}
	return count;

#undef PUTC
}
    e662:	9802      	ldr	r0, [sp, #8]
    e664:	b021      	add	sp, #132	; 0x84
    e666:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				switch (c) {
    e66a:	2d2b      	cmp	r5, #43	; 0x2b
    e66c:	d065      	beq.n	e73a <z_prf+0x10a>
    e66e:	d85c      	bhi.n	e72a <z_prf+0xfa>
    e670:	2d20      	cmp	r5, #32
    e672:	d065      	beq.n	e740 <z_prf+0x110>
    e674:	2d23      	cmp	r5, #35	; 0x23
    e676:	d066      	beq.n	e746 <z_prf+0x116>
    e678:	2d00      	cmp	r5, #0
    e67a:	d0f2      	beq.n	e662 <z_prf+0x32>
					fzero = true;
    e67c:	f8cd 8018 	str.w	r8, [sp, #24]
			while (strchr("-+ #0", (c = *format++)) != NULL) {
    e680:	f8dd 8018 	ldr.w	r8, [sp, #24]
    e684:	48a4      	ldr	r0, [pc, #656]	; (e918 <z_prf+0x2e8>)
    e686:	f818 5b01 	ldrb.w	r5, [r8], #1
    e68a:	4629      	mov	r1, r5
    e68c:	f00d fc6a 	bl	1bf64 <strchr>
    e690:	2800      	cmp	r0, #0
    e692:	d1ea      	bne.n	e66a <z_prf+0x3a>
			if (c == '*') {
    e694:	2d2a      	cmp	r5, #42	; 0x2a
    e696:	d163      	bne.n	e760 <z_prf+0x130>
				width = va_arg(vargs, int);
    e698:	f856 3b04 	ldr.w	r3, [r6], #4
				c = *format++;
    e69c:	f898 5000 	ldrb.w	r5, [r8]
				if (width < 0) {
    e6a0:	2b00      	cmp	r3, #0
				width = va_arg(vargs, int);
    e6a2:	9307      	str	r3, [sp, #28]
					width = -width;
    e6a4:	bfbf      	itttt	lt
    e6a6:	425b      	neglt	r3, r3
    e6a8:	9307      	strlt	r3, [sp, #28]
					fminus = true;
    e6aa:	2301      	movlt	r3, #1
    e6ac:	930d      	strlt	r3, [sp, #52]	; 0x34
				c = *format++;
    e6ae:	9b06      	ldr	r3, [sp, #24]
    e6b0:	f103 0802 	add.w	r8, r3, #2
			if (c == '.') {
    e6b4:	2d2e      	cmp	r5, #46	; 0x2e
    e6b6:	d178      	bne.n	e7aa <z_prf+0x17a>
				if (c == '*') {
    e6b8:	f898 3000 	ldrb.w	r3, [r8]
    e6bc:	2b2a      	cmp	r3, #42	; 0x2a
    e6be:	d171      	bne.n	e7a4 <z_prf+0x174>
					precision = va_arg(vargs, int);
    e6c0:	f856 4b04 	ldr.w	r4, [r6], #4
				c = *format++;
    e6c4:	f108 0801 	add.w	r8, r8, #1
				c = *format++;
    e6c8:	f818 5b01 	ldrb.w	r5, [r8], #1
			if (strchr("hlz", c) != NULL) {
    e6cc:	4629      	mov	r1, r5
    e6ce:	4893      	ldr	r0, [pc, #588]	; (e91c <z_prf+0x2ec>)
    e6d0:	462f      	mov	r7, r5
    e6d2:	f00d fc47 	bl	1bf64 <strchr>
    e6d6:	2800      	cmp	r0, #0
    e6d8:	d06a      	beq.n	e7b0 <z_prf+0x180>
				c = *format++;
    e6da:	4643      	mov	r3, r8
    e6dc:	f813 5b01 	ldrb.w	r5, [r3], #1
				} else if (i == 'h' && c == 'h') {
    e6e0:	2f68      	cmp	r7, #104	; 0x68
				c = *format++;
    e6e2:	9306      	str	r3, [sp, #24]
				} else if (i == 'h' && c == 'h') {
    e6e4:	d107      	bne.n	e6f6 <z_prf+0xc6>
    e6e6:	2d68      	cmp	r5, #104	; 0x68
    e6e8:	d105      	bne.n	e6f6 <z_prf+0xc6>
					i = 'H';
    e6ea:	2748      	movs	r7, #72	; 0x48
					c = *format++;
    e6ec:	f108 0302 	add.w	r3, r8, #2
    e6f0:	f898 5001 	ldrb.w	r5, [r8, #1]
    e6f4:	9306      	str	r3, [sp, #24]
			switch (c) {
    e6f6:	2d78      	cmp	r5, #120	; 0x78
    e6f8:	d808      	bhi.n	e70c <z_prf+0xdc>
    e6fa:	2d57      	cmp	r5, #87	; 0x57
    e6fc:	d85c      	bhi.n	e7b8 <z_prf+0x188>
    e6fe:	2d25      	cmp	r5, #37	; 0x25
    e700:	f000 83f3 	beq.w	eeea <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x48a>
    e704:	f200 80a2 	bhi.w	e84c <z_prf+0x21c>
    e708:	2d00      	cmp	r5, #0
    e70a:	d0aa      	beq.n	e662 <z_prf+0x32>
				PUTC('%');
    e70c:	4649      	mov	r1, r9
    e70e:	2025      	movs	r0, #37	; 0x25
    e710:	9b03      	ldr	r3, [sp, #12]
    e712:	4798      	blx	r3
    e714:	3001      	adds	r0, #1
    e716:	d0a1      	beq.n	e65c <z_prf+0x2c>
				PUTC(c);
    e718:	4649      	mov	r1, r9
    e71a:	4628      	mov	r0, r5
    e71c:	9b03      	ldr	r3, [sp, #12]
    e71e:	4798      	blx	r3
    e720:	3001      	adds	r0, #1
    e722:	d09b      	beq.n	e65c <z_prf+0x2c>
				count += 2;
    e724:	9b02      	ldr	r3, [sp, #8]
    e726:	3302      	adds	r3, #2
    e728:	e3e5      	b.n	eef6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x496>
				switch (c) {
    e72a:	2d2d      	cmp	r5, #45	; 0x2d
    e72c:	d00e      	beq.n	e74c <z_prf+0x11c>
					fzero = true;
    e72e:	2d30      	cmp	r5, #48	; 0x30
    e730:	9b08      	ldr	r3, [sp, #32]
    e732:	bf08      	it	eq
    e734:	2301      	moveq	r3, #1
    e736:	9308      	str	r3, [sp, #32]
    e738:	e7a0      	b.n	e67c <z_prf+0x4c>
					fplus = true;
    e73a:	2301      	movs	r3, #1
    e73c:	9309      	str	r3, [sp, #36]	; 0x24
    e73e:	e79d      	b.n	e67c <z_prf+0x4c>
					fspace = true;
    e740:	2301      	movs	r3, #1
    e742:	930c      	str	r3, [sp, #48]	; 0x30
    e744:	e79a      	b.n	e67c <z_prf+0x4c>
					falt = true;
    e746:	f04f 0a01 	mov.w	sl, #1
    e74a:	e797      	b.n	e67c <z_prf+0x4c>
				switch (c) {
    e74c:	2301      	movs	r3, #1
    e74e:	930d      	str	r3, [sp, #52]	; 0x34
    e750:	e794      	b.n	e67c <z_prf+0x4c>
			fminus = fplus = fspace = falt = fzero = false;
    e752:	2300      	movs	r3, #0
    e754:	469a      	mov	sl, r3
    e756:	9308      	str	r3, [sp, #32]
    e758:	930c      	str	r3, [sp, #48]	; 0x30
    e75a:	9309      	str	r3, [sp, #36]	; 0x24
    e75c:	930d      	str	r3, [sp, #52]	; 0x34
    e75e:	e78f      	b.n	e680 <z_prf+0x50>
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    e760:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
			} else if (!isdigit(c)) {
    e764:	2b09      	cmp	r3, #9
				width = 0;
    e766:	9007      	str	r0, [sp, #28]
			} else if (!isdigit(c)) {
    e768:	d8a4      	bhi.n	e6b4 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    e76a:	220a      	movs	r2, #10
	while (isdigit(*p)) {
    e76c:	f8dd 8018 	ldr.w	r8, [sp, #24]
    e770:	f818 5b01 	ldrb.w	r5, [r8], #1
    e774:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    e778:	2b09      	cmp	r3, #9
    e77a:	d89b      	bhi.n	e6b4 <z_prf+0x84>
		i = 10 * i + *p++ - '0';
    e77c:	9b07      	ldr	r3, [sp, #28]
    e77e:	fb02 5503 	mla	r5, r2, r3, r5
    e782:	f1a5 0330 	sub.w	r3, r5, #48	; 0x30
    e786:	e9cd 8306 	strd	r8, r3, [sp, #24]
    e78a:	e7ef      	b.n	e76c <z_prf+0x13c>
    e78c:	4690      	mov	r8, r2
    e78e:	fb01 3404 	mla	r4, r1, r4, r3
    e792:	3c30      	subs	r4, #48	; 0x30
	while (isdigit(*p)) {
    e794:	4642      	mov	r2, r8
    e796:	f812 3b01 	ldrb.w	r3, [r2], #1
    e79a:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    e79e:	2809      	cmp	r0, #9
    e7a0:	d9f4      	bls.n	e78c <z_prf+0x15c>
    e7a2:	e791      	b.n	e6c8 <z_prf+0x98>
	int i = 0;
    e7a4:	2400      	movs	r4, #0
		i = 10 * i + *p++ - '0';
    e7a6:	210a      	movs	r1, #10
    e7a8:	e7f4      	b.n	e794 <z_prf+0x164>
			precision = -1;
    e7aa:	f04f 34ff 	mov.w	r4, #4294967295
    e7ae:	e78d      	b.n	e6cc <z_prf+0x9c>
			i = 0;
    e7b0:	4607      	mov	r7, r0
    e7b2:	f8cd 8018 	str.w	r8, [sp, #24]
    e7b6:	e79e      	b.n	e6f6 <z_prf+0xc6>
    e7b8:	f1a5 0358 	sub.w	r3, r5, #88	; 0x58
    e7bc:	2b20      	cmp	r3, #32
    e7be:	d8a5      	bhi.n	e70c <z_prf+0xdc>
    e7c0:	a201      	add	r2, pc, #4	; (adr r2, e7c8 <z_prf+0x198>)
    e7c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e7c6:	bf00      	nop
    e7c8:	0000ee4f 	.word	0x0000ee4f
    e7cc:	0000e70d 	.word	0x0000e70d
    e7d0:	0000e70d 	.word	0x0000e70d
    e7d4:	0000e70d 	.word	0x0000e70d
    e7d8:	0000e70d 	.word	0x0000e70d
    e7dc:	0000e70d 	.word	0x0000e70d
    e7e0:	0000e70d 	.word	0x0000e70d
    e7e4:	0000e70d 	.word	0x0000e70d
    e7e8:	0000e70d 	.word	0x0000e70d
    e7ec:	0000e70d 	.word	0x0000e70d
    e7f0:	0000e70d 	.word	0x0000e70d
    e7f4:	0000e921 	.word	0x0000e921
    e7f8:	0000e9f7 	.word	0x0000e9f7
    e7fc:	0000e859 	.word	0x0000e859
    e800:	0000e859 	.word	0x0000e859
    e804:	0000e859 	.word	0x0000e859
    e808:	0000e70d 	.word	0x0000e70d
    e80c:	0000e9f7 	.word	0x0000e9f7
    e810:	0000e70d 	.word	0x0000e70d
    e814:	0000e70d 	.word	0x0000e70d
    e818:	0000e70d 	.word	0x0000e70d
    e81c:	0000e70d 	.word	0x0000e70d
    e820:	0000eddb 	.word	0x0000eddb
    e824:	0000ee4f 	.word	0x0000ee4f
    e828:	0000ee05 	.word	0x0000ee05
    e82c:	0000e70d 	.word	0x0000e70d
    e830:	0000e70d 	.word	0x0000e70d
    e834:	0000ee27 	.word	0x0000ee27
    e838:	0000e70d 	.word	0x0000e70d
    e83c:	0000ee4f 	.word	0x0000ee4f
    e840:	0000e70d 	.word	0x0000e70d
    e844:	0000e70d 	.word	0x0000e70d
    e848:	0000ee4f 	.word	0x0000ee4f
			switch (c) {
    e84c:	f1a5 0345 	sub.w	r3, r5, #69	; 0x45
    e850:	b2db      	uxtb	r3, r3
    e852:	2b02      	cmp	r3, #2
    e854:	f63f af5a 	bhi.w	e70c <z_prf+0xdc>
				u.d = va_arg(vargs, double);
    e858:	3607      	adds	r6, #7
    e85a:	f026 0307 	bic.w	r3, r6, #7
    e85e:	4619      	mov	r1, r3
    e860:	e8f1 2302 	ldrd	r2, r3, [r1], #8
	fract = (double_temp << 11) & ~HIGHBIT64;
    e864:	02d8      	lsls	r0, r3, #11
    e866:	ea40 5052 	orr.w	r0, r0, r2, lsr #21
    e86a:	02d6      	lsls	r6, r2, #11
    e86c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
	if (sign) {
    e870:	2a00      	cmp	r2, #0
				u.d = va_arg(vargs, double);
    e872:	9101      	str	r1, [sp, #4]
	fract = (double_temp << 11) & ~HIGHBIT64;
    e874:	9604      	str	r6, [sp, #16]
	exp = double_temp >> 52 & 0x7ff;
    e876:	f3c3 510a 	ubfx	r1, r3, #20, #11
	fract = (double_temp << 11) & ~HIGHBIT64;
    e87a:	9005      	str	r0, [sp, #20]
	if (sign) {
    e87c:	f173 0300 	sbcs.w	r3, r3, #0
	fract = (double_temp << 11) & ~HIGHBIT64;
    e880:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    e884:	e9cd 6714 	strd	r6, r7, [sp, #80]	; 0x50
	if (sign) {
    e888:	f280 80e5 	bge.w	ea56 <z_prf+0x426>
		*buf++ = '-';
    e88c:	232d      	movs	r3, #45	; 0x2d
		*buf++ = ' ';
    e88e:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    e892:	f10d 0765 	add.w	r7, sp, #101	; 0x65
	if (exp == 0x7ff) {
    e896:	f240 73ff 	movw	r3, #2047	; 0x7ff
    e89a:	4299      	cmp	r1, r3
    e89c:	f040 80f6 	bne.w	ea8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2c>
		if (!fract) {
    e8a0:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
    e8a4:	430a      	orrs	r2, r1
    e8a6:	f1a5 0541 	sub.w	r5, r5, #65	; 0x41
    e8aa:	f107 0303 	add.w	r3, r7, #3
    e8ae:	f040 80e2 	bne.w	ea76 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16>
			if (isupper(c)) {
    e8b2:	2d19      	cmp	r5, #25
    e8b4:	f200 80d9 	bhi.w	ea6a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xa>
				*buf++ = 'I';
    e8b8:	2249      	movs	r2, #73	; 0x49
    e8ba:	703a      	strb	r2, [r7, #0]
				*buf++ = 'N';
    e8bc:	224e      	movs	r2, #78	; 0x4e
    e8be:	707a      	strb	r2, [r7, #1]
				*buf++ = 'F';
    e8c0:	2246      	movs	r2, #70	; 0x46
		*buf = 0;
    e8c2:	2400      	movs	r4, #0
			zero.predot = zero.postdot = zero.trail = 0;
    e8c4:	46a2      	mov	sl, r4
    e8c6:	46a3      	mov	fp, r4
		return buf - start;
    e8c8:	ae19      	add	r6, sp, #100	; 0x64
				*buf++ = 'n';
    e8ca:	70ba      	strb	r2, [r7, #2]
		*buf = 0;
    e8cc:	70fc      	strb	r4, [r7, #3]
		return buf - start;
    e8ce:	1b9b      	subs	r3, r3, r6
				if (fplus || fspace || (buf[0] == '-')) {
    e8d0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    e8d2:	2a00      	cmp	r2, #0
    e8d4:	f040 827e 	bne.w	edd4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x374>
    e8d8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    e8da:	2a00      	cmp	r2, #0
    e8dc:	f040 827a 	bne.w	edd4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x374>
    e8e0:	f89d 8064 	ldrb.w	r8, [sp, #100]	; 0x64
    e8e4:	f1a8 022d 	sub.w	r2, r8, #45	; 0x2d
    e8e8:	f1d2 0800 	rsbs	r8, r2, #0
    e8ec:	eb48 0802 	adc.w	r8, r8, r2
				clen += zero.predot + zero.postdot + zero.trail;
    e8f0:	eb0b 060a 	add.w	r6, fp, sl
    e8f4:	4433      	add	r3, r6
    e8f6:	191e      	adds	r6, r3, r4
				if (!isdigit(buf[prefix])) {
    e8f8:	ab20      	add	r3, sp, #128	; 0x80
    e8fa:	4443      	add	r3, r8
    e8fc:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
    e900:	3b30      	subs	r3, #48	; 0x30
    e902:	2b09      	cmp	r3, #9
    e904:	f200 82ff 	bhi.w	ef06 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4a6>
			} else if (fzero) {
    e908:	9b08      	ldr	r3, [sp, #32]
    e90a:	2b00      	cmp	r3, #0
    e90c:	f000 82fe 	beq.w	ef0c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4ac>
    e910:	9b07      	ldr	r3, [sp, #28]
    e912:	af19      	add	r7, sp, #100	; 0x64
    e914:	1b9b      	subs	r3, r3, r6
    e916:	e014      	b.n	e942 <z_prf+0x312>
    e918:	0001e472 	.word	0x0001e472
    e91c:	0001e478 	.word	0x0001e478
				break;
    e920:	f04f 0800 	mov.w	r8, #0
				buf[0] = va_arg(vargs, int);
    e924:	4632      	mov	r2, r6
				break;
    e926:	4644      	mov	r4, r8
				clen = 1;
    e928:	2601      	movs	r6, #1
				buf[0] = va_arg(vargs, int);
    e92a:	f852 3b04 	ldr.w	r3, [r2], #4
    e92e:	9201      	str	r2, [sp, #4]
    e930:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
				break;
    e934:	af19      	add	r7, sp, #100	; 0x64
				zero_head = precision - clen + prefix;
    e936:	eb04 0308 	add.w	r3, r4, r8
			zero.predot = zero.postdot = zero.trail = 0;
    e93a:	2400      	movs	r4, #0
    e93c:	46a2      	mov	sl, r4
    e93e:	46a3      	mov	fp, r4
				zero_head = precision - clen + prefix;
    e940:	1b9b      	subs	r3, r3, r6
			if (zero_head < 0) {
    e942:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
			width -= clen + zero_head;
    e946:	199a      	adds	r2, r3, r6
    e948:	9208      	str	r2, [sp, #32]
    e94a:	9a07      	ldr	r2, [sp, #28]
    e94c:	1999      	adds	r1, r3, r6
    e94e:	1a55      	subs	r5, r2, r1
			if (!fminus && width > 0) {
    e950:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    e952:	b912      	cbnz	r2, e95a <z_prf+0x32a>
    e954:	2d00      	cmp	r5, #0
    e956:	f300 82ee 	bgt.w	ef36 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4d6>
			while (prefix-- > 0) {
    e95a:	eb07 0208 	add.w	r2, r7, r8
    e95e:	42ba      	cmp	r2, r7
    e960:	f040 82eb 	bne.w	ef3a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4da>
			while (zero_head-- > 0) {
    e964:	3b01      	subs	r3, #1
    e966:	f080 82f6 	bcs.w	ef56 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4f6>
			clen -= prefix;
    e96a:	eba6 0608 	sub.w	r6, r6, r8
			if (zero.predot) {
    e96e:	f1bb 0f00 	cmp.w	fp, #0
    e972:	d010      	beq.n	e996 <z_prf+0x366>
				c = *cptr;
    e974:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c)) {
    e976:	eb07 0806 	add.w	r8, r7, r6
    e97a:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    e97e:	2b09      	cmp	r3, #9
    e980:	eba8 0607 	sub.w	r6, r8, r7
    e984:	f240 82f2 	bls.w	ef6c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x50c>
    e988:	46d8      	mov	r8, fp
				while (zero.predot-- > 0) {
    e98a:	f1b8 0801 	subs.w	r8, r8, #1
    e98e:	f080 82f6 	bcs.w	ef7e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x51e>
				clen -= zero.predot;
    e992:	eba6 060b 	sub.w	r6, r6, fp
			if (zero.postdot) {
    e996:	f1ba 0f00 	cmp.w	sl, #0
    e99a:	d016      	beq.n	e9ca <z_prf+0x39a>
    e99c:	eb07 0806 	add.w	r8, r7, r6
					c = *cptr++;
    e9a0:	f817 bb01 	ldrb.w	fp, [r7], #1
					PUTC(c);
    e9a4:	4649      	mov	r1, r9
    e9a6:	4658      	mov	r0, fp
    e9a8:	9b03      	ldr	r3, [sp, #12]
    e9aa:	4798      	blx	r3
    e9ac:	3001      	adds	r0, #1
    e9ae:	f43f ae55 	beq.w	e65c <z_prf+0x2c>
				} while (c != '.');
    e9b2:	f1bb 0f2e 	cmp.w	fp, #46	; 0x2e
    e9b6:	eba8 0607 	sub.w	r6, r8, r7
    e9ba:	d1f1      	bne.n	e9a0 <z_prf+0x370>
				while (zero.postdot-- > 0) {
    e9bc:	46d0      	mov	r8, sl
    e9be:	f1b8 0f00 	cmp.w	r8, #0
    e9c2:	f300 82e5 	bgt.w	ef90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x530>
				clen -= zero.postdot;
    e9c6:	eba6 060a 	sub.w	r6, r6, sl
			if (zero.trail) {
    e9ca:	b194      	cbz	r4, e9f2 <z_prf+0x3c2>
				c = *cptr;
    e9cc:	7838      	ldrb	r0, [r7, #0]
				while (isdigit(c) || c == '.') {
    e9ce:	eb07 0806 	add.w	r8, r7, r6
    e9d2:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    e9d6:	2b09      	cmp	r3, #9
    e9d8:	eba8 0607 	sub.w	r6, r8, r7
    e9dc:	f240 82e3 	bls.w	efa6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x546>
    e9e0:	282e      	cmp	r0, #46	; 0x2e
    e9e2:	f000 82e0 	beq.w	efa6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x546>
				while (zero.trail-- > 0) {
    e9e6:	46a0      	mov	r8, r4
    e9e8:	f1b8 0f00 	cmp.w	r8, #0
    e9ec:	f300 82e4 	bgt.w	efb8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x558>
				clen -= zero.trail;
    e9f0:	1b36      	subs	r6, r6, r4
    e9f2:	443e      	add	r6, r7
    e9f4:	e2f3      	b.n	efde <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x57e>
				switch (i) {
    e9f6:	6835      	ldr	r5, [r6, #0]
	if (value < 0) {
    e9f8:	1d33      	adds	r3, r6, #4
    e9fa:	2d00      	cmp	r5, #0
    e9fc:	9301      	str	r3, [sp, #4]
    e9fe:	da1c      	bge.n	ea3a <z_prf+0x40a>
		*buf++ = '-';
    ea00:	232d      	movs	r3, #45	; 0x2d
		value = -value;
    ea02:	4269      	negs	r1, r5
		*buf++ = '-';
    ea04:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		*buf++ = ' ';
    ea08:	f10d 0765 	add.w	r7, sp, #101	; 0x65
	return _to_x(buf, value, 10);
    ea0c:	220a      	movs	r2, #10
    ea0e:	4638      	mov	r0, r7
    ea10:	f00d fb36 	bl	1c080 <_to_x>
				if (fplus || fspace || val < 0) {
    ea14:	9b09      	ldr	r3, [sp, #36]	; 0x24
	return (buf + _to_udec(buf, value)) - start;
    ea16:	4438      	add	r0, r7
    ea18:	ae19      	add	r6, sp, #100	; 0x64
    ea1a:	1b86      	subs	r6, r0, r6
				if (fplus || fspace || val < 0) {
    ea1c:	2b00      	cmp	r3, #0
    ea1e:	f040 826d 	bne.w	eefc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x49c>
    ea22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ea24:	2b00      	cmp	r3, #0
    ea26:	f040 8269 	bne.w	eefc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x49c>
    ea2a:	ea4f 78d5 	mov.w	r8, r5, lsr #31
			if (precision >= 0) {
    ea2e:	2c00      	cmp	r4, #0
    ea30:	da80      	bge.n	e934 <z_prf+0x304>
			zero.predot = zero.postdot = zero.trail = 0;
    ea32:	2400      	movs	r4, #0
    ea34:	46a2      	mov	sl, r4
    ea36:	46a3      	mov	fp, r4
    ea38:	e766      	b.n	e908 <z_prf+0x2d8>
	} else if (fplus) {
    ea3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ea3c:	b123      	cbz	r3, ea48 <z_prf+0x418>
		*buf++ = '+';
    ea3e:	232b      	movs	r3, #43	; 0x2b
		*buf++ = ' ';
    ea40:	4629      	mov	r1, r5
    ea42:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
    ea46:	e7df      	b.n	ea08 <z_prf+0x3d8>
	} else if (fspace) {
    ea48:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ea4a:	b10b      	cbz	r3, ea50 <z_prf+0x420>
		*buf++ = ' ';
    ea4c:	2320      	movs	r3, #32
    ea4e:	e7f7      	b.n	ea40 <z_prf+0x410>
    ea50:	4629      	mov	r1, r5
    ea52:	af19      	add	r7, sp, #100	; 0x64
    ea54:	e7da      	b.n	ea0c <z_prf+0x3dc>
	} else if (fplus) {
    ea56:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ea58:	b10b      	cbz	r3, ea5e <z_prf+0x42e>
		*buf++ = '+';
    ea5a:	232b      	movs	r3, #43	; 0x2b
    ea5c:	e717      	b.n	e88e <z_prf+0x25e>
	} else if (fspace) {
    ea5e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ea60:	b10b      	cbz	r3, ea66 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6>
		*buf++ = ' ';
    ea62:	2320      	movs	r3, #32
    ea64:	e713      	b.n	e88e <z_prf+0x25e>
    ea66:	af19      	add	r7, sp, #100	; 0x64
    ea68:	e715      	b.n	e896 <z_prf+0x266>
				*buf++ = 'i';
    ea6a:	2269      	movs	r2, #105	; 0x69
    ea6c:	703a      	strb	r2, [r7, #0]
				*buf++ = 'n';
    ea6e:	226e      	movs	r2, #110	; 0x6e
    ea70:	707a      	strb	r2, [r7, #1]
				*buf++ = 'f';
    ea72:	2266      	movs	r2, #102	; 0x66
    ea74:	e725      	b.n	e8c2 <z_prf+0x292>
			if (isupper(c)) {
    ea76:	2d19      	cmp	r5, #25
				*buf++ = 'N';
    ea78:	bf99      	ittee	ls
    ea7a:	224e      	movls	r2, #78	; 0x4e
				*buf++ = 'A';
    ea7c:	2141      	movls	r1, #65	; 0x41
				*buf++ = 'n';
    ea7e:	226e      	movhi	r2, #110	; 0x6e
				*buf++ = 'a';
    ea80:	2161      	movhi	r1, #97	; 0x61
				*buf++ = 'N';
    ea82:	bf94      	ite	ls
    ea84:	703a      	strbls	r2, [r7, #0]
				*buf++ = 'n';
    ea86:	703a      	strbhi	r2, [r7, #0]
				*buf++ = 'a';
    ea88:	7079      	strb	r1, [r7, #1]
    ea8a:	e71a      	b.n	e8c2 <z_prf+0x292>
	if ((exp | fract) != 0) {
    ea8c:	9b04      	ldr	r3, [sp, #16]
    ea8e:	9805      	ldr	r0, [sp, #20]
    ea90:	430b      	orrs	r3, r1
    ea92:	930e      	str	r3, [sp, #56]	; 0x38
    ea94:	17cb      	asrs	r3, r1, #31
    ea96:	4303      	orrs	r3, r0
		c = 'f';
    ea98:	2d46      	cmp	r5, #70	; 0x46
	if ((exp | fract) != 0) {
    ea9a:	930f      	str	r3, [sp, #60]	; 0x3c
		c = 'f';
    ea9c:	bf08      	it	eq
    ea9e:	2566      	moveq	r5, #102	; 0x66
	if ((exp | fract) != 0) {
    eaa0:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    eaa4:	4313      	orrs	r3, r2
    eaa6:	f000 8107 	beq.w	ecb8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x258>
		if (exp == 0) {
    eaaa:	2900      	cmp	r1, #0
    eaac:	f000 809f 	beq.w	ebee <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x18e>
		fract |= HIGHBIT64;
    eab0:	2600      	movs	r6, #0
    eab2:	9b15      	ldr	r3, [sp, #84]	; 0x54
		exp -= (1023 - 1);	/* +1 since .1 vs 1. */
    eab4:	f2a1 38fe 	subw	r8, r1, #1022	; 0x3fe
		fract |= HIGHBIT64;
    eab8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    eabc:	9315      	str	r3, [sp, #84]	; 0x54
	while (exp <= -3) {
    eabe:	f118 0f02 	cmn.w	r8, #2
    eac2:	f2c0 80a8 	blt.w	ec16 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1b6>
	while (exp > 0) {
    eac6:	f1b8 0f00 	cmp.w	r8, #0
    eaca:	f300 80d4 	bgt.w	ec76 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x216>
		_rlrshift(&fract);
    eace:	a814      	add	r0, sp, #80	; 0x50
		exp++;
    ead0:	f108 0801 	add.w	r8, r8, #1
		_rlrshift(&fract);
    ead4:	f00d faf8 	bl	1c0c8 <_rlrshift>
	while (exp < (0 + 4)) {
    ead8:	f1b8 0f04 	cmp.w	r8, #4
    eadc:	d1f7      	bne.n	eace <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e>
		precision = 6;		/* Default precision if none given */
    eade:	2c00      	cmp	r4, #0
	if ((c == 'g') || (c == 'G')) {
    eae0:	f005 03df 	and.w	r3, r5, #223	; 0xdf
		precision = 6;		/* Default precision if none given */
    eae4:	bfb8      	it	lt
    eae6:	2406      	movlt	r4, #6
	if ((c == 'g') || (c == 'G')) {
    eae8:	2b47      	cmp	r3, #71	; 0x47
    eaea:	f040 80ee 	bne.w	ecca <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x26a>
		if (decexp < (-4 + 1) || decexp > precision) {
    eaee:	1cf1      	adds	r1, r6, #3
    eaf0:	db02      	blt.n	eaf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x98>
    eaf2:	42b4      	cmp	r4, r6
    eaf4:	f280 80e3 	bge.w	ecbe <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x25e>
			c += 'e' - 'g';
    eaf8:	3d02      	subs	r5, #2
    eafa:	b2ed      	uxtb	r5, r5
			if (precision > 0) {
    eafc:	2c00      	cmp	r4, #0
    eafe:	f000 80ea 	beq.w	ecd6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x276>
				precision--;
    eb02:	3c01      	subs	r4, #1
		if (!falt && (precision > 0)) {
    eb04:	f1ba 0f00 	cmp.w	sl, #0
    eb08:	f040 80e5 	bne.w	ecd6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x276>
    eb0c:	2c00      	cmp	r4, #0
    eb0e:	bfd4      	ite	le
    eb10:	f04f 0800 	movle.w	r8, #0
    eb14:	f04f 0801 	movgt.w	r8, #1
	if (c == 'f') {
    eb18:	2d66      	cmp	r5, #102	; 0x66
    eb1a:	f040 80de 	bne.w	ecda <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x27a>
		if (exp < 0) {
    eb1e:	eb14 0b06 	adds.w	fp, r4, r6
    eb22:	f04f 0566 	mov.w	r5, #102	; 0x66
    eb26:	f100 80db 	bmi.w	ece0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x280>
	if (exp > 16) {
    eb2a:	f1bb 0f10 	cmp.w	fp, #16
    eb2e:	bfa8      	it	ge
    eb30:	f04f 0b10 	movge.w	fp, #16
    eb34:	2310      	movs	r3, #16
	ltemp = 0x0800000000000000;
    eb36:	2200      	movs	r2, #0
    eb38:	9313      	str	r3, [sp, #76]	; 0x4c
    eb3a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    eb3e:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
	while (exp--) {
    eb42:	f1bb 0b01 	subs.w	fp, fp, #1
    eb46:	f080 80ce 	bcs.w	ece6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x286>
	fract += ltemp;
    eb4a:	9b14      	ldr	r3, [sp, #80]	; 0x50
    eb4c:	9a16      	ldr	r2, [sp, #88]	; 0x58
    eb4e:	9917      	ldr	r1, [sp, #92]	; 0x5c
    eb50:	189b      	adds	r3, r3, r2
    eb52:	9a15      	ldr	r2, [sp, #84]	; 0x54
    eb54:	eb41 0202 	adc.w	r2, r1, r2
    eb58:	e9cd 3214 	strd	r3, r2, [sp, #80]	; 0x50
	if ((fract >> 32) & 0xF0000000) {
    eb5c:	f002 4370 	and.w	r3, r2, #4026531840	; 0xf0000000
    eb60:	9310      	str	r3, [sp, #64]	; 0x40
    eb62:	2300      	movs	r3, #0
    eb64:	9311      	str	r3, [sp, #68]	; 0x44
    eb66:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
    eb6a:	4313      	orrs	r3, r2
    eb6c:	d006      	beq.n	eb7c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x11c>
		_ldiv5(&fract);
    eb6e:	a814      	add	r0, sp, #80	; 0x50
    eb70:	f00d fabb 	bl	1c0ea <_ldiv5>
		_rlrshift(&fract);
    eb74:	a814      	add	r0, sp, #80	; 0x50
    eb76:	f00d faa7 	bl	1c0c8 <_rlrshift>
		decexp++;
    eb7a:	3601      	adds	r6, #1
	if (c == 'f') {
    eb7c:	2d66      	cmp	r5, #102	; 0x66
    eb7e:	f040 80cf 	bne.w	ed20 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2c0>
		if (decexp > 0) {
    eb82:	2e00      	cmp	r6, #0
    eb84:	f340 80b6 	ble.w	ecf4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x294>
			while (decexp > 0 && digit_count > 0) {
    eb88:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    eb8a:	2b00      	cmp	r3, #0
    eb8c:	dd07      	ble.n	eb9e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x13e>
				*buf++ = _get_digit(&fract, &digit_count);
    eb8e:	a913      	add	r1, sp, #76	; 0x4c
    eb90:	a814      	add	r0, sp, #80	; 0x50
    eb92:	f00d fad2 	bl	1c13a <_get_digit>
			while (decexp > 0 && digit_count > 0) {
    eb96:	3e01      	subs	r6, #1
				*buf++ = _get_digit(&fract, &digit_count);
    eb98:	f807 0b01 	strb.w	r0, [r7], #1
			while (decexp > 0 && digit_count > 0) {
    eb9c:	d1f4      	bne.n	eb88 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x128>
			zp->predot = decexp;
    eb9e:	46b3      	mov	fp, r6
    eba0:	463b      	mov	r3, r7
			decexp = 0;
    eba2:	2600      	movs	r6, #0
		if (falt || (precision > 0)) {
    eba4:	f1ba 0f00 	cmp.w	sl, #0
    eba8:	d101      	bne.n	ebae <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x14e>
    ebaa:	2c00      	cmp	r4, #0
    ebac:	dd15      	ble.n	ebda <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x17a>
			*buf++ = '.';
    ebae:	222e      	movs	r2, #46	; 0x2e
    ebb0:	f803 2b01 	strb.w	r2, [r3], #1
		if (decexp < 0 && precision > 0) {
    ebb4:	2e00      	cmp	r6, #0
    ebb6:	f000 80ae 	beq.w	ed16 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2b6>
    ebba:	2c00      	cmp	r4, #0
    ebbc:	f340 80ad 	ble.w	ed1a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2ba>
			zp->postdot = -decexp;
    ebc0:	f1c6 0a00 	rsb	sl, r6, #0
    ebc4:	45a2      	cmp	sl, r4
    ebc6:	bfa8      	it	ge
    ebc8:	46a2      	movge	sl, r4
			precision -= zp->postdot;
    ebca:	eba4 040a 	sub.w	r4, r4, sl
		while (precision > 0 && digit_count > 0) {
    ebce:	2c00      	cmp	r4, #0
    ebd0:	dd03      	ble.n	ebda <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x17a>
    ebd2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    ebd4:	2a00      	cmp	r2, #0
    ebd6:	f300 8094 	bgt.w	ed02 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2a2>
	if (prune_zero) {
    ebda:	f1b8 0f00 	cmp.w	r8, #0
    ebde:	f040 80b4 	bne.w	ed4a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2ea>
	*buf = 0;
    ebe2:	2200      	movs	r2, #0
	return buf - start;
    ebe4:	ae19      	add	r6, sp, #100	; 0x64
	*buf = 0;
    ebe6:	701a      	strb	r2, [r3, #0]
	return buf - start;
    ebe8:	1b9b      	subs	r3, r3, r6
    ebea:	e671      	b.n	e8d0 <z_prf+0x2a0>
				exp--;
    ebec:	3901      	subs	r1, #1
			while (((fract <<= 1) & HIGHBIT64) == 0) {
    ebee:	9b04      	ldr	r3, [sp, #16]
    ebf0:	18db      	adds	r3, r3, r3
    ebf2:	9304      	str	r3, [sp, #16]
    ebf4:	9b05      	ldr	r3, [sp, #20]
    ebf6:	415b      	adcs	r3, r3
    ebf8:	9305      	str	r3, [sp, #20]
    ebfa:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    ebfe:	2a00      	cmp	r2, #0
    ec00:	f173 0300 	sbcs.w	r3, r3, #0
    ec04:	daf2      	bge.n	ebec <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x18c>
    ec06:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    ec0a:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    ec0e:	e74f      	b.n	eab0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x50>
			_rlrshift(&fract);
    ec10:	a814      	add	r0, sp, #80	; 0x50
    ec12:	f00d fa59 	bl	1c0c8 <_rlrshift>
		while ((fract >> 32) >= (MAXFP1 / 5)) {
    ec16:	e9dd 2c14 	ldrd	r2, ip, [sp, #80]	; 0x50
    ec1a:	2300      	movs	r3, #0
    ec1c:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    ec20:	930b      	str	r3, [sp, #44]	; 0x2c
    ec22:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    ec26:	2900      	cmp	r1, #0
    ec28:	bf08      	it	eq
    ec2a:	f1b0 3f33 	cmpeq.w	r0, #858993459	; 0x33333333
    ec2e:	f108 0801 	add.w	r8, r8, #1
    ec32:	d2ed      	bcs.n	ec10 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1b0>
		fract *= 5U;
    ec34:	2005      	movs	r0, #5
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    ec36:	f04f 0e00 	mov.w	lr, #0
		fract *= 5U;
    ec3a:	fba2 2300 	umull	r2, r3, r2, r0
    ec3e:	fb00 330c 	mla	r3, r0, ip, r3
    ec42:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
		decexp--;
    ec46:	3e01      	subs	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    ec48:	2100      	movs	r1, #0
    ec4a:	f04f 0c00 	mov.w	ip, #0
    ec4e:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    ec52:	458c      	cmp	ip, r1
    ec54:	bf08      	it	eq
    ec56:	459b      	cmpeq	fp, r3
    ec58:	d206      	bcs.n	ec68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x208>
    ec5a:	f1be 0f00 	cmp.w	lr, #0
    ec5e:	f43f af2e 	beq.w	eabe <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5e>
    ec62:	e9cd 2314 	strd	r2, r3, [sp, #80]	; 0x50
    ec66:	e72a      	b.n	eabe <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5e>
			fract <<= 1;
    ec68:	1892      	adds	r2, r2, r2
			exp--;
    ec6a:	f04f 0e01 	mov.w	lr, #1
			fract <<= 1;
    ec6e:	415b      	adcs	r3, r3
			exp--;
    ec70:	f108 38ff 	add.w	r8, r8, #4294967295
    ec74:	e7e8      	b.n	ec48 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x1e8>
		_ldiv5(&fract);
    ec76:	a814      	add	r0, sp, #80	; 0x50
    ec78:	f00d fa37 	bl	1c0ea <_ldiv5>
		exp--;
    ec7c:	e9dd 1014 	ldrd	r1, r0, [sp, #80]	; 0x50
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    ec80:	f04f 0e00 	mov.w	lr, #0
		exp--;
    ec84:	f108 38ff 	add.w	r8, r8, #4294967295
		decexp++;
    ec88:	3601      	adds	r6, #1
		while ((fract >> 32) <= (MAXFP1 / 2)) {
    ec8a:	2300      	movs	r3, #0
    ec8c:	f04f 0c00 	mov.w	ip, #0
    ec90:	f06f 4b00 	mvn.w	fp, #2147483648	; 0x80000000
    ec94:	459c      	cmp	ip, r3
    ec96:	bf08      	it	eq
    ec98:	4583      	cmpeq	fp, r0
    ec9a:	d206      	bcs.n	ecaa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x24a>
    ec9c:	f1be 0f00 	cmp.w	lr, #0
    eca0:	f43f af11 	beq.w	eac6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x66>
    eca4:	e9cd 1014 	strd	r1, r0, [sp, #80]	; 0x50
    eca8:	e70d      	b.n	eac6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x66>
			fract <<= 1;
    ecaa:	1849      	adds	r1, r1, r1
			exp--;
    ecac:	f04f 0e01 	mov.w	lr, #1
			fract <<= 1;
    ecb0:	4140      	adcs	r0, r0
			exp--;
    ecb2:	f108 38ff 	add.w	r8, r8, #4294967295
    ecb6:	e7e8      	b.n	ec8a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x22a>
    ecb8:	2600      	movs	r6, #0
    ecba:	46b0      	mov	r8, r6
    ecbc:	e707      	b.n	eace <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6e>
			precision -= decexp;
    ecbe:	1ba4      	subs	r4, r4, r6
		if (!falt && (precision > 0)) {
    ecc0:	f1ba 0f00 	cmp.w	sl, #0
    ecc4:	d104      	bne.n	ecd0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x270>
			c = 'f';
    ecc6:	2566      	movs	r5, #102	; 0x66
    ecc8:	e720      	b.n	eb0c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xac>
	prune_zero = false;		/* Assume trailing 0's allowed     */
    ecca:	f04f 0800 	mov.w	r8, #0
    ecce:	e723      	b.n	eb18 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xb8>
    ecd0:	f04f 0800 	mov.w	r8, #0
    ecd4:	e723      	b.n	eb1e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xbe>
    ecd6:	f04f 0800 	mov.w	r8, #0
		exp = precision + 1;
    ecda:	f104 0b01 	add.w	fp, r4, #1
    ecde:	e724      	b.n	eb2a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xca>
			exp = 0;
    ece0:	f04f 0b00 	mov.w	fp, #0
    ece4:	e726      	b.n	eb34 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xd4>
		_ldiv5(&ltemp);
    ece6:	a816      	add	r0, sp, #88	; 0x58
    ece8:	f00d f9ff 	bl	1c0ea <_ldiv5>
		_rlrshift(&ltemp);
    ecec:	a816      	add	r0, sp, #88	; 0x58
    ecee:	f00d f9eb 	bl	1c0c8 <_rlrshift>
    ecf2:	e726      	b.n	eb42 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0xe2>
			*buf++ = '0';
    ecf4:	463b      	mov	r3, r7
    ecf6:	2230      	movs	r2, #48	; 0x30
			zero.predot = zero.postdot = zero.trail = 0;
    ecf8:	f04f 0b00 	mov.w	fp, #0
			*buf++ = '0';
    ecfc:	f803 2b01 	strb.w	r2, [r3], #1
    ed00:	e750      	b.n	eba4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x144>
			*buf++ = _get_digit(&fract, &digit_count);
    ed02:	a913      	add	r1, sp, #76	; 0x4c
    ed04:	a814      	add	r0, sp, #80	; 0x50
    ed06:	930a      	str	r3, [sp, #40]	; 0x28
    ed08:	f00d fa17 	bl	1c13a <_get_digit>
    ed0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    ed0e:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    ed10:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    ed14:	e75b      	b.n	ebce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16e>
			zero.predot = zero.postdot = zero.trail = 0;
    ed16:	46b2      	mov	sl, r6
    ed18:	e759      	b.n	ebce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x16e>
    ed1a:	f04f 0a00 	mov.w	sl, #0
    ed1e:	e75c      	b.n	ebda <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x17a>
		*buf = _get_digit(&fract, &digit_count);
    ed20:	a913      	add	r1, sp, #76	; 0x4c
    ed22:	a814      	add	r0, sp, #80	; 0x50
    ed24:	f00d fa09 	bl	1c13a <_get_digit>
		if (*buf++ != '0') {
    ed28:	2830      	cmp	r0, #48	; 0x30
		*buf = _get_digit(&fract, &digit_count);
    ed2a:	7038      	strb	r0, [r7, #0]
			decexp--;
    ed2c:	bf18      	it	ne
    ed2e:	f106 36ff 	addne.w	r6, r6, #4294967295
		if (falt || (precision > 0)) {
    ed32:	f1ba 0f00 	cmp.w	sl, #0
    ed36:	d138      	bne.n	edaa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x34a>
    ed38:	2c00      	cmp	r4, #0
    ed3a:	dc36      	bgt.n	edaa <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x34a>
		if (*buf++ != '0') {
    ed3c:	1c7b      	adds	r3, r7, #1
	if (prune_zero) {
    ed3e:	f1b8 0f00 	cmp.w	r8, #0
    ed42:	d044      	beq.n	edce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x36e>
			zero.predot = zero.postdot = zero.trail = 0;
    ed44:	f04f 0b00 	mov.w	fp, #0
    ed48:	46da      	mov	sl, fp
		while (*--buf == '0')
    ed4a:	4619      	mov	r1, r3
    ed4c:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
    ed50:	2a30      	cmp	r2, #48	; 0x30
    ed52:	d0fa      	beq.n	ed4a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2ea>
		if (*buf != '.') {
    ed54:	2a2e      	cmp	r2, #46	; 0x2e
    ed56:	bf18      	it	ne
    ed58:	460b      	movne	r3, r1
    ed5a:	2400      	movs	r4, #0
	if ((c == 'e') || (c == 'E')) {
    ed5c:	f005 02df 	and.w	r2, r5, #223	; 0xdf
    ed60:	2a45      	cmp	r2, #69	; 0x45
    ed62:	f47f af3e 	bne.w	ebe2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x182>
		if (decexp < 0) {
    ed66:	2e00      	cmp	r6, #0
			*buf++ = '-';
    ed68:	bfb4      	ite	lt
    ed6a:	222d      	movlt	r2, #45	; 0x2d
			*buf++ = '+';
    ed6c:	222b      	movge	r2, #43	; 0x2b
		*buf++ = c;
    ed6e:	4619      	mov	r1, r3
			decexp = -decexp;
    ed70:	bfb8      	it	lt
    ed72:	4276      	neglt	r6, r6
		if (decexp >= 100) {
    ed74:	2e63      	cmp	r6, #99	; 0x63
		*buf++ = c;
    ed76:	f801 5b02 	strb.w	r5, [r1], #2
			*buf++ = '-';
    ed7a:	705a      	strb	r2, [r3, #1]
		if (decexp >= 100) {
    ed7c:	dd08      	ble.n	ed90 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x330>
			*buf++ = (decexp / 100) + '0';
    ed7e:	2064      	movs	r0, #100	; 0x64
    ed80:	fb96 f2f0 	sdiv	r2, r6, r0
			decexp %= 100;
    ed84:	fb00 6612 	mls	r6, r0, r2, r6
			*buf++ = (decexp / 100) + '0';
    ed88:	f102 0530 	add.w	r5, r2, #48	; 0x30
    ed8c:	1cd9      	adds	r1, r3, #3
    ed8e:	709d      	strb	r5, [r3, #2]
		*buf++ = (decexp / 10) + '0';
    ed90:	200a      	movs	r0, #10
    ed92:	fb96 f2f0 	sdiv	r2, r6, r0
    ed96:	460b      	mov	r3, r1
		decexp %= 10;
    ed98:	fb00 6612 	mls	r6, r0, r2, r6
		*buf++ = (decexp / 10) + '0';
    ed9c:	f102 0530 	add.w	r5, r2, #48	; 0x30
		*buf++ = decexp + '0';
    eda0:	3630      	adds	r6, #48	; 0x30
		*buf++ = (decexp / 10) + '0';
    eda2:	f803 5b02 	strb.w	r5, [r3], #2
		*buf++ = decexp + '0';
    eda6:	704e      	strb	r6, [r1, #1]
    eda8:	e71b      	b.n	ebe2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x182>
			*buf++ = '.';
    edaa:	222e      	movs	r2, #46	; 0x2e
    edac:	1cbb      	adds	r3, r7, #2
    edae:	707a      	strb	r2, [r7, #1]
		while (precision > 0 && digit_count > 0) {
    edb0:	2c00      	cmp	r4, #0
    edb2:	ddc4      	ble.n	ed3e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2de>
    edb4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    edb6:	2a00      	cmp	r2, #0
    edb8:	ddc1      	ble.n	ed3e <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2de>
			*buf++ = _get_digit(&fract, &digit_count);
    edba:	a913      	add	r1, sp, #76	; 0x4c
    edbc:	a814      	add	r0, sp, #80	; 0x50
    edbe:	930a      	str	r3, [sp, #40]	; 0x28
    edc0:	f00d f9bb 	bl	1c13a <_get_digit>
    edc4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			precision--;
    edc6:	3c01      	subs	r4, #1
			*buf++ = _get_digit(&fract, &digit_count);
    edc8:	f803 0b01 	strb.w	r0, [r3], #1
			precision--;
    edcc:	e7f0      	b.n	edb0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x350>
			zero.predot = zero.postdot = zero.trail = 0;
    edce:	46c3      	mov	fp, r8
    edd0:	46c2      	mov	sl, r8
    edd2:	e7c3      	b.n	ed5c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x2fc>
					prefix = 1;
    edd4:	f04f 0801 	mov.w	r8, #1
    edd8:	e58a      	b.n	e8f0 <z_prf+0x2c0>
				switch (i) {
    edda:	4632      	mov	r2, r6
    eddc:	f852 3b04 	ldr.w	r3, [r2], #4
    ede0:	2f68      	cmp	r7, #104	; 0x68
    ede2:	9201      	str	r2, [sp, #4]
    ede4:	d006      	beq.n	edf4 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x394>
    ede6:	2f6c      	cmp	r7, #108	; 0x6c
    ede8:	d009      	beq.n	edfe <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x39e>
    edea:	2f48      	cmp	r7, #72	; 0x48
    edec:	d107      	bne.n	edfe <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x39e>
					*va_arg(vargs, char *) = count;
    edee:	9a02      	ldr	r2, [sp, #8]
    edf0:	701a      	strb	r2, [r3, #0]
					break;
    edf2:	e001      	b.n	edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>
					*va_arg(vargs, short *) = count;
    edf4:	9a02      	ldr	r2, [sp, #8]
    edf6:	801a      	strh	r2, [r3, #0]
				continue;
    edf8:	9e01      	ldr	r6, [sp, #4]
    edfa:	9a06      	ldr	r2, [sp, #24]
    edfc:	e420      	b.n	e640 <z_prf+0x10>
					*va_arg(vargs, int *) = count;
    edfe:	9a02      	ldr	r2, [sp, #8]
    ee00:	601a      	str	r2, [r3, #0]
					break;
    ee02:	e7f9      	b.n	edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>
		*buf++ = '0';
    ee04:	f647 0330 	movw	r3, #30768	; 0x7830
    ee08:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
	len = _to_x(buf, value, 16);
    ee0c:	4633      	mov	r3, r6
    ee0e:	f853 1b04 	ldr.w	r1, [r3], #4
    ee12:	2210      	movs	r2, #16
    ee14:	f10d 0066 	add.w	r0, sp, #102	; 0x66
    ee18:	9301      	str	r3, [sp, #4]
    ee1a:	f00d f931 	bl	1c080 <_to_x>
				prefix = 2;
    ee1e:	f04f 0802 	mov.w	r8, #2
	return len + (buf - buf0);
    ee22:	1c86      	adds	r6, r0, #2
				break;
    ee24:	e603      	b.n	ea2e <z_prf+0x3fe>
				cptr = va_arg(vargs, char *);
    ee26:	4633      	mov	r3, r6
					precision = INT_MAX;
    ee28:	2c00      	cmp	r4, #0
    ee2a:	bfb8      	it	lt
    ee2c:	f06f 4400 	mvnlt.w	r4, #2147483648	; 0x80000000
				for (clen = 0; clen < precision; clen++) {
    ee30:	2600      	movs	r6, #0
				cptr = va_arg(vargs, char *);
    ee32:	f853 7b04 	ldr.w	r7, [r3], #4
    ee36:	9301      	str	r3, [sp, #4]
				for (clen = 0; clen < precision; clen++) {
    ee38:	42b4      	cmp	r4, r6
    ee3a:	d103      	bne.n	ee44 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3e4>
    ee3c:	4626      	mov	r6, r4
    ee3e:	2400      	movs	r4, #0
    ee40:	46a0      	mov	r8, r4
    ee42:	e578      	b.n	e936 <z_prf+0x306>
					if (cptr[clen] == '\0') {
    ee44:	5dbb      	ldrb	r3, [r7, r6]
    ee46:	2b00      	cmp	r3, #0
    ee48:	d05b      	beq.n	ef02 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4a2>
				for (clen = 0; clen < precision; clen++) {
    ee4a:	3601      	adds	r6, #1
    ee4c:	e7f4      	b.n	ee38 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3d8>
				switch (i) {
    ee4e:	1d33      	adds	r3, r6, #4
				if (c == 'o') {
    ee50:	2d6f      	cmp	r5, #111	; 0x6f
    ee52:	6831      	ldr	r1, [r6, #0]
    ee54:	9301      	str	r3, [sp, #4]
    ee56:	d119      	bne.n	ee8c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x42c>
	if (alt_form) {
    ee58:	f1ba 0f00 	cmp.w	sl, #0
    ee5c:	d008      	beq.n	ee70 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x410>
		*buf++ = '0';
    ee5e:	2330      	movs	r3, #48	; 0x30
    ee60:	f88d 3064 	strb.w	r3, [sp, #100]	; 0x64
		if (!value) {
    ee64:	b979      	cbnz	r1, ee86 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x426>
			prefix = 0;
    ee66:	4688      	mov	r8, r1
			return 1;
    ee68:	2601      	movs	r6, #1
			*buf++ = 0;
    ee6a:	f88d 1065 	strb.w	r1, [sp, #101]	; 0x65
			return 1;
    ee6e:	e5de      	b.n	ea2e <z_prf+0x3fe>
    ee70:	ad19      	add	r5, sp, #100	; 0x64
	return (buf - buf0) + _to_x(buf, value, 8);
    ee72:	4628      	mov	r0, r5
    ee74:	2208      	movs	r2, #8
    ee76:	f00d f903 	bl	1c080 <_to_x>
    ee7a:	ae19      	add	r6, sp, #100	; 0x64
    ee7c:	1bad      	subs	r5, r5, r6
    ee7e:	182e      	adds	r6, r5, r0
			prefix = 0;
    ee80:	f04f 0800 	mov.w	r8, #0
    ee84:	e5d3      	b.n	ea2e <z_prf+0x3fe>
		*buf++ = '0';
    ee86:	f10d 0565 	add.w	r5, sp, #101	; 0x65
    ee8a:	e7f2      	b.n	ee72 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x412>
				} else if (c == 'u') {
    ee8c:	2d75      	cmp	r5, #117	; 0x75
    ee8e:	d105      	bne.n	ee9c <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x43c>
	return _to_x(buf, value, 10);
    ee90:	220a      	movs	r2, #10
    ee92:	a819      	add	r0, sp, #100	; 0x64
    ee94:	f00d f8f4 	bl	1c080 <_to_x>
    ee98:	4606      	mov	r6, r0
    ee9a:	e7f1      	b.n	ee80 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x420>
	if (alt_form) {
    ee9c:	f1ba 0f00 	cmp.w	sl, #0
    eea0:	d011      	beq.n	eec6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x466>
		*buf++ = '0';
    eea2:	f647 0330 	movw	r3, #30768	; 0x7830
		*buf++ = 'x';
    eea6:	f10d 0766 	add.w	r7, sp, #102	; 0x66
		*buf++ = '0';
    eeaa:	f8ad 3064 	strh.w	r3, [sp, #100]	; 0x64
	len = _to_x(buf, value, 16);
    eeae:	2210      	movs	r2, #16
    eeb0:	4638      	mov	r0, r7
    eeb2:	f00d f8e5 	bl	1c080 <_to_x>
	if (prefix == 'X') {
    eeb6:	2d58      	cmp	r5, #88	; 0x58
    eeb8:	d007      	beq.n	eeca <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46a>
	return len + (buf - buf0);
    eeba:	ab19      	add	r3, sp, #100	; 0x64
    eebc:	1aff      	subs	r7, r7, r3
    eebe:	183e      	adds	r6, r7, r0
						prefix = 2;
    eec0:	ea4f 084a 	mov.w	r8, sl, lsl #1
    eec4:	e5b3      	b.n	ea2e <z_prf+0x3fe>
    eec6:	af19      	add	r7, sp, #100	; 0x64
    eec8:	e7f1      	b.n	eeae <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x44e>
    eeca:	aa19      	add	r2, sp, #100	; 0x64
		if (*buf >= 'a' && *buf <= 'z') {
    eecc:	f812 3b01 	ldrb.w	r3, [r2], #1
    eed0:	f1a3 0161 	sub.w	r1, r3, #97	; 0x61
    eed4:	2919      	cmp	r1, #25
    eed6:	d803      	bhi.n	eee0 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x480>
			*buf += 'A' - 'a';
    eed8:	3b20      	subs	r3, #32
    eeda:	f802 3c01 	strb.w	r3, [r2, #-1]
	} while (*buf++);
    eede:	e7f5      	b.n	eecc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46c>
    eee0:	f812 3c01 	ldrb.w	r3, [r2, #-1]
    eee4:	2b00      	cmp	r3, #0
    eee6:	d1f1      	bne.n	eecc <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x46c>
    eee8:	e7e7      	b.n	eeba <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x45a>
				PUTC('%');
    eeea:	4649      	mov	r1, r9
    eeec:	4628      	mov	r0, r5
    eeee:	f7ff bbb0 	b.w	e652 <z_prf+0x22>
				count++;
    eef2:	9b02      	ldr	r3, [sp, #8]
    eef4:	3301      	adds	r3, #1
				continue;
    eef6:	e9cd 6301 	strd	r6, r3, [sp, #4]
    eefa:	e77d      	b.n	edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>
					prefix = 1;
    eefc:	f04f 0801 	mov.w	r8, #1
    ef00:	e595      	b.n	ea2e <z_prf+0x3fe>
    ef02:	461c      	mov	r4, r3
    ef04:	e79c      	b.n	ee40 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3e0>
				zero_head = 0;
    ef06:	2300      	movs	r3, #0
			cptr = buf;
    ef08:	af19      	add	r7, sp, #100	; 0x64
    ef0a:	e51c      	b.n	e946 <z_prf+0x316>
				zero_head = 0;
    ef0c:	9b08      	ldr	r3, [sp, #32]
    ef0e:	af19      	add	r7, sp, #100	; 0x64
    ef10:	e519      	b.n	e946 <z_prf+0x316>
    ef12:	9309      	str	r3, [sp, #36]	; 0x24
					PUTC(' ');
    ef14:	4649      	mov	r1, r9
    ef16:	9b03      	ldr	r3, [sp, #12]
    ef18:	2020      	movs	r0, #32
    ef1a:	9207      	str	r2, [sp, #28]
    ef1c:	4798      	blx	r3
    ef1e:	3001      	adds	r0, #1
    ef20:	9a07      	ldr	r2, [sp, #28]
    ef22:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ef24:	f43f ab9a 	beq.w	e65c <z_prf+0x2c>
				while (width-- > 0) {
    ef28:	3a01      	subs	r2, #1
    ef2a:	d2f2      	bcs.n	ef12 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4b2>
				count += width;
    ef2c:	9902      	ldr	r1, [sp, #8]
    ef2e:	4429      	add	r1, r5
    ef30:	9102      	str	r1, [sp, #8]
				while (width-- > 0) {
    ef32:	4615      	mov	r5, r2
    ef34:	e511      	b.n	e95a <z_prf+0x32a>
    ef36:	462a      	mov	r2, r5
    ef38:	e7f6      	b.n	ef28 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x4c8>
    ef3a:	9309      	str	r3, [sp, #36]	; 0x24
				PUTC(*cptr++);
    ef3c:	4649      	mov	r1, r9
    ef3e:	9b03      	ldr	r3, [sp, #12]
    ef40:	f817 0b01 	ldrb.w	r0, [r7], #1
    ef44:	9207      	str	r2, [sp, #28]
    ef46:	4798      	blx	r3
    ef48:	3001      	adds	r0, #1
    ef4a:	9a07      	ldr	r2, [sp, #28]
    ef4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ef4e:	f47f ad06 	bne.w	e95e <z_prf+0x32e>
    ef52:	f7ff bb83 	b.w	e65c <z_prf+0x2c>
    ef56:	9307      	str	r3, [sp, #28]
				PUTC('0');
    ef58:	4649      	mov	r1, r9
    ef5a:	9b03      	ldr	r3, [sp, #12]
    ef5c:	2030      	movs	r0, #48	; 0x30
    ef5e:	4798      	blx	r3
    ef60:	3001      	adds	r0, #1
    ef62:	9b07      	ldr	r3, [sp, #28]
    ef64:	f47f acfe 	bne.w	e964 <z_prf+0x334>
    ef68:	f7ff bb78 	b.w	e65c <z_prf+0x2c>
					PUTC(c);
    ef6c:	4649      	mov	r1, r9
    ef6e:	9b03      	ldr	r3, [sp, #12]
    ef70:	4798      	blx	r3
    ef72:	3001      	adds	r0, #1
    ef74:	f43f ab72 	beq.w	e65c <z_prf+0x2c>
					c = *++cptr;
    ef78:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    ef7c:	e4fd      	b.n	e97a <z_prf+0x34a>
					PUTC('0');
    ef7e:	4649      	mov	r1, r9
    ef80:	2030      	movs	r0, #48	; 0x30
    ef82:	9b03      	ldr	r3, [sp, #12]
    ef84:	4798      	blx	r3
    ef86:	3001      	adds	r0, #1
    ef88:	f47f acff 	bne.w	e98a <z_prf+0x35a>
    ef8c:	f7ff bb66 	b.w	e65c <z_prf+0x2c>
					PUTC('0');
    ef90:	4649      	mov	r1, r9
    ef92:	2030      	movs	r0, #48	; 0x30
    ef94:	9b03      	ldr	r3, [sp, #12]
    ef96:	4798      	blx	r3
    ef98:	3001      	adds	r0, #1
    ef9a:	f108 38ff 	add.w	r8, r8, #4294967295
    ef9e:	f47f ad0e 	bne.w	e9be <z_prf+0x38e>
    efa2:	f7ff bb5b 	b.w	e65c <z_prf+0x2c>
					PUTC(c);
    efa6:	4649      	mov	r1, r9
    efa8:	9b03      	ldr	r3, [sp, #12]
    efaa:	4798      	blx	r3
    efac:	3001      	adds	r0, #1
    efae:	f43f ab55 	beq.w	e65c <z_prf+0x2c>
					c = *++cptr;
    efb2:	f817 0f01 	ldrb.w	r0, [r7, #1]!
    efb6:	e50c      	b.n	e9d2 <z_prf+0x3a2>
					PUTC('0');
    efb8:	4649      	mov	r1, r9
    efba:	2030      	movs	r0, #48	; 0x30
    efbc:	9b03      	ldr	r3, [sp, #12]
    efbe:	4798      	blx	r3
    efc0:	3001      	adds	r0, #1
    efc2:	f108 38ff 	add.w	r8, r8, #4294967295
    efc6:	f47f ad0f 	bne.w	e9e8 <z_prf+0x3b8>
    efca:	f7ff bb47 	b.w	e65c <z_prf+0x2c>
				PUTC(*cptr++);
    efce:	4649      	mov	r1, r9
    efd0:	f817 0b01 	ldrb.w	r0, [r7], #1
    efd4:	9b03      	ldr	r3, [sp, #12]
    efd6:	4798      	blx	r3
    efd8:	3001      	adds	r0, #1
    efda:	f43f ab3f 	beq.w	e65c <z_prf+0x2c>
			while (clen-- > 0) {
    efde:	1bf3      	subs	r3, r6, r7
    efe0:	2b00      	cmp	r3, #0
    efe2:	dcf4      	bgt.n	efce <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x56e>
			count += clen;
    efe4:	9b02      	ldr	r3, [sp, #8]
    efe6:	9a08      	ldr	r2, [sp, #32]
			if (width > 0) {
    efe8:	2d00      	cmp	r5, #0
			count += clen;
    efea:	4413      	add	r3, r2
    efec:	9302      	str	r3, [sp, #8]
			if (width > 0) {
    efee:	f77f af03 	ble.w	edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>
    eff2:	462c      	mov	r4, r5
    eff4:	e006      	b.n	f004 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x5a4>
					PUTC(' ');
    eff6:	4649      	mov	r1, r9
    eff8:	2020      	movs	r0, #32
    effa:	9b03      	ldr	r3, [sp, #12]
    effc:	4798      	blx	r3
    effe:	3001      	adds	r0, #1
    f000:	f43f ab2c 	beq.w	e65c <z_prf+0x2c>
				while (width-- > 0) {
    f004:	3c01      	subs	r4, #1
    f006:	d2f6      	bcs.n	eff6 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x596>
				count += width;
    f008:	9b02      	ldr	r3, [sp, #8]
    f00a:	442b      	add	r3, r5
    f00c:	9302      	str	r3, [sp, #8]
    f00e:	e6f3      	b.n	edf8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x398>

0000f010 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    f010:	4b01      	ldr	r3, [pc, #4]	; (f018 <__stdout_hook_install+0x8>)
    f012:	6018      	str	r0, [r3, #0]
}
    f014:	4770      	bx	lr
    f016:	bf00      	nop
    f018:	20020004 	.word	0x20020004

0000f01c <z_impl_zephyr_fputc>:

int z_impl_zephyr_fputc(int c, FILE *stream)
{
	return (stdout == stream) ? _stdout_hook(c) : EOF;
    f01c:	2902      	cmp	r1, #2
    f01e:	d102      	bne.n	f026 <z_impl_zephyr_fputc+0xa>
    f020:	4b02      	ldr	r3, [pc, #8]	; (f02c <z_impl_zephyr_fputc+0x10>)
    f022:	681b      	ldr	r3, [r3, #0]
    f024:	4718      	bx	r3
}
    f026:	f04f 30ff 	mov.w	r0, #4294967295
    f02a:	4770      	bx	lr
    f02c:	20020004 	.word	0x20020004

0000f030 <snprintf>:
	return 0; /* indicate keep going so we get the total count */
}

int snprintf(char *_MLIBC_RESTRICT s, size_t len,
	     const char *_MLIBC_RESTRICT format, ...)
{
    f030:	b40c      	push	{r2, r3}
    f032:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	struct emitter p;
	int     r;
	char    dummy;

	if (len == 0) {
    f034:	b909      	cbnz	r1, f03a <snprintf+0xa>
		s = &dummy; /* write final NUL to dummy, can't change *s */
    f036:	f10d 0003 	add.w	r0, sp, #3
	}

	p.ptr = s;
	p.len = (int) len;
    f03a:	e9cd 0102 	strd	r0, r1, [sp, #8]

	va_start(vargs, format);
    f03e:	ab07      	add	r3, sp, #28
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    f040:	9a06      	ldr	r2, [sp, #24]
    f042:	a902      	add	r1, sp, #8
    f044:	4805      	ldr	r0, [pc, #20]	; (f05c <snprintf+0x2c>)
	va_start(vargs, format);
    f046:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    f048:	f7ff faf2 	bl	e630 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    f04c:	2200      	movs	r2, #0
    f04e:	9b02      	ldr	r3, [sp, #8]
    f050:	701a      	strb	r2, [r3, #0]
	return r;
}
    f052:	b005      	add	sp, #20
    f054:	f85d eb04 	ldr.w	lr, [sp], #4
    f058:	b002      	add	sp, #8
    f05a:	4770      	bx	lr
    f05c:	0001c173 	.word	0x0001c173

0000f060 <sprintf>:

int sprintf(char *_MLIBC_RESTRICT s, const char *_MLIBC_RESTRICT format, ...)
{
    f060:	b40e      	push	{r1, r2, r3}
    f062:	b50f      	push	{r0, r1, r2, r3, lr}

	struct emitter p;
	int     r;

	p.ptr = s;
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    f064:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
    f068:	ab05      	add	r3, sp, #20
    f06a:	f853 2b04 	ldr.w	r2, [r3], #4
	p.ptr = s;
    f06e:	9002      	str	r0, [sp, #8]
	p.len = (int) 0x7fffffff; /* allow up to "maxint" characters */
    f070:	9103      	str	r1, [sp, #12]

	va_start(vargs, format);
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    f072:	4806      	ldr	r0, [pc, #24]	; (f08c <sprintf+0x2c>)
    f074:	a902      	add	r1, sp, #8
	va_start(vargs, format);
    f076:	9301      	str	r3, [sp, #4]
	r = z_prf(sprintf_out, (void *) (&p), format, vargs);
    f078:	f7ff fada 	bl	e630 <z_prf>
	va_end(vargs);

	*(p.ptr) = 0;
    f07c:	2200      	movs	r2, #0
    f07e:	9b02      	ldr	r3, [sp, #8]
    f080:	701a      	strb	r2, [r3, #0]
	return r;
}
    f082:	b004      	add	sp, #16
    f084:	f85d eb04 	ldr.w	lr, [sp], #4
    f088:	b003      	add	sp, #12
    f08a:	4770      	bx	lr
    f08c:	0001c173 	.word	0x0001c173

0000f090 <printf>:

	return r;
}

int printf(const char *_MLIBC_RESTRICT format, ...)
{
    f090:	b40f      	push	{r0, r1, r2, r3}
    f092:	b507      	push	{r0, r1, r2, lr}
    f094:	ab04      	add	r3, sp, #16
    f096:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list vargs;
	int     r;

	va_start(vargs, format);
	r = z_prf(fputc, DESC(stdout), format, vargs);
    f09a:	2102      	movs	r1, #2
    f09c:	4804      	ldr	r0, [pc, #16]	; (f0b0 <printf+0x20>)
	va_start(vargs, format);
    f09e:	9301      	str	r3, [sp, #4]
	r = z_prf(fputc, DESC(stdout), format, vargs);
    f0a0:	f7ff fac6 	bl	e630 <z_prf>
	va_end(vargs);

	return r;
}
    f0a4:	b003      	add	sp, #12
    f0a6:	f85d eb04 	ldr.w	lr, [sp], #4
    f0aa:	b004      	add	sp, #16
    f0ac:	4770      	bx	lr
    f0ae:	bf00      	nop
    f0b0:	0001c16f 	.word	0x0001c16f

0000f0b4 <thingy91_board_init>:
#endif
	return 0;
}

static int thingy91_board_init(struct device *dev)
{
    f0b4:	b530      	push	{r4, r5, lr}
    f0b6:	b0a3      	sub	sp, #140	; 0x8c
	return z_impl_zsock_socket(family, type, proto);
    f0b8:	f240 2201 	movw	r2, #513	; 0x201
    f0bc:	2102      	movs	r1, #2
    f0be:	2066      	movs	r0, #102	; 0x66
    f0c0:	f7fe fb96 	bl	d7f0 <z_impl_zsock_socket>
	if (at_socket_fd == -1) {
    f0c4:	1c43      	adds	r3, r0, #1
    f0c6:	4604      	mov	r4, r0
    f0c8:	d104      	bne.n	f0d4 <thingy91_board_init+0x20>
		return -EFAULT;
    f0ca:	f06f 050d 	mvn.w	r5, #13
		LOG_ERR("thingy91_magpio_configure failed with error: %d", err);
		return err;
	}

	return 0;
}
    f0ce:	4628      	mov	r0, r5
    f0d0:	b023      	add	sp, #140	; 0x8c
    f0d2:	bd30      	pop	{r4, r5, pc}
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
    f0d4:	2500      	movs	r5, #0
    f0d6:	2210      	movs	r2, #16
    f0d8:	462b      	mov	r3, r5
    f0da:	e9cd 5500 	strd	r5, r5, [sp]
    f0de:	4923      	ldr	r1, [pc, #140]	; (f16c <thingy91_board_init+0xb8>)
    f0e0:	f00c fd60 	bl	1bba4 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_TRACE)) {
    f0e4:	2810      	cmp	r0, #16
    f0e6:	d005      	beq.n	f0f4 <thingy91_board_init+0x40>
		close(at_socket_fd);
    f0e8:	4620      	mov	r0, r4
    f0ea:	f00d f84f 	bl	1c18c <close>
		return -EIO;
    f0ee:	f06f 0504 	mvn.w	r5, #4
    f0f2:	e7ec      	b.n	f0ce <thingy91_board_init+0x1a>
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
    f0f4:	2280      	movs	r2, #128	; 0x80
    f0f6:	462b      	mov	r3, r5
    f0f8:	4620      	mov	r0, r4
    f0fa:	e9cd 5500 	strd	r5, r5, [sp]
    f0fe:	a902      	add	r1, sp, #8
    f100:	f00c fd69 	bl	1bbd6 <z_impl_zsock_recvfrom>
	if ((buffer < 2) ||
    f104:	2801      	cmp	r0, #1
    f106:	ddef      	ble.n	f0e8 <thingy91_board_init+0x34>
	    (memcmp("OK", read_buffer, 2 != 0))) {
    f108:	2201      	movs	r2, #1
    f10a:	4819      	ldr	r0, [pc, #100]	; (f170 <thingy91_board_init+0xbc>)
    f10c:	a902      	add	r1, sp, #8
    f10e:	f00c ff59 	bl	1bfc4 <memcmp>
	if ((buffer < 2) ||
    f112:	4605      	mov	r5, r0
    f114:	2800      	cmp	r0, #0
    f116:	d1e7      	bne.n	f0e8 <thingy91_board_init+0x34>
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
    f118:	225c      	movs	r2, #92	; 0x5c
    f11a:	4603      	mov	r3, r0
    f11c:	e9cd 0000 	strd	r0, r0, [sp]
    f120:	4914      	ldr	r1, [pc, #80]	; (f174 <thingy91_board_init+0xc0>)
    f122:	4620      	mov	r0, r4
    f124:	f00c fd3e 	bl	1bba4 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_MAGPIO)) {
    f128:	285c      	cmp	r0, #92	; 0x5c
    f12a:	d1dd      	bne.n	f0e8 <thingy91_board_init+0x34>
    f12c:	2217      	movs	r2, #23
    f12e:	462b      	mov	r3, r5
    f130:	4620      	mov	r0, r4
    f132:	e9cd 5500 	strd	r5, r5, [sp]
    f136:	4910      	ldr	r1, [pc, #64]	; (f178 <thingy91_board_init+0xc4>)
    f138:	f00c fd34 	bl	1bba4 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_COEX0)) {
    f13c:	2817      	cmp	r0, #23
    f13e:	d1d3      	bne.n	f0e8 <thingy91_board_init+0x34>
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
    f140:	2280      	movs	r2, #128	; 0x80
    f142:	462b      	mov	r3, r5
    f144:	4620      	mov	r0, r4
    f146:	e9cd 5500 	strd	r5, r5, [sp]
    f14a:	a902      	add	r1, sp, #8
    f14c:	f00c fd43 	bl	1bbd6 <z_impl_zsock_recvfrom>
	if ((buffer < 2) ||
    f150:	2801      	cmp	r0, #1
    f152:	ddc9      	ble.n	f0e8 <thingy91_board_init+0x34>
	    (memcmp("OK", read_buffer, 2 != 0))) {
    f154:	2201      	movs	r2, #1
    f156:	4806      	ldr	r0, [pc, #24]	; (f170 <thingy91_board_init+0xbc>)
    f158:	a902      	add	r1, sp, #8
    f15a:	f00c ff33 	bl	1bfc4 <memcmp>
	if ((buffer < 2) ||
    f15e:	4605      	mov	r5, r0
    f160:	2800      	cmp	r0, #0
    f162:	d1c1      	bne.n	f0e8 <thingy91_board_init+0x34>
	close(at_socket_fd);
    f164:	4620      	mov	r0, r4
    f166:	f00d f811 	bl	1c18c <close>
	if (err) {
    f16a:	e7b0      	b.n	f0ce <thingy91_board_init+0x1a>
    f16c:	0001e48b 	.word	0x0001e48b
    f170:	0001e49c 	.word	0x0001e49c
    f174:	0001e49f 	.word	0x0001e49f
    f178:	0001e4fc 	.word	0x0001e4fc

0000f17c <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
    f17c:	b538      	push	{r3, r4, r5, lr}

	NET_DBG("");

	net_tc_tx_init();

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
    f17e:	4c07      	ldr	r4, [pc, #28]	; (f19c <net_if_init+0x20>)
    f180:	4d07      	ldr	r5, [pc, #28]	; (f1a0 <net_if_init+0x24>)
    f182:	42ac      	cmp	r4, r5
    f184:	d100      	bne.n	f188 <net_if_init+0xc>
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
    f186:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @return a pointer to the device driver instance
 */
static inline struct device *net_if_get_device(struct net_if *iface)
{
	return iface->if_dev->dev;
    f188:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
    f18a:	681b      	ldr	r3, [r3, #0]
    f18c:	689b      	ldr	r3, [r3, #8]
	if (!api || !api->init) {
    f18e:	b11b      	cbz	r3, f198 <net_if_init+0x1c>
    f190:	681b      	ldr	r3, [r3, #0]
    f192:	b10b      	cbz	r3, f198 <net_if_init+0x1c>
	api->init(iface);
    f194:	4620      	mov	r0, r4
    f196:	4798      	blx	r3
	     iface++, if_count++) {
    f198:	3420      	adds	r4, #32
    f19a:	e7f2      	b.n	f182 <net_if_init+0x6>
    f19c:	20020240 	.word	0x20020240
    f1a0:	20020260 	.word	0x20020260

0000f1a4 <net_if_post_init>:

void net_if_post_init(void)
{
    f1a4:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f1a6:	4c08      	ldr	r4, [pc, #32]	; (f1c8 <net_if_post_init+0x24>)
    f1a8:	4d08      	ldr	r5, [pc, #32]	; (f1cc <net_if_post_init+0x28>)
    f1aa:	42ac      	cmp	r4, r5
    f1ac:	d100      	bne.n	f1b0 <net_if_post_init+0xc>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
    f1ae:	bd38      	pop	{r3, r4, r5, pc}
 * @return Value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_get(const atomic_t *target)
{
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    f1b0:	6823      	ldr	r3, [r4, #0]
    f1b2:	330c      	adds	r3, #12
    f1b4:	e8d3 3faf 	lda	r3, [r3]
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
    f1b8:	071b      	lsls	r3, r3, #28
    f1ba:	d402      	bmi.n	f1c2 <net_if_post_init+0x1e>
			net_if_up(iface);
    f1bc:	4620      	mov	r0, r4
    f1be:	f00d f802 	bl	1c1c6 <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
    f1c2:	3420      	adds	r4, #32
    f1c4:	e7f1      	b.n	f1aa <net_if_post_init+0x6>
    f1c6:	bf00      	nop
    f1c8:	20020240 	.word	0x20020240
    f1cc:	20020260 	.word	0x20020260

0000f1d0 <z_impl_net_addr_ntop>:
	struct in6_addr *addr6;
	u16_t *w;
	u8_t i, bl, bh, longest = 1U;
	s8_t pos = -1;
	char delim = ':';
	unsigned char zeros[8] = { 0 };
    f1d0:	2300      	movs	r3, #0
{
    f1d2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char *ptr = dst;
	int len = -1;
	u16_t value;
	bool needcolon = false;

	if (family == AF_INET6) {
    f1d6:	2802      	cmp	r0, #2
{
    f1d8:	b089      	sub	sp, #36	; 0x24
    f1da:	4607      	mov	r7, r0
    f1dc:	4616      	mov	r6, r2
	unsigned char zeros[8] = { 0 };
    f1de:	e9cd 3306 	strd	r3, r3, [sp, #24]
{
    f1e2:	9104      	str	r1, [sp, #16]
	if (family == AF_INET6) {
    f1e4:	d13e      	bne.n	f264 <z_impl_net_addr_ntop+0x94>
		addr6 = (struct in6_addr *)src;
		w = (u16_t *)addr6->s6_addr16;
    f1e6:	a806      	add	r0, sp, #24
    f1e8:	9105      	str	r1, [sp, #20]
    f1ea:	4601      	mov	r1, r0
{
    f1ec:	461a      	mov	r2, r3
    f1ee:	e006      	b.n	f1fe <z_impl_net_addr_ntop+0x2e>
			for (j = i; j < 8; j++) {
				if (UNALIGNED_GET(&w[j]) != 0) {
					break;
				}

				zeros[i]++;
    f1f0:	780c      	ldrb	r4, [r1, #0]
    f1f2:	3201      	adds	r2, #1
    f1f4:	3401      	adds	r4, #1
    f1f6:	700c      	strb	r4, [r1, #0]
			for (j = i; j < 8; j++) {
    f1f8:	b2d4      	uxtb	r4, r2
    f1fa:	2c07      	cmp	r4, #7
    f1fc:	d804      	bhi.n	f208 <z_impl_net_addr_ntop+0x38>
				if (UNALIGNED_GET(&w[j]) != 0) {
    f1fe:	9c04      	ldr	r4, [sp, #16]
    f200:	f834 4012 	ldrh.w	r4, [r4, r2, lsl #1]
    f204:	2c00      	cmp	r4, #0
    f206:	d0f3      	beq.n	f1f0 <z_impl_net_addr_ntop+0x20>
		for (i = 0U; i < 8; i++) {
    f208:	3301      	adds	r3, #1
    f20a:	2b08      	cmp	r3, #8
    f20c:	f101 0101 	add.w	r1, r1, #1
    f210:	d1ec      	bne.n	f1ec <z_impl_net_addr_ntop+0x1c>
	s8_t pos = -1;
    f212:	f04f 38ff 	mov.w	r8, #4294967295
	u8_t i, bl, bh, longest = 1U;
    f216:	f04f 0901 	mov.w	r9, #1
			}
		}

		for (i = 0U; i < 8; i++) {
    f21a:	2300      	movs	r3, #0
			if (zeros[i] > longest) {
    f21c:	f810 2b01 	ldrb.w	r2, [r0], #1
    f220:	454a      	cmp	r2, r9
				longest = zeros[i];
				pos = i;
    f222:	bf88      	it	hi
    f224:	fa4f f883 	sxtbhi.w	r8, r3
		for (i = 0U; i < 8; i++) {
    f228:	f103 0301 	add.w	r3, r3, #1
    f22c:	b2db      	uxtb	r3, r3
				pos = i;
    f22e:	bf88      	it	hi
    f230:	4691      	movhi	r9, r2
		for (i = 0U; i < 8; i++) {
    f232:	2b08      	cmp	r3, #8
    f234:	d1f2      	bne.n	f21c <z_impl_net_addr_ntop+0x4c>
		len = 8;
    f236:	469b      	mov	fp, r3
    f238:	f1b9 0f01 	cmp.w	r9, #1
    f23c:	f04f 033a 	mov.w	r3, #58	; 0x3a
    f240:	bf08      	it	eq
    f242:	f04f 38ff 	moveq.w	r8, #4294967295
    f246:	9303      	str	r3, [sp, #12]
	bool needcolon = false;
    f248:	2100      	movs	r1, #0
		delim = '.';
	} else {
		return NULL;
	}

	for (i = 0U; i < len; i++) {
    f24a:	4634      	mov	r4, r6
    f24c:	460d      	mov	r5, r1
    f24e:	455d      	cmp	r5, fp
    f250:	db17      	blt.n	f282 <z_impl_net_addr_ntop+0xb2>
		}

		needcolon = true;
	}

	if (!(ptr - dst)) {
    f252:	42b4      	cmp	r4, r6
    f254:	d008      	beq.n	f268 <z_impl_net_addr_ntop+0x98>
		return NULL;
	}

	if (family == AF_INET) {
    f256:	2300      	movs	r3, #0
    f258:	2f01      	cmp	r7, #1
		*(ptr - 1) = '\0';
    f25a:	bf0c      	ite	eq
    f25c:	f804 3c01 	strbeq.w	r3, [r4, #-1]
	} else {
		*ptr = '\0';
    f260:	7023      	strbne	r3, [r4, #0]
    f262:	e002      	b.n	f26a <z_impl_net_addr_ntop+0x9a>
	} else if (family == AF_INET) {
    f264:	2801      	cmp	r0, #1
    f266:	d004      	beq.n	f272 <z_impl_net_addr_ntop+0xa2>
		return NULL;
    f268:	2600      	movs	r6, #0
	}

	return dst;
}
    f26a:	4630      	mov	r0, r6
    f26c:	b009      	add	sp, #36	; 0x24
    f26e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		delim = '.';
    f272:	232e      	movs	r3, #46	; 0x2e
		len = 4;
    f274:	f04f 0b04 	mov.w	fp, #4
	s8_t pos = -1;
    f278:	f04f 38ff 	mov.w	r8, #4294967295
	u8_t i, bl, bh, longest = 1U;
    f27c:	4681      	mov	r9, r0
		delim = '.';
    f27e:	9303      	str	r3, [sp, #12]
    f280:	e7e2      	b.n	f248 <z_impl_net_addr_ntop+0x78>
		if (len == 4) {
    f282:	f1bb 0f04 	cmp.w	fp, #4
    f286:	d13b      	bne.n	f300 <z_impl_net_addr_ntop+0x130>
			value = (u32_t)addr->s4_addr[i];
    f288:	9b04      	ldr	r3, [sp, #16]
    f28a:	5d5a      	ldrb	r2, [r3, r5]
			if (value == 0U) {
    f28c:	b94a      	cbnz	r2, f2a2 <z_impl_net_addr_ntop+0xd2>
				*ptr++ = '0';
    f28e:	2330      	movs	r3, #48	; 0x30
    f290:	4620      	mov	r0, r4
    f292:	f800 3b02 	strb.w	r3, [r0], #2
				*ptr++ = delim;
    f296:	9b03      	ldr	r3, [sp, #12]
    f298:	7063      	strb	r3, [r4, #1]
	for (i = 0U; i < len; i++) {
    f29a:	3501      	adds	r5, #1
    f29c:	4604      	mov	r4, r0
    f29e:	b2ed      	uxtb	r5, r5
    f2a0:	e7d5      	b.n	f24e <z_impl_net_addr_ntop+0x7e>
			l = net_value_to_udec(ptr, value, 0);
    f2a2:	f04f 0e09 	mov.w	lr, #9
    f2a6:	f04f 0a00 	mov.w	sl, #0
    f2aa:	e9cd 2401 	strd	r2, r4, [sp, #4]
    f2ae:	483a      	ldr	r0, [pc, #232]	; (f398 <z_impl_net_addr_ntop+0x1c8>)
		value = value % divisor;
    f2b0:	f8dd c004 	ldr.w	ip, [sp, #4]
		if ((precision > i) || (temp != 0)) {
    f2b4:	45f2      	cmp	sl, lr
		value = value % divisor;
    f2b6:	fbbc f2f0 	udiv	r2, ip, r0
    f2ba:	fb00 c212 	mls	r2, r0, r2, ip
    f2be:	9201      	str	r2, [sp, #4]
		if ((precision > i) || (temp != 0)) {
    f2c0:	dc01      	bgt.n	f2c6 <z_impl_net_addr_ntop+0xf6>
    f2c2:	4584      	cmp	ip, r0
    f2c4:	d308      	bcc.n	f2d8 <z_impl_net_addr_ntop+0x108>
		temp = value / divisor;
    f2c6:	fbbc fcf0 	udiv	ip, ip, r0
			*buf++ = (char) (temp + '0');
    f2ca:	46f2      	mov	sl, lr
    f2cc:	9b02      	ldr	r3, [sp, #8]
    f2ce:	f10c 0c30 	add.w	ip, ip, #48	; 0x30
    f2d2:	f803 cb01 	strb.w	ip, [r3], #1
    f2d6:	9302      	str	r3, [sp, #8]
	for (i = 9; i >= 0; i--, divisor /= 10U) {
    f2d8:	220a      	movs	r2, #10
    f2da:	f10e 3eff 	add.w	lr, lr, #4294967295
    f2de:	f1be 3fff 	cmp.w	lr, #4294967295
    f2e2:	fbb0 f0f2 	udiv	r0, r0, r2
    f2e6:	d1e3      	bne.n	f2b0 <z_impl_net_addr_ntop+0xe0>
	*buf = 0;
    f2e8:	f04f 0200 	mov.w	r2, #0
    f2ec:	9b02      	ldr	r3, [sp, #8]
    f2ee:	701a      	strb	r2, [r3, #0]
	return buf - start;
    f2f0:	1b1b      	subs	r3, r3, r4
			ptr += l;
    f2f2:	b2da      	uxtb	r2, r3
    f2f4:	fa54 f383 	uxtab	r3, r4, r3
			*ptr++ = delim;
    f2f8:	1c58      	adds	r0, r3, #1
    f2fa:	9b03      	ldr	r3, [sp, #12]
    f2fc:	54a3      	strb	r3, [r4, r2]
			continue;
    f2fe:	e7cc      	b.n	f29a <z_impl_net_addr_ntop+0xca>
		if (i == pos) {
    f300:	45a8      	cmp	r8, r5
    f302:	d110      	bne.n	f326 <z_impl_net_addr_ntop+0x156>
			if (needcolon || i == 0U) {
    f304:	b911      	cbnz	r1, f30c <z_impl_net_addr_ntop+0x13c>
    f306:	f1b8 0f00 	cmp.w	r8, #0
    f30a:	d102      	bne.n	f312 <z_impl_net_addr_ntop+0x142>
				*ptr++ = ':';
    f30c:	233a      	movs	r3, #58	; 0x3a
    f30e:	f804 3b01 	strb.w	r3, [r4], #1
			*ptr++ = ':';
    f312:	233a      	movs	r3, #58	; 0x3a
    f314:	4620      	mov	r0, r4
    f316:	f800 3b01 	strb.w	r3, [r0], #1
			i += longest - 1U;
    f31a:	f109 33ff 	add.w	r3, r9, #4294967295
    f31e:	441d      	add	r5, r3
			needcolon = false;
    f320:	2100      	movs	r1, #0
			i += longest - 1U;
    f322:	b2ed      	uxtb	r5, r5
			continue;
    f324:	e7b9      	b.n	f29a <z_impl_net_addr_ntop+0xca>
		if (needcolon) {
    f326:	b111      	cbz	r1, f32e <z_impl_net_addr_ntop+0x15e>
			*ptr++ = ':';
    f328:	233a      	movs	r3, #58	; 0x3a
    f32a:	f804 3b01 	strb.w	r3, [r4], #1
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
    f32e:	9b05      	ldr	r3, [sp, #20]
    f330:	f833 3015 	ldrh.w	r3, [r3, r5, lsl #1]
    f334:	0219      	lsls	r1, r3, #8
    f336:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
		if (bh) {
    f33a:	f411 4f7f 	tst.w	r1, #65280	; 0xff00
		value = (u32_t)sys_be16_to_cpu(UNALIGNED_GET(&w[i]));
    f33e:	b20a      	sxth	r2, r1
		bh = value >> 8;
    f340:	f3c1 2307 	ubfx	r3, r1, #8, #8
		bl = value & 0xff;
    f344:	fa5f fa81 	uxtb.w	sl, r1
		if (bh) {
    f348:	d016      	beq.n	f378 <z_impl_net_addr_ntop+0x1a8>
			if (bh > 0x0f) {
    f34a:	2b0f      	cmp	r3, #15
		bh = value >> 8;
    f34c:	b2d9      	uxtb	r1, r3
			if (bh > 0x0f) {
    f34e:	d90b      	bls.n	f368 <z_impl_net_addr_ntop+0x198>
				ptr = net_byte_to_hex(ptr, bh, 'a', false);
    f350:	2300      	movs	r3, #0
    f352:	2261      	movs	r2, #97	; 0x61
    f354:	4620      	mov	r0, r4
    f356:	f00c ff67 	bl	1c228 <net_byte_to_hex>
			ptr = net_byte_to_hex(ptr, bl, 'a', true);
    f35a:	2301      	movs	r3, #1
    f35c:	2261      	movs	r2, #97	; 0x61
    f35e:	4651      	mov	r1, sl
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
    f360:	f00c ff62 	bl	1c228 <net_byte_to_hex>
		needcolon = true;
    f364:	2101      	movs	r1, #1
    f366:	e798      	b.n	f29a <z_impl_net_addr_ntop+0xca>
				if (bh < 10) {
    f368:	b25b      	sxtb	r3, r3
    f36a:	2909      	cmp	r1, #9
					*ptr++ = (char)(bh + '0');
    f36c:	bf94      	ite	ls
    f36e:	3330      	addls	r3, #48	; 0x30
					*ptr++ = (char) (bh - 10 + 'a');
    f370:	3357      	addhi	r3, #87	; 0x57
    f372:	1c60      	adds	r0, r4, #1
    f374:	7023      	strb	r3, [r4, #0]
    f376:	e7f0      	b.n	f35a <z_impl_net_addr_ntop+0x18a>
		} else if (bl > 0x0f) {
    f378:	f1ba 0f0f 	cmp.w	sl, #15
    f37c:	d903      	bls.n	f386 <z_impl_net_addr_ntop+0x1b6>
			ptr = net_byte_to_hex(ptr, bl, 'a', false);
    f37e:	2261      	movs	r2, #97	; 0x61
    f380:	4651      	mov	r1, sl
    f382:	4620      	mov	r0, r4
    f384:	e7ec      	b.n	f360 <z_impl_net_addr_ntop+0x190>
			if (bl < 10) {
    f386:	b253      	sxtb	r3, r2
    f388:	f1ba 0f09 	cmp.w	sl, #9
				*ptr++ = (char)(bl + '0');
    f38c:	bf94      	ite	ls
    f38e:	3330      	addls	r3, #48	; 0x30
				*ptr++ = (char) (bl - 10 + 'a');
    f390:	3357      	addhi	r3, #87	; 0x57
    f392:	1c60      	adds	r0, r4, #1
    f394:	7023      	strb	r3, [r4, #0]
    f396:	e7e5      	b.n	f364 <z_impl_net_addr_ntop+0x194>
    f398:	3b9aca00 	.word	0x3b9aca00

0000f39c <sys_rand32_get>:

static struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
u32_t sys_rand32_get(void)
{
    f39c:	b513      	push	{r0, r1, r4, lr}
	struct device *dev = entropy_driver;
    f39e:	4c0a      	ldr	r4, [pc, #40]	; (f3c8 <sys_rand32_get+0x2c>)
    f3a0:	6820      	ldr	r0, [r4, #0]
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
    f3a2:	b918      	cbnz	r0, f3ac <sys_rand32_get+0x10>
    f3a4:	4809      	ldr	r0, [pc, #36]	; (f3cc <sys_rand32_get+0x30>)
    f3a6:	f00a fce3 	bl	19d70 <z_impl_device_get_binding>
		dev = device_get_binding(DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		__ASSERT((dev != NULL),
			"Device driver for %s (DT_CHOSEN_ZEPHYR_ENTROPY_LABEL) not found. "
			"Check your build configuration!",
			DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		entropy_driver = dev;
    f3aa:	6020      	str	r0, [r4, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
    f3ac:	2204      	movs	r2, #4
    f3ae:	6883      	ldr	r3, [r0, #8]
    f3b0:	eb0d 0102 	add.w	r1, sp, r2
    f3b4:	681b      	ldr	r3, [r3, #0]
    f3b6:	4798      	blx	r3
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
    f3b8:	2800      	cmp	r0, #0
    f3ba:	da02      	bge.n	f3c2 <sys_rand32_get+0x26>
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
    f3bc:	f7fe fd0a 	bl	ddd4 <z_timer_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
    f3c0:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
    f3c2:	9801      	ldr	r0, [sp, #4]
    f3c4:	b002      	add	sp, #8
    f3c6:	bd10      	pop	{r4, pc}
    f3c8:	200202ec 	.word	0x200202ec
    f3cc:	0001e514 	.word	0x0001e514

0000f3d0 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
    f3d0:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    f3d2:	4b09      	ldr	r3, [pc, #36]	; (f3f8 <gpio_nrfx_init+0x28>)
    f3d4:	781a      	ldrb	r2, [r3, #0]
    f3d6:	b96a      	cbnz	r2, f3f4 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    f3d8:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    f3da:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
    f3dc:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    f3de:	2105      	movs	r1, #5
    f3e0:	f7fe fd3c 	bl	de5c <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
    f3e4:	2031      	movs	r0, #49	; 0x31
    f3e6:	f7fe fd29 	bl	de3c <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    f3ea:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    f3ee:	4b03      	ldr	r3, [pc, #12]	; (f3fc <gpio_nrfx_init+0x2c>)
    f3f0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    f3f4:	2000      	movs	r0, #0
    f3f6:	bd08      	pop	{r3, pc}
    f3f8:	2002259f 	.word	0x2002259f
    f3fc:	40031000 	.word	0x40031000

0000f400 <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    f400:	4b29      	ldr	r3, [pc, #164]	; (f4a8 <gpio_nrfx_config+0xa8>)
{
    f402:	b5f0      	push	{r4, r5, r6, r7, lr}
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f404:	6846      	ldr	r6, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    f406:	4829      	ldr	r0, [pc, #164]	; (f4ac <gpio_nrfx_config+0xac>)
    f408:	4013      	ands	r3, r2
    f40a:	4283      	cmp	r3, r0
    f40c:	d03d      	beq.n	f48a <gpio_nrfx_config+0x8a>
    f40e:	d80d      	bhi.n	f42c <gpio_nrfx_config+0x2c>
    f410:	2b06      	cmp	r3, #6
    f412:	d015      	beq.n	f440 <gpio_nrfx_config+0x40>
    f414:	d805      	bhi.n	f422 <gpio_nrfx_config+0x22>
    f416:	b19b      	cbz	r3, f440 <gpio_nrfx_config+0x40>
    f418:	2b02      	cmp	r3, #2
    f41a:	d038      	beq.n	f48e <gpio_nrfx_config+0x8e>
    f41c:	f06f 0015 	mvn.w	r0, #21
    f420:	e032      	b.n	f488 <gpio_nrfx_config+0x88>
    f422:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    f426:	d1f9      	bne.n	f41c <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_H0S1;
    f428:	2301      	movs	r3, #1
    f42a:	e009      	b.n	f440 <gpio_nrfx_config+0x40>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    f42c:	4820      	ldr	r0, [pc, #128]	; (f4b0 <gpio_nrfx_config+0xb0>)
    f42e:	4283      	cmp	r3, r0
    f430:	d02f      	beq.n	f492 <gpio_nrfx_config+0x92>
    f432:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    f436:	d02e      	beq.n	f496 <gpio_nrfx_config+0x96>
    f438:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    f43c:	d1ee      	bne.n	f41c <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_S0H1;
    f43e:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
    f440:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_PULLUP;
    f442:	bf4c      	ite	mi
    f444:	2503      	movmi	r5, #3
		pull = NRF_GPIO_PIN_NOPULL;
    f446:	f3c2 1540 	ubfxpl	r5, r2, #5, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    f44a:	f482 7480 	eor.w	r4, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
    f44e:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
    f450:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    f454:	f3c4 2400 	ubfx	r4, r4, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
    f458:	d506      	bpl.n	f468 <gpio_nrfx_config+0x68>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    f45a:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    f45e:	6877      	ldr	r7, [r6, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    f460:	d01b      	beq.n	f49a <gpio_nrfx_config+0x9a>
			nrf_gpio_port_out_set(reg, BIT(pin));
    f462:	2201      	movs	r2, #1
    f464:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    f466:	60ba      	str	r2, [r7, #8]
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
    f468:	7a32      	ldrb	r2, [r6, #8]
    f46a:	f001 011f 	and.w	r1, r1, #31
    f46e:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    f472:	ea40 0244 	orr.w	r2, r0, r4, lsl #1
	return 0;
    f476:	2000      	movs	r0, #0
    f478:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    f47c:	4a0d      	ldr	r2, [pc, #52]	; (f4b4 <gpio_nrfx_config+0xb4>)
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    f47e:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    f482:	3180      	adds	r1, #128	; 0x80
    f484:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
    f488:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
    f48a:	2307      	movs	r3, #7
    f48c:	e7d8      	b.n	f440 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0S1;
    f48e:	2304      	movs	r3, #4
    f490:	e7d6      	b.n	f440 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0H1;
    f492:	2305      	movs	r3, #5
    f494:	e7d4      	b.n	f440 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_H0H1;
    f496:	2303      	movs	r3, #3
    f498:	e7d2      	b.n	f440 <gpio_nrfx_config+0x40>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    f49a:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
    f49c:	bf42      	ittt	mi
    f49e:	2201      	movmi	r2, #1
    f4a0:	408a      	lslmi	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
    f4a2:	60fa      	strmi	r2, [r7, #12]
}
    f4a4:	e7e0      	b.n	f468 <gpio_nrfx_config+0x68>
    f4a6:	bf00      	nop
    f4a8:	00f00006 	.word	0x00f00006
    f4ac:	00100006 	.word	0x00100006
    f4b0:	00400002 	.word	0x00400002
    f4b4:	40842500 	.word	0x40842500

0000f4b8 <gpiote_pin_int_cfg>:
{
    f4b8:	b570      	push	{r4, r5, r6, lr}
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    f4ba:	6843      	ldr	r3, [r0, #4]
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    f4bc:	4c4c      	ldr	r4, [pc, #304]	; (f5f0 <gpiote_pin_int_cfg+0x138>)
    f4be:	7a1a      	ldrb	r2, [r3, #8]
    f4c0:	f001 031f 	and.w	r3, r1, #31
    f4c4:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    f4c8:	2200      	movs	r2, #0
	struct gpio_nrfx_data *data = get_port_data(port);
    f4ca:	68c6      	ldr	r6, [r0, #12]
    f4cc:	f8d4 0304 	ldr.w	r0, [r4, #772]	; 0x304
    f4d0:	b2c0      	uxtb	r0, r0
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    f4d2:	f502 75a2 	add.w	r5, r2, #324	; 0x144
    f4d6:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
    f4da:	f3c5 2504 	ubfx	r5, r5, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    f4de:	42ab      	cmp	r3, r5
    f4e0:	d16c      	bne.n	f5bc <gpiote_pin_int_cfg+0x104>
		    && (intenset & BIT(i))) {
    f4e2:	fa20 f502 	lsr.w	r5, r0, r2
    f4e6:	07ed      	lsls	r5, r5, #31
    f4e8:	d568      	bpl.n	f5bc <gpiote_pin_int_cfg+0x104>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    f4ea:	0090      	lsls	r0, r2, #2
    f4ec:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    f4f0:	f500 3044 	add.w	r0, r0, #200704	; 0x31000
    f4f4:	f8d0 5510 	ldr.w	r5, [r0, #1296]	; 0x510
    f4f8:	f025 0501 	bic.w	r5, r5, #1
    f4fc:	f8c0 5510 	str.w	r5, [r0, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    f500:	2001      	movs	r0, #1
    f502:	fa00 f202 	lsl.w	r2, r0, r2
    p_reg->INTENCLR = mask;
    f506:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    f50a:	4d3a      	ldr	r5, [pc, #232]	; (f5f4 <gpiote_pin_int_cfg+0x13c>)
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
    f50c:	68f0      	ldr	r0, [r6, #12]
    f50e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    f512:	f8d5 2200 	ldr.w	r2, [r5, #512]	; 0x200
    f516:	40c8      	lsrs	r0, r1
    f518:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    f51c:	f010 0001 	ands.w	r0, r0, #1
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    f520:	f8c5 2200 	str.w	r2, [r5, #512]	; 0x200
    f524:	d049      	beq.n	f5ba <gpiote_pin_int_cfg+0x102>
    f526:	6930      	ldr	r0, [r6, #16]
    f528:	40c8      	lsrs	r0, r1
    f52a:	f010 0001 	ands.w	r0, r0, #1
    f52e:	d044      	beq.n	f5ba <gpiote_pin_int_cfg+0x102>
		if (data->trig_edge & BIT(pin)) {
    f530:	69b0      	ldr	r0, [r6, #24]
    f532:	40c8      	lsrs	r0, r1
    f534:	f010 0001 	ands.w	r0, r0, #1
    f538:	d04a      	beq.n	f5d0 <gpiote_pin_int_cfg+0x118>
			if (data->double_edge & BIT(pin)) {
    f53a:	69f2      	ldr	r2, [r6, #28]
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    f53c:	2500      	movs	r5, #0
			if (data->double_edge & BIT(pin)) {
    f53e:	40ca      	lsrs	r2, r1
    f540:	07d2      	lsls	r2, r2, #31
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    f542:	bf4f      	iteee	mi
    f544:	2203      	movmi	r2, #3
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    f546:	6972      	ldrpl	r2, [r6, #20]
    f548:	40ca      	lsrpl	r2, r1
    f54a:	f002 0201 	andpl.w	r2, r2, #1
    f54e:	bf5c      	itt	pl
    f550:	f1c2 0202 	rsbpl	r2, r2, #2
    f554:	b2d2      	uxtbpl	r2, r2
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
    f556:	f505 71a2 	add.w	r1, r5, #324	; 0x144
    f55a:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
    f55e:	f010 0003 	ands.w	r0, r0, #3
    f562:	d12f      	bne.n	f5c4 <gpiote_pin_int_cfg+0x10c>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    f564:	00a9      	lsls	r1, r5, #2
    f566:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
    f56a:	f501 3144 	add.w	r1, r1, #200704	; 0x31000
    f56e:	f8d1 6510 	ldr.w	r6, [r1, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    f572:	021b      	lsls	r3, r3, #8
    f574:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    f578:	f426 3647 	bic.w	r6, r6, #203776	; 0x31c00
    f57c:	f426 7640 	bic.w	r6, r6, #768	; 0x300
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    f580:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
			nrf_gpiote_event_t evt =
    f584:	f105 0340 	add.w	r3, r5, #64	; 0x40
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    f588:	f8c1 6510 	str.w	r6, [r1, #1296]	; 0x510
    f58c:	009b      	lsls	r3, r3, #2
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    f58e:	f8d1 6510 	ldr.w	r6, [r1, #1296]	; 0x510
    return ((uint32_t)p_reg + event);
    f592:	b29b      	uxth	r3, r3
    f594:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    f598:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    f59c:	4332      	orrs	r2, r6
    f59e:	f8c1 2510 	str.w	r2, [r1, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    f5a2:	6018      	str	r0, [r3, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    f5a4:	f8d1 3510 	ldr.w	r3, [r1, #1296]	; 0x510
    f5a8:	f043 0301 	orr.w	r3, r3, #1
    f5ac:	f8c1 3510 	str.w	r3, [r1, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    f5b0:	2301      	movs	r3, #1
    f5b2:	fa03 f505 	lsl.w	r5, r3, r5
    p_reg->INTENSET = mask;
    f5b6:	f8c4 5304 	str.w	r5, [r4, #772]	; 0x304
}
    f5ba:	bd70      	pop	{r4, r5, r6, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    f5bc:	3201      	adds	r2, #1
    f5be:	2a08      	cmp	r2, #8
    f5c0:	d187      	bne.n	f4d2 <gpiote_pin_int_cfg+0x1a>
    f5c2:	e7a2      	b.n	f50a <gpiote_pin_int_cfg+0x52>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
    f5c4:	3501      	adds	r5, #1
    f5c6:	2d08      	cmp	r5, #8
    f5c8:	d1c5      	bne.n	f556 <gpiote_pin_int_cfg+0x9e>
	return -ENODEV;
    f5ca:	f06f 0012 	mvn.w	r0, #18
    f5ce:	e7f4      	b.n	f5ba <gpiote_pin_int_cfg+0x102>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    f5d0:	6972      	ldr	r2, [r6, #20]
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    f5d2:	f8d5 3200 	ldr.w	r3, [r5, #512]	; 0x200
    f5d6:	40ca      	lsrs	r2, r1
    f5d8:	f002 0201 	and.w	r2, r2, #1
    f5dc:	f1c2 0203 	rsb	r2, r2, #3
    f5e0:	f423 3140 	bic.w	r1, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    f5e4:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
    f5e8:	f8c5 2200 	str.w	r2, [r5, #512]	; 0x200
}
    f5ec:	e7e5      	b.n	f5ba <gpiote_pin_int_cfg+0x102>
    f5ee:	bf00      	nop
    f5f0:	40031000 	.word	0x40031000
    f5f4:	40842500 	.word	0x40842500

0000f5f8 <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
    f5f8:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
    f5fc:	b470      	push	{r4, r5, r6}
	struct gpio_nrfx_data *data = get_port_data(port);
    f5fe:	68c4      	ldr	r4, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    f600:	d10f      	bne.n	f622 <gpio_nrfx_pin_interrupt_configure+0x2a>
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    f602:	6845      	ldr	r5, [r0, #4]
    f604:	7a2e      	ldrb	r6, [r5, #8]
    f606:	f001 051f 	and.w	r5, r1, #31
    f60a:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    f60e:	4e1d      	ldr	r6, [pc, #116]	; (f684 <gpio_nrfx_pin_interrupt_configure+0x8c>)
    f610:	3580      	adds	r5, #128	; 0x80
    f612:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    f616:	07ed      	lsls	r5, r5, #31
    f618:	d507      	bpl.n	f62a <gpio_nrfx_pin_interrupt_configure+0x32>
}
    f61a:	f06f 0022 	mvn.w	r0, #34	; 0x22
    f61e:	bc70      	pop	{r4, r5, r6}
    f620:	4770      	bx	lr
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    f622:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f626:	68e5      	ldr	r5, [r4, #12]
    f628:	d026      	beq.n	f678 <gpio_nrfx_pin_interrupt_configure+0x80>
    f62a:	2501      	movs	r5, #1
    f62c:	68e6      	ldr	r6, [r4, #12]
    f62e:	408d      	lsls	r5, r1
    f630:	4335      	orrs	r5, r6
    f632:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    f634:	2501      	movs	r5, #1
    f636:	6926      	ldr	r6, [r4, #16]
    f638:	408d      	lsls	r5, r1
    f63a:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    f63e:	bf14      	ite	ne
    f640:	432e      	orrne	r6, r5
    f642:	43ae      	biceq	r6, r5
    f644:	6126      	str	r6, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    f646:	69a6      	ldr	r6, [r4, #24]
    f648:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    f64c:	69e2      	ldr	r2, [r4, #28]
    f64e:	bf0c      	ite	eq
    f650:	432e      	orreq	r6, r5
    f652:	43ae      	bicne	r6, r5
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    f654:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    f658:	bf0c      	ite	eq
    f65a:	432a      	orreq	r2, r5
    f65c:	43aa      	bicne	r2, r5
    f65e:	61e2      	str	r2, [r4, #28]
    f660:	6962      	ldr	r2, [r4, #20]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    f662:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    f666:	bf0c      	ite	eq
    f668:	4315      	orreq	r5, r2
    f66a:	ea22 0505 	bicne.w	r5, r2, r5
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    f66e:	61a6      	str	r6, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    f670:	6165      	str	r5, [r4, #20]
}
    f672:	bc70      	pop	{r4, r5, r6}
	return gpiote_pin_int_cfg(port, pin);
    f674:	f7ff bf20 	b.w	f4b8 <gpiote_pin_int_cfg>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    f678:	2601      	movs	r6, #1
    f67a:	408e      	lsls	r6, r1
    f67c:	ea25 0506 	bic.w	r5, r5, r6
    f680:	e7d7      	b.n	f632 <gpio_nrfx_pin_interrupt_configure+0x3a>
    f682:	bf00      	nop
    f684:	40842500 	.word	0x40842500

0000f688 <gpiote_event_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f688:	494e      	ldr	r1, [pc, #312]	; (f7c4 <gpiote_event_handler+0x13c>)
{
    f68a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f68e:	680e      	ldr	r6, [r1, #0]
	if (port_event) {
    f690:	2e00      	cmp	r6, #0
    f692:	d05e      	beq.n	f752 <gpiote_event_handler+0xca>
	struct gpio_nrfx_data *data = get_port_data(port);
    f694:	4b4c      	ldr	r3, [pc, #304]	; (f7c8 <gpiote_event_handler+0x140>)
	u32_t pin = 0U;
    f696:	2500      	movs	r5, #0
	struct gpio_nrfx_data *data = get_port_data(port);
    f698:	68da      	ldr	r2, [r3, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
    f69a:	f8d3 c004 	ldr.w	ip, [r3, #4]
	u32_t out = data->int_en & data->pin_int_en;
    f69e:	e9d2 0303 	ldrd	r0, r3, [r2, #12]
    f6a2:	4003      	ands	r3, r0
	out &= ~data->trig_edge & ~data->double_edge;
    f6a4:	e9d2 0406 	ldrd	r0, r4, [r2, #24]
    f6a8:	4320      	orrs	r0, r4
    f6aa:	ea23 0300 	bic.w	r3, r3, r0
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
    f6ae:	f8dc 0004 	ldr.w	r0, [ip, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
    f6b2:	6952      	ldr	r2, [r2, #20]
    return p_reg->IN;
    f6b4:	6904      	ldr	r4, [r0, #16]
	u32_t bit = 1U << pin;
    f6b6:	2001      	movs	r0, #1
	u32_t pin_states = ~(port_in ^ data->int_active_level);
    f6b8:	4054      	eors	r4, r2
    f6ba:	f8df e118 	ldr.w	lr, [pc, #280]	; f7d4 <gpiote_event_handler+0x14c>
	u32_t out = pin_states & level_pins;
    f6be:	ea23 0404 	bic.w	r4, r3, r4
	while (level_pins) {
    f6c2:	bb8b      	cbnz	r3, f728 <gpiote_event_handler+0xa0>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    f6c4:	600b      	str	r3, [r1, #0]
	u32_t fired_triggers[GPIO_COUNT] = {0};
    f6c6:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    f6c8:	2001      	movs	r0, #1
    f6ca:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
    f6cc:	493f      	ldr	r1, [pc, #252]	; (f7cc <gpiote_event_handler+0x144>)
    f6ce:	4d40      	ldr	r5, [pc, #256]	; (f7d0 <gpiote_event_handler+0x148>)
    f6d0:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
    f6d4:	fa00 fc03 	lsl.w	ip, r0, r3
    f6d8:	ea1c 0f02 	tst.w	ip, r2
    f6dc:	d00d      	beq.n	f6fa <gpiote_event_handler+0x72>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    f6de:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
    f6e2:	b152      	cbz	r2, f6fa <gpiote_event_handler+0x72>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    f6e4:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    f6e8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    f6ec:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    f6f0:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    f6f4:	fa00 f202 	lsl.w	r2, r0, r2
    f6f8:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    f6fa:	3301      	adds	r3, #1
    f6fc:	2b08      	cmp	r3, #8
    f6fe:	d1e7      	bne.n	f6d0 <gpiote_event_handler+0x48>
	if (fired_triggers[0]) {
    f700:	bb4c      	cbnz	r4, f756 <gpiote_event_handler+0xce>
	if (port_event) {
    f702:	b17e      	cbz	r6, f724 <gpiote_event_handler+0x9c>
	u32_t bit = 1U << pin;
    f704:	2401      	movs	r4, #1
	u32_t pin = 0U;
    f706:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
    f708:	4b2f      	ldr	r3, [pc, #188]	; (f7c8 <gpiote_event_handler+0x140>)
    f70a:	4f32      	ldr	r7, [pc, #200]	; (f7d4 <gpiote_event_handler+0x14c>)
    f70c:	68d8      	ldr	r0, [r3, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
    f70e:	685e      	ldr	r6, [r3, #4]
	u32_t out = data->int_en & data->pin_int_en;
    f710:	e9d0 2303 	ldrd	r2, r3, [r0, #12]
    f714:	4013      	ands	r3, r2
	out &= ~data->trig_edge & ~data->double_edge;
    f716:	e9d0 2106 	ldrd	r2, r1, [r0, #24]
    f71a:	430a      	orrs	r2, r1
    f71c:	ea23 0302 	bic.w	r3, r3, r2
	while (level_pins) {
    f720:	2b00      	cmp	r3, #0
    f722:	d133      	bne.n	f78c <gpiote_event_handler+0x104>
}
    f724:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
    f728:	4203      	tst	r3, r0
    f72a:	d00f      	beq.n	f74c <gpiote_event_handler+0xc4>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    f72c:	f89c 7008 	ldrb.w	r7, [ip, #8]
    f730:	f005 021f 	and.w	r2, r5, #31
    f734:	ea42 1247 	orr.w	r2, r2, r7, lsl #5
    f738:	eb0e 0282 	add.w	r2, lr, r2, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    f73c:	f8d2 7200 	ldr.w	r7, [r2, #512]	; 0x200
			level_pins &= ~bit;
    f740:	ea23 0300 	bic.w	r3, r3, r0
    f744:	f427 3740 	bic.w	r7, r7, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    f748:	f8c2 7200 	str.w	r7, [r2, #512]	; 0x200
		++pin;
    f74c:	3501      	adds	r5, #1
		bit <<= 1;
    f74e:	0040      	lsls	r0, r0, #1
    f750:	e7b7      	b.n	f6c2 <gpiote_event_handler+0x3a>
	u32_t fired_triggers[GPIO_COUNT] = {0};
    f752:	4634      	mov	r4, r6
    f754:	e7b7      	b.n	f6c6 <gpiote_event_handler+0x3e>
	struct gpio_nrfx_data *data = get_port_data(port);
    f756:	481c      	ldr	r0, [pc, #112]	; (f7c8 <gpiote_event_handler+0x140>)
    f758:	68c7      	ldr	r7, [r0, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    f75a:	6879      	ldr	r1, [r7, #4]
    f75c:	2900      	cmp	r1, #0
    f75e:	d0d0      	beq.n	f702 <gpiote_event_handler+0x7a>
	return node->next;
    f760:	680d      	ldr	r5, [r1, #0]
			cb->handler(port, cb, cb->pin_mask & pins);
    f762:	4680      	mov	r8, r0
    f764:	2d00      	cmp	r5, #0
    f766:	bf38      	it	cc
    f768:	2500      	movcc	r5, #0
		if ((cb->pin_mask & pins) & data->int_en) {
    f76a:	688a      	ldr	r2, [r1, #8]
    f76c:	693b      	ldr	r3, [r7, #16]
    f76e:	4022      	ands	r2, r4
    f770:	421a      	tst	r2, r3
    f772:	d002      	beq.n	f77a <gpiote_event_handler+0xf2>
			cb->handler(port, cb, cb->pin_mask & pins);
    f774:	4640      	mov	r0, r8
    f776:	684b      	ldr	r3, [r1, #4]
    f778:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    f77a:	2d00      	cmp	r5, #0
    f77c:	d0c1      	beq.n	f702 <gpiote_event_handler+0x7a>
    f77e:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    f780:	4629      	mov	r1, r5
    f782:	2b00      	cmp	r3, #0
    f784:	bf38      	it	cc
    f786:	2300      	movcc	r3, #0
    f788:	461d      	mov	r5, r3
    f78a:	e7ee      	b.n	f76a <gpiote_event_handler+0xe2>
		if (level_pins & bit) {
    f78c:	421c      	tst	r4, r3
    f78e:	d016      	beq.n	f7be <gpiote_event_handler+0x136>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    f790:	7a32      	ldrb	r2, [r6, #8]
    f792:	f005 011f 	and.w	r1, r5, #31
    f796:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
	if ((BIT(pin) & data->int_active_level) != 0U) {
    f79a:	6942      	ldr	r2, [r0, #20]
    f79c:	eb07 0181 	add.w	r1, r7, r1, lsl #2
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    f7a0:	f8d1 c200 	ldr.w	ip, [r1, #512]	; 0x200
    f7a4:	40ea      	lsrs	r2, r5
    f7a6:	f002 0201 	and.w	r2, r2, #1
    f7aa:	f1c2 0203 	rsb	r2, r2, #3
    f7ae:	f42c 3c40 	bic.w	ip, ip, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    f7b2:	ea4c 4202 	orr.w	r2, ip, r2, lsl #16
    f7b6:	f8c1 2200 	str.w	r2, [r1, #512]	; 0x200
			level_pins &= ~bit;
    f7ba:	ea23 0304 	bic.w	r3, r3, r4
		++pin;
    f7be:	3501      	adds	r5, #1
		bit <<= 1;
    f7c0:	0064      	lsls	r4, r4, #1
    f7c2:	e7ad      	b.n	f720 <gpiote_event_handler+0x98>
    f7c4:	4003117c 	.word	0x4003117c
    f7c8:	20020150 	.word	0x20020150
    f7cc:	40031000 	.word	0x40031000
    f7d0:	40031100 	.word	0x40031100
    f7d4:	40842500 	.word	0x40842500

0000f7d8 <twim_2_init>:
#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
#endif

#ifdef CONFIG_I2C_2_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(2);
    f7d8:	b510      	push	{r4, lr}
    f7da:	4604      	mov	r4, r0
    f7dc:	2200      	movs	r2, #0
    f7de:	2101      	movs	r1, #1
    f7e0:	200a      	movs	r0, #10
    f7e2:	f7fe fb3b 	bl	de5c <z_arm_irq_priority_set>
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
    f7e6:	6860      	ldr	r0, [r4, #4]
    f7e8:	4623      	mov	r3, r4
    f7ea:	4a06      	ldr	r2, [pc, #24]	; (f804 <twim_2_init+0x2c>)
    f7ec:	f100 0108 	add.w	r1, r0, #8
    f7f0:	f00a f81e 	bl	19830 <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
    f7f4:	4b04      	ldr	r3, [pc, #16]	; (f808 <twim_2_init+0x30>)
    f7f6:	4298      	cmp	r0, r3
I2C_NRFX_TWIM_DEVICE(2);
    f7f8:	bf14      	ite	ne
    f7fa:	f06f 000f 	mvnne.w	r0, #15
    f7fe:	2000      	moveq	r0, #0
    f800:	bd10      	pop	{r4, pc}
    f802:	bf00      	nop
    f804:	0000f8cd 	.word	0x0000f8cd
    f808:	0bad0000 	.word	0x0bad0000

0000f80c <i2c_nrfx_twim_transfer>:
{
    f80c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f810:	4604      	mov	r4, r0
    f812:	b087      	sub	sp, #28
    f814:	460d      	mov	r5, r1
    f816:	4616      	mov	r6, r2
    f818:	4698      	mov	r8, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
    f81a:	68c0      	ldr	r0, [r0, #12]
	return z_impl_k_sem_take(sem, timeout);
    f81c:	f04f 32ff 	mov.w	r2, #4294967295
    f820:	f04f 33ff 	mov.w	r3, #4294967295
    f824:	f00b f97a 	bl	1ab1c <z_impl_k_sem_take>
	nrfx_twim_enable(&get_dev_config(dev)->twim);
    f828:	6860      	ldr	r0, [r4, #4]
    f82a:	f00a f845 	bl	198b8 <nrfx_twim_enable>
	for (size_t i = 0; i < num_msgs; i++) {
    f82e:	2700      	movs	r7, #0
		if (res != NRFX_SUCCESS) {
    f830:	f8df 9094 	ldr.w	r9, [pc, #148]	; f8c8 <i2c_nrfx_twim_transfer+0xbc>
	for (size_t i = 0; i < num_msgs; i++) {
    f834:	42b7      	cmp	r7, r6
    f836:	f8d4 b004 	ldr.w	fp, [r4, #4]
    f83a:	d301      	bcc.n	f840 <i2c_nrfx_twim_transfer+0x34>
	int ret = 0;
    f83c:	2500      	movs	r5, #0
    f83e:	e022      	b.n	f886 <i2c_nrfx_twim_transfer+0x7a>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
    f840:	f895 a008 	ldrb.w	sl, [r5, #8]
    f844:	f01a 0108 	ands.w	r1, sl, #8
    f848:	d136      	bne.n	f8b8 <i2c_nrfx_twim_transfer+0xac>
		nrfx_twim_xfer_desc_t cur_xfer = {
    f84a:	2214      	movs	r2, #20
    f84c:	a801      	add	r0, sp, #4
    f84e:	f00c fbf4 	bl	1c03a <memset>
					  NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX
    f852:	f00a 0301 	and.w	r3, sl, #1
		nrfx_twim_xfer_desc_t cur_xfer = {
    f856:	f88d 3004 	strb.w	r3, [sp, #4]
    f85a:	686b      	ldr	r3, [r5, #4]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    f85c:	f01a 0f02 	tst.w	sl, #2
		nrfx_twim_xfer_desc_t cur_xfer = {
    f860:	9302      	str	r3, [sp, #8]
    f862:	682b      	ldr	r3, [r5, #0]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    f864:	bf0c      	ite	eq
    f866:	2220      	moveq	r2, #32
    f868:	2200      	movne	r2, #0
    f86a:	4658      	mov	r0, fp
    f86c:	a901      	add	r1, sp, #4
		nrfx_twim_xfer_desc_t cur_xfer = {
    f86e:	f88d 8005 	strb.w	r8, [sp, #5]
    f872:	9304      	str	r3, [sp, #16]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
    f874:	f00a f84c 	bl	19910 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
    f878:	4548      	cmp	r0, r9
    f87a:	d00e      	beq.n	f89a <i2c_nrfx_twim_transfer+0x8e>
			if (res == NRFX_ERROR_BUSY) {
    f87c:	4b11      	ldr	r3, [pc, #68]	; (f8c4 <i2c_nrfx_twim_transfer+0xb8>)
    f87e:	4298      	cmp	r0, r3
    f880:	d01d      	beq.n	f8be <i2c_nrfx_twim_transfer+0xb2>
				ret = -EIO;
    f882:	f06f 0504 	mvn.w	r5, #4
	nrfx_twim_disable(&get_dev_config(dev)->twim);
    f886:	6860      	ldr	r0, [r4, #4]
    f888:	f00a f826 	bl	198d8 <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
    f88c:	68e0      	ldr	r0, [r4, #12]
	z_impl_k_sem_give(sem);
    f88e:	f00b f91f 	bl	1aad0 <z_impl_k_sem_give>
}
    f892:	4628      	mov	r0, r5
    f894:	b007      	add	sp, #28
    f896:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
    f89a:	68e0      	ldr	r0, [r4, #12]
    f89c:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
    f89e:	f04f 33ff 	mov.w	r3, #4294967295
    f8a2:	f04f 32ff 	mov.w	r2, #4294967295
    f8a6:	f00b f939 	bl	1ab1c <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
    f8aa:	68e3      	ldr	r3, [r4, #12]
	return dev->driver_data;
    f8ac:	350c      	adds	r5, #12
		res = get_dev_data(dev)->res;
    f8ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
    f8b0:	454b      	cmp	r3, r9
    f8b2:	d1e6      	bne.n	f882 <i2c_nrfx_twim_transfer+0x76>
	for (size_t i = 0; i < num_msgs; i++) {
    f8b4:	3701      	adds	r7, #1
    f8b6:	e7bd      	b.n	f834 <i2c_nrfx_twim_transfer+0x28>
			ret = -ENOTSUP;
    f8b8:	f06f 0522 	mvn.w	r5, #34	; 0x22
    f8bc:	e7e3      	b.n	f886 <i2c_nrfx_twim_transfer+0x7a>
				ret = -EBUSY;
    f8be:	f06f 050f 	mvn.w	r5, #15
    f8c2:	e7e0      	b.n	f886 <i2c_nrfx_twim_transfer+0x7a>
    f8c4:	0bad000b 	.word	0x0bad000b
    f8c8:	0bad0000 	.word	0x0bad0000

0000f8cc <event_handler>:
	switch (p_event->type) {
    f8cc:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twim_data *dev_data = get_dev_data(dev);
    f8ce:	68cb      	ldr	r3, [r1, #12]
	switch (p_event->type) {
    f8d0:	2a01      	cmp	r2, #1
    f8d2:	d008      	beq.n	f8e6 <event_handler+0x1a>
    f8d4:	2a02      	cmp	r2, #2
    f8d6:	d008      	beq.n	f8ea <event_handler+0x1e>
    f8d8:	b94a      	cbnz	r2, f8ee <event_handler+0x22>
		dev_data->res = NRFX_SUCCESS;
    f8da:	4a06      	ldr	r2, [pc, #24]	; (f8f4 <event_handler+0x28>)
		dev_data->res = NRFX_ERROR_INTERNAL;
    f8dc:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
    f8de:	f103 0018 	add.w	r0, r3, #24
    f8e2:	f00b b8f5 	b.w	1aad0 <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
    f8e6:	4a04      	ldr	r2, [pc, #16]	; (f8f8 <event_handler+0x2c>)
    f8e8:	e7f8      	b.n	f8dc <event_handler+0x10>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
    f8ea:	4a04      	ldr	r2, [pc, #16]	; (f8fc <event_handler+0x30>)
    f8ec:	e7f6      	b.n	f8dc <event_handler+0x10>
		dev_data->res = NRFX_ERROR_INTERNAL;
    f8ee:	4a04      	ldr	r2, [pc, #16]	; (f900 <event_handler+0x34>)
    f8f0:	e7f4      	b.n	f8dc <event_handler+0x10>
    f8f2:	bf00      	nop
    f8f4:	0bad0000 	.word	0x0bad0000
    f8f8:	0bae0001 	.word	0x0bae0001
    f8fc:	0bae0002 	.word	0x0bae0002
    f900:	0bad0001 	.word	0x0bad0001

0000f904 <spi_3_init>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
    f904:	b510      	push	{r4, lr}
    f906:	4604      	mov	r4, r0
    f908:	2200      	movs	r2, #0
    f90a:	2101      	movs	r1, #1
    f90c:	200b      	movs	r0, #11
    f90e:	f7fe faa5 	bl	de5c <z_arm_irq_priority_set>
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
    f912:	6860      	ldr	r0, [r4, #4]
    f914:	4623      	mov	r3, r4
    f916:	4a08      	ldr	r2, [pc, #32]	; (f938 <spi_3_init+0x34>)
    f918:	f100 010c 	add.w	r1, r0, #12
    f91c:	f009 fe32 	bl	19584 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
    f920:	4b06      	ldr	r3, [pc, #24]	; (f93c <spi_3_init+0x38>)
    f922:	4298      	cmp	r0, r3
    f924:	d104      	bne.n	f930 <spi_3_init+0x2c>
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
    f926:	68e0      	ldr	r0, [r4, #12]
    f928:	f00c fd52 	bl	1c3d0 <spi_context_unlock_unconditionally>
	return 0;
    f92c:	2000      	movs	r0, #0
SPI_NRFX_SPIM_DEVICE(3);
    f92e:	bd10      	pop	{r4, pc}
		return -EBUSY;
    f930:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPIM_DEVICE(3);
    f934:	e7fb      	b.n	f92e <spi_3_init+0x2a>
    f936:	bf00      	nop
    f938:	0001c411 	.word	0x0001c411
    f93c:	0bad0000 	.word	0x0bad0000

0000f940 <transfer_next_chunk>:
{
    f940:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    f942:	68c5      	ldr	r5, [r0, #12]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
    f944:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    f946:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    f948:	b982      	cbnz	r2, f96c <transfer_next_chunk+0x2c>
	if (chunk_len > 0) {
    f94a:	bb93      	cbnz	r3, f9b2 <transfer_next_chunk+0x72>
	int error = 0;
    f94c:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
    f94e:	2200      	movs	r2, #0
    f950:	4628      	mov	r0, r5
    f952:	4611      	mov	r1, r2
    f954:	f00c fd12 	bl	1c37c <_spi_context_cs_control.isra.0>
	ctx->sync_status = status;
    f958:	636c      	str	r4, [r5, #52]	; 0x34
    f95a:	f105 001c 	add.w	r0, r5, #28
    f95e:	f00b f8b7 	bl	1aad0 <z_impl_k_sem_give>
	dev_data->busy = false;
    f962:	2300      	movs	r3, #0
    f964:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
    f968:	b004      	add	sp, #16
    f96a:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
    f96c:	4611      	mov	r1, r2
    f96e:	b113      	cbz	r3, f976 <transfer_next_chunk+0x36>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
    f970:	429a      	cmp	r2, r3
    f972:	bf28      	it	cs
    f974:	4619      	movcs	r1, r3
	const struct spi_nrfx_config *dev_config = get_dev_config(dev);
    f976:	6840      	ldr	r0, [r0, #4]
		const u8_t *tx_buf = ctx->tx_buf;
    f978:	6cac      	ldr	r4, [r5, #72]	; 0x48
		if (chunk_len > dev_config->max_chunk_len) {
    f97a:	6886      	ldr	r6, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
    f97c:	9400      	str	r4, [sp, #0]
    f97e:	42b1      	cmp	r1, r6
    f980:	bf28      	it	cs
    f982:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
    f984:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
    f986:	b1b4      	cbz	r4, f9b6 <transfer_next_chunk+0x76>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    f988:	2a00      	cmp	r2, #0
    f98a:	bf18      	it	ne
    f98c:	460a      	movne	r2, r1
    f98e:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
    f990:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    f992:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
    f994:	b18a      	cbz	r2, f9ba <transfer_next_chunk+0x7a>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    f996:	2b00      	cmp	r3, #0
    f998:	bf18      	it	ne
    f99a:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    f99c:	2200      	movs	r2, #0
    f99e:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    f9a0:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
    f9a2:	f009 fe91 	bl	196c8 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
    f9a6:	4b06      	ldr	r3, [pc, #24]	; (f9c0 <transfer_next_chunk+0x80>)
    f9a8:	4298      	cmp	r0, r3
    f9aa:	d0dd      	beq.n	f968 <transfer_next_chunk+0x28>
			error = -EIO;
    f9ac:	f06f 0404 	mvn.w	r4, #4
    f9b0:	e7cd      	b.n	f94e <transfer_next_chunk+0xe>
    f9b2:	4619      	mov	r1, r3
    f9b4:	e7df      	b.n	f976 <transfer_next_chunk+0x36>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
    f9b6:	4622      	mov	r2, r4
    f9b8:	e7e9      	b.n	f98e <transfer_next_chunk+0x4e>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
    f9ba:	4613      	mov	r3, r2
    f9bc:	e7ee      	b.n	f99c <transfer_next_chunk+0x5c>
    f9be:	bf00      	nop
    f9c0:	0bad0000 	.word	0x0bad0000

0000f9c4 <spi_nrfx_transceive>:
{
    f9c4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
    f9c8:	68c4      	ldr	r4, [r0, #12]
{
    f9ca:	4680      	mov	r8, r0
    f9cc:	460f      	mov	r7, r1
    f9ce:	4616      	mov	r6, r2
    f9d0:	461d      	mov	r5, r3
	k_sem_take(&ctx->lock, K_FOREVER);
    f9d2:	f104 0a04 	add.w	sl, r4, #4
	return z_impl_k_sem_take(sem, timeout);
    f9d6:	f04f 33ff 	mov.w	r3, #4294967295
    f9da:	f04f 32ff 	mov.w	r2, #4294967295
    f9de:	4650      	mov	r0, sl
    f9e0:	f00b f89c 	bl	1ab1c <z_impl_k_sem_take>
	struct spi_context *ctx = &get_dev_data(dev)->ctx;
    f9e4:	f8d8 900c 	ldr.w	r9, [r8, #12]
	if (spi_context_configured(ctx, spi_cfg)) {
    f9e8:	f8d9 3000 	ldr.w	r3, [r9]
    f9ec:	429f      	cmp	r7, r3
    f9ee:	d068      	beq.n	fac2 <spi_nrfx_transceive+0xfe>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    f9f0:	f641 0209 	movw	r2, #6153	; 0x1809
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
    f9f4:	88bb      	ldrh	r3, [r7, #4]
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
    f9f6:	4213      	tst	r3, r2
    f9f8:	f040 80b6 	bne.w	fb68 <spi_nrfx_transceive+0x1a4>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
    f9fc:	f3c3 1345 	ubfx	r3, r3, #5, #6
    fa00:	2b08      	cmp	r3, #8
    fa02:	f040 80b1 	bne.w	fb68 <spi_nrfx_transceive+0x1a4>
	if (spi_cfg->frequency < 125000) {
    fa06:	683a      	ldr	r2, [r7, #0]
    fa08:	4b59      	ldr	r3, [pc, #356]	; (fb70 <spi_nrfx_transceive+0x1ac>)
    fa0a:	429a      	cmp	r2, r3
    fa0c:	f240 80ac 	bls.w	fb68 <spi_nrfx_transceive+0x1a4>
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
    fa10:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ctx->config = spi_cfg;
    fa14:	f8c9 7000 	str.w	r7, [r9]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
    fa18:	9300      	str	r3, [sp, #0]
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
    fa1a:	68bb      	ldr	r3, [r7, #8]
    fa1c:	b30b      	cbz	r3, fa62 <spi_nrfx_transceive+0x9e>
    fa1e:	6818      	ldr	r0, [r3, #0]
    fa20:	b1f8      	cbz	r0, fa62 <spi_nrfx_transceive+0x9e>
				   ctx->config->cs->gpio_pin, GPIO_OUTPUT);
    fa22:	6859      	ldr	r1, [r3, #4]
{
	const struct gpio_driver_api *api =
		(const struct gpio_driver_api *)port->driver_api;
	const struct gpio_driver_config *const cfg =
		(const struct gpio_driver_config *)port->config_info;
	struct gpio_driver_data *data =
    fa24:	f8d0 b00c 	ldr.w	fp, [r0, #12]
	return api->pin_configure(port, pin, flags);
    fa28:	6883      	ldr	r3, [r0, #8]
    fa2a:	b2c9      	uxtb	r1, r1
    fa2c:	f44f 7200 	mov.w	r2, #512	; 0x200
    fa30:	681b      	ldr	r3, [r3, #0]
    fa32:	9101      	str	r1, [sp, #4]
    fa34:	4798      	blx	r3
	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	ret = gpio_config(port, pin, flags);
	if (ret != 0) {
    fa36:	b948      	cbnz	r0, fa4c <spi_nrfx_transceive+0x88>
	}

	if ((flags & GPIO_ACTIVE_LOW) != 0) {
		data->invert |= (gpio_port_pins_t)BIT(pin);
	} else {
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
    fa38:	2301      	movs	r3, #1
    fa3a:	9901      	ldr	r1, [sp, #4]
    fa3c:	fa03 f101 	lsl.w	r1, r3, r1
    fa40:	f8db 3000 	ldr.w	r3, [fp]
    fa44:	ea23 0301 	bic.w	r3, r3, r1
    fa48:	f8cb 3000 	str.w	r3, [fp]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    fa4c:	f8d9 2000 	ldr.w	r2, [r9]
    fa50:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
    fa52:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_set(ctx->config->cs->gpio_dev,
    fa56:	7919      	ldrb	r1, [r3, #4]
    fa58:	43d2      	mvns	r2, r2
    fa5a:	6818      	ldr	r0, [r3, #0]
    fa5c:	0fd2      	lsrs	r2, r2, #31
    fa5e:	f00c fc7d 	bl	1c35c <gpio_pin_set>
	nrf_spim_configure(spim->p_reg,
    fa62:	9b00      	ldr	r3, [sp, #0]
    fa64:	6819      	ldr	r1, [r3, #0]
    fa66:	88bb      	ldrh	r3, [r7, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
    fa68:	0798      	lsls	r0, r3, #30
    fa6a:	f003 0204 	and.w	r2, r3, #4
    fa6e:	d558      	bpl.n	fb22 <spi_nrfx_transceive+0x15e>
			return NRF_SPIM_MODE_2;
    fa70:	2a00      	cmp	r2, #0
    fa72:	bf14      	ite	ne
    fa74:	2203      	movne	r2, #3
    fa76:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
    fa78:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
    fa7a:	f3c3 1300 	ubfx	r3, r3, #4, #1
    fa7e:	d054      	beq.n	fb2a <spi_nrfx_transceive+0x166>
    fa80:	2a03      	cmp	r2, #3
    fa82:	d055      	beq.n	fb30 <spi_nrfx_transceive+0x16c>
    fa84:	2a01      	cmp	r2, #1
    fa86:	d101      	bne.n	fa8c <spi_nrfx_transceive+0xc8>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
    fa88:	f043 0302 	orr.w	r3, r3, #2
	if (frequency < 250000) {
    fa8c:	4a39      	ldr	r2, [pc, #228]	; (fb74 <spi_nrfx_transceive+0x1b0>)
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
    fa8e:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	nrf_spim_frequency_set(spim->p_reg,
    fa92:	683b      	ldr	r3, [r7, #0]
	if (frequency < 250000) {
    fa94:	4293      	cmp	r3, r2
    fa96:	d94e      	bls.n	fb36 <spi_nrfx_transceive+0x172>
	} else if (frequency < 500000) {
    fa98:	4a37      	ldr	r2, [pc, #220]	; (fb78 <spi_nrfx_transceive+0x1b4>)
    fa9a:	4293      	cmp	r3, r2
    fa9c:	d94e      	bls.n	fb3c <spi_nrfx_transceive+0x178>
	} else if (frequency < 1000000) {
    fa9e:	4a37      	ldr	r2, [pc, #220]	; (fb7c <spi_nrfx_transceive+0x1b8>)
    faa0:	4293      	cmp	r3, r2
    faa2:	d94e      	bls.n	fb42 <spi_nrfx_transceive+0x17e>
	} else if (frequency < 2000000) {
    faa4:	4a36      	ldr	r2, [pc, #216]	; (fb80 <spi_nrfx_transceive+0x1bc>)
    faa6:	4293      	cmp	r3, r2
    faa8:	d94e      	bls.n	fb48 <spi_nrfx_transceive+0x184>
	} else if (frequency < 4000000) {
    faaa:	4a36      	ldr	r2, [pc, #216]	; (fb84 <spi_nrfx_transceive+0x1c0>)
    faac:	4293      	cmp	r3, r2
    faae:	d94e      	bls.n	fb4e <spi_nrfx_transceive+0x18a>
		return NRF_SPIM_FREQ_8M;
    fab0:	4a35      	ldr	r2, [pc, #212]	; (fb88 <spi_nrfx_transceive+0x1c4>)
    fab2:	4293      	cmp	r3, r2
    fab4:	bf34      	ite	cc
    fab6:	f04f 4380 	movcc.w	r3, #1073741824	; 0x40000000
    faba:	f04f 4300 	movcs.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
    fabe:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
    fac2:	2301      	movs	r3, #1
    fac4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
    fac8:	2e00      	cmp	r6, #0
    faca:	d043      	beq.n	fb54 <spi_nrfx_transceive+0x190>
		ctx->current_tx = tx_bufs->buffers;
    facc:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
    face:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
    fad0:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
    fad2:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    fad4:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
    fad6:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
    fad8:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
    fada:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
    fadc:	2d00      	cmp	r5, #0
    fade:	d03e      	beq.n	fb5e <spi_nrfx_transceive+0x19a>
		ctx->current_rx = rx_bufs->buffers;
    fae0:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
    fae2:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
    fae4:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
    fae6:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    fae8:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
    faea:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
    faec:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
    faee:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
    faf0:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
    faf2:	2101      	movs	r1, #1
    faf4:	4620      	mov	r0, r4
	ctx->sync_status = 0;
    faf6:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
    faf8:	f00c fc40 	bl	1c37c <_spi_context_cs_control.isra.0>
		transfer_next_chunk(dev);
    fafc:	4640      	mov	r0, r8
    fafe:	f7ff ff1f 	bl	f940 <transfer_next_chunk>
    fb02:	f04f 32ff 	mov.w	r2, #4294967295
    fb06:	f104 001c 	add.w	r0, r4, #28
    fb0a:	f04f 33ff 	mov.w	r3, #4294967295
    fb0e:	f00b f805 	bl	1ab1c <z_impl_k_sem_take>
	status = ctx->sync_status;
    fb12:	6b64      	ldr	r4, [r4, #52]	; 0x34
	z_impl_k_sem_give(sem);
    fb14:	4650      	mov	r0, sl
    fb16:	f00a ffdb 	bl	1aad0 <z_impl_k_sem_give>
}
    fb1a:	4620      	mov	r0, r4
    fb1c:	b003      	add	sp, #12
    fb1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return NRF_SPIM_MODE_0;
    fb22:	3a00      	subs	r2, #0
    fb24:	bf18      	it	ne
    fb26:	2201      	movne	r2, #1
    fb28:	e7a6      	b.n	fa78 <spi_nrfx_transceive+0xb4>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    fb2a:	f043 0304 	orr.w	r3, r3, #4
        break;
    fb2e:	e7ad      	b.n	fa8c <spi_nrfx_transceive+0xc8>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
    fb30:	f043 0306 	orr.w	r3, r3, #6
        break;
    fb34:	e7aa      	b.n	fa8c <spi_nrfx_transceive+0xc8>
		return NRF_SPIM_FREQ_125K;
    fb36:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
    fb3a:	e7c0      	b.n	fabe <spi_nrfx_transceive+0xfa>
		return NRF_SPIM_FREQ_250K;
    fb3c:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    fb40:	e7bd      	b.n	fabe <spi_nrfx_transceive+0xfa>
		return NRF_SPIM_FREQ_500K;
    fb42:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    fb46:	e7ba      	b.n	fabe <spi_nrfx_transceive+0xfa>
		return NRF_SPIM_FREQ_1M;
    fb48:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    fb4c:	e7b7      	b.n	fabe <spi_nrfx_transceive+0xfa>
		return NRF_SPIM_FREQ_2M;
    fb4e:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
    fb52:	e7b4      	b.n	fabe <spi_nrfx_transceive+0xfa>
		ctx->tx_count = 0;
    fb54:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
    fb58:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
    fb5c:	e7be      	b.n	fadc <spi_nrfx_transceive+0x118>
		ctx->rx_count = 0;
    fb5e:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
    fb62:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
    fb66:	e7c3      	b.n	faf0 <spi_nrfx_transceive+0x12c>
		return -EINVAL;
    fb68:	f06f 0415 	mvn.w	r4, #21
    fb6c:	e7d2      	b.n	fb14 <spi_nrfx_transceive+0x150>
    fb6e:	bf00      	nop
    fb70:	0001e847 	.word	0x0001e847
    fb74:	0003d08f 	.word	0x0003d08f
    fb78:	0007a11f 	.word	0x0007a11f
    fb7c:	000f423f 	.word	0x000f423f
    fb80:	001e847f 	.word	0x001e847f
    fb84:	003d08ff 	.word	0x003d08ff
    fb88:	007a1200 	.word	0x007a1200

0000fb8c <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
    fb8c:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    fb8e:	794b      	ldrb	r3, [r1, #5]
    fb90:	2b01      	cmp	r3, #1
    fb92:	d029      	beq.n	fbe8 <uarte_nrfx_configure+0x5c>
    fb94:	2b03      	cmp	r3, #3
    fb96:	d124      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    fb98:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    fb9a:	798b      	ldrb	r3, [r1, #6]
    fb9c:	2b03      	cmp	r3, #3
    fb9e:	d120      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    fba0:	79cc      	ldrb	r4, [r1, #7]
    fba2:	b124      	cbz	r4, fbae <uarte_nrfx_configure+0x22>
    fba4:	2c01      	cmp	r4, #1
    fba6:	d11c      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    fba8:	6843      	ldr	r3, [r0, #4]
    fbaa:	791b      	ldrb	r3, [r3, #4]
    fbac:	b1cb      	cbz	r3, fbe2 <uarte_nrfx_configure+0x56>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    fbae:	790a      	ldrb	r2, [r1, #4]
    fbb0:	b112      	cbz	r2, fbb8 <uarte_nrfx_configure+0x2c>
    fbb2:	2a02      	cmp	r2, #2
    fbb4:	d115      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    fbb6:	220e      	movs	r2, #14
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    fbb8:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    fbba:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
    fbbc:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    fbc0:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
    fbc2:	d064      	beq.n	fc8e <uarte_nrfx_configure+0x102>
    fbc4:	d82d      	bhi.n	fc22 <uarte_nrfx_configure+0x96>
    fbc6:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    fbca:	d063      	beq.n	fc94 <uarte_nrfx_configure+0x108>
    fbcc:	d816      	bhi.n	fbfc <uarte_nrfx_configure+0x70>
    fbce:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    fbd2:	d061      	beq.n	fc98 <uarte_nrfx_configure+0x10c>
    fbd4:	d80a      	bhi.n	fbec <uarte_nrfx_configure+0x60>
    fbd6:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    fbda:	d060      	beq.n	fc9e <uarte_nrfx_configure+0x112>
    fbdc:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    fbe0:	d060      	beq.n	fca4 <uarte_nrfx_configure+0x118>
    fbe2:	f06f 0022 	mvn.w	r0, #34	; 0x22
    fbe6:	e051      	b.n	fc8c <uarte_nrfx_configure+0x100>
	switch (cfg->stop_bits) {
    fbe8:	2600      	movs	r6, #0
    fbea:	e7d6      	b.n	fb9a <uarte_nrfx_configure+0xe>
	switch (baudrate) {
    fbec:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    fbf0:	d05b      	beq.n	fcaa <uarte_nrfx_configure+0x11e>
    fbf2:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    fbf6:	d1f4      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    fbf8:	4b36      	ldr	r3, [pc, #216]	; (fcd4 <uarte_nrfx_configure+0x148>)
    fbfa:	e03c      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fbfc:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    fc00:	d056      	beq.n	fcb0 <uarte_nrfx_configure+0x124>
    fc02:	d807      	bhi.n	fc14 <uarte_nrfx_configure+0x88>
    fc04:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    fc08:	d054      	beq.n	fcb4 <uarte_nrfx_configure+0x128>
    fc0a:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    fc0e:	d1e8      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    fc10:	4b31      	ldr	r3, [pc, #196]	; (fcd8 <uarte_nrfx_configure+0x14c>)
    fc12:	e030      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fc14:	f647 2712 	movw	r7, #31250	; 0x7a12
    fc18:	42bb      	cmp	r3, r7
    fc1a:	d1e2      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    fc1c:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    fc20:	e029      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fc22:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    fc26:	d047      	beq.n	fcb8 <uarte_nrfx_configure+0x12c>
    fc28:	d813      	bhi.n	fc52 <uarte_nrfx_configure+0xc6>
    fc2a:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    fc2e:	d046      	beq.n	fcbe <uarte_nrfx_configure+0x132>
    fc30:	d809      	bhi.n	fc46 <uarte_nrfx_configure+0xba>
    fc32:	f64d 27c0 	movw	r7, #56000	; 0xdac0
    fc36:	42bb      	cmp	r3, r7
    fc38:	d043      	beq.n	fcc2 <uarte_nrfx_configure+0x136>
    fc3a:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    fc3e:	d1d0      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    fc40:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    fc44:	e017      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fc46:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    fc4a:	d1ca      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    fc4c:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    fc50:	e011      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fc52:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    fc56:	d037      	beq.n	fcc8 <uarte_nrfx_configure+0x13c>
    fc58:	d808      	bhi.n	fc6c <uarte_nrfx_configure+0xe0>
    fc5a:	4f20      	ldr	r7, [pc, #128]	; (fcdc <uarte_nrfx_configure+0x150>)
    fc5c:	42bb      	cmp	r3, r7
    fc5e:	d036      	beq.n	fcce <uarte_nrfx_configure+0x142>
    fc60:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    fc64:	d1bd      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    fc66:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    fc6a:	e004      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fc6c:	4f1c      	ldr	r7, [pc, #112]	; (fce0 <uarte_nrfx_configure+0x154>)
    fc6e:	42bb      	cmp	r3, r7
    fc70:	d1b7      	bne.n	fbe2 <uarte_nrfx_configure+0x56>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    fc72:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    fc76:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
    fc7a:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    fc7c:	68c3      	ldr	r3, [r0, #12]
    fc7e:	4322      	orrs	r2, r4
    fc80:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    fc82:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
    fc86:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    fc8a:	2000      	movs	r0, #0
}
    fc8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    fc8e:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    fc92:	e7f0      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    fc94:	4b13      	ldr	r3, [pc, #76]	; (fce4 <uarte_nrfx_configure+0x158>)
    fc96:	e7ee      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    fc98:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    fc9c:	e7eb      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = 0x00014000;
    fc9e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    fca2:	e7e8      	b.n	fc76 <uarte_nrfx_configure+0xea>
	switch (baudrate) {
    fca4:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    fca8:	e7e5      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    fcaa:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    fcae:	e7e2      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    fcb0:	4b0d      	ldr	r3, [pc, #52]	; (fce8 <uarte_nrfx_configure+0x15c>)
    fcb2:	e7e0      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    fcb4:	4b0d      	ldr	r3, [pc, #52]	; (fcec <uarte_nrfx_configure+0x160>)
    fcb6:	e7de      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    fcb8:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    fcbc:	e7db      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    fcbe:	4b0c      	ldr	r3, [pc, #48]	; (fcf0 <uarte_nrfx_configure+0x164>)
    fcc0:	e7d9      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    fcc2:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    fcc6:	e7d6      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    fcc8:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    fccc:	e7d3      	b.n	fc76 <uarte_nrfx_configure+0xea>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    fcce:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    fcd2:	e7d0      	b.n	fc76 <uarte_nrfx_configure+0xea>
    fcd4:	0013b000 	.word	0x0013b000
    fcd8:	004ea000 	.word	0x004ea000
    fcdc:	0003d090 	.word	0x0003d090
    fce0:	000f4240 	.word	0x000f4240
    fce4:	00275000 	.word	0x00275000
    fce8:	0075c000 	.word	0x0075c000
    fcec:	003af000 	.word	0x003af000
    fcf0:	013a9000 	.word	0x013a9000

0000fcf4 <uarte_instance_init.constprop.0>:
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fcf4:	2201      	movs	r2, #1
	.irq_update		= uarte_nrfx_irq_update,
	.irq_callback_set	= uarte_nrfx_irq_callback_set,
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int uarte_instance_init(struct device *dev,
    fcf6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fcf8:	2703      	movs	r7, #3
    fcfa:	460d      	mov	r5, r1
	return config->uarte_regs;
    fcfc:	6843      	ldr	r3, [r0, #4]
{
	int err;
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
	struct uarte_nrfx_data *data = get_dev_data(dev);

	nrf_gpio_pin_write(config->pseltxd, 1);
    fcfe:	6809      	ldr	r1, [r1, #0]
	return config->uarte_regs;
    fd00:	681c      	ldr	r4, [r3, #0]
    p_reg->OUTSET = set_mask;
    fd02:	4b26      	ldr	r3, [pc, #152]	; (fd9c <uarte_instance_init.constprop.0+0xa8>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fd04:	408a      	lsls	r2, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
    fd06:	68c6      	ldr	r6, [r0, #12]
    p_reg->OUTSET = set_mask;
    fd08:	609a      	str	r2, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fd0a:	f101 0280 	add.w	r2, r1, #128	; 0x80
    fd0e:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
	nrf_gpio_cfg_output(config->pseltxd);

	if (config->pselrxd !=  NRF_UARTE_PSEL_DISCONNECTED) {
    fd12:	686a      	ldr	r2, [r5, #4]
    fd14:	1c57      	adds	r7, r2, #1
    fd16:	bf1e      	ittt	ne
    fd18:	f04f 0c00 	movne.w	ip, #0
    fd1c:	f102 0780 	addne.w	r7, r2, #128	; 0x80
    fd20:	f843 c027 	strne.w	ip, [r3, r7, lsl #2]
    p_reg->PSEL.TXD = pseltxd;
    fd24:	f8c4 150c 	str.w	r1, [r4, #1292]	; 0x50c
		nrf_gpio_cfg_input(config->pselrxd, NRF_GPIO_PIN_NOPULL);
	}

	nrf_uarte_txrx_pins_set(uarte, config->pseltxd, config->pselrxd);

	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
    fd28:	68a9      	ldr	r1, [r5, #8]
    p_reg->PSEL.RXD = pselrxd;
    fd2a:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
    fd2e:	1c4a      	adds	r2, r1, #1
    fd30:	d015      	beq.n	fd5e <uarte_instance_init.constprop.0+0x6a>
	    config->pselrts != NRF_UARTE_PSEL_DISCONNECTED) {
    fd32:	68ea      	ldr	r2, [r5, #12]
	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
    fd34:	1c57      	adds	r7, r2, #1
    fd36:	d012      	beq.n	fd5e <uarte_instance_init.constprop.0+0x6a>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fd38:	2701      	movs	r7, #1
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fd3a:	f04f 0c03 	mov.w	ip, #3
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    fd3e:	4097      	lsls	r7, r2
    p_reg->OUTSET = set_mask;
    fd40:	609f      	str	r7, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    fd42:	f102 0780 	add.w	r7, r2, #128	; 0x80
    fd46:	f843 c027 	str.w	ip, [r3, r7, lsl #2]
    fd4a:	f04f 0c00 	mov.w	ip, #0
    fd4e:	f101 0780 	add.w	r7, r1, #128	; 0x80
    fd52:	f843 c027 	str.w	ip, [r3, r7, lsl #2]
    p_reg->PSEL.RTS = pselrts;
    fd56:	f8c4 2508 	str.w	r2, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    fd5a:	f8c4 1510 	str.w	r1, [r4, #1296]	; 0x510
		nrf_uarte_hwfc_pins_set(uarte,
					config->pselrts,
					config->pselcts);
	}

	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    fd5e:	4631      	mov	r1, r6
    fd60:	f7ff ff14 	bl	fb8c <uarte_nrfx_configure>
	if (err) {
    fd64:	b9c8      	cbnz	r0, fd9a <uarte_instance_init.constprop.0+0xa6>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    fd66:	2308      	movs	r3, #8
    fd68:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	}
#endif
	/* Enable receiver and transmitter */
	nrf_uarte_enable(uarte);

	if (config->pselrxd != NRF_UARTE_PSEL_DISCONNECTED) {
    fd6c:	686b      	ldr	r3, [r5, #4]
    fd6e:	3301      	adds	r3, #1
    fd70:	d009      	beq.n	fd86 <uarte_instance_init.constprop.0+0x92>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);

		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    fd72:	f106 0310 	add.w	r3, r6, #16
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    fd76:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    fd7a:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    fd7e:	2301      	movs	r3, #1
    fd80:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    fd84:	6023      	str	r3, [r4, #0]
		/* Set ENDTX event by requesting fake (zero-length) transfer.
		 * Pointer to RAM variable (data->tx_buffer) is set because
		 * otherwise such operation may result in HardFault or RAM
		 * corruption.
		 */
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
    fd86:	68b3      	ldr	r3, [r6, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    fd88:	689b      	ldr	r3, [r3, #8]
    fd8a:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    fd8e:	2300      	movs	r3, #0
    fd90:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    fd94:	2301      	movs	r3, #1
    fd96:	60a3      	str	r3, [r4, #8]
    fd98:	60e3      	str	r3, [r4, #12]
		/* switch off transmitter to save an energy */
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
	}
#endif
	return 0;
}
    fd9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    fd9c:	40842500 	.word	0x40842500

0000fda0 <uarte_1_init>:
#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
    fda0:	b530      	push	{r4, r5, lr}
    fda2:	b085      	sub	sp, #20
    fda4:	466c      	mov	r4, sp
    fda6:	4605      	mov	r5, r0
    fda8:	4b08      	ldr	r3, [pc, #32]	; (fdcc <uarte_1_init+0x2c>)
    fdaa:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    fdac:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    fdb0:	2200      	movs	r2, #0
    fdb2:	2101      	movs	r1, #1
    fdb4:	2009      	movs	r0, #9
    fdb6:	f7fe f851 	bl	de5c <z_arm_irq_priority_set>
    fdba:	2009      	movs	r0, #9
    fdbc:	f7fe f83e 	bl	de3c <arch_irq_enable>
    fdc0:	4621      	mov	r1, r4
    fdc2:	4628      	mov	r0, r5
    fdc4:	f7ff ff96 	bl	fcf4 <uarte_instance_init.constprop.0>
    fdc8:	b005      	add	sp, #20
    fdca:	bd30      	pop	{r4, r5, pc}
    fdcc:	0001dbb0 	.word	0x0001dbb0

0000fdd0 <uarte_0_init>:
UART_NRF_UARTE_DEVICE(0);
    fdd0:	b530      	push	{r4, r5, lr}
    fdd2:	b085      	sub	sp, #20
    fdd4:	466c      	mov	r4, sp
    fdd6:	4605      	mov	r5, r0
    fdd8:	4b08      	ldr	r3, [pc, #32]	; (fdfc <uarte_0_init+0x2c>)
    fdda:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    fddc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    fde0:	2200      	movs	r2, #0
    fde2:	2101      	movs	r1, #1
    fde4:	2008      	movs	r0, #8
    fde6:	f7fe f839 	bl	de5c <z_arm_irq_priority_set>
    fdea:	2008      	movs	r0, #8
    fdec:	f7fe f826 	bl	de3c <arch_irq_enable>
    fdf0:	4621      	mov	r1, r4
    fdf2:	4628      	mov	r0, r5
    fdf4:	f7ff ff7e 	bl	fcf4 <uarte_instance_init.constprop.0>
    fdf8:	b005      	add	sp, #20
    fdfa:	bd30      	pop	{r4, r5, pc}
    fdfc:	0001dbc0 	.word	0x0001dbc0

0000fe00 <_bsdlib_init>:
extern void ipc_proxy_irq_handler(void);

static int init_ret;

static int _bsdlib_init(struct device *unused)
{
    fe00:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Setup the network IRQ used by the BSD library.
	 * Note: No call to irq_enable() here, that is done through bsd_init().
	 */
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
    fe02:	2200      	movs	r2, #0
    fe04:	202a      	movs	r0, #42	; 0x2a
    fe06:	4611      	mov	r1, r2
    fe08:	f7fe f828 	bl	de5c <z_arm_irq_priority_set>
			   ipc_proxy_irq_handler, 0);

	const bsd_init_params_t init_params = {
    fe0c:	4a06      	ldr	r2, [pc, #24]	; (fe28 <_bsdlib_init+0x28>)
    fe0e:	ab01      	add	r3, sp, #4
    fe10:	ca07      	ldmia	r2, {r0, r1, r2}
    fe12:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		.trace_on = true,
		.bsd_memory_address = BSD_RESERVED_MEMORY_ADDRESS,
		.bsd_memory_size = BSD_RESERVED_MEMORY_SIZE
	};

	init_ret = bsd_init(&init_params);
    fe16:	4618      	mov	r0, r3
    fe18:	f007 fbb0 	bl	1757c <bsd_init>
    fe1c:	4b03      	ldr	r3, [pc, #12]	; (fe2c <_bsdlib_init+0x2c>)
    fe1e:	6018      	str	r0, [r3, #0]
		 */
		return 0;
	}

	return init_ret;
}
    fe20:	2000      	movs	r0, #0
    fe22:	b005      	add	sp, #20
    fe24:	f85d fb04 	ldr.w	pc, [sp], #4
    fe28:	0001dbd0 	.word	0x0001dbd0
    fe2c:	20020310 	.word	0x20020310

0000fe30 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which bsdlib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
    fe30:	b570      	push	{r4, r5, r6, lr}
	struct thread_monitor_entry *entry = thread_event_monitor;
	struct thread_monitor_entry *new_entry = thread_event_monitor;
    fe32:	4c0d      	ldr	r4, [pc, #52]	; (fe68 <thread_monitor_entry_get+0x38>)
{
    fe34:	4602      	mov	r2, r0
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
    fe36:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
    fe38:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
    fe3a:	4620      	mov	r0, r4
		entry_age = rpc_event_cnt - entry->cnt;
    fe3c:	4b0b      	ldr	r3, [pc, #44]	; (fe6c <thread_monitor_entry_get+0x3c>)
    fe3e:	681b      	ldr	r3, [r3, #0]
		if (entry->id == id) {
    fe40:	6801      	ldr	r1, [r0, #0]
    fe42:	4291      	cmp	r1, r2
    fe44:	d00e      	beq.n	fe64 <thread_monitor_entry_get+0x34>
		} else if (entry->id == 0) {
    fe46:	b151      	cbz	r1, fe5e <thread_monitor_entry_get+0x2e>
		entry_age = rpc_event_cnt - entry->cnt;
    fe48:	6841      	ldr	r1, [r0, #4]
    fe4a:	1a59      	subs	r1, r3, r1
		if (entry_age > oldest_entry_age) {
    fe4c:	42b1      	cmp	r1, r6
    fe4e:	bfc4      	itt	gt
    fe50:	4604      	movgt	r4, r0
    fe52:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
    fe54:	3d01      	subs	r5, #1
    fe56:	f100 0008 	add.w	r0, r0, #8
    fe5a:	d1f1      	bne.n	fe40 <thread_monitor_entry_get+0x10>
    fe5c:	4620      	mov	r0, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
    fe5e:	3b01      	subs	r3, #1
	new_entry->id = id;
    fe60:	6002      	str	r2, [r0, #0]
	new_entry->cnt = rpc_event_cnt - 1;
    fe62:	6043      	str	r3, [r0, #4]

	return new_entry;
}
    fe64:	bd70      	pop	{r4, r5, r6, pc}
    fe66:	bf00      	nop
    fe68:	20020320 	.word	0x20020320
    fe6c:	20020314 	.word	0x20020314

0000fe70 <rpc_proxy_irq_handler>:
			  */

	return 1; /* We should check if scheduling decision should be made */
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
    fe70:	4668      	mov	r0, sp
    fe72:	f020 0107 	bic.w	r1, r0, #7
    fe76:	468d      	mov	sp, r1
    fe78:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    fe7a:	4b0f      	ldr	r3, [pc, #60]	; (feb8 <rpc_proxy_irq_handler+0x48>)
    fe7c:	e8d3 2fef 	ldaex	r2, [r3]
    fe80:	3201      	adds	r2, #1
    fe82:	e8c3 2fe1 	stlex	r1, r2, [r3]
    fe86:	2900      	cmp	r1, #0
    fe88:	d1f8      	bne.n	fe7c <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	bsd_os_application_irq_handler();
    fe8a:	f002 fa2f 	bl	122ec <bsd_os_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
    fe8e:	4b0b      	ldr	r3, [pc, #44]	; (febc <rpc_proxy_irq_handler+0x4c>)
    fe90:	681c      	ldr	r4, [r3, #0]
    fe92:	2c00      	cmp	r4, #0
    fe94:	bf38      	it	cc
    fe96:	2400      	movcc	r4, #0
    fe98:	b12c      	cbz	r4, fea6 <rpc_proxy_irq_handler+0x36>
    fe9a:	1d20      	adds	r0, r4, #4
    fe9c:	f00a fe18 	bl	1aad0 <z_impl_k_sem_give>
    fea0:	6824      	ldr	r4, [r4, #0]
    fea2:	2c00      	cmp	r4, #0
    fea4:	d1f8      	bne.n	fe98 <rpc_proxy_irq_handler+0x28>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
    fea6:	f7fd ffef 	bl	de88 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
    feaa:	f7fe f927 	bl	e0fc <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
    feae:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
    feb2:	4685      	mov	sp, r0
    feb4:	4770      	bx	lr
    feb6:	bf00      	nop
    feb8:	20020314 	.word	0x20020314
    febc:	20020318 	.word	0x20020318

0000fec0 <bsd_os_timedwait>:
{
    fec0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fec4:	460c      	mov	r4, r1
    fec6:	b089      	sub	sp, #36	; 0x24
	return z_impl_k_uptime_ticks();
    fec8:	f00d fbd3 	bl	1d672 <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
    fecc:	6823      	ldr	r3, [r4, #0]
    fece:	4680      	mov	r8, r0
    fed0:	2b00      	cmp	r3, #0
    fed2:	468a      	mov	sl, r1
    fed4:	d103      	bne.n	fede <bsd_os_timedwait+0x1e>
	z_impl_k_yield();
    fed6:	f00a fd87 	bl	1a9e8 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
    feda:	203c      	movs	r0, #60	; 0x3c
    fedc:	e091      	b.n	10002 <bsd_os_timedwait+0x142>
		*timeout = SYS_FOREVER_MS;
    fede:	bfbc      	itt	lt
    fee0:	f04f 33ff 	movlt.w	r3, #4294967295
    fee4:	6023      	strlt	r3, [r4, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
    fee6:	2201      	movs	r2, #1
    fee8:	2100      	movs	r1, #0
    feea:	a802      	add	r0, sp, #8
    feec:	f00d fb61 	bl	1d5b2 <z_impl_k_sem_init>
    fef0:	ad01      	add	r5, sp, #4
    fef2:	f04f 0320 	mov.w	r3, #32
    fef6:	f3ef 8b11 	mrs	fp, BASEPRI
    fefa:	f383 8811 	msr	BASEPRI, r3
    fefe:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
    ff02:	f00a fddf 	bl	1aac4 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
    ff06:	f7ff ff93 	bl	fe30 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
    ff0a:	4946      	ldr	r1, [pc, #280]	; (10024 <bsd_os_timedwait+0x164>)
    ff0c:	6843      	ldr	r3, [r0, #4]
    ff0e:	680a      	ldr	r2, [r1, #0]
    ff10:	4689      	mov	r9, r1
    ff12:	4293      	cmp	r3, r2
    ff14:	f04f 0300 	mov.w	r3, #0
    ff18:	d108      	bne.n	ff2c <bsd_os_timedwait+0x6c>
	parent->next = child;
    ff1a:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
    ff1c:	4b42      	ldr	r3, [pc, #264]	; (10028 <bsd_os_timedwait+0x168>)
    ff1e:	685a      	ldr	r2, [r3, #4]
    ff20:	2a00      	cmp	r2, #0
    ff22:	d171      	bne.n	10008 <bsd_os_timedwait+0x148>
	list->head = node;
    ff24:	e9c3 5500 	strd	r5, r5, [r3]
		allow_to_sleep = true;
    ff28:	2301      	movs	r3, #1
}
    ff2a:	e000      	b.n	ff2e <bsd_os_timedwait+0x6e>
	entry->cnt = rpc_event_cnt;
    ff2c:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
    ff2e:	f38b 8811 	msr	BASEPRI, fp
    ff32:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
    ff36:	2b00      	cmp	r3, #0
    ff38:	d062      	beq.n	10000 <bsd_os_timedwait+0x140>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
    ff3a:	6820      	ldr	r0, [r4, #0]
    ff3c:	1c42      	adds	r2, r0, #1
    ff3e:	d066      	beq.n	1000e <bsd_os_timedwait+0x14e>
    ff40:	ea20 7ce0 	bic.w	ip, r0, r0, asr #31
    ff44:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
    ff48:	f240 30e7 	movw	r0, #999	; 0x3e7
    ff4c:	2100      	movs	r1, #0
    ff4e:	2300      	movs	r3, #0
    ff50:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ff54:	fbce 010c 	smlal	r0, r1, lr, ip
    ff58:	f7fc fca8 	bl	c8ac <__aeabi_uldivmod>
    ff5c:	2300      	movs	r3, #0
	return z_impl_k_sem_take(sem, timeout);
    ff5e:	4602      	mov	r2, r0
    ff60:	a802      	add	r0, sp, #8
    ff62:	f00a fddb 	bl	1ab1c <z_impl_k_sem_take>
	__asm__ volatile(
    ff66:	f04f 0320 	mov.w	r3, #32
    ff6a:	f3ef 8b11 	mrs	fp, BASEPRI
    ff6e:	f383 8811 	msr	BASEPRI, r3
    ff72:	f3bf 8f6f 	isb	sy
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    ff76:	2000      	movs	r0, #0
    ff78:	4b2b      	ldr	r3, [pc, #172]	; (10028 <bsd_os_timedwait+0x168>)
    ff7a:	681a      	ldr	r2, [r3, #0]
    ff7c:	b15a      	cbz	r2, ff96 <bsd_os_timedwait+0xd6>
    ff7e:	42aa      	cmp	r2, r5
    ff80:	d14d      	bne.n	1001e <bsd_os_timedwait+0x15e>
Z_GENLIST_REMOVE(slist, snode)
    ff82:	9d01      	ldr	r5, [sp, #4]
    ff84:	2800      	cmp	r0, #0
    ff86:	d144      	bne.n	10012 <bsd_os_timedwait+0x152>
    ff88:	6859      	ldr	r1, [r3, #4]
	list->head = node;
    ff8a:	601d      	str	r5, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
    ff8c:	4291      	cmp	r1, r2
    ff8e:	d100      	bne.n	ff92 <bsd_os_timedwait+0xd2>
	list->tail = node;
    ff90:	605d      	str	r5, [r3, #4]
	parent->next = child;
    ff92:	2300      	movs	r3, #0
    ff94:	9301      	str	r3, [sp, #4]
	return z_impl_k_current_get();
    ff96:	f00a fd95 	bl	1aac4 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
    ff9a:	f7ff ff49 	bl	fe30 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
    ff9e:	f8d9 3000 	ldr.w	r3, [r9]
    ffa2:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
    ffa4:	f38b 8811 	msr	BASEPRI, fp
    ffa8:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
    ffac:	6825      	ldr	r5, [r4, #0]
    ffae:	1c6b      	adds	r3, r5, #1
    ffb0:	d026      	beq.n	10000 <bsd_os_timedwait+0x140>
	return z_impl_k_uptime_ticks();
    ffb2:	f00d fb5e 	bl	1d672 <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
    ffb6:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
    ffba:	468e      	mov	lr, r1
    ffbc:	fba8 890c 	umull	r8, r9, r8, ip
    ffc0:	fba0 010c 	umull	r0, r1, r0, ip
    ffc4:	fb0c 990a 	mla	r9, ip, sl, r9
    ffc8:	fb0c 110e 	mla	r1, ip, lr, r1
    ffcc:	ea4f 32d8 	mov.w	r2, r8, lsr #15
    ffd0:	ea42 4249 	orr.w	r2, r2, r9, lsl #17
	remaining = *timeout - k_uptime_delta(&start);
    ffd4:	1952      	adds	r2, r2, r5
    ffd6:	ea4f 33d9 	mov.w	r3, r9, lsr #15
    ffda:	eb43 73e5 	adc.w	r3, r3, r5, asr #31
    ffde:	0bc5      	lsrs	r5, r0, #15
    ffe0:	ea45 4541 	orr.w	r5, r5, r1, lsl #17
    ffe4:	1b56      	subs	r6, r2, r5
    ffe6:	ea4f 3cd1 	mov.w	ip, r1, lsr #15
    ffea:	eb63 070c 	sbc.w	r7, r3, ip
	*timeout = remaining > 0 ? remaining : 0;
    ffee:	2e00      	cmp	r6, #0
    fff0:	f177 0300 	sbcs.w	r3, r7, #0
    fff4:	bfb8      	it	lt
    fff6:	2600      	movlt	r6, #0
    fff8:	6026      	str	r6, [r4, #0]
	if (*timeout == 0) {
    fffa:	2e00      	cmp	r6, #0
    fffc:	f43f af6d 	beq.w	feda <bsd_os_timedwait+0x1a>
	return 0;
   10000:	2000      	movs	r0, #0
}
   10002:	b009      	add	sp, #36	; 0x24
   10004:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10008:	6015      	str	r5, [r2, #0]
	list->tail = node;
   1000a:	605d      	str	r5, [r3, #4]
   1000c:	e78c      	b.n	ff28 <bsd_os_timedwait+0x68>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   1000e:	4603      	mov	r3, r0
   10010:	e7a5      	b.n	ff5e <bsd_os_timedwait+0x9e>
	parent->next = child;
   10012:	6005      	str	r5, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   10014:	6859      	ldr	r1, [r3, #4]
   10016:	4291      	cmp	r1, r2
	list->tail = node;
   10018:	bf08      	it	eq
   1001a:	6058      	streq	r0, [r3, #4]
}
   1001c:	e7b9      	b.n	ff92 <bsd_os_timedwait+0xd2>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1001e:	4610      	mov	r0, r2
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   10020:	6812      	ldr	r2, [r2, #0]
   10022:	e7ab      	b.n	ff7c <bsd_os_timedwait+0xbc>
   10024:	20020314 	.word	0x20020314
   10028:	20020318 	.word	0x20020318

0001002c <bsd_os_errno_set>:
	switch (err_code) {
   1002c:	283c      	cmp	r0, #60	; 0x3c
{
   1002e:	b508      	push	{r3, lr}
	switch (err_code) {
   10030:	f300 8084 	bgt.w	1013c <bsd_os_errno_set+0x110>
   10034:	2800      	cmp	r0, #0
   10036:	dc03      	bgt.n	10040 <bsd_os_errno_set+0x14>
		errno = 0xBAADBAAD;
   10038:	f00c fb4b 	bl	1c6d2 <z_errno>
   1003c:	4ba8      	ldr	r3, [pc, #672]	; (102e0 <bsd_os_errno_set+0x2b4>)
   1003e:	e0bc      	b.n	101ba <bsd_os_errno_set+0x18e>
   10040:	3801      	subs	r0, #1
   10042:	283b      	cmp	r0, #59	; 0x3b
   10044:	d8f8      	bhi.n	10038 <bsd_os_errno_set+0xc>
   10046:	a301      	add	r3, pc, #4	; (adr r3, 1004c <bsd_os_errno_set+0x20>)
   10048:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
   1004c:	000101b5 	.word	0x000101b5
   10050:	000101bf 	.word	0x000101bf
   10054:	00010039 	.word	0x00010039
   10058:	00010039 	.word	0x00010039
   1005c:	000101c7 	.word	0x000101c7
   10060:	00010039 	.word	0x00010039
   10064:	00010039 	.word	0x00010039
   10068:	000101cf 	.word	0x000101cf
   1006c:	000101d7 	.word	0x000101d7
   10070:	00010039 	.word	0x00010039
   10074:	00010039 	.word	0x00010039
   10078:	000101df 	.word	0x000101df
   1007c:	000101e7 	.word	0x000101e7
   10080:	000101ef 	.word	0x000101ef
   10084:	00010039 	.word	0x00010039
   10088:	00010039 	.word	0x00010039
   1008c:	00010039 	.word	0x00010039
   10090:	00010039 	.word	0x00010039
   10094:	00010039 	.word	0x00010039
   10098:	00010039 	.word	0x00010039
   1009c:	00010039 	.word	0x00010039
   100a0:	000101f7 	.word	0x000101f7
   100a4:	00010039 	.word	0x00010039
   100a8:	000101ff 	.word	0x000101ff
   100ac:	00010039 	.word	0x00010039
   100b0:	00010039 	.word	0x00010039
   100b4:	00010039 	.word	0x00010039
   100b8:	00010039 	.word	0x00010039
   100bc:	00010039 	.word	0x00010039
   100c0:	00010039 	.word	0x00010039
   100c4:	00010039 	.word	0x00010039
   100c8:	00010039 	.word	0x00010039
   100cc:	00010039 	.word	0x00010039
   100d0:	00010039 	.word	0x00010039
   100d4:	00010207 	.word	0x00010207
   100d8:	00010039 	.word	0x00010039
   100dc:	0001020f 	.word	0x0001020f
   100e0:	00010039 	.word	0x00010039
   100e4:	00010039 	.word	0x00010039
   100e8:	000102d7 	.word	0x000102d7
   100ec:	00010217 	.word	0x00010217
   100f0:	0001021f 	.word	0x0001021f
   100f4:	00010227 	.word	0x00010227
   100f8:	0001022f 	.word	0x0001022f
   100fc:	00010237 	.word	0x00010237
   10100:	00010039 	.word	0x00010039
   10104:	0001023f 	.word	0x0001023f
   10108:	00010247 	.word	0x00010247
   1010c:	00010039 	.word	0x00010039
   10110:	0001024f 	.word	0x0001024f
   10114:	00010257 	.word	0x00010257
   10118:	0001025f 	.word	0x0001025f
   1011c:	00010039 	.word	0x00010039
   10120:	00010267 	.word	0x00010267
   10124:	00010039 	.word	0x00010039
   10128:	0001026f 	.word	0x0001026f
   1012c:	00010277 	.word	0x00010277
   10130:	00010039 	.word	0x00010039
   10134:	00010039 	.word	0x00010039
   10138:	0001027f 	.word	0x0001027f
	switch (err_code) {
   1013c:	3869      	subs	r0, #105	; 0x69
   1013e:	2818      	cmp	r0, #24
   10140:	f63f af7a 	bhi.w	10038 <bsd_os_errno_set+0xc>
   10144:	2818      	cmp	r0, #24
   10146:	f63f af77 	bhi.w	10038 <bsd_os_errno_set+0xc>
   1014a:	a301      	add	r3, pc, #4	; (adr r3, 10150 <bsd_os_errno_set+0x124>)
   1014c:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
   10150:	00010287 	.word	0x00010287
   10154:	00010039 	.word	0x00010039
   10158:	00010039 	.word	0x00010039
   1015c:	00010039 	.word	0x00010039
   10160:	00010039 	.word	0x00010039
   10164:	00010039 	.word	0x00010039
   10168:	00010039 	.word	0x00010039
   1016c:	0001028f 	.word	0x0001028f
   10170:	00010039 	.word	0x00010039
   10174:	0001029f 	.word	0x0001029f
   10178:	00010297 	.word	0x00010297
   1017c:	00010039 	.word	0x00010039
   10180:	00010039 	.word	0x00010039
   10184:	00010039 	.word	0x00010039
   10188:	00010039 	.word	0x00010039
   1018c:	00010039 	.word	0x00010039
   10190:	00010039 	.word	0x00010039
   10194:	00010039 	.word	0x00010039
   10198:	00010039 	.word	0x00010039
   1019c:	00010039 	.word	0x00010039
   101a0:	000102a7 	.word	0x000102a7
   101a4:	000102af 	.word	0x000102af
   101a8:	000102b9 	.word	0x000102b9
   101ac:	000102c3 	.word	0x000102c3
   101b0:	000102cd 	.word	0x000102cd
		errno = EPERM;
   101b4:	f00c fa8d 	bl	1c6d2 <z_errno>
   101b8:	2301      	movs	r3, #1
		errno = 0xBAADBAAD;
   101ba:	6003      	str	r3, [r0, #0]
}
   101bc:	bd08      	pop	{r3, pc}
		errno = ENOENT;
   101be:	f00c fa88 	bl	1c6d2 <z_errno>
   101c2:	2302      	movs	r3, #2
   101c4:	e7f9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EIO;
   101c6:	f00c fa84 	bl	1c6d2 <z_errno>
   101ca:	2305      	movs	r3, #5
   101cc:	e7f5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOEXEC;
   101ce:	f00c fa80 	bl	1c6d2 <z_errno>
   101d2:	2308      	movs	r3, #8
   101d4:	e7f1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EBADF;
   101d6:	f00c fa7c 	bl	1c6d2 <z_errno>
   101da:	2309      	movs	r3, #9
   101dc:	e7ed      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOMEM;
   101de:	f00c fa78 	bl	1c6d2 <z_errno>
   101e2:	230c      	movs	r3, #12
   101e4:	e7e9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EACCES;
   101e6:	f00c fa74 	bl	1c6d2 <z_errno>
   101ea:	230d      	movs	r3, #13
   101ec:	e7e5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EFAULT;
   101ee:	f00c fa70 	bl	1c6d2 <z_errno>
   101f2:	230e      	movs	r3, #14
   101f4:	e7e1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EINVAL;
   101f6:	f00c fa6c 	bl	1c6d2 <z_errno>
   101fa:	2316      	movs	r3, #22
   101fc:	e7dd      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EMFILE;
   101fe:	f00c fa68 	bl	1c6d2 <z_errno>
   10202:	2318      	movs	r3, #24
   10204:	e7d9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EAGAIN;
   10206:	f00c fa64 	bl	1c6d2 <z_errno>
   1020a:	230b      	movs	r3, #11
   1020c:	e7d5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EDOM;
   1020e:	f00c fa60 	bl	1c6d2 <z_errno>
   10212:	2325      	movs	r3, #37	; 0x25
   10214:	e7d1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EPROTOTYPE;
   10216:	f00c fa5c 	bl	1c6d2 <z_errno>
   1021a:	2329      	movs	r3, #41	; 0x29
   1021c:	e7cd      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOPROTOOPT;
   1021e:	f00c fa58 	bl	1c6d2 <z_errno>
   10222:	232a      	movs	r3, #42	; 0x2a
   10224:	e7c9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EPROTONOSUPPORT;
   10226:	f00c fa54 	bl	1c6d2 <z_errno>
   1022a:	232b      	movs	r3, #43	; 0x2b
   1022c:	e7c5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ESOCKTNOSUPPORT;
   1022e:	f00c fa50 	bl	1c6d2 <z_errno>
   10232:	232c      	movs	r3, #44	; 0x2c
   10234:	e7c1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EOPNOTSUPP;
   10236:	f00c fa4c 	bl	1c6d2 <z_errno>
   1023a:	232d      	movs	r3, #45	; 0x2d
   1023c:	e7bd      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EAFNOSUPPORT;
   1023e:	f00c fa48 	bl	1c6d2 <z_errno>
   10242:	232f      	movs	r3, #47	; 0x2f
   10244:	e7b9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EADDRINUSE;
   10246:	f00c fa44 	bl	1c6d2 <z_errno>
   1024a:	2330      	movs	r3, #48	; 0x30
   1024c:	e7b5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENETDOWN;
   1024e:	f00c fa40 	bl	1c6d2 <z_errno>
   10252:	233e      	movs	r3, #62	; 0x3e
   10254:	e7b1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENETUNREACH;
   10256:	f00c fa3c 	bl	1c6d2 <z_errno>
   1025a:	2333      	movs	r3, #51	; 0x33
   1025c:	e7ad      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENETRESET;
   1025e:	f00c fa38 	bl	1c6d2 <z_errno>
   10262:	2334      	movs	r3, #52	; 0x34
   10264:	e7a9      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ECONNRESET;
   10266:	f00c fa34 	bl	1c6d2 <z_errno>
   1026a:	2336      	movs	r3, #54	; 0x36
   1026c:	e7a5      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EISCONN;
   1026e:	f00c fa30 	bl	1c6d2 <z_errno>
   10272:	2338      	movs	r3, #56	; 0x38
   10274:	e7a1      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOTCONN;
   10276:	f00c fa2c 	bl	1c6d2 <z_errno>
   1027a:	2339      	movs	r3, #57	; 0x39
   1027c:	e79d      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ETIMEDOUT;
   1027e:	f00c fa28 	bl	1c6d2 <z_errno>
   10282:	233c      	movs	r3, #60	; 0x3c
   10284:	e799      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOBUFS;
   10286:	f00c fa24 	bl	1c6d2 <z_errno>
   1028a:	2337      	movs	r3, #55	; 0x37
   1028c:	e795      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EHOSTDOWN;
   1028e:	f00c fa20 	bl	1c6d2 <z_errno>
   10292:	2343      	movs	r3, #67	; 0x43
   10294:	e791      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EINPROGRESS;
   10296:	f00c fa1c 	bl	1c6d2 <z_errno>
   1029a:	2344      	movs	r3, #68	; 0x44
   1029c:	e78d      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EALREADY;
   1029e:	f00c fa18 	bl	1c6d2 <z_errno>
   102a2:	2345      	movs	r3, #69	; 0x45
   102a4:	e789      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ECANCELED;
   102a6:	f00c fa14 	bl	1c6d2 <z_errno>
   102aa:	2348      	movs	r3, #72	; 0x48
   102ac:	e785      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = ENOKEY;
   102ae:	f00c fa10 	bl	1c6d2 <z_errno>
   102b2:	f240 73d1 	movw	r3, #2001	; 0x7d1
   102b6:	e780      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EKEYEXPIRED;
   102b8:	f00c fa0b 	bl	1c6d2 <z_errno>
   102bc:	f240 73d2 	movw	r3, #2002	; 0x7d2
   102c0:	e77b      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EKEYREVOKED;
   102c2:	f00c fa06 	bl	1c6d2 <z_errno>
   102c6:	f240 73d3 	movw	r3, #2003	; 0x7d3
   102ca:	e776      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EKEYREJECTED;
   102cc:	f00c fa01 	bl	1c6d2 <z_errno>
   102d0:	f240 73d4 	movw	r3, #2004	; 0x7d4
   102d4:	e771      	b.n	101ba <bsd_os_errno_set+0x18e>
		errno = EMSGSIZE;
   102d6:	f00c f9fc 	bl	1c6d2 <z_errno>
   102da:	2324      	movs	r3, #36	; 0x24
   102dc:	e76d      	b.n	101ba <bsd_os_errno_set+0x18e>
   102de:	bf00      	nop
   102e0:	baadbaad 	.word	0xbaadbaad

000102e4 <bsd_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   102e4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   102e8:	4b01      	ldr	r3, [pc, #4]	; (102f0 <bsd_os_application_irq_set+0xc>)
   102ea:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   102ee:	4770      	bx	lr
   102f0:	e000e100 	.word	0xe000e100

000102f4 <bsd_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   102f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   102f8:	4b01      	ldr	r3, [pc, #4]	; (10300 <bsd_os_application_irq_clear+0xc>)
   102fa:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   102fe:	4770      	bx	lr
   10300:	e000e100 	.word	0xe000e100

00010304 <bsd_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10304:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   10308:	4b01      	ldr	r3, [pc, #4]	; (10310 <bsd_os_trace_irq_set+0xc>)
   1030a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   1030e:	4770      	bx	lr
   10310:	e000e100 	.word	0xe000e100

00010314 <bsd_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10314:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   10318:	4b01      	ldr	r3, [pc, #4]	; (10320 <bsd_os_trace_irq_clear+0xc>)
   1031a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   1031e:	4770      	bx	lr
   10320:	e000e100 	.word	0xe000e100

00010324 <bsd_os_init>:
#endif
}

/* This function is called by bsd_init and must not be called explicitly. */
void bsd_os_init(void)
{
   10324:	b508      	push	{r3, lr}
	list->head = NULL;
   10326:	2300      	movs	r3, #0
   10328:	4a07      	ldr	r2, [pc, #28]	; (10348 <bsd_os_init+0x24>)
	list->tail = NULL;
   1032a:	e9c2 3300 	strd	r3, r3, [r2]
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1032e:	4a07      	ldr	r2, [pc, #28]	; (1034c <bsd_os_init+0x28>)
   10330:	e8d2 1fef 	ldaex	r1, [r2]
   10334:	e8c2 3fe0 	stlex	r0, r3, [r2]
   10338:	2800      	cmp	r0, #0
   1033a:	d1f9      	bne.n	10330 <bsd_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   1033c:	f00c f9f4 	bl	1c728 <read_task_create>

	/* Configure and enable modem tracing over UART. */
	trace_uart_init();
	trace_task_create();
}
   10340:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	trace_task_create();
   10344:	f00c b9e5 	b.w	1c712 <trace_task_create>
   10348:	20020318 	.word	0x20020318
   1034c:	20020314 	.word	0x20020314

00010350 <z_to_nrf_optname>:
static int z_to_nrf_optname(int z_in_level, int z_in_optname,
			    int *nrf_out_optname)
{
	int retval = 0;

	switch (z_in_level) {
   10350:	f240 2302 	movw	r3, #514	; 0x202
   10354:	4298      	cmp	r0, r3
   10356:	d05c      	beq.n	10412 <z_to_nrf_optname+0xc2>
   10358:	dc07      	bgt.n	1036a <z_to_nrf_optname+0x1a>
   1035a:	2801      	cmp	r0, #1
   1035c:	d043      	beq.n	103e6 <z_to_nrf_optname+0x96>
   1035e:	f5b0 7f8d 	cmp.w	r0, #282	; 0x11a
   10362:	d035      	beq.n	103d0 <z_to_nrf_optname+0x80>
   10364:	f04f 30ff 	mov.w	r0, #4294967295
		retval = -1;
		break;
	}

	return retval;
}
   10368:	4770      	bx	lr
	switch (z_in_level) {
   1036a:	f240 2303 	movw	r3, #515	; 0x203
   1036e:	4298      	cmp	r0, r3
   10370:	d1f8      	bne.n	10364 <z_to_nrf_optname+0x14>
		switch (z_in_optname) {
   10372:	3901      	subs	r1, #1
   10374:	2913      	cmp	r1, #19
   10376:	d8f5      	bhi.n	10364 <z_to_nrf_optname+0x14>
   10378:	a301      	add	r3, pc, #4	; (adr r3, 10380 <z_to_nrf_optname+0x30>)
   1037a:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   1037e:	bf00      	nop
   10380:	0001041f 	.word	0x0001041f
   10384:	00010403 	.word	0x00010403
   10388:	000103e3 	.word	0x000103e3
   1038c:	000103f3 	.word	0x000103f3
   10390:	00010407 	.word	0x00010407
   10394:	0001040b 	.word	0x0001040b
   10398:	0001040f 	.word	0x0001040f
   1039c:	00010365 	.word	0x00010365
   103a0:	00010365 	.word	0x00010365
   103a4:	00010365 	.word	0x00010365
   103a8:	00010365 	.word	0x00010365
   103ac:	00010365 	.word	0x00010365
   103b0:	00010365 	.word	0x00010365
   103b4:	00010365 	.word	0x00010365
   103b8:	00010365 	.word	0x00010365
   103bc:	00010365 	.word	0x00010365
   103c0:	00010365 	.word	0x00010365
   103c4:	00010365 	.word	0x00010365
   103c8:	00010365 	.word	0x00010365
   103cc:	000103f9 	.word	0x000103f9
		switch (z_in_optname) {
   103d0:	3901      	subs	r1, #1
   103d2:	2906      	cmp	r1, #6
   103d4:	d8c6      	bhi.n	10364 <z_to_nrf_optname+0x14>
   103d6:	e8df f001 	tbb	[pc, r1]
   103da:	1614      	.short	0x1614
   103dc:	220c1a18 	.word	0x220c1a18
   103e0:	04          	.byte	0x04
   103e1:	00          	.byte	0x00
			*nrf_out_optname = NRF_SO_SEC_SESSION_CACHE;
   103e2:	2303      	movs	r3, #3
   103e4:	e006      	b.n	103f4 <z_to_nrf_optname+0xa4>
		switch (z_in_optname) {
   103e6:	2914      	cmp	r1, #20
   103e8:	d006      	beq.n	103f8 <z_to_nrf_optname+0xa8>
   103ea:	2919      	cmp	r1, #25
   103ec:	d006      	beq.n	103fc <z_to_nrf_optname+0xac>
   103ee:	2904      	cmp	r1, #4
   103f0:	d1b8      	bne.n	10364 <z_to_nrf_optname+0x14>
			*nrf_out_optname = NRF_SO_SEC_PEER_VERIFY;
   103f2:	2304      	movs	r3, #4
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   103f4:	6013      	str	r3, [r2, #0]
   103f6:	e002      	b.n	103fe <z_to_nrf_optname+0xae>
			*nrf_out_optname = NRF_SO_RCVTIMEO;
   103f8:	2314      	movs	r3, #20
   103fa:	e7fb      	b.n	103f4 <z_to_nrf_optname+0xa4>
			*nrf_out_optname = NRF_SO_BINDTODEVICE;
   103fc:	6011      	str	r1, [r2, #0]
	int retval = 0;
   103fe:	2000      	movs	r0, #0
			break;
   10400:	4770      	bx	lr
			*nrf_out_optname = NRF_SO_DFU_RESOURCES;
   10402:	2302      	movs	r3, #2
   10404:	e7f6      	b.n	103f4 <z_to_nrf_optname+0xa4>
			*nrf_out_optname = NRF_SO_DFU_REVERT;
   10406:	2305      	movs	r3, #5
   10408:	e7f4      	b.n	103f4 <z_to_nrf_optname+0xa4>
			*nrf_out_optname = NRF_SO_DFU_BACKUP_DELETE;
   1040a:	2306      	movs	r3, #6
   1040c:	e7f2      	b.n	103f4 <z_to_nrf_optname+0xa4>
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   1040e:	2307      	movs	r3, #7
   10410:	e7f0      	b.n	103f4 <z_to_nrf_optname+0xa4>
		switch (z_in_optname) {
   10412:	2902      	cmp	r1, #2
   10414:	d0f5      	beq.n	10402 <z_to_nrf_optname+0xb2>
   10416:	2903      	cmp	r1, #3
   10418:	d0e3      	beq.n	103e2 <z_to_nrf_optname+0x92>
   1041a:	2901      	cmp	r1, #1
   1041c:	d1a2      	bne.n	10364 <z_to_nrf_optname+0x14>
			*nrf_out_optname = NRF_SO_SEC_ROLE;
   1041e:	2301      	movs	r3, #1
   10420:	e7e8      	b.n	103f4 <z_to_nrf_optname+0xa4>
   10422:	bf00      	nop

00010424 <nrf91_socket_offload_ioctl>:
	return retval;
}

static int nrf91_socket_offload_ioctl(void *obj, unsigned int request,
				      va_list args)
{
   10424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10428:	f5a1 7380 	sub.w	r3, r1, #256	; 0x100
   1042c:	b091      	sub	sp, #68	; 0x44
	int sd = OBJ_TO_SD(obj);
   1042e:	3801      	subs	r0, #1

	switch (request) {
   10430:	2b05      	cmp	r3, #5
   10432:	d879      	bhi.n	10528 <nrf91_socket_offload_ioctl+0x104>
   10434:	e8df f003 	tbb	[pc, r3]
   10438:	94787809 	.word	0x94787809
   1043c:	0d03      	.short	0x0d03
	int sd = OBJ_TO_SD(obj);
   1043e:	f06f 042c 	mvn.w	r4, #44	; 0x2c
	 * In Zephyr, fcntl() is just an alias of ioctl().
	 */
	default:
		return nrf91_socket_offload_fcntl(sd, request, args);
	}
}
   10442:	4620      	mov	r0, r4
   10444:	b011      	add	sp, #68	; 0x44
   10446:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return nrf_close(sd);
   1044a:	f007 fabf 	bl	179cc <nrf_close>
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   1044e:	4604      	mov	r4, r0
		break;
   10450:	e7f7      	b.n	10442 <nrf91_socket_offload_ioctl+0x1e>
	for (int i = 0; i < nfds; i++) {
   10452:	f04f 0800 	mov.w	r8, #0
		nfds = va_arg(args, int);
   10456:	e9d2 a900 	ldrd	sl, r9, [r2]
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = { 0 };
   1045a:	2100      	movs	r1, #0
		timeout = va_arg(args, int);
   1045c:	f8d2 b008 	ldr.w	fp, [r2, #8]
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = { 0 };
   10460:	4668      	mov	r0, sp
   10462:	2240      	movs	r2, #64	; 0x40
   10464:	f00b fde9 	bl	1c03a <memset>
	for (int i = 0; i < nfds; i++) {
   10468:	466e      	mov	r6, sp
   1046a:	4655      	mov	r5, sl
   1046c:	4657      	mov	r7, sl
	int retval = 0;
   1046e:	4644      	mov	r4, r8
		tmp[i].events = 0;
   10470:	4643      	mov	r3, r8
			obj = z_get_fd_obj(fds[i].fd,
   10472:	493d      	ldr	r1, [pc, #244]	; (10568 <nrf91_socket_offload_ioctl+0x144>)
	for (int i = 0; i < nfds; i++) {
   10474:	45c1      	cmp	r9, r8
   10476:	dc32      	bgt.n	104de <nrf91_socket_offload_ioctl+0xba>
	if (retval > 0) {
   10478:	2c00      	cmp	r4, #0
   1047a:	dce2      	bgt.n	10442 <nrf91_socket_offload_ioctl+0x1e>
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   1047c:	465a      	mov	r2, fp
   1047e:	4649      	mov	r1, r9
   10480:	4668      	mov	r0, sp
   10482:	f007 fb6f 	bl	17b64 <nrf_poll>
	for (int i = 0; i < nfds; i++) {
   10486:	2300      	movs	r3, #0
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   10488:	4604      	mov	r4, r0
	for (int i = 0; i < nfds; i++) {
   1048a:	4599      	cmp	r9, r3
   1048c:	ddd9      	ble.n	10442 <nrf91_socket_offload_ioctl+0x1e>
		if (fds[i].fd < 0) {
   1048e:	f85a 2033 	ldr.w	r2, [sl, r3, lsl #3]
   10492:	2a00      	cmp	r2, #0
   10494:	db20      	blt.n	104d8 <nrf91_socket_offload_ioctl+0xb4>
		if (tmp[i].revents & NRF_POLLIN) {
   10496:	eb0d 02c3 	add.w	r2, sp, r3, lsl #3
   1049a:	88d2      	ldrh	r2, [r2, #6]
   1049c:	07d7      	lsls	r7, r2, #31
			fds[i].revents |= POLLIN;
   1049e:	bf42      	ittt	mi
   104a0:	88e9      	ldrhmi	r1, [r5, #6]
   104a2:	f041 0101 	orrmi.w	r1, r1, #1
   104a6:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLOUT) {
   104a8:	0796      	lsls	r6, r2, #30
			fds[i].revents |= POLLOUT;
   104aa:	bf42      	ittt	mi
   104ac:	88e9      	ldrhmi	r1, [r5, #6]
   104ae:	f041 0104 	orrmi.w	r1, r1, #4
   104b2:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLERR) {
   104b4:	0750      	lsls	r0, r2, #29
			fds[i].revents |= POLLERR;
   104b6:	bf42      	ittt	mi
   104b8:	88e9      	ldrhmi	r1, [r5, #6]
   104ba:	f041 0108 	orrmi.w	r1, r1, #8
   104be:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLNVAL) {
   104c0:	06d1      	lsls	r1, r2, #27
			fds[i].revents |= POLLNVAL;
   104c2:	bf42      	ittt	mi
   104c4:	88e9      	ldrhmi	r1, [r5, #6]
   104c6:	f041 0120 	orrmi.w	r1, r1, #32
   104ca:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLHUP) {
   104cc:	0712      	lsls	r2, r2, #28
			fds[i].revents |= POLLHUP;
   104ce:	bf42      	ittt	mi
   104d0:	88ea      	ldrhmi	r2, [r5, #6]
   104d2:	f042 0210 	orrmi.w	r2, r2, #16
   104d6:	80ea      	strhmi	r2, [r5, #6]
	for (int i = 0; i < nfds; i++) {
   104d8:	3301      	adds	r3, #1
   104da:	3508      	adds	r5, #8
   104dc:	e7d5      	b.n	1048a <nrf91_socket_offload_ioctl+0x66>
		if (fds[i].fd < 0) {
   104de:	6838      	ldr	r0, [r7, #0]
		tmp[i].events = 0;
   104e0:	80b3      	strh	r3, [r6, #4]
		if (fds[i].fd < 0) {
   104e2:	2800      	cmp	r0, #0
		fds[i].revents = 0;
   104e4:	80fb      	strh	r3, [r7, #6]
		if (fds[i].fd < 0) {
   104e6:	da05      	bge.n	104f4 <nrf91_socket_offload_ioctl+0xd0>
			tmp[i].fd = fds[i].fd;
   104e8:	6030      	str	r0, [r6, #0]
	for (int i = 0; i < nfds; i++) {
   104ea:	f108 0801 	add.w	r8, r8, #1
   104ee:	3608      	adds	r6, #8
   104f0:	3708      	adds	r7, #8
   104f2:	e7bf      	b.n	10474 <nrf91_socket_offload_ioctl+0x50>
			obj = z_get_fd_obj(fds[i].fd,
   104f4:	2223      	movs	r2, #35	; 0x23
   104f6:	f7fc fed1 	bl	d29c <z_get_fd_obj>
			if (obj != NULL) {
   104fa:	2300      	movs	r3, #0
   104fc:	491a      	ldr	r1, [pc, #104]	; (10568 <nrf91_socket_offload_ioctl+0x144>)
   104fe:	b178      	cbz	r0, 10520 <nrf91_socket_offload_ioctl+0xfc>
				tmp[i].fd = OBJ_TO_SD(obj);
   10500:	3801      	subs	r0, #1
   10502:	6030      	str	r0, [r6, #0]
		if (fds[i].events & POLLIN) {
   10504:	88b8      	ldrh	r0, [r7, #4]
   10506:	07c2      	lsls	r2, r0, #31
			tmp[i].events |= NRF_POLLIN;
   10508:	bf42      	ittt	mi
   1050a:	88b2      	ldrhmi	r2, [r6, #4]
   1050c:	f042 0201 	orrmi.w	r2, r2, #1
   10510:	80b2      	strhmi	r2, [r6, #4]
		if (fds[i].events & POLLOUT) {
   10512:	0742      	lsls	r2, r0, #29
			tmp[i].events |= NRF_POLLOUT;
   10514:	bf42      	ittt	mi
   10516:	88b2      	ldrhmi	r2, [r6, #4]
   10518:	f042 0202 	orrmi.w	r2, r2, #2
   1051c:	80b2      	strhmi	r2, [r6, #4]
   1051e:	e7e4      	b.n	104ea <nrf91_socket_offload_ioctl+0xc6>
				fds[i].revents = POLLNVAL;
   10520:	2220      	movs	r2, #32
				retval++;
   10522:	3401      	adds	r4, #1
				fds[i].revents = POLLNVAL;
   10524:	80fa      	strh	r2, [r7, #6]
				retval++;
   10526:	e7ed      	b.n	10504 <nrf91_socket_offload_ioctl+0xe0>
	switch (cmd) {
   10528:	2903      	cmp	r1, #3
   1052a:	d00a      	beq.n	10542 <nrf91_socket_offload_ioctl+0x11e>
   1052c:	2904      	cmp	r1, #4
   1052e:	d110      	bne.n	10552 <nrf91_socket_offload_ioctl+0x12e>
		flags = va_arg(args, int);
   10530:	6812      	ldr	r2, [r2, #0]
		if (flags != 0 && flags != O_NONBLOCK)
   10532:	f432 4380 	bics.w	r3, r2, #16384	; 0x4000
   10536:	d10c      	bne.n	10552 <nrf91_socket_offload_ioctl+0x12e>
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   10538:	2101      	movs	r1, #1
   1053a:	1392      	asrs	r2, r2, #14
   1053c:	f007 fb14 	bl	17b68 <nrf_fcntl>
   10540:	e785      	b.n	1044e <nrf91_socket_offload_ioctl+0x2a>
		flags = nrf_fcntl(fd, NRF_F_GETFL, 0);
   10542:	2200      	movs	r2, #0
   10544:	2102      	movs	r1, #2
   10546:	f007 fb0f 	bl	17b68 <nrf_fcntl>
		retval = (flags & NRF_O_NONBLOCK) ? O_NONBLOCK : 0;
   1054a:	0380      	lsls	r0, r0, #14
   1054c:	f400 4480 	and.w	r4, r0, #16384	; 0x4000
		break;
   10550:	e777      	b.n	10442 <nrf91_socket_offload_ioctl+0x1e>
	errno = EINVAL;
   10552:	f00c f94d 	bl	1c7f0 <z_errno>
   10556:	2316      	movs	r3, #22
	return retval;
   10558:	f04f 34ff 	mov.w	r4, #4294967295
	errno = EINVAL;
   1055c:	6003      	str	r3, [r0, #0]
		return nrf91_socket_offload_fcntl(sd, request, args);
   1055e:	e770      	b.n	10442 <nrf91_socket_offload_ioctl+0x1e>
		return -EXDEV;
   10560:	f06f 0411 	mvn.w	r4, #17
   10564:	e76d      	b.n	10442 <nrf91_socket_offload_ioctl+0x1e>
   10566:	bf00      	nop
   10568:	0001dd38 	.word	0x0001dd38

0001056c <nrf91_socket_iface_init>:

static void nrf91_socket_iface_init(struct net_if *iface)
{
	nrf91_socket_iface_data.iface = iface;

	iface->if_dev->offloaded = true;
   1056c:	2201      	movs	r2, #1
	nrf91_socket_iface_data.iface = iface;
   1056e:	4b03      	ldr	r3, [pc, #12]	; (1057c <nrf91_socket_iface_init+0x10>)
   10570:	6018      	str	r0, [r3, #0]
	iface->if_dev->offloaded = true;
   10572:	6803      	ldr	r3, [r0, #0]

	socket_offload_dns_register(&nrf91_socket_dns_offload_ops);
   10574:	4802      	ldr	r0, [pc, #8]	; (10580 <nrf91_socket_iface_init+0x14>)
	iface->if_dev->offloaded = true;
   10576:	769a      	strb	r2, [r3, #26]
	socket_offload_dns_register(&nrf91_socket_dns_offload_ops);
   10578:	f7fd ba40 	b.w	d9fc <socket_offload_dns_register>
   1057c:	20020370 	.word	0x20020370
   10580:	0001dd30 	.word	0x0001dd30

00010584 <nrf91_socket_create>:
{
   10584:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10586:	4606      	mov	r6, r0
   10588:	460d      	mov	r5, r1
   1058a:	4617      	mov	r7, r2
	int fd = z_reserve_fd();
   1058c:	f7fc feb4 	bl	d2f8 <z_reserve_fd>
	if (fd < 0) {
   10590:	1e04      	subs	r4, r0, #0
   10592:	db0d      	blt.n	105b0 <nrf91_socket_create+0x2c>
	family = z_to_nrf_family(family);
   10594:	b2b0      	uxth	r0, r6
   10596:	f00c f8de 	bl	1c756 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   1059a:	f110 0f2f 	cmn.w	r0, #47	; 0x2f
	family = z_to_nrf_family(family);
   1059e:	4606      	mov	r6, r0
	if (family == -EAFNOSUPPORT) {
   105a0:	d109      	bne.n	105b6 <nrf91_socket_create+0x32>
		errno = EAFNOSUPPORT;
   105a2:	f00c f925 	bl	1c7f0 <z_errno>
   105a6:	232f      	movs	r3, #47	; 0x2f
		errno = EPROTONOSUPPORT;
   105a8:	6003      	str	r3, [r0, #0]
		z_free_fd(fd);
   105aa:	4620      	mov	r0, r4
   105ac:	f7fc fed2 	bl	d354 <z_free_fd>
		return -1;
   105b0:	f04f 34ff 	mov.w	r4, #4294967295
   105b4:	e01b      	b.n	105ee <nrf91_socket_create+0x6a>
	switch (socktype) {
   105b6:	2d03      	cmp	r5, #3
   105b8:	d003      	beq.n	105c2 <nrf91_socket_create+0x3e>
   105ba:	2d04      	cmp	r5, #4
   105bc:	bf08      	it	eq
   105be:	f44f 7500 	moveq.w	r5, #512	; 0x200
	proto = z_to_nrf_protocol(proto);
   105c2:	4638      	mov	r0, r7
   105c4:	f00c f8e3 	bl	1c78e <z_to_nrf_protocol>
	if (proto == -EPROTONOSUPPORT) {
   105c8:	f110 0f2b 	cmn.w	r0, #43	; 0x2b
	proto = z_to_nrf_protocol(proto);
   105cc:	4602      	mov	r2, r0
	if (proto == -EPROTONOSUPPORT) {
   105ce:	d103      	bne.n	105d8 <nrf91_socket_create+0x54>
		errno = EPROTONOSUPPORT;
   105d0:	f00c f90e 	bl	1c7f0 <z_errno>
   105d4:	232b      	movs	r3, #43	; 0x2b
   105d6:	e7e7      	b.n	105a8 <nrf91_socket_create+0x24>
	retval = nrf_socket(family, type, proto);
   105d8:	4629      	mov	r1, r5
   105da:	4630      	mov	r0, r6
   105dc:	f007 f9e4 	bl	179a8 <nrf_socket>
	if (sd < 0) {
   105e0:	1e01      	subs	r1, r0, #0
   105e2:	dbe2      	blt.n	105aa <nrf91_socket_create+0x26>
	z_finalize_fd(fd, SD_TO_OBJ(sd),
   105e4:	4620      	mov	r0, r4
   105e6:	4a03      	ldr	r2, [pc, #12]	; (105f4 <nrf91_socket_create+0x70>)
   105e8:	3101      	adds	r1, #1
   105ea:	f7fc fea9 	bl	d340 <z_finalize_fd>
}
   105ee:	4620      	mov	r0, r4
   105f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   105f2:	bf00      	nop
   105f4:	0001dd38 	.word	0x0001dd38

000105f8 <nrf91_socket_offload_sendmsg>:
{
   105f8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   105fc:	4607      	mov	r7, r0
   105fe:	4690      	mov	r8, r2
	if (msg == NULL) {
   10600:	460c      	mov	r4, r1
   10602:	b319      	cbz	r1, 1064c <nrf91_socket_offload_sendmsg+0x54>
	for (i = 0; i < msg->msg_iovlen; i++) {
   10604:	2300      	movs	r3, #0
	ssize_t len = 0;
   10606:	461a      	mov	r2, r3
   10608:	68c8      	ldr	r0, [r1, #12]
	for (i = 0; i < msg->msg_iovlen; i++) {
   1060a:	4298      	cmp	r0, r3
   1060c:	d128      	bne.n	10660 <nrf91_socket_offload_sendmsg+0x68>
	if (len <= sizeof(buf)) {
   1060e:	2a80      	cmp	r2, #128	; 0x80
   10610:	d857      	bhi.n	106c2 <nrf91_socket_offload_sendmsg+0xca>
		for (i = 0; i < msg->msg_iovlen; i++) {
   10612:	2500      	movs	r5, #0
	return z_impl_k_mutex_lock(mutex, timeout);
   10614:	f04f 32ff 	mov.w	r2, #4294967295
   10618:	f04f 33ff 	mov.w	r3, #4294967295
   1061c:	482a      	ldr	r0, [pc, #168]	; (106c8 <nrf91_socket_offload_sendmsg+0xd0>)
   1061e:	f009 fe15 	bl	1a24c <z_impl_k_mutex_lock>
		len = 0;
   10622:	462e      	mov	r6, r5
			memcpy(buf + len, msg->msg_iov[i].iov_base,
   10624:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 106cc <nrf91_socket_offload_sendmsg+0xd4>
		for (i = 0; i < msg->msg_iovlen; i++) {
   10628:	68e3      	ldr	r3, [r4, #12]
   1062a:	42ab      	cmp	r3, r5
   1062c:	d81f      	bhi.n	1066e <nrf91_socket_offload_sendmsg+0x76>
		ret = nrf91_socket_offload_sendto(obj, buf, len,
   1062e:	6863      	ldr	r3, [r4, #4]
   10630:	4632      	mov	r2, r6
   10632:	9301      	str	r3, [sp, #4]
   10634:	6823      	ldr	r3, [r4, #0]
   10636:	4638      	mov	r0, r7
   10638:	9300      	str	r3, [sp, #0]
   1063a:	4924      	ldr	r1, [pc, #144]	; (106cc <nrf91_socket_offload_sendmsg+0xd4>)
   1063c:	4643      	mov	r3, r8
   1063e:	f00c fade 	bl	1cbfe <nrf91_socket_offload_sendto>
   10642:	4605      	mov	r5, r0
	return z_impl_k_mutex_unlock(mutex);
   10644:	4820      	ldr	r0, [pc, #128]	; (106c8 <nrf91_socket_offload_sendmsg+0xd0>)
   10646:	f009 fe79 	bl	1a33c <z_impl_k_mutex_unlock>
		return ret;
   1064a:	e005      	b.n	10658 <nrf91_socket_offload_sendmsg+0x60>
		errno = EINVAL;
   1064c:	f00c f8d0 	bl	1c7f0 <z_errno>
   10650:	2316      	movs	r3, #22
		return -1;
   10652:	f04f 35ff 	mov.w	r5, #4294967295
		errno = EINVAL;
   10656:	6003      	str	r3, [r0, #0]
}
   10658:	4628      	mov	r0, r5
   1065a:	b002      	add	sp, #8
   1065c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		len += msg->msg_iov[i].iov_len;
   10660:	68a1      	ldr	r1, [r4, #8]
   10662:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   10666:	6849      	ldr	r1, [r1, #4]
	for (i = 0; i < msg->msg_iovlen; i++) {
   10668:	3301      	adds	r3, #1
		len += msg->msg_iov[i].iov_len;
   1066a:	440a      	add	r2, r1
	for (i = 0; i < msg->msg_iovlen; i++) {
   1066c:	e7cd      	b.n	1060a <nrf91_socket_offload_sendmsg+0x12>
			memcpy(buf + len, msg->msg_iov[i].iov_base,
   1066e:	68a1      	ldr	r1, [r4, #8]
   10670:	eb09 0006 	add.w	r0, r9, r6
   10674:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
   10678:	685a      	ldr	r2, [r3, #4]
   1067a:	f851 1035 	ldr.w	r1, [r1, r5, lsl #3]
   1067e:	f00b fcb1 	bl	1bfe4 <memcpy>
			len += msg->msg_iov[i].iov_len;
   10682:	68a3      	ldr	r3, [r4, #8]
   10684:	ea4f 0ac5 	mov.w	sl, r5, lsl #3
   10688:	4453      	add	r3, sl
   1068a:	685b      	ldr	r3, [r3, #4]
		for (i = 0; i < msg->msg_iovlen; i++) {
   1068c:	3501      	adds	r5, #1
			len += msg->msg_iov[i].iov_len;
   1068e:	441e      	add	r6, r3
		for (i = 0; i < msg->msg_iovlen; i++) {
   10690:	e7ca      	b.n	10628 <nrf91_socket_offload_sendmsg+0x30>
		if (msg->msg_iov[i].iov_len == 0) {
   10692:	68a1      	ldr	r1, [r4, #8]
   10694:	eb01 03c6 	add.w	r3, r1, r6, lsl #3
   10698:	685a      	ldr	r2, [r3, #4]
   1069a:	b162      	cbz	r2, 106b6 <nrf91_socket_offload_sendmsg+0xbe>
		ret = nrf91_socket_offload_sendto(obj, msg->msg_iov[i].iov_base,
   1069c:	6863      	ldr	r3, [r4, #4]
   1069e:	4638      	mov	r0, r7
   106a0:	9301      	str	r3, [sp, #4]
   106a2:	6823      	ldr	r3, [r4, #0]
   106a4:	9300      	str	r3, [sp, #0]
   106a6:	f851 1036 	ldr.w	r1, [r1, r6, lsl #3]
   106aa:	4643      	mov	r3, r8
   106ac:	f00c faa7 	bl	1cbfe <nrf91_socket_offload_sendto>
		if (ret < 0) {
   106b0:	1e05      	subs	r5, r0, #0
   106b2:	dbd1      	blt.n	10658 <nrf91_socket_offload_sendmsg+0x60>
		len += ret;
   106b4:	44a9      	add	r9, r5
	for (i = 0; i < msg->msg_iovlen; i++) {
   106b6:	3601      	adds	r6, #1
   106b8:	68e3      	ldr	r3, [r4, #12]
   106ba:	429e      	cmp	r6, r3
   106bc:	d3e9      	bcc.n	10692 <nrf91_socket_offload_sendmsg+0x9a>
   106be:	464d      	mov	r5, r9
   106c0:	e7ca      	b.n	10658 <nrf91_socket_offload_sendmsg+0x60>
   106c2:	2600      	movs	r6, #0
	len = 0;
   106c4:	46b1      	mov	r9, r6
   106c6:	e7f7      	b.n	106b8 <nrf91_socket_offload_sendmsg+0xc0>
   106c8:	200201ec 	.word	0x200201ec
   106cc:	200225e0 	.word	0x200225e0

000106d0 <nrf91_socket_offload_accept>:
{
   106d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   106d4:	b08a      	sub	sp, #40	; 0x28
   106d6:	4607      	mov	r7, r0
   106d8:	460c      	mov	r4, r1
   106da:	4615      	mov	r5, r2
	int fd = z_reserve_fd();
   106dc:	f7fc fe0c 	bl	d2f8 <z_reserve_fd>
   106e0:	4606      	mov	r6, r0
	if (fd < 0) {
   106e2:	2e00      	cmp	r6, #0
	int sd = OBJ_TO_SD(obj);
   106e4:	f107 30ff 	add.w	r0, r7, #4294967295
	if (fd < 0) {
   106e8:	da05      	bge.n	106f6 <nrf91_socket_offload_accept+0x26>
	return -1;
   106ea:	f04f 36ff 	mov.w	r6, #4294967295
}
   106ee:	4630      	mov	r0, r6
   106f0:	b00a      	add	sp, #40	; 0x28
   106f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((addr != NULL) && (addrlen != NULL)) {
   106f6:	b31c      	cbz	r4, 10740 <nrf91_socket_offload_accept+0x70>
   106f8:	b32d      	cbz	r5, 10746 <nrf91_socket_offload_accept+0x76>
		if (*addrlen == sizeof(struct sockaddr_in)) {
   106fa:	682b      	ldr	r3, [r5, #0]
		nrf_addrlen_ptr = &nrf_addrlen;
   106fc:	466a      	mov	r2, sp
		if (*addrlen == sizeof(struct sockaddr_in)) {
   106fe:	2b08      	cmp	r3, #8
			nrf_addrlen = sizeof(struct nrf_sockaddr_in);
   10700:	bf0c      	ite	eq
   10702:	2310      	moveq	r3, #16
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   10704:	2324      	movne	r3, #36	; 0x24
		nrf_addr_ptr = (struct nrf_sockaddr *)&nrf_addr;
   10706:	af01      	add	r7, sp, #4
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   10708:	9300      	str	r3, [sp, #0]
	new_sd = nrf_accept(sd, nrf_addr_ptr, nrf_addrlen_ptr);
   1070a:	4639      	mov	r1, r7
   1070c:	f007 f9c6 	bl	17a9c <nrf_accept>
	if (new_sd < 0) {
   10710:	f1b0 0800 	subs.w	r8, r0, #0
   10714:	dbe9      	blt.n	106ea <nrf91_socket_offload_accept+0x1a>
	if ((addr != NULL) && (addrlen != NULL)) {
   10716:	b164      	cbz	r4, 10732 <nrf91_socket_offload_accept+0x62>
   10718:	b15d      	cbz	r5, 10732 <nrf91_socket_offload_accept+0x62>
		if (nrf_addr_ptr->sa_family == NRF_AF_INET) {
   1071a:	687b      	ldr	r3, [r7, #4]
   1071c:	2b02      	cmp	r3, #2
   1071e:	d115      	bne.n	1074c <nrf91_socket_offload_accept+0x7c>
			*addrlen = sizeof(struct sockaddr_in);
   10720:	2308      	movs	r3, #8
   10722:	602b      	str	r3, [r5, #0]
	ptr->sin_port = nrf_in->sin_port;
   10724:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   10728:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   1072a:	2301      	movs	r3, #1
   1072c:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   1072e:	9b04      	ldr	r3, [sp, #16]
   10730:	6063      	str	r3, [r4, #4]
	z_finalize_fd(fd, SD_TO_OBJ(new_sd),
   10732:	4630      	mov	r0, r6
   10734:	4a10      	ldr	r2, [pc, #64]	; (10778 <nrf91_socket_offload_accept+0xa8>)
   10736:	f108 0101 	add.w	r1, r8, #1
   1073a:	f7fc fe01 	bl	d340 <z_finalize_fd>
	return fd;
   1073e:	e7d6      	b.n	106ee <nrf91_socket_offload_accept+0x1e>
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   10740:	4622      	mov	r2, r4
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   10742:	4627      	mov	r7, r4
   10744:	e7e1      	b.n	1070a <nrf91_socket_offload_accept+0x3a>
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   10746:	462a      	mov	r2, r5
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   10748:	462f      	mov	r7, r5
   1074a:	e7de      	b.n	1070a <nrf91_socket_offload_accept+0x3a>
		} else if (nrf_addr_ptr->sa_family == NRF_AF_INET6) {
   1074c:	2b0a      	cmp	r3, #10
   1074e:	d10f      	bne.n	10770 <nrf91_socket_offload_accept+0xa0>
			*addrlen = sizeof(struct sockaddr_in6);
   10750:	2318      	movs	r3, #24
   10752:	602b      	str	r3, [r5, #0]
	ptr->sin6_port = nrf_in->sin6_port;
   10754:	f8bd 300c 	ldrh.w	r3, [sp, #12]
	ptr->sin6_family = AF_INET6;
   10758:	4620      	mov	r0, r4
	ptr->sin6_port = nrf_in->sin6_port;
   1075a:	8063      	strh	r3, [r4, #2]
	ptr->sin6_family = AF_INET6;
   1075c:	2302      	movs	r3, #2
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1075e:	2210      	movs	r2, #16
	ptr->sin6_family = AF_INET6;
   10760:	f820 3b04 	strh.w	r3, [r0], #4
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   10764:	a905      	add	r1, sp, #20
   10766:	f00b fc3d 	bl	1bfe4 <memcpy>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   1076a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1076c:	7523      	strb	r3, [r4, #20]
}
   1076e:	e7e0      	b.n	10732 <nrf91_socket_offload_accept+0x62>
	z_free_fd(fd);
   10770:	4630      	mov	r0, r6
   10772:	f7fc fdef 	bl	d354 <z_free_fd>
   10776:	e7b8      	b.n	106ea <nrf91_socket_offload_accept+0x1a>
   10778:	0001dd38 	.word	0x0001dd38

0001077c <callback_worker>:

	return new_len;
}

static void callback_worker(struct k_work *item)
{
   1077c:	b507      	push	{r0, r1, r2, lr}
	struct callback_work_item *data =
   1077e:	9001      	str	r0, [sp, #4]
		CONTAINER_OF(item, struct callback_work_item, work);

	if (data != NULL) {
   10780:	b118      	cbz	r0, 1078a <callback_worker+0xe>
		data->callback(data->data);
   10782:	f8d0 3a98 	ldr.w	r3, [r0, #2712]	; 0xa98
   10786:	300c      	adds	r0, #12
   10788:	4798      	blx	r3
	}

	k_mem_slab_free(&rsp_work_items, (void **)&data);
   1078a:	4803      	ldr	r0, [pc, #12]	; (10798 <callback_worker+0x1c>)
   1078c:	a901      	add	r1, sp, #4
   1078e:	f009 fc61 	bl	1a054 <k_mem_slab_free>
}
   10792:	b003      	add	sp, #12
   10794:	f85d fb04 	ldr.w	pc, [sp], #4
   10798:	20020190 	.word	0x20020190

0001079c <at_write>:
		}
	}
}

static inline int at_write(const char *const cmd, enum at_cmd_state *state)
{
   1079c:	b530      	push	{r4, r5, lr}
   1079e:	b085      	sub	sp, #20
   107a0:	4605      	mov	r5, r0
   107a2:	460c      	mov	r4, r1
	int bytes_sent;
	int bytes_to_send = strlen(cmd);
   107a4:	f00b fbec 	bl	1bf80 <strlen>
	struct return_state_object ret;

	LOG_DBG("Sending command %s", log_strdup(cmd));

	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   107a8:	4b11      	ldr	r3, [pc, #68]	; (107f0 <at_write+0x54>)
	int bytes_to_send = strlen(cmd);
   107aa:	4602      	mov	r2, r0
	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   107ac:	6818      	ldr	r0, [r3, #0]
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   107ae:	2300      	movs	r3, #0
   107b0:	4629      	mov	r1, r5
   107b2:	e9cd 3300 	strd	r3, r3, [sp]
   107b6:	f00b f9f5 	bl	1bba4 <z_impl_zsock_sendto>

	if (bytes_sent == -1) {
   107ba:	3001      	adds	r0, #1
   107bc:	d10e      	bne.n	107dc <at_write+0x40>
   107be:	f009 fafb 	bl	19db8 <z_impl_z_errno>
		LOG_ERR("Failed to send AT command (err:%d)", errno);
		ret.code  = -errno;
   107c2:	6803      	ldr	r3, [r0, #0]
   107c4:	425b      	negs	r3, r3
   107c6:	9302      	str	r3, [sp, #8]
		ret.state = AT_CMD_ERROR;
   107c8:	2301      	movs	r3, #1
   107ca:	f88d 300c 	strb.w	r3, [sp, #12]
				"same as expected (%d)",
				bytes_sent, bytes_to_send);
		}
	}

	if (state) {
   107ce:	b114      	cbz	r4, 107d6 <at_write+0x3a>
		*state = ret.state;
   107d0:	f89d 300c 	ldrb.w	r3, [sp, #12]
   107d4:	7023      	strb	r3, [r4, #0]
	}

	return ret.code;
}
   107d6:	9802      	ldr	r0, [sp, #8]
   107d8:	b005      	add	sp, #20
   107da:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_msgq_get(msgq, data, timeout);
   107dc:	f04f 32ff 	mov.w	r2, #4294967295
   107e0:	f04f 33ff 	mov.w	r3, #4294967295
   107e4:	a902      	add	r1, sp, #8
   107e6:	4803      	ldr	r0, [pc, #12]	; (107f4 <at_write+0x58>)
   107e8:	f009 fcd2 	bl	1a190 <z_impl_k_msgq_get>
			LOG_ERR("Bytes sent (%d) was not the "
   107ec:	e7ef      	b.n	107ce <at_write+0x32>
   107ee:	bf00      	nop
   107f0:	20020374 	.word	0x20020374
   107f4:	20020214 	.word	0x20020214

000107f8 <open_socket>:
{
   107f8:	b508      	push	{r3, lr}
	return z_impl_zsock_socket(family, type, proto);
   107fa:	f240 2201 	movw	r2, #513	; 0x201
   107fe:	2102      	movs	r1, #2
   10800:	2066      	movs	r0, #102	; 0x66
   10802:	f7fc fff5 	bl	d7f0 <z_impl_zsock_socket>
	common_socket_fd = socket(AF_LTE, SOCK_DGRAM, NPROTO_AT);
   10806:	4b05      	ldr	r3, [pc, #20]	; (1081c <open_socket+0x24>)
   10808:	6018      	str	r0, [r3, #0]
	if (common_socket_fd == -1) {
   1080a:	3001      	adds	r0, #1
   1080c:	d104      	bne.n	10818 <open_socket+0x20>
   1080e:	f009 fad3 	bl	19db8 <z_impl_z_errno>
		return -errno;
   10812:	6800      	ldr	r0, [r0, #0]
   10814:	4240      	negs	r0, r0
}
   10816:	bd08      	pop	{r3, pc}
	return 0;
   10818:	2000      	movs	r0, #0
   1081a:	e7fc      	b.n	10816 <open_socket+0x1e>
   1081c:	20020374 	.word	0x20020374

00010820 <at_cmd_driver_init>:

	k_sem_give(&cmd_pending);
}

static int at_cmd_driver_init(struct device *dev)
{
   10820:	b530      	push	{r4, r5, lr}
	static bool initialized;

	if (initialized) {
   10822:	4d10      	ldr	r5, [pc, #64]	; (10864 <at_cmd_driver_init+0x44>)
{
   10824:	b089      	sub	sp, #36	; 0x24
	if (initialized) {
   10826:	782b      	ldrb	r3, [r5, #0]
   10828:	b9cb      	cbnz	r3, 1085e <at_cmd_driver_init+0x3e>

	int err;

	ARG_UNUSED(dev);

	err = open_socket();
   1082a:	f7ff ffe5 	bl	107f8 <open_socket>
	if (err) {
   1082e:	4604      	mov	r4, r0
   10830:	b990      	cbnz	r0, 10858 <at_cmd_driver_init+0x38>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   10832:	2200      	movs	r2, #0
   10834:	2300      	movs	r3, #0
   10836:	e9cd 2306 	strd	r2, r3, [sp, #24]
   1083a:	230a      	movs	r3, #10
   1083c:	e9cd 0000 	strd	r0, r0, [sp]
   10840:	e9cd 0302 	strd	r0, r3, [sp, #8]
   10844:	9004      	str	r0, [sp, #16]
   10846:	4b08      	ldr	r3, [pc, #32]	; (10868 <at_cmd_driver_init+0x48>)
   10848:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1084c:	4907      	ldr	r1, [pc, #28]	; (1086c <at_cmd_driver_init+0x4c>)
   1084e:	4808      	ldr	r0, [pc, #32]	; (10870 <at_cmd_driver_init+0x50>)
   10850:	f00a f9cc 	bl	1abec <z_impl_k_thread_create>
			K_THREAD_STACK_SIZEOF(socket_thread_stack),
			socket_thread_fn,
			NULL, NULL, NULL,
			THREAD_PRIORITY, 0, K_NO_WAIT);

	initialized = true;
   10854:	2301      	movs	r3, #1
   10856:	702b      	strb	r3, [r5, #0]
	LOG_DBG("Common AT socket processing thread created");

	return 0;
}
   10858:	4620      	mov	r0, r4
   1085a:	b009      	add	sp, #36	; 0x24
   1085c:	bd30      	pop	{r4, r5, pc}
		return 0;
   1085e:	2400      	movs	r4, #0
   10860:	e7fa      	b.n	10858 <at_cmd_driver_init+0x38>
   10862:	bf00      	nop
   10864:	20022660 	.word	0x20022660
   10868:	00010875 	.word	0x00010875
   1086c:	200237e0 	.word	0x200237e0
   10870:	20020388 	.word	0x20020388

00010874 <socket_thread_fn>:
{
   10874:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		bytes_read = recv(common_socket_fd, item->data,
   10878:	4e69      	ldr	r6, [pc, #420]	; (10a20 <socket_thread_fn+0x1ac>)
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   1087a:	4f6a      	ldr	r7, [pc, #424]	; (10a24 <socket_thread_fn+0x1b0>)
   1087c:	46b0      	mov	r8, r6
{
   1087e:	b086      	sub	sp, #24
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   10880:	a903      	add	r1, sp, #12
   10882:	f04f 32ff 	mov.w	r2, #4294967295
   10886:	f04f 33ff 	mov.w	r3, #4294967295
   1088a:	4638      	mov	r0, r7
   1088c:	f009 fbb0 	bl	19ff0 <k_mem_slab_alloc>
		ret.code  = 0;
   10890:	2300      	movs	r3, #0
		item->callback = NULL;
   10892:	9903      	ldr	r1, [sp, #12]
		bytes_read = recv(common_socket_fd, item->data,
   10894:	6830      	ldr	r0, [r6, #0]
		ret.code  = 0;
   10896:	9304      	str	r3, [sp, #16]
		ret.state = AT_CMD_OK;
   10898:	f88d 3014 	strb.w	r3, [sp, #20]
		item->callback = NULL;
   1089c:	f8c1 3a98 	str.w	r3, [r1, #2712]	; 0xa98
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   108a0:	f640 228c 	movw	r2, #2700	; 0xa8c
   108a4:	e9cd 3300 	strd	r3, r3, [sp]
   108a8:	310c      	adds	r1, #12
   108aa:	f00b f994 	bl	1bbd6 <z_impl_zsock_recvfrom>
		if (bytes_read < 0) {
   108ae:	2800      	cmp	r0, #0
   108b0:	da31      	bge.n	10916 <socket_thread_fn+0xa2>
			if ((close(common_socket_fd) == 0) &&
   108b2:	6830      	ldr	r0, [r6, #0]
	return z_impl_zsock_close(sock);
   108b4:	f00b f94f 	bl	1bb56 <z_impl_zsock_close>
   108b8:	bb30      	cbnz	r0, 10908 <socket_thread_fn+0x94>
			    (open_socket() == 0)) {
   108ba:	f7ff ff9d 	bl	107f8 <open_socket>
			if ((close(common_socket_fd) == 0) &&
   108be:	bb18      	cbnz	r0, 10908 <socket_thread_fn+0x94>
				ret.state = AT_CMD_ERROR;
   108c0:	2301      	movs	r3, #1
   108c2:	f88d 3014 	strb.w	r3, [sp, #20]
   108c6:	f009 fa77 	bl	19db8 <z_impl_z_errno>
				ret.code  = -errno;
   108ca:	6803      	ldr	r3, [r0, #0]
   108cc:	425b      	negs	r3, r3
			ret.code  = -ENOBUFS;
   108ce:	9304      	str	r3, [sp, #16]
		if (item->callback == NULL) {
   108d0:	9903      	ldr	r1, [sp, #12]
   108d2:	f8d1 3a98 	ldr.w	r3, [r1, #2712]	; 0xa98
   108d6:	2b00      	cmp	r3, #0
   108d8:	d179      	bne.n	109ce <socket_thread_fn+0x15a>
			k_mem_slab_free(&rsp_work_items, (void **)&item);
   108da:	4638      	mov	r0, r7
   108dc:	a903      	add	r1, sp, #12
   108de:	f009 fbb9 	bl	1a054 <k_mem_slab_free>
	return z_impl_k_sem_count_get(sem);
   108e2:	4b51      	ldr	r3, [pc, #324]	; (10a28 <socket_thread_fn+0x1b4>)
		if ((k_sem_count_get(&cmd_pending) == 0) &&
   108e4:	689b      	ldr	r3, [r3, #8]
   108e6:	2b00      	cmp	r3, #0
   108e8:	d1ca      	bne.n	10880 <socket_thread_fn+0xc>
   108ea:	f89d 2014 	ldrb.w	r2, [sp, #20]
   108ee:	2a04      	cmp	r2, #4
   108f0:	d0c6      	beq.n	10880 <socket_thread_fn+0xc>
			current_cmd_handler = NULL;
   108f2:	4a4e      	ldr	r2, [pc, #312]	; (10a2c <socket_thread_fn+0x1b8>)
   108f4:	6013      	str	r3, [r2, #0]
	return z_impl_k_msgq_put(msgq, data, timeout);
   108f6:	f04f 32ff 	mov.w	r2, #4294967295
   108fa:	f04f 33ff 	mov.w	r3, #4294967295
   108fe:	a904      	add	r1, sp, #16
   10900:	484b      	ldr	r0, [pc, #300]	; (10a30 <socket_thread_fn+0x1bc>)
   10902:	f009 fbf1 	bl	1a0e8 <z_impl_k_msgq_put>
	for (;;) {
   10906:	e7bb      	b.n	10880 <socket_thread_fn+0xc>
			close(common_socket_fd);
   10908:	f8d8 0000 	ldr.w	r0, [r8]
   1090c:	f00b f923 	bl	1bb56 <z_impl_zsock_close>
}
   10910:	b006      	add	sp, #24
   10912:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (item->data[bytes_read - 1] != '\0') {
   10916:	f8dd 900c 	ldr.w	r9, [sp, #12]
   1091a:	4448      	add	r0, r9
   1091c:	f890 a00b 	ldrb.w	sl, [r0, #11]
   10920:	f1ba 0f00 	cmp.w	sl, #0
   10924:	d002      	beq.n	1092c <socket_thread_fn+0xb8>
			ret.code  = -ENOBUFS;
   10926:	f06f 0336 	mvn.w	r3, #54	; 0x36
   1092a:	e7d0      	b.n	108ce <socket_thread_fn+0x5a>
	ret->state = AT_CMD_NOTIFICATION;
   1092c:	2304      	movs	r3, #4
		payload_len = get_return_code(item->data, &ret);
   1092e:	f109 050c 	add.w	r5, r9, #12
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   10932:	4628      	mov	r0, r5
   10934:	493f      	ldr	r1, [pc, #252]	; (10a34 <socket_thread_fn+0x1c0>)
	ret->state = AT_CMD_NOTIFICATION;
   10936:	f88d 3014 	strb.w	r3, [sp, #20]
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   1093a:	f00b faf3 	bl	1bf24 <strstr>
		if (tmpstr) {
   1093e:	4604      	mov	r4, r0
   10940:	b1e8      	cbz	r0, 1097e <socket_thread_fn+0x10a>
			ret->state = AT_CMD_OK;
   10942:	f88d a014 	strb.w	sl, [sp, #20]
			ret->code  = 0;
   10946:	f8cd a010 	str.w	sl, [sp, #16]
		buf[new_len++] = '\0';
   1094a:	2300      	movs	r3, #0
		new_len = tmpstr - buf;
   1094c:	1b62      	subs	r2, r4, r5
		buf[new_len++] = '\0';
   1094e:	3201      	adds	r2, #1
   10950:	7023      	strb	r3, [r4, #0]
		if (ret.state != AT_CMD_NOTIFICATION) {
   10952:	f89d 3014 	ldrb.w	r3, [sp, #20]
   10956:	9903      	ldr	r1, [sp, #12]
   10958:	2b04      	cmp	r3, #4
   1095a:	d04e      	beq.n	109fa <socket_thread_fn+0x186>
			if ((response_buf_len > 0) &&
   1095c:	4d36      	ldr	r5, [pc, #216]	; (10a38 <socket_thread_fn+0x1c4>)
   1095e:	682b      	ldr	r3, [r5, #0]
   10960:	2b00      	cmp	r3, #0
   10962:	d052      	beq.n	10a0a <socket_thread_fn+0x196>
			    (response_buf != NULL)) {
   10964:	4c35      	ldr	r4, [pc, #212]	; (10a3c <socket_thread_fn+0x1c8>)
   10966:	6820      	ldr	r0, [r4, #0]
			if ((response_buf_len > 0) &&
   10968:	2800      	cmp	r0, #0
   1096a:	d04e      	beq.n	10a0a <socket_thread_fn+0x196>
				if (response_buf_len >= payload_len) {
   1096c:	4293      	cmp	r3, r2
   1096e:	d32a      	bcc.n	109c6 <socket_thread_fn+0x152>
					memcpy(response_buf, item->data,
   10970:	310c      	adds	r1, #12
   10972:	f00b fb37 	bl	1bfe4 <memcpy>
				response_buf_len = 0;
   10976:	2300      	movs	r3, #0
   10978:	602b      	str	r3, [r5, #0]
				response_buf     = NULL;
   1097a:	6023      	str	r3, [r4, #0]
				goto next;
   1097c:	e7a8      	b.n	108d0 <socket_thread_fn+0x5c>
		tmpstr = strstr(buf, AT_CMD_CMS_STR);
   1097e:	4628      	mov	r0, r5
   10980:	492f      	ldr	r1, [pc, #188]	; (10a40 <socket_thread_fn+0x1cc>)
   10982:	f00b facf 	bl	1bf24 <strstr>
		if (tmpstr) {
   10986:	4604      	mov	r4, r0
   10988:	b140      	cbz	r0, 1099c <socket_thread_fn+0x128>
			ret->state = AT_CMD_ERROR_CMS;
   1098a:	2302      	movs	r3, #2
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   1098c:	f109 0017 	add.w	r0, r9, #23
			ret->state = AT_CMD_ERROR_CME;
   10990:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   10994:	f00b f9b1 	bl	1bcfa <atoi>
   10998:	9004      	str	r0, [sp, #16]
			break;
   1099a:	e7d6      	b.n	1094a <socket_thread_fn+0xd6>
		tmpstr = strstr(buf, AT_CMD_CME_STR);
   1099c:	4628      	mov	r0, r5
   1099e:	4929      	ldr	r1, [pc, #164]	; (10a44 <socket_thread_fn+0x1d0>)
   109a0:	f00b fac0 	bl	1bf24 <strstr>
		if (tmpstr) {
   109a4:	4604      	mov	r4, r0
   109a6:	b108      	cbz	r0, 109ac <socket_thread_fn+0x138>
			ret->state = AT_CMD_ERROR_CME;
   109a8:	2303      	movs	r3, #3
   109aa:	e7ef      	b.n	1098c <socket_thread_fn+0x118>
		tmpstr = strstr(buf, AT_CMD_ERROR_STR);
   109ac:	4628      	mov	r0, r5
   109ae:	4926      	ldr	r1, [pc, #152]	; (10a48 <socket_thread_fn+0x1d4>)
   109b0:	f00b fab8 	bl	1bf24 <strstr>
		if (tmpstr) {
   109b4:	4604      	mov	r4, r0
   109b6:	b368      	cbz	r0, 10a14 <socket_thread_fn+0x1a0>
			ret->state = AT_CMD_ERROR;
   109b8:	2301      	movs	r3, #1
   109ba:	f88d 3014 	strb.w	r3, [sp, #20]
			ret->code  = -ENOEXEC;
   109be:	f06f 0307 	mvn.w	r3, #7
   109c2:	9304      	str	r3, [sp, #16]
			break;
   109c4:	e7c1      	b.n	1094a <socket_thread_fn+0xd6>
					ret.code  = -EMSGSIZE;
   109c6:	f06f 0323 	mvn.w	r3, #35	; 0x23
   109ca:	9304      	str	r3, [sp, #16]
   109cc:	e7d3      	b.n	10976 <socket_thread_fn+0x102>
 *
 * @return N/A
 */
static inline void k_work_init(struct k_work *work, k_work_handler_t handler)
{
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   109ce:	4b1f      	ldr	r3, [pc, #124]	; (10a4c <socket_thread_fn+0x1d8>)
   109d0:	2200      	movs	r2, #0
   109d2:	604b      	str	r3, [r1, #4]
   109d4:	460b      	mov	r3, r1
   109d6:	600a      	str	r2, [r1, #0]
   109d8:	f843 2f08 	str.w	r2, [r3, #8]!
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   109dc:	e8d3 2fef 	ldaex	r2, [r3]
   109e0:	f042 0001 	orr.w	r0, r2, #1
   109e4:	e8c3 0fe4 	stlex	r4, r0, [r3]
   109e8:	2c00      	cmp	r4, #0
   109ea:	d1f7      	bne.n	109dc <socket_thread_fn+0x168>
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   109ec:	07d3      	lsls	r3, r2, #31
   109ee:	f53f af78 	bmi.w	108e2 <socket_thread_fn+0x6e>
		k_queue_append(&work_q->queue, work);
   109f2:	4817      	ldr	r0, [pc, #92]	; (10a50 <socket_thread_fn+0x1dc>)
   109f4:	f00c fcd4 	bl	1d3a0 <k_queue_append>
   109f8:	e773      	b.n	108e2 <socket_thread_fn+0x6e>
		if (payload_len == 0) {
   109fa:	2a00      	cmp	r2, #0
   109fc:	f43f af68 	beq.w	108d0 <socket_thread_fn+0x5c>
			item->callback = notification_handler;
   10a00:	4b14      	ldr	r3, [pc, #80]	; (10a54 <socket_thread_fn+0x1e0>)
			item->callback = current_cmd_handler;
   10a02:	681b      	ldr	r3, [r3, #0]
   10a04:	f8c1 3a98 	str.w	r3, [r1, #2712]	; 0xa98
   10a08:	e762      	b.n	108d0 <socket_thread_fn+0x5c>
		if (payload_len == 0) {
   10a0a:	2a00      	cmp	r2, #0
   10a0c:	f43f af60 	beq.w	108d0 <socket_thread_fn+0x5c>
			item->callback = current_cmd_handler;
   10a10:	4b06      	ldr	r3, [pc, #24]	; (10a2c <socket_thread_fn+0x1b8>)
   10a12:	e7f6      	b.n	10a02 <socket_thread_fn+0x18e>
		new_len = strlen(buf) + 1;
   10a14:	4628      	mov	r0, r5
   10a16:	f00b fab3 	bl	1bf80 <strlen>
   10a1a:	1c42      	adds	r2, r0, #1
   10a1c:	e799      	b.n	10952 <socket_thread_fn+0xde>
   10a1e:	bf00      	nop
   10a20:	20020374 	.word	0x20020374
   10a24:	20020190 	.word	0x20020190
   10a28:	200201c0 	.word	0x200201c0
   10a2c:	20020378 	.word	0x20020378
   10a30:	20020214 	.word	0x20020214
   10a34:	0001e49c 	.word	0x0001e49c
   10a38:	20020384 	.word	0x20020384
   10a3c:	20020380 	.word	0x20020380
   10a40:	0001e549 	.word	0x0001e549
   10a44:	0001e555 	.word	0x0001e555
   10a48:	0001e561 	.word	0x0001e561
   10a4c:	0001077d 	.word	0x0001077d
   10a50:	20021fa4 	.word	0x20021fa4
   10a54:	2002037c 	.word	0x2002037c

00010a58 <at_cmd_write>:
{
   10a58:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   10a5a:	4604      	mov	r4, r0
   10a5c:	460e      	mov	r6, r1
   10a5e:	4615      	mov	r5, r2
   10a60:	9301      	str	r3, [sp, #4]
	return z_impl_k_sem_take(sem, timeout);
   10a62:	4f0b      	ldr	r7, [pc, #44]	; (10a90 <at_cmd_write+0x38>)
   10a64:	f04f 32ff 	mov.w	r2, #4294967295
   10a68:	f04f 33ff 	mov.w	r3, #4294967295
   10a6c:	4638      	mov	r0, r7
   10a6e:	f00a f855 	bl	1ab1c <z_impl_k_sem_take>
	response_buf     = buf;
   10a72:	4b08      	ldr	r3, [pc, #32]	; (10a94 <at_cmd_write+0x3c>)
	int return_code = at_write(cmd, state);
   10a74:	4620      	mov	r0, r4
	response_buf     = buf;
   10a76:	601e      	str	r6, [r3, #0]
	response_buf_len = buf_len;
   10a78:	4b07      	ldr	r3, [pc, #28]	; (10a98 <at_cmd_write+0x40>)
	int return_code = at_write(cmd, state);
   10a7a:	9901      	ldr	r1, [sp, #4]
	response_buf_len = buf_len;
   10a7c:	601d      	str	r5, [r3, #0]
	int return_code = at_write(cmd, state);
   10a7e:	f7ff fe8d 	bl	1079c <at_write>
   10a82:	4604      	mov	r4, r0
	z_impl_k_sem_give(sem);
   10a84:	4638      	mov	r0, r7
   10a86:	f00a f823 	bl	1aad0 <z_impl_k_sem_give>
}
   10a8a:	4620      	mov	r0, r4
   10a8c:	b003      	add	sp, #12
   10a8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10a90:	200201c0 	.word	0x200201c0
   10a94:	20020380 	.word	0x20020380
   10a98:	20020384 	.word	0x20020384

00010a9c <at_cmd_set_notification_handler>:
{
   10a9c:	b538      	push	{r3, r4, r5, lr}
   10a9e:	4604      	mov	r4, r0
	return z_impl_k_sem_take(sem, timeout);
   10aa0:	4d07      	ldr	r5, [pc, #28]	; (10ac0 <at_cmd_set_notification_handler+0x24>)
   10aa2:	f04f 32ff 	mov.w	r2, #4294967295
   10aa6:	f04f 33ff 	mov.w	r3, #4294967295
   10aaa:	4628      	mov	r0, r5
   10aac:	f00a f836 	bl	1ab1c <z_impl_k_sem_take>
	notification_handler = handler;
   10ab0:	4b04      	ldr	r3, [pc, #16]	; (10ac4 <at_cmd_set_notification_handler+0x28>)
   10ab2:	601c      	str	r4, [r3, #0]
	z_impl_k_sem_give(sem);
   10ab4:	4628      	mov	r0, r5
}
   10ab6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   10aba:	f00a b809 	b.w	1aad0 <z_impl_k_sem_give>
   10abe:	bf00      	nop
   10ac0:	200201c0 	.word	0x200201c0
   10ac4:	2002037c 	.word	0x2002037c

00010ac8 <find_node>:
static struct notif_handler *find_node(struct notif_handler **prev_out,
	void *ctx, at_notif_handler_t handler)
{
	struct notif_handler *prev = NULL, *curr, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   10ac8:	4b0f      	ldr	r3, [pc, #60]	; (10b08 <find_node+0x40>)
{
   10aca:	b570      	push	{r4, r5, r6, lr}
   10acc:	4604      	mov	r4, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   10ace:	6818      	ldr	r0, [r3, #0]
   10ad0:	b170      	cbz	r0, 10af0 <find_node+0x28>
	return node->next;
   10ad2:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   10ad4:	4603      	mov	r3, r0
   10ad6:	2d00      	cmp	r5, #0
   10ad8:	4628      	mov	r0, r5
   10ada:	bf38      	it	cc
   10adc:	2000      	movcc	r0, #0
   10ade:	2500      	movs	r5, #0
		if (curr->ctx == ctx && curr->handler == handler) {
   10ae0:	685e      	ldr	r6, [r3, #4]
   10ae2:	428e      	cmp	r6, r1
   10ae4:	d105      	bne.n	10af2 <find_node+0x2a>
   10ae6:	689e      	ldr	r6, [r3, #8]
   10ae8:	4296      	cmp	r6, r2
   10aea:	d102      	bne.n	10af2 <find_node+0x2a>
			*prev_out = prev;
			return curr;
   10aec:	4618      	mov	r0, r3
			*prev_out = prev;
   10aee:	6025      	str	r5, [r4, #0]
		}
		prev = curr;
	}
	return NULL;
}
   10af0:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   10af2:	2800      	cmp	r0, #0
   10af4:	d0fc      	beq.n	10af0 <find_node+0x28>
	return node->next;
   10af6:	6806      	ldr	r6, [r0, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   10af8:	461d      	mov	r5, r3
   10afa:	2e00      	cmp	r6, #0
   10afc:	4603      	mov	r3, r0
   10afe:	4630      	mov	r0, r6
   10b00:	bf38      	it	cc
   10b02:	2000      	movcc	r0, #0
   10b04:	e7ec      	b.n	10ae0 <find_node+0x18>
   10b06:	bf00      	nop
   10b08:	20020440 	.word	0x20020440

00010b0c <module_init>:
{
	ARG_UNUSED(dev);

	static bool initialized;

	if (initialized) {
   10b0c:	4a06      	ldr	r2, [pc, #24]	; (10b28 <module_init+0x1c>)
{
   10b0e:	b508      	push	{r3, lr}
	if (initialized) {
   10b10:	7813      	ldrb	r3, [r2, #0]
   10b12:	b93b      	cbnz	r3, 10b24 <module_init+0x18>
		LOG_WRN("Already initialized. Nothing to do");
		return 0;
	}

	initialized = true;
   10b14:	2101      	movs	r1, #1
   10b16:	7011      	strb	r1, [r2, #0]
	list->head = NULL;
   10b18:	4a04      	ldr	r2, [pc, #16]	; (10b2c <module_init+0x20>)

	LOG_DBG("Initialization");
	sys_slist_init(&handler_list);
	at_cmd_set_notification_handler(notif_dispatch);
   10b1a:	4805      	ldr	r0, [pc, #20]	; (10b30 <module_init+0x24>)
	list->tail = NULL;
   10b1c:	e9c2 3300 	strd	r3, r3, [r2]
   10b20:	f7ff ffbc 	bl	10a9c <at_cmd_set_notification_handler>
	return 0;
}
   10b24:	2000      	movs	r0, #0
   10b26:	bd08      	pop	{r3, pc}
   10b28:	20022661 	.word	0x20022661
   10b2c:	20020440 	.word	0x20020440
   10b30:	00010b41 	.word	0x00010b41

00010b34 <k_mutex_unlock.constprop.0>:
	return z_impl_k_mutex_unlock(mutex);
   10b34:	4801      	ldr	r0, [pc, #4]	; (10b3c <k_mutex_unlock.constprop.0+0x8>)
   10b36:	f009 bc01 	b.w	1a33c <z_impl_k_mutex_unlock>
   10b3a:	bf00      	nop
   10b3c:	20020200 	.word	0x20020200

00010b40 <notif_dispatch>:
{
   10b40:	b538      	push	{r3, r4, r5, lr}
   10b42:	4605      	mov	r5, r0
	return z_impl_k_mutex_lock(mutex, timeout);
   10b44:	f04f 33ff 	mov.w	r3, #4294967295
   10b48:	f04f 32ff 	mov.w	r2, #4294967295
   10b4c:	480d      	ldr	r0, [pc, #52]	; (10b84 <notif_dispatch+0x44>)
   10b4e:	f009 fb7d 	bl	1a24c <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   10b52:	4b0d      	ldr	r3, [pc, #52]	; (10b88 <notif_dispatch+0x48>)
   10b54:	681b      	ldr	r3, [r3, #0]
   10b56:	b91b      	cbnz	r3, 10b60 <notif_dispatch+0x20>
}
   10b58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_mutex_unlock(&list_mtx);
   10b5c:	f7ff bfea 	b.w	10b34 <k_mutex_unlock.constprop.0>
	return node->next;
   10b60:	681c      	ldr	r4, [r3, #0]
   10b62:	2c00      	cmp	r4, #0
   10b64:	bf38      	it	cc
   10b66:	2400      	movcc	r4, #0
		curr->handler(curr->ctx, response);
   10b68:	4629      	mov	r1, r5
   10b6a:	689a      	ldr	r2, [r3, #8]
   10b6c:	6858      	ldr	r0, [r3, #4]
   10b6e:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   10b70:	2c00      	cmp	r4, #0
   10b72:	d0f1      	beq.n	10b58 <notif_dispatch+0x18>
   10b74:	6822      	ldr	r2, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   10b76:	4623      	mov	r3, r4
   10b78:	2a00      	cmp	r2, #0
   10b7a:	bf38      	it	cc
   10b7c:	2200      	movcc	r2, #0
   10b7e:	4614      	mov	r4, r2
   10b80:	e7f2      	b.n	10b68 <notif_dispatch+0x28>
   10b82:	bf00      	nop
   10b84:	20020200 	.word	0x20020200
   10b88:	20020440 	.word	0x20020440

00010b8c <at_notif_register_handler>:
{
	return module_init(NULL);
}

int at_notif_register_handler(void *context, at_notif_handler_t handler)
{
   10b8c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   10b8e:	4606      	mov	r6, r0
	if (handler == NULL) {
   10b90:	460d      	mov	r5, r1
   10b92:	b369      	cbz	r1, 10bf0 <at_notif_register_handler+0x64>
   10b94:	f04f 32ff 	mov.w	r2, #4294967295
   10b98:	f04f 33ff 	mov.w	r3, #4294967295
   10b9c:	4816      	ldr	r0, [pc, #88]	; (10bf8 <at_notif_register_handler+0x6c>)
   10b9e:	f009 fb55 	bl	1a24c <z_impl_k_mutex_lock>
	if (find_node(&to_ins, ctx, handler) != NULL) {
   10ba2:	462a      	mov	r2, r5
   10ba4:	4631      	mov	r1, r6
   10ba6:	a801      	add	r0, sp, #4
   10ba8:	f7ff ff8e 	bl	10ac8 <find_node>
   10bac:	4604      	mov	r4, r0
   10bae:	b120      	cbz	r0, 10bba <at_notif_register_handler+0x2e>
		k_mutex_unlock(&list_mtx);
   10bb0:	f7ff ffc0 	bl	10b34 <k_mutex_unlock.constprop.0>
		return 0;
   10bb4:	2000      	movs	r0, #0
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
	}
	return append_notif_handler(context, handler);
}
   10bb6:	b002      	add	sp, #8
   10bb8:	bd70      	pop	{r4, r5, r6, pc}
	to_ins = (struct notif_handler *)k_malloc(sizeof(struct notif_handler));
   10bba:	200c      	movs	r0, #12
   10bbc:	f009 fa74 	bl	1a0a8 <k_malloc>
   10bc0:	9001      	str	r0, [sp, #4]
	if (to_ins == NULL) {
   10bc2:	b920      	cbnz	r0, 10bce <at_notif_register_handler+0x42>
		k_mutex_unlock(&list_mtx);
   10bc4:	f7ff ffb6 	bl	10b34 <k_mutex_unlock.constprop.0>
		return -ENOBUFS;
   10bc8:	f06f 0036 	mvn.w	r0, #54	; 0x36
   10bcc:	e7f3      	b.n	10bb6 <at_notif_register_handler+0x2a>
	memset(to_ins, 0, sizeof(struct notif_handler));
   10bce:	220c      	movs	r2, #12
   10bd0:	4621      	mov	r1, r4
   10bd2:	f00b fa32 	bl	1c03a <memset>
	to_ins->ctx     = ctx;
   10bd6:	9b01      	ldr	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   10bd8:	4a08      	ldr	r2, [pc, #32]	; (10bfc <at_notif_register_handler+0x70>)
	parent->next = child;
   10bda:	601c      	str	r4, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
   10bdc:	6851      	ldr	r1, [r2, #4]
	to_ins->handler = handler;
   10bde:	e9c3 6501 	strd	r6, r5, [r3, #4]
   10be2:	b911      	cbnz	r1, 10bea <at_notif_register_handler+0x5e>
	list->head = node;
   10be4:	e9c2 3300 	strd	r3, r3, [r2]
}
   10be8:	e7e2      	b.n	10bb0 <at_notif_register_handler+0x24>
	parent->next = child;
   10bea:	600b      	str	r3, [r1, #0]
	list->tail = node;
   10bec:	6053      	str	r3, [r2, #4]
}
   10bee:	e7df      	b.n	10bb0 <at_notif_register_handler+0x24>
		return -EINVAL;
   10bf0:	f06f 0015 	mvn.w	r0, #21
   10bf4:	e7df      	b.n	10bb6 <at_notif_register_handler+0x2a>
   10bf6:	bf00      	nop
   10bf8:	20020200 	.word	0x20020200
   10bfc:	20020440 	.word	0x20020440

00010c00 <write_uart_string>:
static struct k_work cmd_send_work;



static inline void write_uart_string(const char *str)
{
   10c00:	b538      	push	{r3, r4, r5, lr}
	/* Send characters until, but not including, null */
	for (size_t i = 0; str[i]; i++) {
		uart_poll_out(uart_dev, str[i]);
   10c02:	4d05      	ldr	r5, [pc, #20]	; (10c18 <write_uart_string+0x18>)
   10c04:	1e44      	subs	r4, r0, #1
	for (size_t i = 0; str[i]; i++) {
   10c06:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   10c0a:	b901      	cbnz	r1, 10c0e <write_uart_string+0xe>
	}
}
   10c0c:	bd38      	pop	{r3, r4, r5, pc}
		uart_poll_out(uart_dev, str[i]);
   10c0e:	6828      	ldr	r0, [r5, #0]
   10c10:	6883      	ldr	r3, [r0, #8]
   10c12:	685b      	ldr	r3, [r3, #4]
   10c14:	4798      	blx	r3
	for (size_t i = 0; str[i]; i++) {
   10c16:	e7f6      	b.n	10c06 <write_uart_string+0x6>
   10c18:	20020528 	.word	0x20020528

00010c1c <cmd_send>:
	/* Forward the data over UART */
	write_uart_string(response);
}

static void cmd_send(struct k_work *work)
{
   10c1c:	b500      	push	{lr}
	enum at_cmd_state state;
	int               err;

	ARG_UNUSED(work);

	err = at_cmd_write(at_buf, at_buf,
   10c1e:	491a      	ldr	r1, [pc, #104]	; (10c88 <cmd_send+0x6c>)
{
   10c20:	b089      	sub	sp, #36	; 0x24
	err = at_cmd_write(at_buf, at_buf,
   10c22:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   10c26:	4608      	mov	r0, r1
   10c28:	f10d 0303 	add.w	r3, sp, #3
   10c2c:	f7ff ff14 	bl	10a58 <at_cmd_write>
			   sizeof(at_buf), &state);
	if (err < 0) {
   10c30:	1e02      	subs	r2, r0, #0
   10c32:	da04      	bge.n	10c3e <cmd_send+0x22>
		LOG_ERR("Error while processing AT command: %d", err);
		state = AT_CMD_ERROR;
   10c34:	2301      	movs	r3, #1
   10c36:	f88d 3003 	strb.w	r3, [sp, #3]
	case AT_CMD_OK:
		write_uart_string(at_buf);
		write_uart_string(OK_STR);
		break;
	case AT_CMD_ERROR:
		write_uart_string(ERROR_STR);
   10c3a:	4814      	ldr	r0, [pc, #80]	; (10c8c <cmd_send+0x70>)
   10c3c:	e012      	b.n	10c64 <cmd_send+0x48>
	switch (state) {
   10c3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
   10c42:	2b03      	cmp	r3, #3
   10c44:	d810      	bhi.n	10c68 <cmd_send+0x4c>
   10c46:	a101      	add	r1, pc, #4	; (adr r1, 10c4c <cmd_send+0x30>)
   10c48:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   10c4c:	00010c5d 	.word	0x00010c5d
   10c50:	00010c3b 	.word	0x00010c3b
   10c54:	00010c77 	.word	0x00010c77
   10c58:	00010c83 	.word	0x00010c83
		write_uart_string(at_buf);
   10c5c:	480a      	ldr	r0, [pc, #40]	; (10c88 <cmd_send+0x6c>)
   10c5e:	f7ff ffcf 	bl	10c00 <write_uart_string>
		write_uart_string(OK_STR);
   10c62:	480b      	ldr	r0, [pc, #44]	; (10c90 <cmd_send+0x74>)
		sprintf(str, "+CMS ERROR: %d\r\n", err);
		write_uart_string(str);
		break;
	case AT_CMD_ERROR_CME:
		sprintf(str, "+CME ERROR: %d\r\n", err);
		write_uart_string(str);
   10c64:	f7ff ffcc 	bl	10c00 <write_uart_string>
		break;
	default:
		break;
	}

	uart_irq_rx_enable(uart_dev);
   10c68:	4b0a      	ldr	r3, [pc, #40]	; (10c94 <cmd_send+0x78>)
   10c6a:	6818      	ldr	r0, [r3, #0]
		arch_syscall_invoke1(*(uintptr_t *)&dev, K_SYSCALL_UART_IRQ_RX_ENABLE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_irq_rx_enable(dev);
   10c6c:	f00c f88e 	bl	1cd8c <z_impl_uart_irq_rx_enable>
}
   10c70:	b009      	add	sp, #36	; 0x24
   10c72:	f85d fb04 	ldr.w	pc, [sp], #4
		sprintf(str, "+CMS ERROR: %d\r\n", err);
   10c76:	4908      	ldr	r1, [pc, #32]	; (10c98 <cmd_send+0x7c>)
		sprintf(str, "+CME ERROR: %d\r\n", err);
   10c78:	a801      	add	r0, sp, #4
   10c7a:	f7fe f9f1 	bl	f060 <sprintf>
		write_uart_string(str);
   10c7e:	a801      	add	r0, sp, #4
   10c80:	e7f0      	b.n	10c64 <cmd_send+0x48>
		sprintf(str, "+CME ERROR: %d\r\n", err);
   10c82:	4906      	ldr	r1, [pc, #24]	; (10c9c <cmd_send+0x80>)
   10c84:	e7f8      	b.n	10c78 <cmd_send+0x5c>
   10c86:	bf00      	nop
   10c88:	20022662 	.word	0x20022662
   10c8c:	0001e56c 	.word	0x0001e56c
   10c90:	0001e567 	.word	0x0001e567
   10c94:	20020528 	.word	0x20020528
   10c98:	0001e574 	.word	0x0001e574
   10c9c:	0001e585 	.word	0x0001e585

00010ca0 <isr>:
		k_work_submit_to_queue(&at_host_work_q, &cmd_send_work);
	}
}

static void isr(struct device *dev)
{
   10ca0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   10ca2:	4604      	mov	r4, r0
static inline int z_impl_uart_irq_update(struct device *dev)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	if (api->irq_update) {
   10ca4:	6883      	ldr	r3, [r0, #8]
   10ca6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   10ca8:	b103      	cbz	r3, 10cac <isr+0xc>
		return api->irq_update(dev);
   10caa:	4798      	blx	r3
	if (api->irq_rx_ready) {
   10cac:	68a3      	ldr	r3, [r4, #8]
   10cae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   10cb0:	b193      	cbz	r3, 10cd8 <isr+0x38>
		return api->irq_rx_ready(dev);
   10cb2:	4620      	mov	r0, r4
   10cb4:	4798      	blx	r3
	u8_t character;

	uart_irq_update(dev);

	if (!uart_irq_rx_ready(dev)) {
   10cb6:	b178      	cbz	r0, 10cd8 <isr+0x38>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   10cb8:	4f37      	ldr	r7, [pc, #220]	; (10d98 <isr+0xf8>)
		if (at_cmd_len > 0) {
   10cba:	4d38      	ldr	r5, [pc, #224]	; (10d9c <isr+0xfc>)
   10cbc:	463e      	mov	r6, r7
   10cbe:	e8d7 3faf 	lda	r3, [r7]

	/*
	 * Check that we are not sending data (buffer must be preserved then),
	 * and that a new character is available before handling each character
	 */
	while ((!k_work_pending(&cmd_send_work)) &&
   10cc2:	07db      	lsls	r3, r3, #31
   10cc4:	d408      	bmi.n	10cd8 <isr+0x38>
	if (api->fifo_read) {
   10cc6:	68a3      	ldr	r3, [r4, #8]
   10cc8:	699b      	ldr	r3, [r3, #24]
   10cca:	b12b      	cbz	r3, 10cd8 <isr+0x38>
		return api->fifo_read(dev, rx_data, size);
   10ccc:	2201      	movs	r2, #1
   10cce:	4620      	mov	r0, r4
   10cd0:	f10d 0107 	add.w	r1, sp, #7
   10cd4:	4798      	blx	r3
   10cd6:	b908      	cbnz	r0, 10cdc <isr+0x3c>
	       (uart_fifo_read(dev, &character, 1))) {
		uart_rx_handler(character);
	}
}
   10cd8:	b003      	add	sp, #12
   10cda:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uart_rx_handler(character);
   10cdc:	f89d 3007 	ldrb.w	r3, [sp, #7]
	switch (character) {
   10ce0:	2b08      	cmp	r3, #8
   10ce2:	d001      	beq.n	10ce8 <isr+0x48>
   10ce4:	2b7f      	cmp	r3, #127	; 0x7f
   10ce6:	d105      	bne.n	10cf4 <isr+0x54>
		if (at_cmd_len > 0) {
   10ce8:	682b      	ldr	r3, [r5, #0]
   10cea:	2b00      	cmp	r3, #0
   10cec:	d0e7      	beq.n	10cbe <isr+0x1e>
			at_cmd_len--;
   10cee:	3b01      	subs	r3, #1
   10cf0:	602b      	str	r3, [r5, #0]
   10cf2:	e7e4      	b.n	10cbe <isr+0x1e>
	if (!inside_quotes) {
   10cf4:	492a      	ldr	r1, [pc, #168]	; (10da0 <isr+0x100>)
   10cf6:	780a      	ldrb	r2, [r1, #0]
   10cf8:	bb52      	cbnz	r2, 10d50 <isr+0xb0>
		switch (character) {
   10cfa:	2b0a      	cmp	r3, #10
   10cfc:	d03a      	beq.n	10d74 <isr+0xd4>
   10cfe:	2b0d      	cmp	r3, #13
   10d00:	d022      	beq.n	10d48 <isr+0xa8>
   10d02:	bb2b      	cbnz	r3, 10d50 <isr+0xb0>
			if (term_mode == MODE_NULL_TERM) {
   10d04:	4b27      	ldr	r3, [pc, #156]	; (10da4 <isr+0x104>)
   10d06:	781b      	ldrb	r3, [r3, #0]
   10d08:	2b00      	cmp	r3, #0
   10d0a:	d1d8      	bne.n	10cbe <isr+0x1e>
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   10d0c:	2300      	movs	r3, #0
   10d0e:	4a26      	ldr	r2, [pc, #152]	; (10da8 <isr+0x108>)
   10d10:	6828      	ldr	r0, [r5, #0]
	inside_quotes = false;
   10d12:	700b      	strb	r3, [r1, #0]
	at_buf[at_cmd_len] = '\0'; /* Terminate the command string */
   10d14:	5413      	strb	r3, [r2, r0]
	at_cmd_len = 0;
   10d16:	602b      	str	r3, [r5, #0]
	if (at_buf[0]) {
   10d18:	7813      	ldrb	r3, [r2, #0]
   10d1a:	2b00      	cmp	r3, #0
   10d1c:	d0cf      	beq.n	10cbe <isr+0x1e>
		uart_irq_rx_disable(uart_dev); /* Stop UART to protect at_buf */
   10d1e:	4b23      	ldr	r3, [pc, #140]	; (10dac <isr+0x10c>)
   10d20:	6818      	ldr	r0, [r3, #0]
	if (api->irq_rx_disable) {
   10d22:	6883      	ldr	r3, [r0, #8]
   10d24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   10d26:	b103      	cbz	r3, 10d2a <isr+0x8a>
		api->irq_rx_disable(dev);
   10d28:	4798      	blx	r3
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   10d2a:	e8d6 3fef 	ldaex	r3, [r6]
   10d2e:	f043 0201 	orr.w	r2, r3, #1
   10d32:	e8c6 2fe1 	stlex	r1, r2, [r6]
   10d36:	2900      	cmp	r1, #0
   10d38:	d1f7      	bne.n	10d2a <isr+0x8a>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   10d3a:	07da      	lsls	r2, r3, #31
   10d3c:	d4bf      	bmi.n	10cbe <isr+0x1e>
		k_queue_append(&work_q->queue, work);
   10d3e:	491c      	ldr	r1, [pc, #112]	; (10db0 <isr+0x110>)
   10d40:	481c      	ldr	r0, [pc, #112]	; (10db4 <isr+0x114>)
   10d42:	f00c fb2d 	bl	1d3a0 <k_queue_append>
   10d46:	e7ba      	b.n	10cbe <isr+0x1e>
			if (term_mode == MODE_CR) {
   10d48:	4816      	ldr	r0, [pc, #88]	; (10da4 <isr+0x104>)
   10d4a:	7800      	ldrb	r0, [r0, #0]
   10d4c:	2801      	cmp	r0, #1
			    at_cmd_len > 0 &&
   10d4e:	d0dd      	beq.n	10d0c <isr+0x6c>
	if (at_cmd_len + 1 > sizeof(at_buf) - 1) {
   10d50:	f8d5 c000 	ldr.w	ip, [r5]
   10d54:	f10c 0001 	add.w	r0, ip, #1
   10d58:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
   10d5c:	d2af      	bcs.n	10cbe <isr+0x1e>
	at_buf[at_cmd_len] = character;
   10d5e:	f8df e048 	ldr.w	lr, [pc, #72]	; 10da8 <isr+0x108>
	if (character == '"') {
   10d62:	2b22      	cmp	r3, #34	; 0x22
	at_buf[at_cmd_len] = character;
   10d64:	f80e 300c 	strb.w	r3, [lr, ip]
	at_cmd_len++;
   10d68:	6028      	str	r0, [r5, #0]
	if (character == '"') {
   10d6a:	d1a8      	bne.n	10cbe <isr+0x1e>
	if (!inside_quotes) {
   10d6c:	f082 0201 	eor.w	r2, r2, #1
		inside_quotes = !inside_quotes;
   10d70:	700a      	strb	r2, [r1, #0]
   10d72:	e7a4      	b.n	10cbe <isr+0x1e>
			if (term_mode == MODE_LF) {
   10d74:	480b      	ldr	r0, [pc, #44]	; (10da4 <isr+0x104>)
   10d76:	7800      	ldrb	r0, [r0, #0]
   10d78:	2802      	cmp	r0, #2
   10d7a:	d0c7      	beq.n	10d0c <isr+0x6c>
			if (term_mode == MODE_CR_LF &&
   10d7c:	2803      	cmp	r0, #3
   10d7e:	d1e7      	bne.n	10d50 <isr+0xb0>
   10d80:	f8d5 c000 	ldr.w	ip, [r5]
   10d84:	f1bc 0f00 	cmp.w	ip, #0
   10d88:	d0e2      	beq.n	10d50 <isr+0xb0>
			    at_buf[at_cmd_len - 1] == '\r') {
   10d8a:	4807      	ldr	r0, [pc, #28]	; (10da8 <isr+0x108>)
   10d8c:	4460      	add	r0, ip
			    at_cmd_len > 0 &&
   10d8e:	f810 0c01 	ldrb.w	r0, [r0, #-1]
   10d92:	280d      	cmp	r0, #13
   10d94:	e7db      	b.n	10d4e <isr+0xae>
   10d96:	bf00      	nop
   10d98:	20020524 	.word	0x20020524
   10d9c:	20020448 	.word	0x20020448
   10da0:	20023662 	.word	0x20023662
   10da4:	20023663 	.word	0x20023663
   10da8:	20022662 	.word	0x20022662
   10dac:	20020528 	.word	0x20020528
   10db0:	2002051c 	.word	0x2002051c
   10db4:	2002044c 	.word	0x2002044c

00010db8 <at_host_init>:

	ARG_UNUSED(arg);

	/* Choosing the termination mode */
	if (mode < MODE_COUNT) {
		term_mode = mode;
   10db8:	2201      	movs	r2, #1
   10dba:	4b2f      	ldr	r3, [pc, #188]	; (10e78 <at_host_init+0xc0>)
{
   10dbc:	e92d 48f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, fp, lr}
	default:
		LOG_ERR("Unknown UART instance %d", uart_id);
		return -EINVAL;
	}

	err = at_notif_register_handler(NULL, response_handler);
   10dc0:	2000      	movs	r0, #0
   10dc2:	492e      	ldr	r1, [pc, #184]	; (10e7c <at_host_init+0xc4>)
		term_mode = mode;
   10dc4:	701a      	strb	r2, [r3, #0]
	err = at_notif_register_handler(NULL, response_handler);
   10dc6:	f7ff fee1 	bl	10b8c <at_notif_register_handler>
	if (err != 0) {
   10dca:	4606      	mov	r6, r0
   10dcc:	bb30      	cbnz	r0, 10e1c <at_host_init+0x64>
   10dce:	482c      	ldr	r0, [pc, #176]	; (10e80 <at_host_init+0xc8>)
   10dd0:	f008 ffce 	bl	19d70 <z_impl_device_get_binding>
	uart_dev = device_get_binding(uart_dev_name);
   10dd4:	4c2b      	ldr	r4, [pc, #172]	; (10e84 <at_host_init+0xcc>)
   10dd6:	6020      	str	r0, [r4, #0]
	if (uart_dev == NULL) {
   10dd8:	b1f0      	cbz	r0, 10e18 <at_host_init+0x60>
	return z_impl_k_uptime_ticks();
   10dda:	f00c fc4a 	bl	1d672 <z_impl_k_uptime_ticks>
   10dde:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   10de2:	fba0 2305 	umull	r2, r3, r0, r5
   10de6:	fb05 3301 	mla	r3, r5, r1, r3
   10dea:	0bd7      	lsrs	r7, r2, #15
   10dec:	ea47 4743 	orr.w	r7, r7, r3, lsl #17
		err = uart_err_check(uart_dev);
   10df0:	6820      	ldr	r0, [r4, #0]
	if (api->err_check != NULL) {
   10df2:	6883      	ldr	r3, [r0, #8]
   10df4:	689b      	ldr	r3, [r3, #8]
   10df6:	b32b      	cbz	r3, 10e44 <at_host_init+0x8c>
		return api->err_check(dev);
   10df8:	4798      	blx	r3
		if (err) {
   10dfa:	b318      	cbz	r0, 10e44 <at_host_init+0x8c>
   10dfc:	f00c fc39 	bl	1d672 <z_impl_k_uptime_ticks>
   10e00:	fba0 bc05 	umull	fp, ip, r0, r5
   10e04:	fb05 cc01 	mla	ip, r5, r1, ip
   10e08:	ea4f 32db 	mov.w	r2, fp, lsr #15
   10e0c:	ea42 424c 	orr.w	r2, r2, ip, lsl #17
			if (k_uptime_get_32() - start_time >
   10e10:	1bd2      	subs	r2, r2, r7
   10e12:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
   10e16:	d905      	bls.n	10e24 <at_host_init+0x6c>

	/* Initialize the UART module */
	err = at_uart_init(uart_dev_name);
	if (err) {
		LOG_ERR("UART could not be initialized: %d", err);
		return -EFAULT;
   10e18:	f06f 060d 	mvn.w	r6, #13
		       K_THREAD_STACK_SIZEOF(at_host_stack_area),
		       CONFIG_AT_HOST_THREAD_PRIO);
	uart_irq_rx_enable(uart_dev);

	return err;
}
   10e1c:	4630      	mov	r0, r6
   10e1e:	b002      	add	sp, #8
   10e20:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
			while (uart_fifo_read(uart_dev, &dummy, 1)) {
   10e24:	6820      	ldr	r0, [r4, #0]
	if (api->fifo_read) {
   10e26:	6883      	ldr	r3, [r0, #8]
   10e28:	699b      	ldr	r3, [r3, #24]
   10e2a:	b12b      	cbz	r3, 10e38 <at_host_init+0x80>
		return api->fifo_read(dev, rx_data, size);
   10e2c:	2201      	movs	r2, #1
   10e2e:	f10d 0107 	add.w	r1, sp, #7
   10e32:	4798      	blx	r3
   10e34:	2800      	cmp	r0, #0
   10e36:	d1f5      	bne.n	10e24 <at_host_init+0x6c>
	return z_impl_k_sleep(timeout);
   10e38:	2100      	movs	r1, #0
   10e3a:	f44f 70a4 	mov.w	r0, #328	; 0x148
   10e3e:	f009 fe21 	bl	1aa84 <z_impl_k_sleep>
	} while (err);
   10e42:	e7d5      	b.n	10df0 <at_host_init+0x38>
	uart_irq_callback_set(uart_dev, isr);
   10e44:	6822      	ldr	r2, [r4, #0]
static inline void uart_irq_callback_user_data_set(
					struct device *dev,
					uart_irq_callback_user_data_t cb,
					void *user_data)
{
	const struct uart_driver_api *api =
   10e46:	6893      	ldr	r3, [r2, #8]
		(const struct uart_driver_api *)dev->driver_api;

	if ((api != NULL) && (api->irq_callback_set != NULL)) {
   10e48:	b123      	cbz	r3, 10e54 <at_host_init+0x9c>
   10e4a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   10e4c:	b113      	cbz	r3, 10e54 <at_host_init+0x9c>
		api->irq_callback_set(dev, cb, user_data);
   10e4e:	4610      	mov	r0, r2
   10e50:	490d      	ldr	r1, [pc, #52]	; (10e88 <at_host_init+0xd0>)
   10e52:	4798      	blx	r3
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   10e54:	2200      	movs	r2, #0
   10e56:	4b0d      	ldr	r3, [pc, #52]	; (10e8c <at_host_init+0xd4>)
   10e58:	490d      	ldr	r1, [pc, #52]	; (10e90 <at_host_init+0xd8>)
   10e5a:	601a      	str	r2, [r3, #0]
   10e5c:	e9c3 1201 	strd	r1, r2, [r3, #4]
	k_work_q_start(&at_host_work_q, at_host_stack_area,
   10e60:	480c      	ldr	r0, [pc, #48]	; (10e94 <at_host_init+0xdc>)
   10e62:	230a      	movs	r3, #10
   10e64:	f44f 7240 	mov.w	r2, #768	; 0x300
   10e68:	490b      	ldr	r1, [pc, #44]	; (10e98 <at_host_init+0xe0>)
   10e6a:	f009 ff4d 	bl	1ad08 <k_work_q_start>
	uart_irq_rx_enable(uart_dev);
   10e6e:	6820      	ldr	r0, [r4, #0]
   10e70:	f00b ff8c 	bl	1cd8c <z_impl_uart_irq_rx_enable>
	return err;
   10e74:	e7d2      	b.n	10e1c <at_host_init+0x64>
   10e76:	bf00      	nop
   10e78:	20023663 	.word	0x20023663
   10e7c:	0001cd97 	.word	0x0001cd97
   10e80:	0001e45b 	.word	0x0001e45b
   10e84:	20020528 	.word	0x20020528
   10e88:	00010ca1 	.word	0x00010ca1
   10e8c:	2002051c 	.word	0x2002051c
   10e90:	00010c1d 	.word	0x00010c1d
   10e94:	2002044c 	.word	0x2002044c
   10e98:	20023be0 	.word	0x20023be0

00010e9c <at_parse_process_element>:
	return 0;
}

static int at_parse_process_element(const char **str, int index,
				    struct at_param_list *const list)
{
   10e9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const char *tmpstr = *str;
   10ea0:	6805      	ldr	r5, [r0, #0]
{
   10ea2:	b0a3      	sub	sp, #140	; 0x8c
	const char *tmpstr = *str;
   10ea4:	9500      	str	r5, [sp, #0]
 * @retval true  If character is 0
 * @retval false If character is not 0
 */
static inline bool is_terminated(char chr)
{
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   10ea6:	782b      	ldrb	r3, [r5, #0]
{
   10ea8:	4680      	mov	r8, r0
   10eaa:	460f      	mov	r7, r1
   10eac:	4616      	mov	r6, r2
   10eae:	2b00      	cmp	r3, #0
   10eb0:	f000 80cc 	beq.w	1104c <at_parse_process_element+0x1b0>

	if (is_terminated(*tmpstr)) {
		return -1;
	}

	if (state == NOTIFICATION) {
   10eb4:	4b67      	ldr	r3, [pc, #412]	; (11054 <at_parse_process_element+0x1b8>)
   10eb6:	781c      	ldrb	r4, [r3, #0]
   10eb8:	2c06      	cmp	r4, #6
   10eba:	d110      	bne.n	10ede <at_parse_process_element+0x42>
		const char *start_ptr = tmpstr++;
   10ebc:	1c6b      	adds	r3, r5, #1
   10ebe:	9300      	str	r3, [sp, #0]

		while (is_valid_notification_char(*tmpstr)) {
   10ec0:	9a00      	ldr	r2, [sp, #0]
   10ec2:	7810      	ldrb	r0, [r2, #0]
   10ec4:	f00b ff81 	bl	1cdca <is_valid_notification_char>
   10ec8:	b930      	cbnz	r0, 10ed8 <at_parse_process_element+0x3c>
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   10eca:	1b53      	subs	r3, r2, r5

		while (isxdigit((int)*tmpstr)) {
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   10ecc:	462a      	mov	r2, r5
   10ece:	4639      	mov	r1, r7
   10ed0:	4630      	mov	r0, r6
   10ed2:	f00c f849 	bl	1cf68 <at_params_string_put>
   10ed6:	e01b      	b.n	10f10 <at_parse_process_element+0x74>
			tmpstr++;
   10ed8:	3201      	adds	r2, #1
   10eda:	9200      	str	r2, [sp, #0]
   10edc:	e7f0      	b.n	10ec0 <at_parse_process_element+0x24>
	} else if (state == COMMAND) {
   10ede:	2c07      	cmp	r4, #7
   10ee0:	d124      	bne.n	10f2c <at_parse_process_element+0x90>
		skip_command_prefix(&tmpstr);
   10ee2:	4668      	mov	r0, sp
   10ee4:	f00b ff63 	bl	1cdae <skip_command_prefix>
		while (is_valid_notification_char(*tmpstr)) {
   10ee8:	9a00      	ldr	r2, [sp, #0]
   10eea:	7810      	ldrb	r0, [r2, #0]
   10eec:	f00b ff6d 	bl	1cdca <is_valid_notification_char>
   10ef0:	b9a8      	cbnz	r0, 10f1e <at_parse_process_element+0x82>
		at_params_string_put(list, index, start_ptr,
   10ef2:	1b53      	subs	r3, r2, r5
   10ef4:	4639      	mov	r1, r7
   10ef6:	462a      	mov	r2, r5
   10ef8:	4630      	mov	r0, r6
   10efa:	f00c f835 	bl	1cf68 <at_params_string_put>
		if ((*tmpstr == AT_CMD_SEPARATOR) &&
   10efe:	9b00      	ldr	r3, [sp, #0]
   10f00:	781a      	ldrb	r2, [r3, #0]
   10f02:	2a3d      	cmp	r2, #61	; 0x3d
   10f04:	d10e      	bne.n	10f24 <at_parse_process_element+0x88>
   10f06:	785a      	ldrb	r2, [r3, #1]
   10f08:	2a3f      	cmp	r2, #63	; 0x3f
   10f0a:	d101      	bne.n	10f10 <at_parse_process_element+0x74>
			tmpstr += 2;
   10f0c:	3302      	adds	r3, #2
			tmpstr++;
   10f0e:	9300      	str	r3, [sp, #0]
				     tmpstr - start_ptr);
	}

	*str = tmpstr;
	return 0;
   10f10:	2000      	movs	r0, #0
	*str = tmpstr;
   10f12:	9b00      	ldr	r3, [sp, #0]
   10f14:	f8c8 3000 	str.w	r3, [r8]
}
   10f18:	b023      	add	sp, #140	; 0x8c
   10f1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			tmpstr++;
   10f1e:	3201      	adds	r2, #1
   10f20:	9200      	str	r2, [sp, #0]
   10f22:	e7e1      	b.n	10ee8 <at_parse_process_element+0x4c>
		} else if (*tmpstr == AT_CMD_READ_TEST_IDENTIFIER) {
   10f24:	2a3f      	cmp	r2, #63	; 0x3f
   10f26:	d1f3      	bne.n	10f10 <at_parse_process_element+0x74>
			tmpstr++;
   10f28:	3301      	adds	r3, #1
   10f2a:	e7f0      	b.n	10f0e <at_parse_process_element+0x72>
	} else if (state == OPTIONAL) {
   10f2c:	2c08      	cmp	r4, #8
   10f2e:	d103      	bne.n	10f38 <at_parse_process_element+0x9c>
		at_params_empty_put(list, index);
   10f30:	4610      	mov	r0, r2
   10f32:	f00b fff4 	bl	1cf1e <at_params_empty_put>
   10f36:	e7eb      	b.n	10f10 <at_parse_process_element+0x74>
	} else if (state == STRING) {
   10f38:	2c02      	cmp	r4, #2
   10f3a:	d111      	bne.n	10f60 <at_parse_process_element+0xc4>
		while (!is_lfcr(*tmpstr) && !is_terminated(*tmpstr)) {
   10f3c:	9a00      	ldr	r2, [sp, #0]
   10f3e:	7811      	ldrb	r1, [r2, #0]
   10f40:	4608      	mov	r0, r1
   10f42:	f00b ff2b 	bl	1cd9c <is_lfcr>
   10f46:	b918      	cbnz	r0, 10f50 <at_parse_process_element+0xb4>
   10f48:	b111      	cbz	r1, 10f50 <at_parse_process_element+0xb4>
			tmpstr++;
   10f4a:	3201      	adds	r2, #1
   10f4c:	9200      	str	r2, [sp, #0]
   10f4e:	e7f5      	b.n	10f3c <at_parse_process_element+0xa0>
		at_params_string_put(list, index, start_ptr,
   10f50:	1b53      	subs	r3, r2, r5
		at_params_string_put(list, index, start_ptr,
   10f52:	462a      	mov	r2, r5
   10f54:	4639      	mov	r1, r7
   10f56:	4630      	mov	r0, r6
   10f58:	f00c f806 	bl	1cf68 <at_params_string_put>
		tmpstr++;
   10f5c:	9b00      	ldr	r3, [sp, #0]
   10f5e:	e7e3      	b.n	10f28 <at_parse_process_element+0x8c>
	} else if (state == QUOTED_STRING) {
   10f60:	2c03      	cmp	r4, #3
   10f62:	d109      	bne.n	10f78 <at_parse_process_element+0xdc>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr)) {
   10f64:	9b00      	ldr	r3, [sp, #0]
   10f66:	781a      	ldrb	r2, [r3, #0]
 * @retval true  If character is "
 * @retval false If character is something else
 */
static inline bool is_dblquote(char chr)
{
	if (chr == '"') {
   10f68:	2a22      	cmp	r2, #34	; 0x22
   10f6a:	d003      	beq.n	10f74 <at_parse_process_element+0xd8>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   10f6c:	b112      	cbz	r2, 10f74 <at_parse_process_element+0xd8>
			tmpstr++;
   10f6e:	3301      	adds	r3, #1
   10f70:	9300      	str	r3, [sp, #0]
   10f72:	e7f7      	b.n	10f64 <at_parse_process_element+0xc8>
		at_params_string_put(list, index, start_ptr,
   10f74:	1b5b      	subs	r3, r3, r5
   10f76:	e7ec      	b.n	10f52 <at_parse_process_element+0xb6>
	} else if (state == ARRAY) {
   10f78:	2c01      	cmp	r4, #1
   10f7a:	d13c      	bne.n	10ff6 <at_parse_process_element+0x15a>
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   10f7c:	4628      	mov	r0, r5
   10f7e:	220a      	movs	r2, #10
   10f80:	a901      	add	r1, sp, #4
   10f82:	f00a ff56 	bl	1be32 <strtoul>
		tmpstr = next;
   10f86:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   10f88:	4d33      	ldr	r5, [pc, #204]	; (11058 <at_parse_process_element+0x1bc>)
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   10f8a:	9002      	str	r0, [sp, #8]
		tmpstr = next;
   10f8c:	9300      	str	r3, [sp, #0]
		while (!is_array_stop(*tmpstr) && !is_terminated(*tmpstr)) {
   10f8e:	9800      	ldr	r0, [sp, #0]
   10f90:	7803      	ldrb	r3, [r0, #0]
 * @retval true  If character is )
 * @retval false If character is something else
 */
static inline bool is_array_stop(char chr)
{
	if (chr == ')') {
   10f92:	2b29      	cmp	r3, #41	; 0x29
   10f94:	d028      	beq.n	10fe8 <at_parse_process_element+0x14c>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   10f96:	b33b      	cbz	r3, 10fe8 <at_parse_process_element+0x14c>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   10f98:	3b2c      	subs	r3, #44	; 0x2c
   10f9a:	b2db      	uxtb	r3, r3
   10f9c:	3001      	adds	r0, #1
   10f9e:	2b11      	cmp	r3, #17
				tmparray[i++] =
   10fa0:	9000      	str	r0, [sp, #0]
   10fa2:	d803      	bhi.n	10fac <at_parse_process_element+0x110>
   10fa4:	fa25 f303 	lsr.w	r3, r5, r3
   10fa8:	07db      	lsls	r3, r3, #31
   10faa:	d408      	bmi.n	10fbe <at_parse_process_element+0x122>
				tmpstr++;
   10fac:	46a1      	mov	r9, r4
   10fae:	e004      	b.n	10fba <at_parse_process_element+0x11e>
					tmpstr = next;
   10fb0:	9b01      	ldr	r3, [sp, #4]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   10fb2:	f1b9 0f20 	cmp.w	r9, #32
					tmpstr = next;
   10fb6:	9300      	str	r3, [sp, #0]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   10fb8:	d015      	beq.n	10fe6 <at_parse_process_element+0x14a>
				tmpstr++;
   10fba:	464c      	mov	r4, r9
   10fbc:	e7e7      	b.n	10f8e <at_parse_process_element+0xf2>
					(u32_t)strtoul(++tmpstr, &next, 10);
   10fbe:	220a      	movs	r2, #10
   10fc0:	a901      	add	r1, sp, #4
   10fc2:	f00a ff36 	bl	1be32 <strtoul>
				tmparray[i++] =
   10fc6:	ab22      	add	r3, sp, #136	; 0x88
   10fc8:	f104 0901 	add.w	r9, r4, #1
   10fcc:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   10fd0:	f844 0c80 	str.w	r0, [r4, #-128]
				if (strlen(tmpstr) == strlen(next)) {
   10fd4:	9800      	ldr	r0, [sp, #0]
   10fd6:	f00a ffd3 	bl	1bf80 <strlen>
   10fda:	4604      	mov	r4, r0
   10fdc:	9801      	ldr	r0, [sp, #4]
   10fde:	f00a ffcf 	bl	1bf80 <strlen>
   10fe2:	4284      	cmp	r4, r0
   10fe4:	d1e4      	bne.n	10fb0 <at_parse_process_element+0x114>
   10fe6:	464c      	mov	r4, r9
		at_params_array_put(list, index, tmparray, i * sizeof(u32_t));
   10fe8:	4639      	mov	r1, r7
   10fea:	4630      	mov	r0, r6
   10fec:	00a3      	lsls	r3, r4, #2
   10fee:	aa02      	add	r2, sp, #8
   10ff0:	f00b ffdd 	bl	1cfae <at_params_array_put>
   10ff4:	e7b2      	b.n	10f5c <at_parse_process_element+0xc0>
	} else if (state == NUMBER) {
   10ff6:	2c04      	cmp	r4, #4
   10ff8:	d115      	bne.n	11026 <at_parse_process_element+0x18a>
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   10ffa:	220a      	movs	r2, #10
   10ffc:	4628      	mov	r0, r5
   10ffe:	a902      	add	r1, sp, #8
   11000:	f00a ff17 	bl	1be32 <strtoul>
		tmpstr = next;
   11004:	9b02      	ldr	r3, [sp, #8]
		if (value <= USHRT_MAX) {
   11006:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   1100a:	4602      	mov	r2, r0
		tmpstr = next;
   1100c:	9300      	str	r3, [sp, #0]
		if (value <= USHRT_MAX) {
   1100e:	d205      	bcs.n	1101c <at_parse_process_element+0x180>
			at_params_short_put(list, index, (u16_t)value);
   11010:	b282      	uxth	r2, r0
   11012:	4639      	mov	r1, r7
   11014:	4630      	mov	r0, r6
   11016:	f00b ff6f 	bl	1cef8 <at_params_short_put>
   1101a:	e779      	b.n	10f10 <at_parse_process_element+0x74>
			at_params_int_put(list, index, value);
   1101c:	4639      	mov	r1, r7
   1101e:	4630      	mov	r0, r6
   11020:	f00b ff8f 	bl	1cf42 <at_params_int_put>
   11024:	e774      	b.n	10f10 <at_parse_process_element+0x74>
	} else if (state == SMS_PDU) {
   11026:	2c05      	cmp	r4, #5
   11028:	f47f af72 	bne.w	10f10 <at_parse_process_element+0x74>
		while (isxdigit((int)*tmpstr)) {
   1102c:	9b00      	ldr	r3, [sp, #0]
   1102e:	781a      	ldrb	r2, [r3, #0]

static inline int isxdigit(int a)
{
	unsigned int ua = (unsigned int)a;

	return (int)(((ua - (unsigned)'0') < 10U) ||
   11030:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   11034:	2909      	cmp	r1, #9
   11036:	d906      	bls.n	11046 <at_parse_process_element+0x1aa>
			((ua | 32U) - (unsigned)'a' < 6U));
   11038:	f042 0220 	orr.w	r2, r2, #32
   1103c:	3a61      	subs	r2, #97	; 0x61
	return (int)(((ua - (unsigned)'0') < 10U) ||
   1103e:	2a05      	cmp	r2, #5
   11040:	d901      	bls.n	11046 <at_parse_process_element+0x1aa>
		at_params_string_put(list, index, start_ptr,
   11042:	1b5b      	subs	r3, r3, r5
   11044:	e742      	b.n	10ecc <at_parse_process_element+0x30>
			tmpstr++;
   11046:	3301      	adds	r3, #1
   11048:	9300      	str	r3, [sp, #0]
   1104a:	e7ef      	b.n	1102c <at_parse_process_element+0x190>
		return -1;
   1104c:	f04f 30ff 	mov.w	r0, #4294967295
   11050:	e762      	b.n	10f18 <at_parse_process_element+0x7c>
   11052:	bf00      	nop
   11054:	20023664 	.word	0x20023664
   11058:	00024001 	.word	0x00024001

0001105c <at_parse_detect_type>:
{
   1105c:	b570      	push	{r4, r5, r6, lr}
	const char *tmpstr = *str;
   1105e:	6804      	ldr	r4, [r0, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   11060:	2900      	cmp	r1, #0
{
   11062:	4605      	mov	r5, r0
   11064:	7822      	ldrb	r2, [r4, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   11066:	d144      	bne.n	110f2 <at_parse_detect_type+0x96>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   11068:	2a2b      	cmp	r2, #43	; 0x2b
   1106a:	4e2a      	ldr	r6, [pc, #168]	; (11114 <at_parse_detect_type+0xb8>)
   1106c:	d001      	beq.n	11072 <at_parse_detect_type+0x16>
   1106e:	2a25      	cmp	r2, #37	; 0x25
   11070:	d104      	bne.n	1107c <at_parse_detect_type+0x20>
	state = new_state;
   11072:	2306      	movs	r3, #6
   11074:	7033      	strb	r3, [r6, #0]
	return 0;
   11076:	2000      	movs	r0, #0
	*str = tmpstr;
   11078:	602c      	str	r4, [r5, #0]
}
   1107a:	bd70      	pop	{r4, r5, r6, pc}
	} else if ((index == 0) && is_command(tmpstr)) {
   1107c:	4620      	mov	r0, r4
   1107e:	f00b feb0 	bl	1cde2 <is_command>
   11082:	b3a0      	cbz	r0, 110ee <at_parse_detect_type+0x92>
	state = new_state;
   11084:	2307      	movs	r3, #7
   11086:	e7f5      	b.n	11074 <at_parse_detect_type+0x18>
 * @retval true  If character is number character
 * @retval false If character is something else
 */
static inline bool is_number(char chr)
{
	if (isdigit((int)chr) || (chr == '-') || (chr == '+')) {
   11088:	f647 71e5 	movw	r1, #32741	; 0x7fe5
   1108c:	fa21 f303 	lsr.w	r3, r1, r3
   11090:	07d9      	lsls	r1, r3, #31
   11092:	d50a      	bpl.n	110aa <at_parse_detect_type+0x4e>
   11094:	2204      	movs	r2, #4
   11096:	4b1f      	ldr	r3, [pc, #124]	; (11114 <at_parse_detect_type+0xb8>)
   11098:	701a      	strb	r2, [r3, #0]
}
   1109a:	e7ec      	b.n	11076 <at_parse_detect_type+0x1a>
	if (chr == '(') {
   1109c:	2a28      	cmp	r2, #40	; 0x28
   1109e:	d104      	bne.n	110aa <at_parse_detect_type+0x4e>
	state = new_state;
   110a0:	2201      	movs	r2, #1
   110a2:	4b1c      	ldr	r3, [pc, #112]	; (11114 <at_parse_detect_type+0xb8>)
		tmpstr++;
   110a4:	4414      	add	r4, r2
	state = new_state;
   110a6:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   110a8:	e7e5      	b.n	11076 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == NUMBER)) {
   110aa:	4610      	mov	r0, r2
   110ac:	f00b fe76 	bl	1cd9c <is_lfcr>
   110b0:	b170      	cbz	r0, 110d0 <at_parse_detect_type+0x74>
   110b2:	4918      	ldr	r1, [pc, #96]	; (11114 <at_parse_detect_type+0xb8>)
   110b4:	7808      	ldrb	r0, [r1, #0]
   110b6:	2804      	cmp	r0, #4
   110b8:	d108      	bne.n	110cc <at_parse_detect_type+0x70>
		while (is_lfcr(*tmpstr)) {
   110ba:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   110be:	f00b fe6d 	bl	1cd9c <is_lfcr>
   110c2:	2800      	cmp	r0, #0
   110c4:	d1f9      	bne.n	110ba <at_parse_detect_type+0x5e>
	state = new_state;
   110c6:	2305      	movs	r3, #5
   110c8:	700b      	strb	r3, [r1, #0]
}
   110ca:	e7d4      	b.n	11076 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == OPTIONAL)) {
   110cc:	2808      	cmp	r0, #8
   110ce:	d0d2      	beq.n	11076 <at_parse_detect_type+0x1a>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   110d0:	3a2c      	subs	r2, #44	; 0x2c
   110d2:	b2d2      	uxtb	r2, r2
   110d4:	2a11      	cmp	r2, #17
   110d6:	d807      	bhi.n	110e8 <at_parse_detect_type+0x8c>
   110d8:	4b0f      	ldr	r3, [pc, #60]	; (11118 <at_parse_detect_type+0xbc>)
   110da:	fa23 f202 	lsr.w	r2, r3, r2
   110de:	07d3      	lsls	r3, r2, #31
   110e0:	d502      	bpl.n	110e8 <at_parse_detect_type+0x8c>
	state = new_state;
   110e2:	2208      	movs	r2, #8
   110e4:	4b0b      	ldr	r3, [pc, #44]	; (11114 <at_parse_detect_type+0xb8>)
   110e6:	e7d7      	b.n	11098 <at_parse_detect_type+0x3c>
		return -1;
   110e8:	f04f 30ff 	mov.w	r0, #4294967295
   110ec:	e7c5      	b.n	1107a <at_parse_detect_type+0x1e>
	state = new_state;
   110ee:	2302      	movs	r3, #2
   110f0:	e7c0      	b.n	11074 <at_parse_detect_type+0x18>
	} else if ((index > 0) && is_notification(*tmpstr)) {
   110f2:	dd03      	ble.n	110fc <at_parse_detect_type+0xa0>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   110f4:	2a2b      	cmp	r2, #43	; 0x2b
   110f6:	d0f7      	beq.n	110e8 <at_parse_detect_type+0x8c>
   110f8:	2a25      	cmp	r2, #37	; 0x25
   110fa:	d0f5      	beq.n	110e8 <at_parse_detect_type+0x8c>
	if (isdigit((int)chr) || (chr == '-') || (chr == '+')) {
   110fc:	f1a2 032b 	sub.w	r3, r2, #43	; 0x2b
   11100:	b2db      	uxtb	r3, r3
   11102:	2b0e      	cmp	r3, #14
   11104:	d9c0      	bls.n	11088 <at_parse_detect_type+0x2c>
	if (chr == '"') {
   11106:	2a22      	cmp	r2, #34	; 0x22
   11108:	d1c8      	bne.n	1109c <at_parse_detect_type+0x40>
	state = new_state;
   1110a:	2203      	movs	r2, #3
   1110c:	4b01      	ldr	r3, [pc, #4]	; (11114 <at_parse_detect_type+0xb8>)
		tmpstr++;
   1110e:	3401      	adds	r4, #1
	state = new_state;
   11110:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   11112:	e7b0      	b.n	11076 <at_parse_detect_type+0x1a>
   11114:	20023664 	.word	0x20023664
   11118:	00024001 	.word	0x00024001

0001111c <at_parser_max_params_from_str>:

int at_parser_max_params_from_str(const char *at_params_str,
				  char **next_param_str,
				  struct at_param_list *const list,
				  size_t max_params_count)
{
   1111c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   11120:	4688      	mov	r8, r1
   11122:	4616      	mov	r6, r2
   11124:	461f      	mov	r7, r3
	int err = 0;

	if (at_params_str == NULL || list == NULL || list->params == NULL) {
   11126:	4604      	mov	r4, r0
   11128:	2800      	cmp	r0, #0
   1112a:	d07c      	beq.n	11226 <at_parser_max_params_from_str+0x10a>
   1112c:	2a00      	cmp	r2, #0
   1112e:	d07a      	beq.n	11226 <at_parser_max_params_from_str+0x10a>
   11130:	6853      	ldr	r3, [r2, #4]
   11132:	2b00      	cmp	r3, #0
   11134:	d077      	beq.n	11226 <at_parser_max_params_from_str+0x10a>
	state = IDLE;
   11136:	2500      	movs	r5, #0
		return -EINVAL;
	}

	at_params_list_clear(list);
   11138:	4610      	mov	r0, r2
   1113a:	f00b feb6 	bl	1ceaa <at_params_list_clear>
	const char *str = *at_params_str;
   1113e:	9401      	str	r4, [sp, #4]
	int index = 0;
   11140:	462c      	mov	r4, r5

	max_params_count = MIN(max_params_count, list->param_count);
   11142:	6833      	ldr	r3, [r6, #0]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   11144:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 11230 <at_parser_max_params_from_str+0x114>
   11148:	429f      	cmp	r7, r3
   1114a:	bf28      	it	cs
   1114c:	461f      	movcs	r7, r3
	state = IDLE;
   1114e:	4b37      	ldr	r3, [pc, #220]	; (1122c <at_parser_max_params_from_str+0x110>)
   11150:	701d      	strb	r5, [r3, #0]
	while ((!is_terminated(*str)) && (index < max_params)) {
   11152:	9a01      	ldr	r2, [sp, #4]
   11154:	7813      	ldrb	r3, [r2, #0]
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   11156:	2b00      	cmp	r3, #0
   11158:	d04b      	beq.n	111f2 <at_parser_max_params_from_str+0xd6>
   1115a:	42a7      	cmp	r7, r4
   1115c:	d949      	bls.n	111f2 <at_parser_max_params_from_str+0xd6>
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   1115e:	2b20      	cmp	r3, #32
   11160:	d002      	beq.n	11168 <at_parser_max_params_from_str+0x4c>
   11162:	3b09      	subs	r3, #9
   11164:	2b04      	cmp	r3, #4
   11166:	d801      	bhi.n	1116c <at_parser_max_params_from_str+0x50>
			str++;
   11168:	3201      	adds	r2, #1
   1116a:	9201      	str	r2, [sp, #4]
		if (at_parse_detect_type(&str, index) == -1) {
   1116c:	4621      	mov	r1, r4
   1116e:	a801      	add	r0, sp, #4
   11170:	f7ff ff74 	bl	1105c <at_parse_detect_type>
   11174:	1c42      	adds	r2, r0, #1
   11176:	d03c      	beq.n	111f2 <at_parser_max_params_from_str+0xd6>
		if (at_parse_process_element(&str, index, list) == -1) {
   11178:	4632      	mov	r2, r6
   1117a:	4621      	mov	r1, r4
   1117c:	a801      	add	r0, sp, #4
   1117e:	f7ff fe8d 	bl	10e9c <at_parse_process_element>
   11182:	1c43      	adds	r3, r0, #1
   11184:	d035      	beq.n	111f2 <at_parser_max_params_from_str+0xd6>
		if (is_separator(*str)) {
   11186:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   11188:	781a      	ldrb	r2, [r3, #0]
   1118a:	3a2c      	subs	r2, #44	; 0x2c
   1118c:	b2d2      	uxtb	r2, r2
   1118e:	2a11      	cmp	r2, #17
   11190:	d81a      	bhi.n	111c8 <at_parser_max_params_from_str+0xac>
   11192:	fa29 f202 	lsr.w	r2, r9, r2
   11196:	07d1      	lsls	r1, r2, #31
   11198:	d516      	bpl.n	111c8 <at_parser_max_params_from_str+0xac>
			if (is_lfcr(*(str + 1))) {
   1119a:	7858      	ldrb	r0, [r3, #1]
   1119c:	f00b fdfe 	bl	1cd9c <is_lfcr>
   111a0:	b178      	cbz	r0, 111c2 <at_parser_max_params_from_str+0xa6>
				index++;
   111a2:	3401      	adds	r4, #1
				if (index == max_params) {
   111a4:	42bc      	cmp	r4, r7
   111a6:	d039      	beq.n	1121c <at_parser_max_params_from_str+0x100>
				if (at_parse_detect_type(&str, index) == -1) {
   111a8:	4621      	mov	r1, r4
   111aa:	a801      	add	r0, sp, #4
   111ac:	f7ff ff56 	bl	1105c <at_parse_detect_type>
   111b0:	1c42      	adds	r2, r0, #1
   111b2:	d01e      	beq.n	111f2 <at_parser_max_params_from_str+0xd6>
				if (at_parse_process_element(&str, index,
   111b4:	4632      	mov	r2, r6
   111b6:	4621      	mov	r1, r4
   111b8:	a801      	add	r0, sp, #4
   111ba:	f7ff fe6f 	bl	10e9c <at_parse_process_element>
   111be:	1c43      	adds	r3, r0, #1
   111c0:	d017      	beq.n	111f2 <at_parser_max_params_from_str+0xd6>
			str++;
   111c2:	9b01      	ldr	r3, [sp, #4]
   111c4:	3301      	adds	r3, #1
   111c6:	9301      	str	r3, [sp, #4]
		if (is_lfcr(*str)) {
   111c8:	9a01      	ldr	r2, [sp, #4]
   111ca:	7810      	ldrb	r0, [r2, #0]
   111cc:	f00b fde6 	bl	1cd9c <is_lfcr>
   111d0:	b1f8      	cbz	r0, 11212 <at_parser_max_params_from_str+0xf6>
   111d2:	3201      	adds	r2, #1
			while (is_lfcr(str[++i])) {
   111d4:	7811      	ldrb	r1, [r2, #0]
   111d6:	4692      	mov	sl, r2
   111d8:	4608      	mov	r0, r1
   111da:	3201      	adds	r2, #1
   111dc:	f00b fdde 	bl	1cd9c <is_lfcr>
   111e0:	2800      	cmp	r0, #0
   111e2:	d1f7      	bne.n	111d4 <at_parser_max_params_from_str+0xb8>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   111e4:	b119      	cbz	r1, 111ee <at_parser_max_params_from_str+0xd2>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   111e6:	292b      	cmp	r1, #43	; 0x2b
   111e8:	d001      	beq.n	111ee <at_parser_max_params_from_str+0xd2>
   111ea:	2925      	cmp	r1, #37	; 0x25
   111ec:	d111      	bne.n	11212 <at_parser_max_params_from_str+0xf6>
				str += i;
   111ee:	f8cd a004 	str.w	sl, [sp, #4]
	*at_params_str = str;
   111f2:	9b01      	ldr	r3, [sp, #4]
	if (oversized) {
   111f4:	b9a5      	cbnz	r5, 11220 <at_parser_max_params_from_str+0x104>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   111f6:	781a      	ldrb	r2, [r3, #0]
		return -EAGAIN;
   111f8:	2a00      	cmp	r2, #0
   111fa:	bf0c      	ite	eq
   111fc:	2000      	moveq	r0, #0
   111fe:	f06f 000a 	mvnne.w	r0, #10

	err = at_parse_param(&at_params_str, list, max_params_count);

	if (next_param_str) {
   11202:	f1b8 0f00 	cmp.w	r8, #0
   11206:	d001      	beq.n	1120c <at_parser_max_params_from_str+0xf0>
		*next_param_str = (char *)at_params_str;
   11208:	f8c8 3000 	str.w	r3, [r8]
	}

	return err;
}
   1120c:	b002      	add	sp, #8
   1120e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		index++;
   11212:	3401      	adds	r4, #1
			oversized = true;
   11214:	42bc      	cmp	r4, r7
   11216:	bf08      	it	eq
   11218:	2501      	moveq	r5, #1
   1121a:	e79a      	b.n	11152 <at_parser_max_params_from_str+0x36>
					oversized = true;
   1121c:	4605      	mov	r5, r0
   1121e:	e7e8      	b.n	111f2 <at_parser_max_params_from_str+0xd6>
		return -E2BIG;
   11220:	f06f 0006 	mvn.w	r0, #6
   11224:	e7ed      	b.n	11202 <at_parser_max_params_from_str+0xe6>
		return -EINVAL;
   11226:	f06f 0015 	mvn.w	r0, #21
   1122a:	e7ef      	b.n	1120c <at_parser_max_params_from_str+0xf0>
   1122c:	20023664 	.word	0x20023664
   11230:	00024001 	.word	0x00024001

00011234 <parse_psm_cfg>:
	char timer_str[9] = {0};
   11234:	2300      	movs	r3, #0
{
   11236:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1123a:	b086      	sub	sp, #24
	char timer_str[9] = {0};
   1123c:	e9cd 3303 	strd	r3, r3, [sp, #12]
   11240:	f88d 3014 	strb.w	r3, [sp, #20]
	char unit_str[4] = {0};
   11244:	9301      	str	r3, [sp, #4]
	size_t timer_str_len = sizeof(timer_str) - 1;
   11246:	2308      	movs	r3, #8
	size_t tau_idx = is_notif ? AT_CEREG_TAU_INDEX :
   11248:	2900      	cmp	r1, #0
	size_t timer_str_len = sizeof(timer_str) - 1;
   1124a:	9302      	str	r3, [sp, #8]
{
   1124c:	4616      	mov	r6, r2
	err = at_params_string_get(at_params,
   1124e:	bf14      	ite	ne
   11250:	2108      	movne	r1, #8
   11252:	2109      	moveq	r1, #9
   11254:	446b      	add	r3, sp
   11256:	aa03      	add	r2, sp, #12
{
   11258:	4607      	mov	r7, r0
	size_t tau_idx = is_notif ? AT_CEREG_TAU_INDEX :
   1125a:	bf14      	ite	ne
   1125c:	f04f 0807 	movne.w	r8, #7
   11260:	f04f 0808 	moveq.w	r8, #8
	err = at_params_string_get(at_params,
   11264:	f00b fed9 	bl	1d01a <at_params_string_get>
	if (err) {
   11268:	4604      	mov	r4, r0
   1126a:	b968      	cbnz	r0, 11288 <parse_psm_cfg+0x54>
	memcpy(unit_str, timer_str, unit_str_len);
   1126c:	2203      	movs	r2, #3
   1126e:	a903      	add	r1, sp, #12
   11270:	a801      	add	r0, sp, #4
   11272:	f00a feb7 	bl	1bfe4 <memcpy>
	lut_idx = strtoul(unit_str, NULL, 2);
   11276:	2202      	movs	r2, #2
   11278:	4621      	mov	r1, r4
   1127a:	a801      	add	r0, sp, #4
   1127c:	f00a fdd9 	bl	1be32 <strtoul>
	if (lut_idx > (ARRAY_SIZE(t3412_lookup) - 1)) {
   11280:	2807      	cmp	r0, #7
   11282:	d905      	bls.n	11290 <parse_psm_cfg+0x5c>
		return err;
   11284:	f06f 0415 	mvn.w	r4, #21
}
   11288:	4620      	mov	r0, r4
   1128a:	b006      	add	sp, #24
   1128c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	timer_unit = t3412_lookup[lut_idx];
   11290:	4b19      	ldr	r3, [pc, #100]	; (112f8 <parse_psm_cfg+0xc4>)
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   11292:	2202      	movs	r2, #2
	timer_unit = t3412_lookup[lut_idx];
   11294:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   11298:	4621      	mov	r1, r4
   1129a:	f10d 000f 	add.w	r0, sp, #15
   1129e:	f00a fdc8 	bl	1be32 <strtoul>
	psm_cfg->tau = timer_unit ? timer_unit * timer_value : -1;
   112a2:	b31d      	cbz	r5, 112ec <parse_psm_cfg+0xb8>
   112a4:	4345      	muls	r5, r0
	err = at_params_string_get(at_params,
   112a6:	4641      	mov	r1, r8
   112a8:	4638      	mov	r0, r7
	psm_cfg->tau = timer_unit ? timer_unit * timer_value : -1;
   112aa:	6035      	str	r5, [r6, #0]
	err = at_params_string_get(at_params,
   112ac:	ab02      	add	r3, sp, #8
   112ae:	aa03      	add	r2, sp, #12
   112b0:	f00b feb3 	bl	1d01a <at_params_string_get>
	if (err) {
   112b4:	4604      	mov	r4, r0
   112b6:	2800      	cmp	r0, #0
   112b8:	d1e6      	bne.n	11288 <parse_psm_cfg+0x54>
	memcpy(unit_str, timer_str, unit_str_len);
   112ba:	2203      	movs	r2, #3
   112bc:	a903      	add	r1, sp, #12
   112be:	a801      	add	r0, sp, #4
   112c0:	f00a fe90 	bl	1bfe4 <memcpy>
	lut_idx = strtoul(unit_str, NULL, 2);
   112c4:	2202      	movs	r2, #2
   112c6:	4621      	mov	r1, r4
   112c8:	a801      	add	r0, sp, #4
   112ca:	f00a fdb2 	bl	1be32 <strtoul>
	if (lut_idx > (ARRAY_SIZE(t3324_lookup) - 1)) {
   112ce:	2807      	cmp	r0, #7
   112d0:	d8d8      	bhi.n	11284 <parse_psm_cfg+0x50>
	timer_unit = t3324_lookup[lut_idx];
   112d2:	4b0a      	ldr	r3, [pc, #40]	; (112fc <parse_psm_cfg+0xc8>)
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   112d4:	2202      	movs	r2, #2
	timer_unit = t3324_lookup[lut_idx];
   112d6:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   112da:	4621      	mov	r1, r4
   112dc:	f10d 000f 	add.w	r0, sp, #15
   112e0:	f00a fda7 	bl	1be32 <strtoul>
	psm_cfg->active_time = timer_unit ? timer_unit * timer_value : -1;
   112e4:	b12d      	cbz	r5, 112f2 <parse_psm_cfg+0xbe>
   112e6:	4368      	muls	r0, r5
   112e8:	6070      	str	r0, [r6, #4]
	return 0;
   112ea:	e7cd      	b.n	11288 <parse_psm_cfg+0x54>
	psm_cfg->tau = timer_unit ? timer_unit * timer_value : -1;
   112ec:	f04f 35ff 	mov.w	r5, #4294967295
   112f0:	e7d9      	b.n	112a6 <parse_psm_cfg+0x72>
	psm_cfg->active_time = timer_unit ? timer_unit * timer_value : -1;
   112f2:	f04f 30ff 	mov.w	r0, #4294967295
   112f6:	e7f7      	b.n	112e8 <parse_psm_cfg+0xb4>
   112f8:	0001ddac 	.word	0x0001ddac
   112fc:	0001dd8c 	.word	0x0001dd8c

00011300 <lte_lc_offline>:
{
   11300:	b508      	push	{r3, lr}
	if (at_cmd_write(offline, NULL, 0, NULL) != 0) {
   11302:	2300      	movs	r3, #0
   11304:	4804      	ldr	r0, [pc, #16]	; (11318 <lte_lc_offline+0x18>)
   11306:	461a      	mov	r2, r3
   11308:	4619      	mov	r1, r3
   1130a:	f7ff fba5 	bl	10a58 <at_cmd_write>
   1130e:	2800      	cmp	r0, #0
}
   11310:	bf18      	it	ne
   11312:	f06f 0004 	mvnne.w	r0, #4
   11316:	bd08      	pop	{r3, pc}
   11318:	0001e62c 	.word	0x0001e62c

0001131c <lte_lc_normal>:
{
   1131c:	b508      	push	{r3, lr}
	if (at_cmd_write(normal, NULL, 0, NULL) != 0) {
   1131e:	2300      	movs	r3, #0
   11320:	4804      	ldr	r0, [pc, #16]	; (11334 <lte_lc_normal+0x18>)
   11322:	461a      	mov	r2, r3
   11324:	4619      	mov	r1, r3
   11326:	f7ff fb97 	bl	10a58 <at_cmd_write>
   1132a:	2800      	cmp	r0, #0
}
   1132c:	bf18      	it	ne
   1132e:	f06f 0004 	mvnne.w	r0, #4
   11332:	bd08      	pop	{r3, pc}
   11334:	0001e622 	.word	0x0001e622

00011338 <lte_lc_system_mode_set>:

	return err;
}

int lte_lc_system_mode_set(enum lte_lc_system_mode mode)
{
   11338:	b500      	push	{lr}
   1133a:	b08f      	sub	sp, #60	; 0x3c
	int err, len;
	char cmd[50];

	switch (mode) {
   1133c:	b190      	cbz	r0, 11364 <lte_lc_system_mode_set+0x2c>
   1133e:	1e43      	subs	r3, r0, #1
   11340:	2b04      	cmp	r3, #4
   11342:	d812      	bhi.n	1136a <lte_lc_system_mode_set+0x32>
	default:
		LOG_ERR("Invalid system mode requested");
		return -EINVAL;
	}

	len = snprintk(cmd, sizeof(cmd), "AT%%XSYSTEMMODE=%s",
   11344:	4b0c      	ldr	r3, [pc, #48]	; (11378 <lte_lc_system_mode_set+0x40>)
   11346:	2132      	movs	r1, #50	; 0x32
   11348:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   1134c:	4a0b      	ldr	r2, [pc, #44]	; (1137c <lte_lc_system_mode_set+0x44>)
   1134e:	a801      	add	r0, sp, #4
   11350:	f009 feb6 	bl	1b0c0 <snprintk>
		       system_mode_params[mode]);
	if (len < 0) {
   11354:	2800      	cmp	r0, #0
   11356:	db0b      	blt.n	11370 <lte_lc_system_mode_set+0x38>
		return -EFAULT;
	}

	LOG_DBG("Sending AT command to set system mode: %s", log_strdup(cmd));

	err = at_cmd_write(cmd, NULL, 0, NULL);
   11358:	2300      	movs	r3, #0
   1135a:	a801      	add	r0, sp, #4
   1135c:	461a      	mov	r2, r3
   1135e:	4619      	mov	r1, r3
   11360:	f7ff fb7a 	bl	10a58 <at_cmd_write>
	if (err) {
		LOG_ERR("Could not send AT command, error: %d", err);
	}

	return err;
}
   11364:	b00f      	add	sp, #60	; 0x3c
   11366:	f85d fb04 	ldr.w	pc, [sp], #4
	switch (mode) {
   1136a:	f06f 0015 	mvn.w	r0, #21
   1136e:	e7f9      	b.n	11364 <lte_lc_system_mode_set+0x2c>
		return -EFAULT;
   11370:	f06f 000d 	mvn.w	r0, #13
   11374:	e7f6      	b.n	11364 <lte_lc_system_mode_set+0x2c>
   11376:	bf00      	nop
   11378:	0001dd74 	.word	0x0001dd74
   1137c:	0001e59d 	.word	0x0001e59d

00011380 <w_lte_lc_init>:
{
   11380:	b530      	push	{r4, r5, lr}
	if (is_initialized) {
   11382:	4d17      	ldr	r5, [pc, #92]	; (113e0 <w_lte_lc_init+0x60>)
{
   11384:	b08f      	sub	sp, #60	; 0x3c
	if (is_initialized) {
   11386:	7828      	ldrb	r0, [r5, #0]
   11388:	bb18      	cbnz	r0, 113d2 <w_lte_lc_init+0x52>
	err = at_notif_register_handler(NULL, at_handler);
   1138a:	4916      	ldr	r1, [pc, #88]	; (113e4 <w_lte_lc_init+0x64>)
   1138c:	f7ff fbfe 	bl	10b8c <at_notif_register_handler>
	if (err) {
   11390:	4604      	mov	r4, r0
   11392:	b9d8      	cbnz	r0, 113cc <w_lte_lc_init+0x4c>
	err = lte_lc_system_mode_set(sys_mode_preferred);
   11394:	2001      	movs	r0, #1
   11396:	f7ff ffcf 	bl	11338 <lte_lc_system_mode_set>
	if (err) {
   1139a:	4604      	mov	r4, r0
   1139c:	b9b0      	cbnz	r0, 113cc <w_lte_lc_init+0x4c>
	if (at_cmd_write(cereg_5_subscribe, NULL, 0, NULL) != 0) {
   1139e:	4603      	mov	r3, r0
   113a0:	4602      	mov	r2, r0
   113a2:	4601      	mov	r1, r0
   113a4:	4810      	ldr	r0, [pc, #64]	; (113e8 <w_lte_lc_init+0x68>)
   113a6:	f7ff fb57 	bl	10a58 <at_cmd_write>
   113aa:	4604      	mov	r4, r0
   113ac:	b9a0      	cbnz	r0, 113d8 <w_lte_lc_init+0x58>
	err = at_cmd_write(cscon, NULL, 0, NULL);
   113ae:	4603      	mov	r3, r0
   113b0:	4602      	mov	r2, r0
   113b2:	4601      	mov	r1, r0
   113b4:	480d      	ldr	r0, [pc, #52]	; (113ec <w_lte_lc_init+0x6c>)
   113b6:	f7ff fb4f 	bl	10a58 <at_cmd_write>
	if (err) {
   113ba:	b128      	cbz	r0, 113c8 <w_lte_lc_init+0x48>
		err = at_cmd_write("AT+CGMR", buf, sizeof(buf), NULL);
   113bc:	4623      	mov	r3, r4
   113be:	2232      	movs	r2, #50	; 0x32
   113c0:	480b      	ldr	r0, [pc, #44]	; (113f0 <w_lte_lc_init+0x70>)
   113c2:	a901      	add	r1, sp, #4
   113c4:	f7ff fb48 	bl	10a58 <at_cmd_write>
	is_initialized = true;
   113c8:	2301      	movs	r3, #1
   113ca:	702b      	strb	r3, [r5, #0]
}
   113cc:	4620      	mov	r0, r4
   113ce:	b00f      	add	sp, #60	; 0x3c
   113d0:	bd30      	pop	{r4, r5, pc}
		return -EALREADY;
   113d2:	f06f 0444 	mvn.w	r4, #68	; 0x44
   113d6:	e7f9      	b.n	113cc <w_lte_lc_init+0x4c>
		return -EIO;
   113d8:	f06f 0404 	mvn.w	r4, #4
   113dc:	e7f6      	b.n	113cc <w_lte_lc_init+0x4c>
   113de:	bf00      	nop
   113e0:	20023665 	.word	0x20023665
   113e4:	0000cba1 	.word	0x0000cba1
   113e8:	0001e60c 	.word	0x0001e60c
   113ec:	0001e617 	.word	0x0001e617
   113f0:	0001e5b0 	.word	0x0001e5b0

000113f4 <w_lte_lc_connect>:
	if (!is_initialized) {
   113f4:	4b16      	ldr	r3, [pc, #88]	; (11450 <w_lte_lc_connect+0x5c>)
{
   113f6:	b570      	push	{r4, r5, r6, lr}
	if (!is_initialized) {
   113f8:	781b      	ldrb	r3, [r3, #0]
{
   113fa:	4604      	mov	r4, r0
	if (!is_initialized) {
   113fc:	b30b      	cbz	r3, 11442 <w_lte_lc_connect+0x4e>
	return z_impl_k_sem_init(sem, initial_count, limit);
   113fe:	2201      	movs	r2, #1
   11400:	2100      	movs	r1, #0
   11402:	4814      	ldr	r0, [pc, #80]	; (11454 <w_lte_lc_connect+0x60>)
   11404:	f00c f8d5 	bl	1d5b2 <z_impl_k_sem_init>
   11408:	2502      	movs	r5, #2
	enum lte_lc_system_mode current_network_mode = sys_mode_preferred;
   1140a:	2301      	movs	r3, #1
	return z_impl_k_sem_take(sem, timeout);
   1140c:	4e11      	ldr	r6, [pc, #68]	; (11454 <w_lte_lc_connect+0x60>)
		err = lte_lc_system_mode_set(current_network_mode);
   1140e:	4618      	mov	r0, r3
   11410:	f7ff ff92 	bl	11338 <lte_lc_system_mode_set>
		if (err) {
   11414:	b9a0      	cbnz	r0, 11440 <w_lte_lc_connect+0x4c>
		err = lte_lc_normal();
   11416:	f7ff ff81 	bl	1131c <lte_lc_normal>
		if (err || !blocking) {
   1141a:	b988      	cbnz	r0, 11440 <w_lte_lc_connect+0x4c>
   1141c:	b184      	cbz	r4, 11440 <w_lte_lc_connect+0x4c>
   1141e:	f04f 7296 	mov.w	r2, #19660800	; 0x12c0000
   11422:	2300      	movs	r3, #0
   11424:	4630      	mov	r0, r6
   11426:	f009 fb79 	bl	1ab1c <z_impl_k_sem_take>
		if (err == -EAGAIN) {
   1142a:	f110 0f0b 	cmn.w	r0, #11
   1142e:	d107      	bne.n	11440 <w_lte_lc_connect+0x4c>
			if (IS_ENABLED(CONFIG_LTE_NETWORK_USE_FALLBACK) &&
   11430:	2d01      	cmp	r5, #1
   11432:	d009      	beq.n	11448 <w_lte_lc_connect+0x54>
				err = lte_lc_offline();
   11434:	f7ff ff64 	bl	11300 <lte_lc_offline>
				if (err) {
   11438:	2501      	movs	r5, #1
				current_network_mode = sys_mode_fallback;
   1143a:	2302      	movs	r3, #2
				if (err) {
   1143c:	2800      	cmp	r0, #0
   1143e:	d0e6      	beq.n	1140e <w_lte_lc_connect+0x1a>
}
   11440:	bd70      	pop	{r4, r5, r6, pc}
		return -EPERM;
   11442:	f04f 30ff 	mov.w	r0, #4294967295
   11446:	e7fb      	b.n	11440 <w_lte_lc_connect+0x4c>
				err = -ETIMEDOUT;
   11448:	f06f 003b 	mvn.w	r0, #59	; 0x3b
	} while (retry);
   1144c:	e7f8      	b.n	11440 <w_lte_lc_connect+0x4c>
   1144e:	bf00      	nop
   11450:	20023665 	.word	0x20023665
   11454:	20020530 	.word	0x20020530

00011458 <lte_lc_system_mode_get>:

int lte_lc_system_mode_get(enum lte_lc_system_mode *mode)
{
   11458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err, bitmask = 0;
	struct at_param_list resp_list = {0};
   1145c:	2400      	movs	r4, #0
{
   1145e:	b090      	sub	sp, #64	; 0x40
   11460:	4605      	mov	r5, r0
	char response[AT_XSYSTEMMODE_RESPONSE_MAX_LEN] = {0};
   11462:	221a      	movs	r2, #26
   11464:	4621      	mov	r1, r4
   11466:	a809      	add	r0, sp, #36	; 0x24
	struct at_param_list resp_list = {0};
   11468:	e9cd 4402 	strd	r4, r4, [sp, #8]
	char response[AT_XSYSTEMMODE_RESPONSE_MAX_LEN] = {0};
   1146c:	9408      	str	r4, [sp, #32]
   1146e:	f00a fde4 	bl	1c03a <memset>
	char response_prefix[sizeof(AT_XSYSTEMMODE_RESPONSE_PREFIX)] = {0};
	size_t response_prefix_len = sizeof(response_prefix);
   11472:	230d      	movs	r3, #13
	char response_prefix[sizeof(AT_XSYSTEMMODE_RESPONSE_PREFIX)] = {0};
   11474:	e9cd 4404 	strd	r4, r4, [sp, #16]
   11478:	9406      	str	r4, [sp, #24]
   1147a:	f88d 401c 	strb.w	r4, [sp, #28]
	size_t response_prefix_len = sizeof(response_prefix);
   1147e:	9300      	str	r3, [sp, #0]

	if (mode == NULL) {
   11480:	2d00      	cmp	r5, #0
   11482:	d05d      	beq.n	11540 <lte_lc_system_mode_get+0xe8>
		return -EINVAL;
	}

	err = at_cmd_write(AT_XSYSTEMMODE_READ, response, sizeof(response),
   11484:	4623      	mov	r3, r4
   11486:	221e      	movs	r2, #30
   11488:	482f      	ldr	r0, [pc, #188]	; (11548 <lte_lc_system_mode_get+0xf0>)
   1148a:	a908      	add	r1, sp, #32
   1148c:	f7ff fae4 	bl	10a58 <at_cmd_write>
			   NULL);
	if (err) {
   11490:	4604      	mov	r4, r0
   11492:	2800      	cmp	r0, #0
   11494:	d13f      	bne.n	11516 <lte_lc_system_mode_get+0xbe>
		LOG_ERR("Could not send AT command");
		return err;
	}

	err = at_params_list_init(&resp_list, AT_XSYSTEMMODE_PARAMS_COUNT);
   11496:	2105      	movs	r1, #5
   11498:	a802      	add	r0, sp, #8
   1149a:	f00b fcf3 	bl	1ce84 <at_params_list_init>
	if (err) {
   1149e:	4604      	mov	r4, r0
   114a0:	2800      	cmp	r0, #0
   114a2:	d138      	bne.n	11516 <lte_lc_system_mode_get+0xbe>
		LOG_ERR("Could init AT params list, error: %d", err);
		return err;
	}

	err = at_parser_max_params_from_str(response, NULL, &resp_list,
   114a4:	4601      	mov	r1, r0
   114a6:	2305      	movs	r3, #5
   114a8:	aa02      	add	r2, sp, #8
   114aa:	a808      	add	r0, sp, #32
   114ac:	f7ff fe36 	bl	1111c <at_parser_max_params_from_str>
					    AT_XSYSTEMMODE_PARAMS_COUNT);
	if (err) {
   114b0:	4604      	mov	r4, r0
   114b2:	bb68      	cbnz	r0, 11510 <lte_lc_system_mode_get+0xb8>
		LOG_ERR("Could not parse AT response, error: %d", err);
		goto clean_exit;
	}

	/* Check if AT command response starts with %XSYSTEMMODE */
	err = at_params_string_get(&resp_list,
   114b4:	4601      	mov	r1, r0
   114b6:	466b      	mov	r3, sp
   114b8:	aa04      	add	r2, sp, #16
   114ba:	a802      	add	r0, sp, #8
   114bc:	f00b fdad 	bl	1d01a <at_params_string_get>
				   AT_RESPONSE_PREFIX_INDEX,
				   response_prefix,
				   &response_prefix_len);
	if (err) {
   114c0:	4604      	mov	r4, r0
   114c2:	bb28      	cbnz	r0, 11510 <lte_lc_system_mode_get+0xb8>
	if ((response == NULL) || (check == NULL)) {
   114c4:	4a21      	ldr	r2, [pc, #132]	; (1154c <lte_lc_system_mode_get+0xf4>)
   114c6:	9900      	ldr	r1, [sp, #0]
   114c8:	a804      	add	r0, sp, #16
   114ca:	f00b fdc9 	bl	1d060 <response_is_valid.part.0>
		LOG_ERR("Could not get response prefix, error: %d", err);
		goto clean_exit;
	}

	if (!response_is_valid(response_prefix, response_prefix_len,
   114ce:	b388      	cbz	r0, 11534 <lte_lc_system_mode_get+0xdc>
	}

	/* We skip the first parameter, as that's the response prefix,
	 * "%XSYSTEMMODE:" in this case."
	 */
	for (size_t i = 1; i < AT_XSYSTEMMODE_PARAMS_COUNT; i++) {
   114d0:	2601      	movs	r6, #1
	int err, bitmask = 0;
   114d2:	4627      	mov	r7, r4
		if (err) {
			LOG_ERR("Could not parse mode parameter, err: %d", err);
			goto clean_exit;
		}

		bitmask = param ? bitmask | BIT(i) : bitmask;
   114d4:	46b0      	mov	r8, r6
		err = at_params_int_get(&resp_list, i, &param);
   114d6:	4631      	mov	r1, r6
   114d8:	aa01      	add	r2, sp, #4
   114da:	a802      	add	r0, sp, #8
   114dc:	f00b fd8a 	bl	1cff4 <at_params_int_get>
		if (err) {
   114e0:	4604      	mov	r4, r0
   114e2:	b9a8      	cbnz	r0, 11510 <lte_lc_system_mode_get+0xb8>
		bitmask = param ? bitmask | BIT(i) : bitmask;
   114e4:	9b01      	ldr	r3, [sp, #4]
   114e6:	b113      	cbz	r3, 114ee <lte_lc_system_mode_get+0x96>
   114e8:	fa08 f306 	lsl.w	r3, r8, r6
   114ec:	431f      	orrs	r7, r3
	for (size_t i = 1; i < AT_XSYSTEMMODE_PARAMS_COUNT; i++) {
   114ee:	3601      	adds	r6, #1
   114f0:	2e05      	cmp	r6, #5
   114f2:	d1f0      	bne.n	114d6 <lte_lc_system_mode_get+0x7e>
	}

	/* When checking the bitmask, we need to add 1 to the indices,
	 * as the response prefix is also counted as a parameter.
	 */
	switch (bitmask) {
   114f4:	2f0c      	cmp	r7, #12
   114f6:	d820      	bhi.n	1153a <lte_lc_system_mode_get+0xe2>
   114f8:	e8df f007 	tbb	[pc, r7]
   114fc:	1f111f07 	.word	0x1f111f07
   11500:	1f1f1f14 	.word	0x1f1f1f14
   11504:	1f181f16 	.word	0x1f181f16
   11508:	1a          	.byte	0x1a
   11509:	00          	.byte	0x00
	case 0:
		*mode = LTE_LC_SYSTEM_MODE_NONE;
   1150a:	2300      	movs	r3, #0
		break;
   1150c:	463c      	mov	r4, r7
		*mode = LTE_LC_SYSTEM_MODE_NONE;
   1150e:	702b      	strb	r3, [r5, #0]
		err = -EFAULT;
		break;
	}

clean_exit:
	at_params_list_free(&resp_list);
   11510:	a802      	add	r0, sp, #8
   11512:	f00b fce3 	bl	1cedc <at_params_list_free>

	return err;
}
   11516:	4620      	mov	r0, r4
   11518:	b010      	add	sp, #64	; 0x40
   1151a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*mode = LTE_LC_SYSTEM_MODE_LTEM;
   1151e:	2301      	movs	r3, #1
		*mode = LTE_LC_SYSTEM_MODE_NBIOT_GPS;
   11520:	702b      	strb	r3, [r5, #0]
		break;
   11522:	e7f5      	b.n	11510 <lte_lc_system_mode_get+0xb8>
		*mode = LTE_LC_SYSTEM_MODE_NBIOT;
   11524:	2302      	movs	r3, #2
   11526:	e7fb      	b.n	11520 <lte_lc_system_mode_get+0xc8>
		*mode = LTE_LC_SYSTEM_MODE_GPS;
   11528:	2303      	movs	r3, #3
   1152a:	e7f9      	b.n	11520 <lte_lc_system_mode_get+0xc8>
		*mode = LTE_LC_SYSTEM_MODE_LTEM_GPS;
   1152c:	2304      	movs	r3, #4
   1152e:	e7f7      	b.n	11520 <lte_lc_system_mode_get+0xc8>
		*mode = LTE_LC_SYSTEM_MODE_NBIOT_GPS;
   11530:	2305      	movs	r3, #5
   11532:	e7f5      	b.n	11520 <lte_lc_system_mode_get+0xc8>
		err = -EIO;
   11534:	f06f 0404 	mvn.w	r4, #4
   11538:	e7ea      	b.n	11510 <lte_lc_system_mode_get+0xb8>
	for (size_t i = 1; i < AT_XSYSTEMMODE_PARAMS_COUNT; i++) {
   1153a:	f06f 040d 	mvn.w	r4, #13
   1153e:	e7e7      	b.n	11510 <lte_lc_system_mode_get+0xb8>
		return -EINVAL;
   11540:	f06f 0415 	mvn.w	r4, #21
   11544:	e7e7      	b.n	11516 <lte_lc_system_mode_get+0xbe>
   11546:	bf00      	nop
   11548:	0001e5b8 	.word	0x0001e5b8
   1154c:	0001e5c8 	.word	0x0001e5c8

00011550 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(struct device *dev)
{
   11550:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   11554:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   11556:	4c21      	ldr	r4, [pc, #132]	; (115dc <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
   11558:	4e21      	ldr	r6, [pc, #132]	; (115e0 <check_ext_api_requests+0x90>)
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   1155a:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   1155e:	f8df 9088 	ldr.w	r9, [pc, #136]	; 115e8 <check_ext_api_requests+0x98>
{
   11562:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   11564:	45a8      	cmp	r8, r5
   11566:	d803      	bhi.n	11570 <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   11568:	2000      	movs	r0, #0
   1156a:	b005      	add	sp, #20
   1156c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
   11570:	6a63      	ldr	r3, [r4, #36]	; 0x24
   11572:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   11576:	681f      	ldr	r7, [r3, #0]
   11578:	ab01      	add	r3, sp, #4
   1157a:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   1157e:	220c      	movs	r2, #12
   11580:	4619      	mov	r1, r3
   11582:	4638      	mov	r0, r7
   11584:	f00a fd1e 	bl	1bfc4 <memcmp>
   11588:	b990      	cbnz	r0, 115b0 <check_ext_api_requests+0x60>
   1158a:	b18f      	cbz	r7, 115b0 <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   1158c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
   1158e:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   11590:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   11592:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   11594:	4291      	cmp	r1, r2
   11596:	d10b      	bne.n	115b0 <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   11598:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
   1159a:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   1159c:	4291      	cmp	r1, r2
   1159e:	d807      	bhi.n	115b0 <check_ext_api_requests+0x60>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
   115a0:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   115a2:	4291      	cmp	r1, r2
   115a4:	d904      	bls.n	115b0 <check_ext_api_requests+0x60>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
   115a6:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   115a8:	695b      	ldr	r3, [r3, #20]
   115aa:	ea32 0303 	bics.w	r3, r2, r3
   115ae:	d00a      	beq.n	115c6 <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   115b0:	6a27      	ldr	r7, [r4, #32]
   115b2:	b167      	cbz	r7, 115ce <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   115b4:	480b      	ldr	r0, [pc, #44]	; (115e4 <check_ext_api_requests+0x94>)
   115b6:	f009 fd76 	bl	1b0a6 <printk>
			k_panic();
   115ba:	4040      	eors	r0, r0
   115bc:	f380 8811 	msr	BASEPRI, r0
   115c0:	f04f 0004 	mov.w	r0, #4
   115c4:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   115c6:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   115c8:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   115ca:	441c      	add	r4, r3
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   115cc:	e7ca      	b.n	11564 <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   115ce:	4648      	mov	r0, r9
   115d0:	f009 fd69 	bl	1b0a6 <printk>
			*ext_api_req->ext_api = NULL;
   115d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   115d6:	601f      	str	r7, [r3, #0]
   115d8:	e7f5      	b.n	115c6 <check_ext_api_requests+0x76>
   115da:	bf00      	nop
   115dc:	0000c23c 	.word	0x0000c23c
   115e0:	0001dbdc 	.word	0x0001dbdc
   115e4:	0001e636 	.word	0x0001e636
   115e8:	0001e65f 	.word	0x0001e65f

000115ec <packet_free_cb>:
   115ec:	b510      	push	{r4, lr}
   115ee:	4604      	mov	r4, r0
   115f0:	6800      	ldr	r0, [r0, #0]
   115f2:	f004 fc9b 	bl	15f2c <rpc_logobj_client_data_free>
   115f6:	68a0      	ldr	r0, [r4, #8]
   115f8:	b118      	cbz	r0, 11602 <packet_free_cb+0x16>
   115fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   115fe:	f007 ba1b 	b.w	18a38 <nrf_free>
   11602:	bd10      	pop	{r4, pc}

00011604 <logobj_event_handler>:
   11604:	b530      	push	{r4, r5, lr}
   11606:	4b3b      	ldr	r3, [pc, #236]	; (116f4 <logobj_event_handler+0xf0>)
   11608:	b085      	sub	sp, #20
   1160a:	681d      	ldr	r5, [r3, #0]
   1160c:	2d00      	cmp	r5, #0
   1160e:	d04c      	beq.n	116aa <logobj_event_handler+0xa6>
   11610:	f248 0302 	movw	r3, #32770	; 0x8002
   11614:	4299      	cmp	r1, r3
   11616:	d053      	beq.n	116c0 <logobj_event_handler+0xbc>
   11618:	d91c      	bls.n	11654 <logobj_event_handler+0x50>
   1161a:	f248 0303 	movw	r3, #32771	; 0x8003
   1161e:	4299      	cmp	r1, r3
   11620:	d05a      	beq.n	116d8 <logobj_event_handler+0xd4>
   11622:	f249 0301 	movw	r3, #36865	; 0x9001
   11626:	4299      	cmp	r1, r3
   11628:	d147      	bne.n	116ba <logobj_event_handler+0xb6>
   1162a:	2400      	movs	r4, #0
   1162c:	6843      	ldr	r3, [r0, #4]
   1162e:	6802      	ldr	r2, [r0, #0]
   11630:	e9cd 4402 	strd	r4, r4, [sp, #8]
   11634:	e9cd 2300 	strd	r2, r3, [sp]
   11638:	69e8      	ldr	r0, [r5, #28]
   1163a:	4669      	mov	r1, sp
   1163c:	6803      	ldr	r3, [r0, #0]
   1163e:	685b      	ldr	r3, [r3, #4]
   11640:	4798      	blx	r3
   11642:	3001      	adds	r0, #1
   11644:	d04e      	beq.n	116e4 <logobj_event_handler+0xe0>
   11646:	4620      	mov	r0, r4
   11648:	682b      	ldr	r3, [r5, #0]
   1164a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   1164e:	602b      	str	r3, [r5, #0]
   11650:	b005      	add	sp, #20
   11652:	bd30      	pop	{r4, r5, pc}
   11654:	f248 0301 	movw	r3, #32769	; 0x8001
   11658:	4299      	cmp	r1, r3
   1165a:	d12e      	bne.n	116ba <logobj_event_handler+0xb6>
   1165c:	68c3      	ldr	r3, [r0, #12]
   1165e:	2b00      	cmp	r3, #0
   11660:	d135      	bne.n	116ce <logobj_event_handler+0xca>
   11662:	6828      	ldr	r0, [r5, #0]
   11664:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
   11668:	d03e      	beq.n	116e8 <logobj_event_handler+0xe4>
   1166a:	682b      	ldr	r3, [r5, #0]
   1166c:	b29b      	uxth	r3, r3
   1166e:	2b01      	cmp	r3, #1
   11670:	d105      	bne.n	1167e <logobj_event_handler+0x7a>
   11672:	682b      	ldr	r3, [r5, #0]
   11674:	0c1b      	lsrs	r3, r3, #16
   11676:	041b      	lsls	r3, r3, #16
   11678:	f043 0302 	orr.w	r3, r3, #2
   1167c:	602b      	str	r3, [r5, #0]
   1167e:	4b1e      	ldr	r3, [pc, #120]	; (116f8 <logobj_event_handler+0xf4>)
   11680:	781a      	ldrb	r2, [r3, #0]
   11682:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   11686:	2a00      	cmp	r2, #0
   11688:	d031      	beq.n	116ee <logobj_event_handler+0xea>
   1168a:	4a1c      	ldr	r2, [pc, #112]	; (116fc <logobj_event_handler+0xf8>)
   1168c:	7811      	ldrb	r1, [r2, #0]
   1168e:	b909      	cbnz	r1, 11694 <logobj_event_handler+0x90>
   11690:	2101      	movs	r1, #1
   11692:	7011      	strb	r1, [r2, #0]
   11694:	2000      	movs	r0, #0
   11696:	7018      	strb	r0, [r3, #0]
   11698:	682b      	ldr	r3, [r5, #0]
   1169a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1169e:	602b      	str	r3, [r5, #0]
   116a0:	682b      	ldr	r3, [r5, #0]
   116a2:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   116a6:	602b      	str	r3, [r5, #0]
   116a8:	e7d2      	b.n	11650 <logobj_event_handler+0x4c>
   116aa:	6800      	ldr	r0, [r0, #0]
   116ac:	2800      	cmp	r0, #0
   116ae:	d0cf      	beq.n	11650 <logobj_event_handler+0x4c>
   116b0:	f004 fc3c 	bl	15f2c <rpc_logobj_client_data_free>
   116b4:	4628      	mov	r0, r5
   116b6:	b005      	add	sp, #20
   116b8:	bd30      	pop	{r4, r5, pc}
   116ba:	2000      	movs	r0, #0
   116bc:	b005      	add	sp, #20
   116be:	bd30      	pop	{r4, r5, pc}
   116c0:	682b      	ldr	r3, [r5, #0]
   116c2:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
   116c6:	d00b      	beq.n	116e0 <logobj_event_handler+0xdc>
   116c8:	68c0      	ldr	r0, [r0, #12]
   116ca:	2800      	cmp	r0, #0
   116cc:	d0e4      	beq.n	11698 <logobj_event_handler+0x94>
   116ce:	230e      	movs	r3, #14
   116d0:	2000      	movs	r0, #0
   116d2:	606b      	str	r3, [r5, #4]
   116d4:	b005      	add	sp, #20
   116d6:	bd30      	pop	{r4, r5, pc}
   116d8:	68c3      	ldr	r3, [r0, #12]
   116da:	2b01      	cmp	r3, #1
   116dc:	d1a5      	bne.n	1162a <logobj_event_handler+0x26>
   116de:	e7f6      	b.n	116ce <logobj_event_handler+0xca>
   116e0:	4618      	mov	r0, r3
   116e2:	e7b5      	b.n	11650 <logobj_event_handler+0x4c>
   116e4:	2002      	movs	r0, #2
   116e6:	e7b3      	b.n	11650 <logobj_event_handler+0x4c>
   116e8:	230e      	movs	r3, #14
   116ea:	606b      	str	r3, [r5, #4]
   116ec:	e7b0      	b.n	11650 <logobj_event_handler+0x4c>
   116ee:	4a03      	ldr	r2, [pc, #12]	; (116fc <logobj_event_handler+0xf8>)
   116f0:	7011      	strb	r1, [r2, #0]
   116f2:	e7cf      	b.n	11694 <logobj_event_handler+0x90>
   116f4:	2002055c 	.word	0x2002055c
   116f8:	20023667 	.word	0x20023667
   116fc:	20023668 	.word	0x20023668

00011700 <logobj_interface_init>:
   11700:	2300      	movs	r3, #0
   11702:	b510      	push	{r4, lr}
   11704:	4808      	ldr	r0, [pc, #32]	; (11728 <logobj_interface_init+0x28>)
   11706:	4c09      	ldr	r4, [pc, #36]	; (1172c <logobj_interface_init+0x2c>)
   11708:	4909      	ldr	r1, [pc, #36]	; (11730 <logobj_interface_init+0x30>)
   1170a:	4a0a      	ldr	r2, [pc, #40]	; (11734 <logobj_interface_init+0x34>)
   1170c:	7023      	strb	r3, [r4, #0]
   1170e:	6003      	str	r3, [r0, #0]
   11710:	700b      	strb	r3, [r1, #0]
   11712:	6013      	str	r3, [r2, #0]
   11714:	f004 fbce 	bl	15eb4 <rpc_logobj_client_init>
   11718:	b918      	cbnz	r0, 11722 <logobj_interface_init+0x22>
   1171a:	2201      	movs	r2, #1
   1171c:	4b06      	ldr	r3, [pc, #24]	; (11738 <logobj_interface_init+0x38>)
   1171e:	701a      	strb	r2, [r3, #0]
   11720:	bd10      	pop	{r4, pc}
   11722:	f04f 30ff 	mov.w	r0, #4294967295
   11726:	bd10      	pop	{r4, pc}
   11728:	2002055c 	.word	0x2002055c
   1172c:	20023668 	.word	0x20023668
   11730:	20023667 	.word	0x20023667
   11734:	20020558 	.word	0x20020558
   11738:	20023669 	.word	0x20023669

0001173c <logobj_interface_open>:
   1173c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11740:	2400      	movs	r4, #0
   11742:	4b5b      	ldr	r3, [pc, #364]	; (118b0 <logobj_interface_open+0x174>)
   11744:	b084      	sub	sp, #16
   11746:	781b      	ldrb	r3, [r3, #0]
   11748:	9401      	str	r4, [sp, #4]
   1174a:	2b00      	cmp	r3, #0
   1174c:	f000 809f 	beq.w	1188e <logobj_interface_open+0x152>
   11750:	2866      	cmp	r0, #102	; 0x66
   11752:	4680      	mov	r8, r0
   11754:	f040 808f 	bne.w	11876 <logobj_interface_open+0x13a>
   11758:	2902      	cmp	r1, #2
   1175a:	4689      	mov	r9, r1
   1175c:	f040 808b 	bne.w	11876 <logobj_interface_open+0x13a>
   11760:	f240 2305 	movw	r3, #517	; 0x205
   11764:	429a      	cmp	r2, r3
   11766:	4692      	mov	sl, r2
   11768:	f040 8085 	bne.w	11876 <logobj_interface_open+0x13a>
   1176c:	4f51      	ldr	r7, [pc, #324]	; (118b4 <logobj_interface_open+0x178>)
   1176e:	683d      	ldr	r5, [r7, #0]
   11770:	2d00      	cmp	r5, #0
   11772:	f040 8086 	bne.w	11882 <logobj_interface_open+0x146>
   11776:	4a50      	ldr	r2, [pc, #320]	; (118b8 <logobj_interface_open+0x17c>)
   11778:	a801      	add	r0, sp, #4
   1177a:	f007 fc85 	bl	19088 <interface_socket_allocate>
   1177e:	9b01      	ldr	r3, [sp, #4]
   11780:	4606      	mov	r6, r0
   11782:	2b00      	cmp	r3, #0
   11784:	f000 808d 	beq.w	118a2 <logobj_interface_open+0x166>
   11788:	4629      	mov	r1, r5
   1178a:	2204      	movs	r2, #4
   1178c:	484b      	ldr	r0, [pc, #300]	; (118bc <logobj_interface_open+0x180>)
   1178e:	603b      	str	r3, [r7, #0]
   11790:	f00a fc53 	bl	1c03a <memset>
   11794:	9c01      	ldr	r4, [sp, #4]
   11796:	4629      	mov	r1, r5
   11798:	e9c4 8903 	strd	r8, r9, [r4, #12]
   1179c:	f8c4 a014 	str.w	sl, [r4, #20]
   117a0:	a802      	add	r0, sp, #8
   117a2:	f004 fb8d 	bl	15ec0 <rpc_logobj_client_request_alloc>
   117a6:	2800      	cmp	r0, #0
   117a8:	d142      	bne.n	11830 <logobj_interface_open+0xf4>
   117aa:	2201      	movs	r2, #1
   117ac:	2104      	movs	r1, #4
   117ae:	9b02      	ldr	r3, [sp, #8]
   117b0:	4d43      	ldr	r5, [pc, #268]	; (118c0 <logobj_interface_open+0x184>)
   117b2:	7358      	strb	r0, [r3, #13]
   117b4:	7398      	strb	r0, [r3, #14]
   117b6:	73d8      	strb	r0, [r3, #15]
   117b8:	7258      	strb	r0, [r3, #9]
   117ba:	7298      	strb	r0, [r3, #10]
   117bc:	72d8      	strb	r0, [r3, #11]
   117be:	7219      	strb	r1, [r3, #8]
   117c0:	702a      	strb	r2, [r5, #0]
   117c2:	731a      	strb	r2, [r3, #12]
   117c4:	6822      	ldr	r2, [r4, #0]
   117c6:	4618      	mov	r0, r3
   117c8:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   117cc:	6022      	str	r2, [r4, #0]
   117ce:	f247 0101 	movw	r1, #28673	; 0x7001
   117d2:	f004 fb8d 	bl	15ef0 <rpc_logobj_client_request_send>
   117d6:	bb68      	cbnz	r0, 11834 <logobj_interface_open+0xf8>
   117d8:	6a61      	ldr	r1, [r4, #36]	; 0x24
   117da:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   117de:	2900      	cmp	r1, #0
   117e0:	bf08      	it	eq
   117e2:	f04f 31ff 	moveq.w	r1, #4294967295
   117e6:	ab04      	add	r3, sp, #16
   117e8:	f843 1d04 	str.w	r1, [r3, #-4]!
   117ec:	4630      	mov	r0, r6
   117ee:	4611      	mov	r1, r2
   117f0:	f007 fcfc 	bl	191ec <interface_socket_wait>
   117f4:	4604      	mov	r4, r0
   117f6:	b310      	cbz	r0, 1183e <logobj_interface_open+0x102>
   117f8:	9a01      	ldr	r2, [sp, #4]
   117fa:	2e00      	cmp	r6, #0
   117fc:	6813      	ldr	r3, [r2, #0]
   117fe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11802:	6013      	str	r3, [r2, #0]
   11804:	9a01      	ldr	r2, [sp, #4]
   11806:	6813      	ldr	r3, [r2, #0]
   11808:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   1180c:	6013      	str	r3, [r2, #0]
   1180e:	9a01      	ldr	r2, [sp, #4]
   11810:	6813      	ldr	r3, [r2, #0]
   11812:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   11816:	6013      	str	r3, [r2, #0]
   11818:	da3f      	bge.n	1189a <logobj_interface_open+0x15e>
   1181a:	2300      	movs	r3, #0
   1181c:	4620      	mov	r0, r4
   1181e:	603b      	str	r3, [r7, #0]
   11820:	f04f 36ff 	mov.w	r6, #4294967295
   11824:	f7fe fc02 	bl	1002c <bsd_os_errno_set>
   11828:	4630      	mov	r0, r6
   1182a:	b004      	add	sp, #16
   1182c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11830:	240c      	movs	r4, #12
   11832:	e7e1      	b.n	117f8 <logobj_interface_open+0xbc>
   11834:	9802      	ldr	r0, [sp, #8]
   11836:	f004 fb71 	bl	15f1c <rpc_logobj_client_message_free>
   1183a:	2405      	movs	r4, #5
   1183c:	e7dc      	b.n	117f8 <logobj_interface_open+0xbc>
   1183e:	4630      	mov	r0, r6
   11840:	f007 fd54 	bl	192ec <interface_socket_from_handle_get>
   11844:	b120      	cbz	r0, 11850 <logobj_interface_open+0x114>
   11846:	6844      	ldr	r4, [r0, #4]
   11848:	b114      	cbz	r4, 11850 <logobj_interface_open+0x114>
   1184a:	2300      	movs	r3, #0
   1184c:	6043      	str	r3, [r0, #4]
   1184e:	e7d3      	b.n	117f8 <logobj_interface_open+0xbc>
   11850:	4630      	mov	r0, r6
   11852:	9a01      	ldr	r2, [sp, #4]
   11854:	6813      	ldr	r3, [r2, #0]
   11856:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1185a:	6013      	str	r3, [r2, #0]
   1185c:	9a01      	ldr	r2, [sp, #4]
   1185e:	6813      	ldr	r3, [r2, #0]
   11860:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   11864:	6013      	str	r3, [r2, #0]
   11866:	9a01      	ldr	r2, [sp, #4]
   11868:	6813      	ldr	r3, [r2, #0]
   1186a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   1186e:	6013      	str	r3, [r2, #0]
   11870:	b004      	add	sp, #16
   11872:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11876:	2016      	movs	r0, #22
   11878:	f7fe fbd8 	bl	1002c <bsd_os_errno_set>
   1187c:	f04f 36ff 	mov.w	r6, #4294967295
   11880:	e7d2      	b.n	11828 <logobj_interface_open+0xec>
   11882:	2001      	movs	r0, #1
   11884:	f7fe fbd2 	bl	1002c <bsd_os_errno_set>
   11888:	f04f 36ff 	mov.w	r6, #4294967295
   1188c:	e7cc      	b.n	11828 <logobj_interface_open+0xec>
   1188e:	2005      	movs	r0, #5
   11890:	f7fe fbcc 	bl	1002c <bsd_os_errno_set>
   11894:	f04f 36ff 	mov.w	r6, #4294967295
   11898:	e7c6      	b.n	11828 <logobj_interface_open+0xec>
   1189a:	4630      	mov	r0, r6
   1189c:	f007 fc58 	bl	19150 <interface_socket_free>
   118a0:	e7bb      	b.n	1181a <logobj_interface_open+0xde>
   118a2:	2018      	movs	r0, #24
   118a4:	f7fe fbc2 	bl	1002c <bsd_os_errno_set>
   118a8:	f04f 36ff 	mov.w	r6, #4294967295
   118ac:	e7bc      	b.n	11828 <logobj_interface_open+0xec>
   118ae:	bf00      	nop
   118b0:	20023669 	.word	0x20023669
   118b4:	2002055c 	.word	0x2002055c
   118b8:	000115ed 	.word	0x000115ed
   118bc:	20020558 	.word	0x20020558
   118c0:	20023667 	.word	0x20023667

000118c4 <logobj_interface_read>:
   118c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   118c8:	b087      	sub	sp, #28
   118ca:	2900      	cmp	r1, #0
   118cc:	d06b      	beq.n	119a6 <logobj_interface_read+0xe2>
   118ce:	2a00      	cmp	r2, #0
   118d0:	4617      	mov	r7, r2
   118d2:	dd68      	ble.n	119a6 <logobj_interface_read+0xe2>
   118d4:	461d      	mov	r5, r3
   118d6:	4680      	mov	r8, r0
   118d8:	460e      	mov	r6, r1
   118da:	f007 fd07 	bl	192ec <interface_socket_from_handle_get>
   118de:	4604      	mov	r4, r0
   118e0:	2800      	cmp	r0, #0
   118e2:	d066      	beq.n	119b2 <logobj_interface_read+0xee>
   118e4:	bb4d      	cbnz	r5, 1193a <logobj_interface_read+0x76>
   118e6:	69e0      	ldr	r0, [r4, #28]
   118e8:	07aa      	lsls	r2, r5, #30
   118ea:	6803      	ldr	r3, [r0, #0]
   118ec:	68db      	ldr	r3, [r3, #12]
   118ee:	d52d      	bpl.n	1194c <logobj_interface_read+0x88>
   118f0:	4798      	blx	r3
   118f2:	3001      	adds	r0, #1
   118f4:	d047      	beq.n	11986 <logobj_interface_read+0xc2>
   118f6:	6823      	ldr	r3, [r4, #0]
   118f8:	69e0      	ldr	r0, [r4, #28]
   118fa:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   118fe:	d044      	beq.n	1198a <logobj_interface_read+0xc6>
   11900:	2100      	movs	r1, #0
   11902:	6823      	ldr	r3, [r4, #0]
   11904:	462a      	mov	r2, r5
   11906:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1190a:	6023      	str	r3, [r4, #0]
   1190c:	e9cd 1104 	strd	r1, r1, [sp, #16]
   11910:	e9cd 6702 	strd	r6, r7, [sp, #8]
   11914:	6803      	ldr	r3, [r0, #0]
   11916:	a902      	add	r1, sp, #8
   11918:	689b      	ldr	r3, [r3, #8]
   1191a:	4798      	blx	r3
   1191c:	4605      	mov	r5, r0
   1191e:	69e0      	ldr	r0, [r4, #28]
   11920:	6803      	ldr	r3, [r0, #0]
   11922:	68db      	ldr	r3, [r3, #12]
   11924:	4798      	blx	r3
   11926:	3001      	adds	r0, #1
   11928:	d003      	beq.n	11932 <logobj_interface_read+0x6e>
   1192a:	6823      	ldr	r3, [r4, #0]
   1192c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   11930:	6023      	str	r3, [r4, #0]
   11932:	4628      	mov	r0, r5
   11934:	b007      	add	sp, #28
   11936:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1193a:	f015 0f2a 	tst.w	r5, #42	; 0x2a
   1193e:	d1d2      	bne.n	118e6 <logobj_interface_read+0x22>
   11940:	202d      	movs	r0, #45	; 0x2d
   11942:	f7fe fb73 	bl	1002c <bsd_os_errno_set>
   11946:	f04f 35ff 	mov.w	r5, #4294967295
   1194a:	e7f2      	b.n	11932 <logobj_interface_read+0x6e>
   1194c:	6822      	ldr	r2, [r4, #0]
   1194e:	f012 5980 	ands.w	r9, r2, #268435456	; 0x10000000
   11952:	d1cd      	bne.n	118f0 <logobj_interface_read+0x2c>
   11954:	4798      	blx	r3
   11956:	1c43      	adds	r3, r0, #1
   11958:	d1cd      	bne.n	118f6 <logobj_interface_read+0x32>
   1195a:	6a22      	ldr	r2, [r4, #32]
   1195c:	ab06      	add	r3, sp, #24
   1195e:	2a00      	cmp	r2, #0
   11960:	bf18      	it	ne
   11962:	4610      	movne	r0, r2
   11964:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   11968:	f843 0d14 	str.w	r0, [r3, #-20]!
   1196c:	4611      	mov	r1, r2
   1196e:	4640      	mov	r0, r8
   11970:	f007 fc3c 	bl	191ec <interface_socket_wait>
   11974:	b158      	cbz	r0, 1198e <logobj_interface_read+0xca>
   11976:	f04f 35ff 	mov.w	r5, #4294967295
   1197a:	f7fe fb57 	bl	1002c <bsd_os_errno_set>
   1197e:	4628      	mov	r0, r5
   11980:	b007      	add	sp, #28
   11982:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11986:	2023      	movs	r0, #35	; 0x23
   11988:	e7f5      	b.n	11976 <logobj_interface_read+0xb2>
   1198a:	461d      	mov	r5, r3
   1198c:	e7c8      	b.n	11920 <logobj_interface_read+0x5c>
   1198e:	4640      	mov	r0, r8
   11990:	f007 fcac 	bl	192ec <interface_socket_from_handle_get>
   11994:	4603      	mov	r3, r0
   11996:	2800      	cmp	r0, #0
   11998:	d0ad      	beq.n	118f6 <logobj_interface_read+0x32>
   1199a:	6840      	ldr	r0, [r0, #4]
   1199c:	2800      	cmp	r0, #0
   1199e:	d0aa      	beq.n	118f6 <logobj_interface_read+0x32>
   119a0:	f8c3 9004 	str.w	r9, [r3, #4]
   119a4:	e7e7      	b.n	11976 <logobj_interface_read+0xb2>
   119a6:	2016      	movs	r0, #22
   119a8:	f7fe fb40 	bl	1002c <bsd_os_errno_set>
   119ac:	f04f 35ff 	mov.w	r5, #4294967295
   119b0:	e7bf      	b.n	11932 <logobj_interface_read+0x6e>
   119b2:	2009      	movs	r0, #9
   119b4:	f7fe fb3a 	bl	1002c <bsd_os_errno_set>
   119b8:	f04f 35ff 	mov.w	r5, #4294967295
   119bc:	e7b9      	b.n	11932 <logobj_interface_read+0x6e>
   119be:	bf00      	nop

000119c0 <logobj_interface_write>:
   119c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   119c4:	b082      	sub	sp, #8
   119c6:	2900      	cmp	r1, #0
   119c8:	d06b      	beq.n	11aa2 <logobj_interface_write+0xe2>
   119ca:	2a04      	cmp	r2, #4
   119cc:	d169      	bne.n	11aa2 <logobj_interface_write+0xe2>
   119ce:	461f      	mov	r7, r3
   119d0:	4606      	mov	r6, r0
   119d2:	460d      	mov	r5, r1
   119d4:	f007 fc8a 	bl	192ec <interface_socket_from_handle_get>
   119d8:	4604      	mov	r4, r0
   119da:	2800      	cmp	r0, #0
   119dc:	d074      	beq.n	11ac8 <logobj_interface_write+0x108>
   119de:	b1e7      	cbz	r7, 11a1a <logobj_interface_write+0x5a>
   119e0:	07b8      	lsls	r0, r7, #30
   119e2:	d56b      	bpl.n	11abc <logobj_interface_write+0xfc>
   119e4:	6823      	ldr	r3, [r4, #0]
   119e6:	039b      	lsls	r3, r3, #14
   119e8:	d564      	bpl.n	11ab4 <logobj_interface_write+0xf4>
   119ea:	2700      	movs	r7, #0
   119ec:	6823      	ldr	r3, [r4, #0]
   119ee:	2100      	movs	r1, #0
   119f0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   119f4:	6023      	str	r3, [r4, #0]
   119f6:	4668      	mov	r0, sp
   119f8:	f8d5 8000 	ldr.w	r8, [r5]
   119fc:	f004 fa60 	bl	15ec0 <rpc_logobj_client_request_alloc>
   11a00:	b198      	cbz	r0, 11a2a <logobj_interface_write+0x6a>
   11a02:	200c      	movs	r0, #12
   11a04:	6823      	ldr	r3, [r4, #0]
   11a06:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11a0a:	6023      	str	r3, [r4, #0]
   11a0c:	f7fe fb0e 	bl	1002c <bsd_os_errno_set>
   11a10:	f04f 30ff 	mov.w	r0, #4294967295
   11a14:	b002      	add	sp, #8
   11a16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11a1a:	6803      	ldr	r3, [r0, #0]
   11a1c:	00d9      	lsls	r1, r3, #3
   11a1e:	d4e1      	bmi.n	119e4 <logobj_interface_write+0x24>
   11a20:	6803      	ldr	r3, [r0, #0]
   11a22:	039a      	lsls	r2, r3, #14
   11a24:	d548      	bpl.n	11ab8 <logobj_interface_write+0xf8>
   11a26:	2701      	movs	r7, #1
   11a28:	e7e0      	b.n	119ec <logobj_interface_write+0x2c>
   11a2a:	2504      	movs	r5, #4
   11a2c:	9b00      	ldr	r3, [sp, #0]
   11a2e:	f247 0103 	movw	r1, #28675	; 0x7003
   11a32:	f8c3 800c 	str.w	r8, [r3, #12]
   11a36:	7258      	strb	r0, [r3, #9]
   11a38:	7298      	strb	r0, [r3, #10]
   11a3a:	72d8      	strb	r0, [r3, #11]
   11a3c:	721d      	strb	r5, [r3, #8]
   11a3e:	4618      	mov	r0, r3
   11a40:	f004 fa56 	bl	15ef0 <rpc_logobj_client_request_send>
   11a44:	4680      	mov	r8, r0
   11a46:	bb18      	cbnz	r0, 11a90 <logobj_interface_write+0xd0>
   11a48:	b1d7      	cbz	r7, 11a80 <logobj_interface_write+0xc0>
   11a4a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   11a4c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   11a50:	2900      	cmp	r1, #0
   11a52:	bf08      	it	eq
   11a54:	f04f 31ff 	moveq.w	r1, #4294967295
   11a58:	ab02      	add	r3, sp, #8
   11a5a:	f843 1d04 	str.w	r1, [r3, #-4]!
   11a5e:	4630      	mov	r0, r6
   11a60:	4611      	mov	r1, r2
   11a62:	f007 fbc3 	bl	191ec <interface_socket_wait>
   11a66:	b120      	cbz	r0, 11a72 <logobj_interface_write+0xb2>
   11a68:	6823      	ldr	r3, [r4, #0]
   11a6a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11a6e:	6023      	str	r3, [r4, #0]
   11a70:	e7cc      	b.n	11a0c <logobj_interface_write+0x4c>
   11a72:	4630      	mov	r0, r6
   11a74:	f007 fc3a 	bl	192ec <interface_socket_from_handle_get>
   11a78:	4603      	mov	r3, r0
   11a7a:	b108      	cbz	r0, 11a80 <logobj_interface_write+0xc0>
   11a7c:	6840      	ldr	r0, [r0, #4]
   11a7e:	b9b0      	cbnz	r0, 11aae <logobj_interface_write+0xee>
   11a80:	4628      	mov	r0, r5
   11a82:	6823      	ldr	r3, [r4, #0]
   11a84:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11a88:	6023      	str	r3, [r4, #0]
   11a8a:	b002      	add	sp, #8
   11a8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11a90:	9800      	ldr	r0, [sp, #0]
   11a92:	f004 fa43 	bl	15f1c <rpc_logobj_client_message_free>
   11a96:	6823      	ldr	r3, [r4, #0]
   11a98:	2005      	movs	r0, #5
   11a9a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11a9e:	6023      	str	r3, [r4, #0]
   11aa0:	e7b4      	b.n	11a0c <logobj_interface_write+0x4c>
   11aa2:	2016      	movs	r0, #22
   11aa4:	f7fe fac2 	bl	1002c <bsd_os_errno_set>
   11aa8:	f04f 30ff 	mov.w	r0, #4294967295
   11aac:	e7b2      	b.n	11a14 <logobj_interface_write+0x54>
   11aae:	f8c3 8004 	str.w	r8, [r3, #4]
   11ab2:	e7d9      	b.n	11a68 <logobj_interface_write+0xa8>
   11ab4:	2073      	movs	r0, #115	; 0x73
   11ab6:	e7a9      	b.n	11a0c <logobj_interface_write+0x4c>
   11ab8:	2009      	movs	r0, #9
   11aba:	e7a7      	b.n	11a0c <logobj_interface_write+0x4c>
   11abc:	202d      	movs	r0, #45	; 0x2d
   11abe:	f7fe fab5 	bl	1002c <bsd_os_errno_set>
   11ac2:	f04f 30ff 	mov.w	r0, #4294967295
   11ac6:	e7a5      	b.n	11a14 <logobj_interface_write+0x54>
   11ac8:	2009      	movs	r0, #9
   11aca:	f7fe faaf 	bl	1002c <bsd_os_errno_set>
   11ace:	f04f 30ff 	mov.w	r0, #4294967295
   11ad2:	e79f      	b.n	11a14 <logobj_interface_write+0x54>

00011ad4 <logobj_interface_setopt>:
   11ad4:	b5f0      	push	{r4, r5, r6, r7, lr}
   11ad6:	2901      	cmp	r1, #1
   11ad8:	b085      	sub	sp, #20
   11ada:	d06d      	beq.n	11bb8 <logobj_interface_setopt+0xe4>
   11adc:	461e      	mov	r6, r3
   11ade:	f240 2305 	movw	r3, #517	; 0x205
   11ae2:	4299      	cmp	r1, r3
   11ae4:	f040 80a0 	bne.w	11c28 <logobj_interface_setopt+0x154>
   11ae8:	4607      	mov	r7, r0
   11aea:	4615      	mov	r5, r2
   11aec:	f007 fbfe 	bl	192ec <interface_socket_from_handle_get>
   11af0:	4604      	mov	r4, r0
   11af2:	2800      	cmp	r0, #0
   11af4:	f000 80c3 	beq.w	11c7e <logobj_interface_setopt+0x1aa>
   11af8:	2d01      	cmp	r5, #1
   11afa:	d019      	beq.n	11b30 <logobj_interface_setopt+0x5c>
   11afc:	2d02      	cmp	r5, #2
   11afe:	d010      	beq.n	11b22 <logobj_interface_setopt+0x4e>
   11b00:	252a      	movs	r5, #42	; 0x2a
   11b02:	6803      	ldr	r3, [r0, #0]
   11b04:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   11b08:	6023      	str	r3, [r4, #0]
   11b0a:	6823      	ldr	r3, [r4, #0]
   11b0c:	4628      	mov	r0, r5
   11b0e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   11b12:	6023      	str	r3, [r4, #0]
   11b14:	f7fe fa8a 	bl	1002c <bsd_os_errno_set>
   11b18:	f04f 35ff 	mov.w	r5, #4294967295
   11b1c:	4628      	mov	r0, r5
   11b1e:	b005      	add	sp, #20
   11b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11b22:	b116      	cbz	r6, 11b2a <logobj_interface_setopt+0x56>
   11b24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   11b26:	2b01      	cmp	r3, #1
   11b28:	d04e      	beq.n	11bc8 <logobj_interface_setopt+0xf4>
   11b2a:	6823      	ldr	r3, [r4, #0]
   11b2c:	2516      	movs	r5, #22
   11b2e:	e7e9      	b.n	11b04 <logobj_interface_setopt+0x30>
   11b30:	2e00      	cmp	r6, #0
   11b32:	d0fa      	beq.n	11b2a <logobj_interface_setopt+0x56>
   11b34:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   11b36:	2b04      	cmp	r3, #4
   11b38:	d1f7      	bne.n	11b2a <logobj_interface_setopt+0x56>
   11b3a:	2100      	movs	r1, #0
   11b3c:	a803      	add	r0, sp, #12
   11b3e:	f004 f9bf 	bl	15ec0 <rpc_logobj_client_request_alloc>
   11b42:	4605      	mov	r5, r0
   11b44:	2800      	cmp	r0, #0
   11b46:	d175      	bne.n	11c34 <logobj_interface_setopt+0x160>
   11b48:	9803      	ldr	r0, [sp, #12]
   11b4a:	2208      	movs	r2, #8
   11b4c:	4629      	mov	r1, r5
   11b4e:	300c      	adds	r0, #12
   11b50:	f00a fa73 	bl	1c03a <memset>
   11b54:	9803      	ldr	r0, [sp, #12]
   11b56:	4631      	mov	r1, r6
   11b58:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   11b5a:	300c      	adds	r0, #12
   11b5c:	f00a fa42 	bl	1bfe4 <memcpy>
   11b60:	2308      	movs	r3, #8
   11b62:	9803      	ldr	r0, [sp, #12]
   11b64:	f247 0102 	movw	r1, #28674	; 0x7002
   11b68:	7203      	strb	r3, [r0, #8]
   11b6a:	7245      	strb	r5, [r0, #9]
   11b6c:	7285      	strb	r5, [r0, #10]
   11b6e:	72c5      	strb	r5, [r0, #11]
   11b70:	6823      	ldr	r3, [r4, #0]
   11b72:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   11b76:	6023      	str	r3, [r4, #0]
   11b78:	f004 f9ba 	bl	15ef0 <rpc_logobj_client_request_send>
   11b7c:	2800      	cmp	r0, #0
   11b7e:	d178      	bne.n	11c72 <logobj_interface_setopt+0x19e>
   11b80:	6a61      	ldr	r1, [r4, #36]	; 0x24
   11b82:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   11b86:	2900      	cmp	r1, #0
   11b88:	bf08      	it	eq
   11b8a:	f04f 31ff 	moveq.w	r1, #4294967295
   11b8e:	ab04      	add	r3, sp, #16
   11b90:	f843 1d08 	str.w	r1, [r3, #-8]!
   11b94:	4638      	mov	r0, r7
   11b96:	4611      	mov	r1, r2
   11b98:	f007 fb28 	bl	191ec <interface_socket_wait>
   11b9c:	4605      	mov	r5, r0
   11b9e:	2800      	cmp	r0, #0
   11ba0:	d140      	bne.n	11c24 <logobj_interface_setopt+0x150>
   11ba2:	4638      	mov	r0, r7
   11ba4:	f007 fba2 	bl	192ec <interface_socket_from_handle_get>
   11ba8:	2800      	cmp	r0, #0
   11baa:	d04e      	beq.n	11c4a <logobj_interface_setopt+0x176>
   11bac:	6843      	ldr	r3, [r0, #4]
   11bae:	2b00      	cmp	r3, #0
   11bb0:	d04b      	beq.n	11c4a <logobj_interface_setopt+0x176>
   11bb2:	6045      	str	r5, [r0, #4]
   11bb4:	461d      	mov	r5, r3
   11bb6:	e035      	b.n	11c24 <logobj_interface_setopt+0x150>
   11bb8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   11bba:	9400      	str	r4, [sp, #0]
   11bbc:	f007 fbbe 	bl	1933c <interface_socket_setopt>
   11bc0:	4605      	mov	r5, r0
   11bc2:	4628      	mov	r0, r5
   11bc4:	b005      	add	sp, #20
   11bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11bc8:	2100      	movs	r1, #0
   11bca:	a802      	add	r0, sp, #8
   11bcc:	7835      	ldrb	r5, [r6, #0]
   11bce:	f004 f977 	bl	15ec0 <rpc_logobj_client_request_alloc>
   11bd2:	bb78      	cbnz	r0, 11c34 <logobj_interface_setopt+0x160>
   11bd4:	2d01      	cmp	r5, #1
   11bd6:	bf08      	it	eq
   11bd8:	4b2c      	ldreq	r3, [pc, #176]	; (11c8c <logobj_interface_setopt+0x1b8>)
   11bda:	f04f 0204 	mov.w	r2, #4
   11bde:	bf08      	it	eq
   11be0:	701d      	strbeq	r5, [r3, #0]
   11be2:	2300      	movs	r3, #0
   11be4:	9802      	ldr	r0, [sp, #8]
   11be6:	f247 0101 	movw	r1, #28673	; 0x7001
   11bea:	7243      	strb	r3, [r0, #9]
   11bec:	60c5      	str	r5, [r0, #12]
   11bee:	7283      	strb	r3, [r0, #10]
   11bf0:	72c3      	strb	r3, [r0, #11]
   11bf2:	7202      	strb	r2, [r0, #8]
   11bf4:	6823      	ldr	r3, [r4, #0]
   11bf6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   11bfa:	6023      	str	r3, [r4, #0]
   11bfc:	f004 f978 	bl	15ef0 <rpc_logobj_client_request_send>
   11c00:	4606      	mov	r6, r0
   11c02:	bb80      	cbnz	r0, 11c66 <logobj_interface_setopt+0x192>
   11c04:	6a61      	ldr	r1, [r4, #36]	; 0x24
   11c06:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   11c0a:	2900      	cmp	r1, #0
   11c0c:	bf08      	it	eq
   11c0e:	f04f 31ff 	moveq.w	r1, #4294967295
   11c12:	ab04      	add	r3, sp, #16
   11c14:	f843 1d04 	str.w	r1, [r3, #-4]!
   11c18:	4638      	mov	r0, r7
   11c1a:	4611      	mov	r1, r2
   11c1c:	f007 fae6 	bl	191ec <interface_socket_wait>
   11c20:	4605      	mov	r5, r0
   11c22:	b150      	cbz	r0, 11c3a <logobj_interface_setopt+0x166>
   11c24:	6823      	ldr	r3, [r4, #0]
   11c26:	e76d      	b.n	11b04 <logobj_interface_setopt+0x30>
   11c28:	202a      	movs	r0, #42	; 0x2a
   11c2a:	f7fe f9ff 	bl	1002c <bsd_os_errno_set>
   11c2e:	f04f 35ff 	mov.w	r5, #4294967295
   11c32:	e773      	b.n	11b1c <logobj_interface_setopt+0x48>
   11c34:	6823      	ldr	r3, [r4, #0]
   11c36:	250c      	movs	r5, #12
   11c38:	e764      	b.n	11b04 <logobj_interface_setopt+0x30>
   11c3a:	4638      	mov	r0, r7
   11c3c:	f007 fb56 	bl	192ec <interface_socket_from_handle_get>
   11c40:	b140      	cbz	r0, 11c54 <logobj_interface_setopt+0x180>
   11c42:	6845      	ldr	r5, [r0, #4]
   11c44:	b135      	cbz	r5, 11c54 <logobj_interface_setopt+0x180>
   11c46:	6046      	str	r6, [r0, #4]
   11c48:	e7ec      	b.n	11c24 <logobj_interface_setopt+0x150>
   11c4a:	4631      	mov	r1, r6
   11c4c:	2204      	movs	r2, #4
   11c4e:	4810      	ldr	r0, [pc, #64]	; (11c90 <logobj_interface_setopt+0x1bc>)
   11c50:	f00a f9c8 	bl	1bfe4 <memcpy>
   11c54:	6823      	ldr	r3, [r4, #0]
   11c56:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   11c5a:	6023      	str	r3, [r4, #0]
   11c5c:	6823      	ldr	r3, [r4, #0]
   11c5e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   11c62:	6023      	str	r3, [r4, #0]
   11c64:	e75a      	b.n	11b1c <logobj_interface_setopt+0x48>
   11c66:	9802      	ldr	r0, [sp, #8]
   11c68:	f004 f958 	bl	15f1c <rpc_logobj_client_message_free>
   11c6c:	2505      	movs	r5, #5
   11c6e:	6823      	ldr	r3, [r4, #0]
   11c70:	e748      	b.n	11b04 <logobj_interface_setopt+0x30>
   11c72:	9803      	ldr	r0, [sp, #12]
   11c74:	f004 f952 	bl	15f1c <rpc_logobj_client_message_free>
   11c78:	2505      	movs	r5, #5
   11c7a:	6823      	ldr	r3, [r4, #0]
   11c7c:	e742      	b.n	11b04 <logobj_interface_setopt+0x30>
   11c7e:	2009      	movs	r0, #9
   11c80:	f7fe f9d4 	bl	1002c <bsd_os_errno_set>
   11c84:	f04f 35ff 	mov.w	r5, #4294967295
   11c88:	e748      	b.n	11b1c <logobj_interface_setopt+0x48>
   11c8a:	bf00      	nop
   11c8c:	20023667 	.word	0x20023667
   11c90:	20020558 	.word	0x20020558

00011c94 <logobj_interface_getopt>:
   11c94:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c96:	2901      	cmp	r1, #1
   11c98:	b083      	sub	sp, #12
   11c9a:	9e08      	ldr	r6, [sp, #32]
   11c9c:	d030      	beq.n	11d00 <logobj_interface_getopt+0x6c>
   11c9e:	461f      	mov	r7, r3
   11ca0:	f240 2305 	movw	r3, #517	; 0x205
   11ca4:	4299      	cmp	r1, r3
   11ca6:	d134      	bne.n	11d12 <logobj_interface_getopt+0x7e>
   11ca8:	4615      	mov	r5, r2
   11caa:	f007 fb1f 	bl	192ec <interface_socket_from_handle_get>
   11cae:	2800      	cmp	r0, #0
   11cb0:	d037      	beq.n	11d22 <logobj_interface_getopt+0x8e>
   11cb2:	2d01      	cmp	r5, #1
   11cb4:	d015      	beq.n	11ce2 <logobj_interface_getopt+0x4e>
   11cb6:	2d02      	cmp	r5, #2
   11cb8:	d10b      	bne.n	11cd2 <logobj_interface_getopt+0x3e>
   11cba:	b387      	cbz	r7, 11d1e <logobj_interface_getopt+0x8a>
   11cbc:	6833      	ldr	r3, [r6, #0]
   11cbe:	b373      	cbz	r3, 11d1e <logobj_interface_getopt+0x8a>
   11cc0:	2300      	movs	r3, #0
   11cc2:	2201      	movs	r2, #1
   11cc4:	4618      	mov	r0, r3
   11cc6:	491a      	ldr	r1, [pc, #104]	; (11d30 <logobj_interface_getopt+0x9c>)
   11cc8:	7809      	ldrb	r1, [r1, #0]
   11cca:	7039      	strb	r1, [r7, #0]
   11ccc:	6032      	str	r2, [r6, #0]
   11cce:	b003      	add	sp, #12
   11cd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11cd2:	2009      	movs	r0, #9
   11cd4:	f7fe f9aa 	bl	1002c <bsd_os_errno_set>
   11cd8:	f04f 33ff 	mov.w	r3, #4294967295
   11cdc:	4618      	mov	r0, r3
   11cde:	b003      	add	sp, #12
   11ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11ce2:	b1e7      	cbz	r7, 11d1e <logobj_interface_getopt+0x8a>
   11ce4:	6833      	ldr	r3, [r6, #0]
   11ce6:	2b03      	cmp	r3, #3
   11ce8:	d919      	bls.n	11d1e <logobj_interface_getopt+0x8a>
   11cea:	4638      	mov	r0, r7
   11cec:	2204      	movs	r2, #4
   11cee:	4911      	ldr	r1, [pc, #68]	; (11d34 <logobj_interface_getopt+0xa0>)
   11cf0:	f00a f978 	bl	1bfe4 <memcpy>
   11cf4:	2300      	movs	r3, #0
   11cf6:	2204      	movs	r2, #4
   11cf8:	4618      	mov	r0, r3
   11cfa:	6032      	str	r2, [r6, #0]
   11cfc:	b003      	add	sp, #12
   11cfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d00:	9600      	str	r6, [sp, #0]
   11d02:	f007 fb61 	bl	193c8 <interface_socket_getopt>
   11d06:	4603      	mov	r3, r0
   11d08:	2800      	cmp	r0, #0
   11d0a:	d1e3      	bne.n	11cd4 <logobj_interface_getopt+0x40>
   11d0c:	4618      	mov	r0, r3
   11d0e:	b003      	add	sp, #12
   11d10:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d12:	202a      	movs	r0, #42	; 0x2a
   11d14:	f7fe f98a 	bl	1002c <bsd_os_errno_set>
   11d18:	f04f 33ff 	mov.w	r3, #4294967295
   11d1c:	e7de      	b.n	11cdc <logobj_interface_getopt+0x48>
   11d1e:	2016      	movs	r0, #22
   11d20:	e7d8      	b.n	11cd4 <logobj_interface_getopt+0x40>
   11d22:	2009      	movs	r0, #9
   11d24:	f7fe f982 	bl	1002c <bsd_os_errno_set>
   11d28:	f04f 33ff 	mov.w	r3, #4294967295
   11d2c:	e7d6      	b.n	11cdc <logobj_interface_getopt+0x48>
   11d2e:	bf00      	nop
   11d30:	20023668 	.word	0x20023668
   11d34:	20020558 	.word	0x20020558

00011d38 <logobj_interface_close>:
   11d38:	b510      	push	{r4, lr}
   11d3a:	4604      	mov	r4, r0
   11d3c:	f007 fad6 	bl	192ec <interface_socket_from_handle_get>
   11d40:	b138      	cbz	r0, 11d52 <logobj_interface_close+0x1a>
   11d42:	4620      	mov	r0, r4
   11d44:	f007 fa04 	bl	19150 <interface_socket_free>
   11d48:	2300      	movs	r3, #0
   11d4a:	4a05      	ldr	r2, [pc, #20]	; (11d60 <logobj_interface_close+0x28>)
   11d4c:	4618      	mov	r0, r3
   11d4e:	6013      	str	r3, [r2, #0]
   11d50:	bd10      	pop	{r4, pc}
   11d52:	2009      	movs	r0, #9
   11d54:	f7fe f96a 	bl	1002c <bsd_os_errno_set>
   11d58:	f04f 30ff 	mov.w	r0, #4294967295
   11d5c:	bd10      	pop	{r4, pc}
   11d5e:	bf00      	nop
   11d60:	2002055c 	.word	0x2002055c

00011d64 <rpc_transport_send>:
   11d64:	f000 bed0 	b.w	12b08 <rpc_transport_ipc_send>

00011d68 <rpc_transport_rpc_alloc>:
   11d68:	f000 bf50 	b.w	12c0c <rpc_transport_ipc_tx_rpc_data_alloc>

00011d6c <rpc_transport_data_alloc>:
   11d6c:	f000 bfb6 	b.w	12cdc <rpc_transport_ipc_tx_data_alloc>

00011d70 <rpc_transport_rpc_free>:
   11d70:	f000 bdae 	b.w	128d0 <rpc_transport_ipc_msg_free>

00011d74 <rpc_transport_data_free>:
   11d74:	f000 ba64 	b.w	12240 <rpc_transport_ipc_data_free>

00011d78 <ipc_trace_init>:
   11d78:	4b01      	ldr	r3, [pc, #4]	; (11d80 <ipc_trace_init+0x8>)
   11d7a:	6018      	str	r0, [r3, #0]
   11d7c:	4770      	bx	lr
   11d7e:	bf00      	nop
   11d80:	2002056c 	.word	0x2002056c

00011d84 <bsd_os_trace_irq_handler>:
   11d84:	b5f0      	push	{r4, r5, r6, r7, lr}
   11d86:	4b6e      	ldr	r3, [pc, #440]	; (11f40 <bsd_os_trace_irq_handler+0x1bc>)
   11d88:	b083      	sub	sp, #12
   11d8a:	781b      	ldrb	r3, [r3, #0]
   11d8c:	2b00      	cmp	r3, #0
   11d8e:	f000 80d3 	beq.w	11f38 <bsd_os_trace_irq_handler+0x1b4>
   11d92:	4b6c      	ldr	r3, [pc, #432]	; (11f44 <bsd_os_trace_irq_handler+0x1c0>)
   11d94:	681c      	ldr	r4, [r3, #0]
   11d96:	b124      	cbz	r4, 11da2 <bsd_os_trace_irq_handler+0x1e>
   11d98:	68a3      	ldr	r3, [r4, #8]
   11d9a:	6862      	ldr	r2, [r4, #4]
   11d9c:	4293      	cmp	r3, r2
   11d9e:	f040 808c 	bne.w	11eba <bsd_os_trace_irq_handler+0x136>
   11da2:	4b69      	ldr	r3, [pc, #420]	; (11f48 <bsd_os_trace_irq_handler+0x1c4>)
   11da4:	681c      	ldr	r4, [r3, #0]
   11da6:	b11c      	cbz	r4, 11db0 <bsd_os_trace_irq_handler+0x2c>
   11da8:	68a3      	ldr	r3, [r4, #8]
   11daa:	6862      	ldr	r2, [r4, #4]
   11dac:	4293      	cmp	r3, r2
   11dae:	d146      	bne.n	11e3e <bsd_os_trace_irq_handler+0xba>
   11db0:	4b66      	ldr	r3, [pc, #408]	; (11f4c <bsd_os_trace_irq_handler+0x1c8>)
   11db2:	681c      	ldr	r4, [r3, #0]
   11db4:	b11c      	cbz	r4, 11dbe <bsd_os_trace_irq_handler+0x3a>
   11db6:	68a3      	ldr	r3, [r4, #8]
   11db8:	6862      	ldr	r2, [r4, #4]
   11dba:	4293      	cmp	r3, r2
   11dbc:	d101      	bne.n	11dc2 <bsd_os_trace_irq_handler+0x3e>
   11dbe:	b003      	add	sp, #12
   11dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11dc2:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   11dc6:	f8ad 2000 	strh.w	r2, [sp]
   11dca:	7822      	ldrb	r2, [r4, #0]
   11dcc:	466e      	mov	r6, sp
   11dce:	f88d 2004 	strb.w	r2, [sp, #4]
   11dd2:	6862      	ldr	r2, [r4, #4]
   11dd4:	2105      	movs	r1, #5
   11dd6:	4293      	cmp	r3, r2
   11dd8:	bf2a      	itet	cs
   11dda:	6927      	ldrcs	r7, [r4, #16]
   11ddc:	1ad7      	subcc	r7, r2, r3
   11dde:	1aff      	subcs	r7, r7, r3
   11de0:	4293      	cmp	r3, r2
   11de2:	bf94      	ite	ls
   11de4:	2500      	movls	r5, #0
   11de6:	68e5      	ldrhi	r5, [r4, #12]
   11de8:	b2bf      	uxth	r7, r7
   11dea:	bf88      	it	hi
   11dec:	1b52      	subhi	r2, r2, r5
   11dee:	4630      	mov	r0, r6
   11df0:	bf88      	it	hi
   11df2:	b295      	uxthhi	r5, r2
   11df4:	f8ad 7002 	strh.w	r7, [sp, #2]
   11df8:	f00a fca1 	bl	1c73e <bsd_os_trace_put>
   11dfc:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11e00:	68a0      	ldr	r0, [r4, #8]
   11e02:	f00a fc9c 	bl	1c73e <bsd_os_trace_put>
   11e06:	68a3      	ldr	r3, [r4, #8]
   11e08:	6922      	ldr	r2, [r4, #16]
   11e0a:	441f      	add	r7, r3
   11e0c:	4297      	cmp	r7, r2
   11e0e:	bf08      	it	eq
   11e10:	68e3      	ldreq	r3, [r4, #12]
   11e12:	60a7      	str	r7, [r4, #8]
   11e14:	bf08      	it	eq
   11e16:	60a3      	streq	r3, [r4, #8]
   11e18:	2d00      	cmp	r5, #0
   11e1a:	d0d0      	beq.n	11dbe <bsd_os_trace_irq_handler+0x3a>
   11e1c:	2105      	movs	r1, #5
   11e1e:	4630      	mov	r0, r6
   11e20:	f8ad 5002 	strh.w	r5, [sp, #2]
   11e24:	f00a fc8b 	bl	1c73e <bsd_os_trace_put>
   11e28:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11e2c:	68e0      	ldr	r0, [r4, #12]
   11e2e:	f00a fc86 	bl	1c73e <bsd_os_trace_put>
   11e32:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11e36:	68e3      	ldr	r3, [r4, #12]
   11e38:	4413      	add	r3, r2
   11e3a:	60a3      	str	r3, [r4, #8]
   11e3c:	e7bf      	b.n	11dbe <bsd_os_trace_irq_handler+0x3a>
   11e3e:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   11e42:	f8ad 2000 	strh.w	r2, [sp]
   11e46:	7822      	ldrb	r2, [r4, #0]
   11e48:	466e      	mov	r6, sp
   11e4a:	f88d 2004 	strb.w	r2, [sp, #4]
   11e4e:	6862      	ldr	r2, [r4, #4]
   11e50:	2105      	movs	r1, #5
   11e52:	4293      	cmp	r3, r2
   11e54:	bf2a      	itet	cs
   11e56:	6927      	ldrcs	r7, [r4, #16]
   11e58:	1ad7      	subcc	r7, r2, r3
   11e5a:	1aff      	subcs	r7, r7, r3
   11e5c:	4293      	cmp	r3, r2
   11e5e:	bf94      	ite	ls
   11e60:	2500      	movls	r5, #0
   11e62:	68e5      	ldrhi	r5, [r4, #12]
   11e64:	b2bf      	uxth	r7, r7
   11e66:	bf88      	it	hi
   11e68:	1b52      	subhi	r2, r2, r5
   11e6a:	4630      	mov	r0, r6
   11e6c:	bf88      	it	hi
   11e6e:	b295      	uxthhi	r5, r2
   11e70:	f8ad 7002 	strh.w	r7, [sp, #2]
   11e74:	f00a fc63 	bl	1c73e <bsd_os_trace_put>
   11e78:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11e7c:	68a0      	ldr	r0, [r4, #8]
   11e7e:	f00a fc5e 	bl	1c73e <bsd_os_trace_put>
   11e82:	68a3      	ldr	r3, [r4, #8]
   11e84:	6922      	ldr	r2, [r4, #16]
   11e86:	441f      	add	r7, r3
   11e88:	4297      	cmp	r7, r2
   11e8a:	bf08      	it	eq
   11e8c:	68e3      	ldreq	r3, [r4, #12]
   11e8e:	60a7      	str	r7, [r4, #8]
   11e90:	bf08      	it	eq
   11e92:	60a3      	streq	r3, [r4, #8]
   11e94:	2d00      	cmp	r5, #0
   11e96:	d08b      	beq.n	11db0 <bsd_os_trace_irq_handler+0x2c>
   11e98:	2105      	movs	r1, #5
   11e9a:	4630      	mov	r0, r6
   11e9c:	f8ad 5002 	strh.w	r5, [sp, #2]
   11ea0:	f00a fc4d 	bl	1c73e <bsd_os_trace_put>
   11ea4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11ea8:	68e0      	ldr	r0, [r4, #12]
   11eaa:	f00a fc48 	bl	1c73e <bsd_os_trace_put>
   11eae:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11eb2:	68e3      	ldr	r3, [r4, #12]
   11eb4:	4413      	add	r3, r2
   11eb6:	60a3      	str	r3, [r4, #8]
   11eb8:	e77a      	b.n	11db0 <bsd_os_trace_irq_handler+0x2c>
   11eba:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   11ebe:	f8ad 2000 	strh.w	r2, [sp]
   11ec2:	7822      	ldrb	r2, [r4, #0]
   11ec4:	466e      	mov	r6, sp
   11ec6:	f88d 2004 	strb.w	r2, [sp, #4]
   11eca:	6862      	ldr	r2, [r4, #4]
   11ecc:	2105      	movs	r1, #5
   11ece:	4293      	cmp	r3, r2
   11ed0:	bf2a      	itet	cs
   11ed2:	6927      	ldrcs	r7, [r4, #16]
   11ed4:	1ad7      	subcc	r7, r2, r3
   11ed6:	1aff      	subcs	r7, r7, r3
   11ed8:	4293      	cmp	r3, r2
   11eda:	bf94      	ite	ls
   11edc:	2500      	movls	r5, #0
   11ede:	68e5      	ldrhi	r5, [r4, #12]
   11ee0:	b2bf      	uxth	r7, r7
   11ee2:	bf88      	it	hi
   11ee4:	1b52      	subhi	r2, r2, r5
   11ee6:	4630      	mov	r0, r6
   11ee8:	bf88      	it	hi
   11eea:	b295      	uxthhi	r5, r2
   11eec:	f8ad 7002 	strh.w	r7, [sp, #2]
   11ef0:	f00a fc25 	bl	1c73e <bsd_os_trace_put>
   11ef4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11ef8:	68a0      	ldr	r0, [r4, #8]
   11efa:	f00a fc20 	bl	1c73e <bsd_os_trace_put>
   11efe:	68a3      	ldr	r3, [r4, #8]
   11f00:	6922      	ldr	r2, [r4, #16]
   11f02:	441f      	add	r7, r3
   11f04:	4297      	cmp	r7, r2
   11f06:	bf08      	it	eq
   11f08:	68e3      	ldreq	r3, [r4, #12]
   11f0a:	60a7      	str	r7, [r4, #8]
   11f0c:	bf08      	it	eq
   11f0e:	60a3      	streq	r3, [r4, #8]
   11f10:	2d00      	cmp	r5, #0
   11f12:	f43f af46 	beq.w	11da2 <bsd_os_trace_irq_handler+0x1e>
   11f16:	2105      	movs	r1, #5
   11f18:	4630      	mov	r0, r6
   11f1a:	f8ad 5002 	strh.w	r5, [sp, #2]
   11f1e:	f00a fc0e 	bl	1c73e <bsd_os_trace_put>
   11f22:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   11f26:	68e0      	ldr	r0, [r4, #12]
   11f28:	f00a fc09 	bl	1c73e <bsd_os_trace_put>
   11f2c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   11f30:	68e3      	ldr	r3, [r4, #12]
   11f32:	4413      	add	r3, r2
   11f34:	60a3      	str	r3, [r4, #8]
   11f36:	e734      	b.n	11da2 <bsd_os_trace_irq_handler+0x1e>
   11f38:	f7fe f9ec 	bl	10314 <bsd_os_trace_irq_clear>
   11f3c:	e729      	b.n	11d92 <bsd_os_trace_irq_handler+0xe>
   11f3e:	bf00      	nop
   11f40:	2002366a 	.word	0x2002366a
   11f44:	20020568 	.word	0x20020568
   11f48:	20020560 	.word	0x20020560
   11f4c:	20020564 	.word	0x20020564

00011f50 <ipc_trace_handle>:
   11f50:	2200      	movs	r2, #0
   11f52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11f56:	4bb2      	ldr	r3, [pc, #712]	; (12220 <ipc_trace_handle+0x2d0>)
   11f58:	b083      	sub	sp, #12
   11f5a:	681b      	ldr	r3, [r3, #0]
   11f5c:	6919      	ldr	r1, [r3, #16]
   11f5e:	695c      	ldr	r4, [r3, #20]
   11f60:	7c18      	ldrb	r0, [r3, #16]
   11f62:	741a      	strb	r2, [r3, #16]
   11f64:	7c58      	ldrb	r0, [r3, #17]
   11f66:	745a      	strb	r2, [r3, #17]
   11f68:	7c98      	ldrb	r0, [r3, #18]
   11f6a:	749a      	strb	r2, [r3, #18]
   11f6c:	7cd8      	ldrb	r0, [r3, #19]
   11f6e:	74da      	strb	r2, [r3, #19]
   11f70:	7d18      	ldrb	r0, [r3, #20]
   11f72:	751a      	strb	r2, [r3, #20]
   11f74:	7d58      	ldrb	r0, [r3, #21]
   11f76:	755a      	strb	r2, [r3, #21]
   11f78:	7d98      	ldrb	r0, [r3, #22]
   11f7a:	759a      	strb	r2, [r3, #22]
   11f7c:	7dd8      	ldrb	r0, [r3, #23]
   11f7e:	75da      	strb	r2, [r3, #23]
   11f80:	b1a9      	cbz	r1, 11fae <ipc_trace_handle+0x5e>
   11f82:	3901      	subs	r1, #1
   11f84:	2903      	cmp	r1, #3
   11f86:	d812      	bhi.n	11fae <ipc_trace_handle+0x5e>
   11f88:	e8df f001 	tbb	[pc, r1]
   11f8c:	1402a97c 	.word	0x1402a97c
   11f90:	2501      	movs	r5, #1
   11f92:	2003      	movs	r0, #3
   11f94:	2200      	movs	r2, #0
   11f96:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   11f9a:	4ca2      	ldr	r4, [pc, #648]	; (12224 <ipc_trace_handle+0x2d4>)
   11f9c:	7025      	strb	r5, [r4, #0]
   11f9e:	7a1c      	ldrb	r4, [r3, #8]
   11fa0:	7218      	strb	r0, [r3, #8]
   11fa2:	7a58      	ldrb	r0, [r3, #9]
   11fa4:	725a      	strb	r2, [r3, #9]
   11fa6:	7a98      	ldrb	r0, [r3, #10]
   11fa8:	729a      	strb	r2, [r3, #10]
   11faa:	7ada      	ldrb	r2, [r3, #11]
   11fac:	72d9      	strb	r1, [r3, #11]
   11fae:	b003      	add	sp, #12
   11fb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11fb4:	2104      	movs	r1, #4
   11fb6:	2200      	movs	r2, #0
   11fb8:	f06f 005f 	mvn.w	r0, #95	; 0x5f
   11fbc:	7a1c      	ldrb	r4, [r3, #8]
   11fbe:	7219      	strb	r1, [r3, #8]
   11fc0:	7a59      	ldrb	r1, [r3, #9]
   11fc2:	725a      	strb	r2, [r3, #9]
   11fc4:	4997      	ldr	r1, [pc, #604]	; (12224 <ipc_trace_handle+0x2d4>)
   11fc6:	7a9c      	ldrb	r4, [r3, #10]
   11fc8:	729a      	strb	r2, [r3, #10]
   11fca:	7adc      	ldrb	r4, [r3, #11]
   11fcc:	72d8      	strb	r0, [r3, #11]
   11fce:	700a      	strb	r2, [r1, #0]
   11fd0:	780b      	ldrb	r3, [r1, #0]
   11fd2:	2b00      	cmp	r3, #0
   11fd4:	f000 809f 	beq.w	12116 <ipc_trace_handle+0x1c6>
   11fd8:	4b93      	ldr	r3, [pc, #588]	; (12228 <ipc_trace_handle+0x2d8>)
   11fda:	681c      	ldr	r4, [r3, #0]
   11fdc:	b124      	cbz	r4, 11fe8 <ipc_trace_handle+0x98>
   11fde:	68a3      	ldr	r3, [r4, #8]
   11fe0:	6862      	ldr	r2, [r4, #4]
   11fe2:	4293      	cmp	r3, r2
   11fe4:	f040 80d9 	bne.w	1219a <ipc_trace_handle+0x24a>
   11fe8:	4b90      	ldr	r3, [pc, #576]	; (1222c <ipc_trace_handle+0x2dc>)
   11fea:	681c      	ldr	r4, [r3, #0]
   11fec:	b124      	cbz	r4, 11ff8 <ipc_trace_handle+0xa8>
   11fee:	68a3      	ldr	r3, [r4, #8]
   11ff0:	6862      	ldr	r2, [r4, #4]
   11ff2:	4293      	cmp	r3, r2
   11ff4:	f040 8092 	bne.w	1211c <ipc_trace_handle+0x1cc>
   11ff8:	4b8d      	ldr	r3, [pc, #564]	; (12230 <ipc_trace_handle+0x2e0>)
   11ffa:	681c      	ldr	r4, [r3, #0]
   11ffc:	2c00      	cmp	r4, #0
   11ffe:	d0d6      	beq.n	11fae <ipc_trace_handle+0x5e>
   12000:	68a3      	ldr	r3, [r4, #8]
   12002:	6862      	ldr	r2, [r4, #4]
   12004:	4293      	cmp	r3, r2
   12006:	d0d2      	beq.n	11fae <ipc_trace_handle+0x5e>
   12008:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   1200c:	f8ad 2000 	strh.w	r2, [sp]
   12010:	7822      	ldrb	r2, [r4, #0]
   12012:	466e      	mov	r6, sp
   12014:	f88d 2004 	strb.w	r2, [sp, #4]
   12018:	6862      	ldr	r2, [r4, #4]
   1201a:	2105      	movs	r1, #5
   1201c:	4293      	cmp	r3, r2
   1201e:	bf2a      	itet	cs
   12020:	6927      	ldrcs	r7, [r4, #16]
   12022:	1ad7      	subcc	r7, r2, r3
   12024:	1aff      	subcs	r7, r7, r3
   12026:	4293      	cmp	r3, r2
   12028:	bf94      	ite	ls
   1202a:	2500      	movls	r5, #0
   1202c:	68e5      	ldrhi	r5, [r4, #12]
   1202e:	b2bf      	uxth	r7, r7
   12030:	bf88      	it	hi
   12032:	1b52      	subhi	r2, r2, r5
   12034:	4630      	mov	r0, r6
   12036:	bf88      	it	hi
   12038:	b295      	uxthhi	r5, r2
   1203a:	f8ad 7002 	strh.w	r7, [sp, #2]
   1203e:	f00a fb7e 	bl	1c73e <bsd_os_trace_put>
   12042:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   12046:	68a0      	ldr	r0, [r4, #8]
   12048:	f00a fb79 	bl	1c73e <bsd_os_trace_put>
   1204c:	68a3      	ldr	r3, [r4, #8]
   1204e:	6922      	ldr	r2, [r4, #16]
   12050:	441f      	add	r7, r3
   12052:	4297      	cmp	r7, r2
   12054:	bf08      	it	eq
   12056:	68e3      	ldreq	r3, [r4, #12]
   12058:	60a7      	str	r7, [r4, #8]
   1205a:	bf08      	it	eq
   1205c:	60a3      	streq	r3, [r4, #8]
   1205e:	2d00      	cmp	r5, #0
   12060:	d0a5      	beq.n	11fae <ipc_trace_handle+0x5e>
   12062:	2105      	movs	r1, #5
   12064:	4630      	mov	r0, r6
   12066:	f8ad 5002 	strh.w	r5, [sp, #2]
   1206a:	f00a fb68 	bl	1c73e <bsd_os_trace_put>
   1206e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   12072:	68e0      	ldr	r0, [r4, #12]
   12074:	f00a fb63 	bl	1c73e <bsd_os_trace_put>
   12078:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   1207c:	68e3      	ldr	r3, [r4, #12]
   1207e:	4413      	add	r3, r2
   12080:	60a3      	str	r3, [r4, #8]
   12082:	e794      	b.n	11fae <ipc_trace_handle+0x5e>
   12084:	4a67      	ldr	r2, [pc, #412]	; (12224 <ipc_trace_handle+0x2d4>)
   12086:	7811      	ldrb	r1, [r2, #0]
   12088:	b109      	cbz	r1, 1208e <ipc_trace_handle+0x13e>
   1208a:	2100      	movs	r1, #0
   1208c:	7011      	strb	r1, [r2, #0]
   1208e:	68a5      	ldr	r5, [r4, #8]
   12090:	2d00      	cmp	r5, #0
   12092:	d03b      	beq.n	1210c <ipc_trace_handle+0x1bc>
   12094:	f04f 0c00 	mov.w	ip, #0
   12098:	f8df a190 	ldr.w	sl, [pc, #400]	; 1222c <ipc_trace_handle+0x2dc>
   1209c:	f8df b188 	ldr.w	fp, [pc, #392]	; 12228 <ipc_trace_handle+0x2d8>
   120a0:	4963      	ldr	r1, [pc, #396]	; (12230 <ipc_trace_handle+0x2e0>)
   120a2:	46e1      	mov	r9, ip
   120a4:	4666      	mov	r6, ip
   120a6:	4662      	mov	r2, ip
   120a8:	f8d1 e000 	ldr.w	lr, [r1]
   120ac:	f8da 8000 	ldr.w	r8, [sl]
   120b0:	f8db 7000 	ldr.w	r7, [fp]
   120b4:	e008      	b.n	120c8 <ipc_trace_handle+0x178>
   120b6:	2963      	cmp	r1, #99	; 0x63
   120b8:	d016      	beq.n	120e8 <ipc_trace_handle+0x198>
   120ba:	2961      	cmp	r1, #97	; 0x61
   120bc:	bf04      	itt	eq
   120be:	4607      	moveq	r7, r0
   120c0:	2601      	moveq	r6, #1
   120c2:	3201      	adds	r2, #1
   120c4:	42aa      	cmp	r2, r5
   120c6:	d013      	beq.n	120f0 <ipc_trace_handle+0x1a0>
   120c8:	1c91      	adds	r1, r2, #2
   120ca:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   120ce:	6848      	ldr	r0, [r1, #4]
   120d0:	7801      	ldrb	r1, [r0, #0]
   120d2:	2962      	cmp	r1, #98	; 0x62
   120d4:	d1ef      	bne.n	120b6 <ipc_trace_handle+0x166>
   120d6:	4680      	mov	r8, r0
   120d8:	f04f 0901 	mov.w	r9, #1
   120dc:	e7f1      	b.n	120c2 <ipc_trace_handle+0x172>
   120de:	f7fe f911 	bl	10304 <bsd_os_trace_irq_set>
   120e2:	b003      	add	sp, #12
   120e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   120e8:	4686      	mov	lr, r0
   120ea:	f04f 0c01 	mov.w	ip, #1
   120ee:	e7e8      	b.n	120c2 <ipc_trace_handle+0x172>
   120f0:	2e00      	cmp	r6, #0
   120f2:	f040 8091 	bne.w	12218 <ipc_trace_handle+0x2c8>
   120f6:	f1b9 0f00 	cmp.w	r9, #0
   120fa:	d001      	beq.n	12100 <ipc_trace_handle+0x1b0>
   120fc:	f8ca 8000 	str.w	r8, [sl]
   12100:	f1bc 0f00 	cmp.w	ip, #0
   12104:	d002      	beq.n	1210c <ipc_trace_handle+0x1bc>
   12106:	4a4a      	ldr	r2, [pc, #296]	; (12230 <ipc_trace_handle+0x2e0>)
   12108:	f8c2 e000 	str.w	lr, [r2]
   1210c:	2001      	movs	r0, #1
   1210e:	2200      	movs	r2, #0
   12110:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   12114:	e743      	b.n	11f9e <ipc_trace_handle+0x4e>
   12116:	f7fe f8fd 	bl	10314 <bsd_os_trace_irq_clear>
   1211a:	e75d      	b.n	11fd8 <ipc_trace_handle+0x88>
   1211c:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   12120:	f8ad 2000 	strh.w	r2, [sp]
   12124:	7822      	ldrb	r2, [r4, #0]
   12126:	466e      	mov	r6, sp
   12128:	f88d 2004 	strb.w	r2, [sp, #4]
   1212c:	6862      	ldr	r2, [r4, #4]
   1212e:	2105      	movs	r1, #5
   12130:	4293      	cmp	r3, r2
   12132:	bf2a      	itet	cs
   12134:	6927      	ldrcs	r7, [r4, #16]
   12136:	1ad7      	subcc	r7, r2, r3
   12138:	1aff      	subcs	r7, r7, r3
   1213a:	4293      	cmp	r3, r2
   1213c:	bf94      	ite	ls
   1213e:	2500      	movls	r5, #0
   12140:	68e5      	ldrhi	r5, [r4, #12]
   12142:	b2bf      	uxth	r7, r7
   12144:	bf88      	it	hi
   12146:	1b52      	subhi	r2, r2, r5
   12148:	4630      	mov	r0, r6
   1214a:	bf88      	it	hi
   1214c:	b295      	uxthhi	r5, r2
   1214e:	f8ad 7002 	strh.w	r7, [sp, #2]
   12152:	f00a faf4 	bl	1c73e <bsd_os_trace_put>
   12156:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   1215a:	68a0      	ldr	r0, [r4, #8]
   1215c:	f00a faef 	bl	1c73e <bsd_os_trace_put>
   12160:	68a3      	ldr	r3, [r4, #8]
   12162:	6922      	ldr	r2, [r4, #16]
   12164:	441f      	add	r7, r3
   12166:	4297      	cmp	r7, r2
   12168:	bf08      	it	eq
   1216a:	68e3      	ldreq	r3, [r4, #12]
   1216c:	60a7      	str	r7, [r4, #8]
   1216e:	bf08      	it	eq
   12170:	60a3      	streq	r3, [r4, #8]
   12172:	2d00      	cmp	r5, #0
   12174:	f43f af40 	beq.w	11ff8 <ipc_trace_handle+0xa8>
   12178:	2105      	movs	r1, #5
   1217a:	4630      	mov	r0, r6
   1217c:	f8ad 5002 	strh.w	r5, [sp, #2]
   12180:	f00a fadd 	bl	1c73e <bsd_os_trace_put>
   12184:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   12188:	68e0      	ldr	r0, [r4, #12]
   1218a:	f00a fad8 	bl	1c73e <bsd_os_trace_put>
   1218e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   12192:	68e3      	ldr	r3, [r4, #12]
   12194:	4413      	add	r3, r2
   12196:	60a3      	str	r3, [r4, #8]
   12198:	e72e      	b.n	11ff8 <ipc_trace_handle+0xa8>
   1219a:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   1219e:	f8ad 2000 	strh.w	r2, [sp]
   121a2:	7822      	ldrb	r2, [r4, #0]
   121a4:	466e      	mov	r6, sp
   121a6:	f88d 2004 	strb.w	r2, [sp, #4]
   121aa:	6862      	ldr	r2, [r4, #4]
   121ac:	2105      	movs	r1, #5
   121ae:	4293      	cmp	r3, r2
   121b0:	bf2a      	itet	cs
   121b2:	6927      	ldrcs	r7, [r4, #16]
   121b4:	1ad7      	subcc	r7, r2, r3
   121b6:	1aff      	subcs	r7, r7, r3
   121b8:	4293      	cmp	r3, r2
   121ba:	bf94      	ite	ls
   121bc:	2500      	movls	r5, #0
   121be:	68e5      	ldrhi	r5, [r4, #12]
   121c0:	b2bf      	uxth	r7, r7
   121c2:	bf88      	it	hi
   121c4:	1b52      	subhi	r2, r2, r5
   121c6:	4630      	mov	r0, r6
   121c8:	bf88      	it	hi
   121ca:	b295      	uxthhi	r5, r2
   121cc:	f8ad 7002 	strh.w	r7, [sp, #2]
   121d0:	f00a fab5 	bl	1c73e <bsd_os_trace_put>
   121d4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   121d8:	68a0      	ldr	r0, [r4, #8]
   121da:	f00a fab0 	bl	1c73e <bsd_os_trace_put>
   121de:	68a3      	ldr	r3, [r4, #8]
   121e0:	6922      	ldr	r2, [r4, #16]
   121e2:	441f      	add	r7, r3
   121e4:	4297      	cmp	r7, r2
   121e6:	bf08      	it	eq
   121e8:	68e3      	ldreq	r3, [r4, #12]
   121ea:	60a7      	str	r7, [r4, #8]
   121ec:	bf08      	it	eq
   121ee:	60a3      	streq	r3, [r4, #8]
   121f0:	2d00      	cmp	r5, #0
   121f2:	f43f aef9 	beq.w	11fe8 <ipc_trace_handle+0x98>
   121f6:	2105      	movs	r1, #5
   121f8:	4630      	mov	r0, r6
   121fa:	f8ad 5002 	strh.w	r5, [sp, #2]
   121fe:	f00a fa9e 	bl	1c73e <bsd_os_trace_put>
   12202:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   12206:	68e0      	ldr	r0, [r4, #12]
   12208:	f00a fa99 	bl	1c73e <bsd_os_trace_put>
   1220c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   12210:	68e3      	ldr	r3, [r4, #12]
   12212:	4413      	add	r3, r2
   12214:	60a3      	str	r3, [r4, #8]
   12216:	e6e7      	b.n	11fe8 <ipc_trace_handle+0x98>
   12218:	f8cb 7000 	str.w	r7, [fp]
   1221c:	e76b      	b.n	120f6 <ipc_trace_handle+0x1a6>
   1221e:	bf00      	nop
   12220:	2002056c 	.word	0x2002056c
   12224:	2002366a 	.word	0x2002366a
   12228:	20020568 	.word	0x20020568
   1222c:	20020560 	.word	0x20020560
   12230:	20020564 	.word	0x20020564

00012234 <rpc_trace_coredump_in_progress>:
   12234:	4b01      	ldr	r3, [pc, #4]	; (1223c <rpc_trace_coredump_in_progress+0x8>)
   12236:	7818      	ldrb	r0, [r3, #0]
   12238:	4770      	bx	lr
   1223a:	bf00      	nop
   1223c:	2002366a 	.word	0x2002366a

00012240 <rpc_transport_ipc_data_free>:
   12240:	b510      	push	{r4, lr}
   12242:	4b0e      	ldr	r3, [pc, #56]	; (1227c <rpc_transport_ipc_data_free+0x3c>)
   12244:	4604      	mov	r4, r0
   12246:	e9d3 2300 	ldrd	r2, r3, [r3]
   1224a:	4413      	add	r3, r2
   1224c:	4298      	cmp	r0, r3
   1224e:	d20d      	bcs.n	1226c <rpc_transport_ipc_data_free+0x2c>
   12250:	4282      	cmp	r2, r0
   12252:	d80b      	bhi.n	1226c <rpc_transport_ipc_data_free+0x2c>
   12254:	f000 fd12 	bl	12c7c <rpc_transport_ipc_tx_rpc_ctrl_alloc>
   12258:	b158      	cbz	r0, 12272 <rpc_transport_ipc_data_free+0x32>
   1225a:	4a09      	ldr	r2, [pc, #36]	; (12280 <rpc_transport_ipc_data_free+0x40>)
   1225c:	6084      	str	r4, [r0, #8]
   1225e:	6002      	str	r2, [r0, #0]
   12260:	f7ff fd80 	bl	11d64 <rpc_transport_send>
   12264:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12268:	f7fe b83c 	b.w	102e4 <bsd_os_application_irq_set>
   1226c:	4620      	mov	r0, r4
   1226e:	f006 fbf9 	bl	18a64 <nrf_shared_free>
   12272:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   12276:	f7fe b835 	b.w	102e4 <bsd_os_application_irq_set>
   1227a:	bf00      	nop
   1227c:	20020570 	.word	0x20020570
   12280:	00020001 	.word	0x00020001

00012284 <rpc_transport_ipc_init>:
   12284:	b188      	cbz	r0, 122aa <rpc_transport_ipc_init+0x26>
   12286:	b510      	push	{r4, lr}
   12288:	b082      	sub	sp, #8
   1228a:	aa01      	add	r2, sp, #4
   1228c:	4669      	mov	r1, sp
   1228e:	4604      	mov	r4, r0
   12290:	f000 fb50 	bl	12934 <rpc_transport_ipc_tx_init>
   12294:	4602      	mov	r2, r0
   12296:	b148      	cbz	r0, 122ac <rpc_transport_ipc_init+0x28>
   12298:	4b12      	ldr	r3, [pc, #72]	; (122e4 <rpc_transport_ipc_init+0x60>)
   1229a:	3428      	adds	r4, #40	; 0x28
   1229c:	e894 0003 	ldmia.w	r4, {r0, r1}
   122a0:	e883 0003 	stmia.w	r3, {r0, r1}
   122a4:	4610      	mov	r0, r2
   122a6:	b002      	add	sp, #8
   122a8:	bd10      	pop	{r4, pc}
   122aa:	e7fe      	b.n	122aa <rpc_transport_ipc_init+0x26>
   122ac:	e9dd 1200 	ldrd	r1, r2, [sp]
   122b0:	4620      	mov	r0, r4
   122b2:	f000 f9fb 	bl	126ac <rpc_transport_ipc_rx_init>
   122b6:	4602      	mov	r2, r0
   122b8:	4b0a      	ldr	r3, [pc, #40]	; (122e4 <rpc_transport_ipc_init+0x60>)
   122ba:	f104 0128 	add.w	r1, r4, #40	; 0x28
   122be:	c903      	ldmia	r1, {r0, r1}
   122c0:	e883 0003 	stmia.w	r3, {r0, r1}
   122c4:	2a00      	cmp	r2, #0
   122c6:	d1ed      	bne.n	122a4 <rpc_transport_ipc_init+0x20>
   122c8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   122cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   122ce:	4906      	ldr	r1, [pc, #24]	; (122e8 <rpc_transport_ipc_init+0x64>)
   122d0:	015b      	lsls	r3, r3, #5
   122d2:	b2db      	uxtb	r3, r3
   122d4:	f881 332a 	strb.w	r3, [r1, #810]	; 0x32a
   122d8:	f8c1 0184 	str.w	r0, [r1, #388]	; 0x184
   122dc:	6048      	str	r0, [r1, #4]
   122de:	4610      	mov	r0, r2
   122e0:	b002      	add	sp, #8
   122e2:	bd10      	pop	{r4, pc}
   122e4:	20020570 	.word	0x20020570
   122e8:	e000e100 	.word	0xe000e100

000122ec <bsd_os_application_irq_handler>:
   122ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   122f0:	f7fe f800 	bl	102f4 <bsd_os_application_irq_clear>
   122f4:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 123cc <bsd_os_application_irq_handler+0xe0>
   122f8:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 123d0 <bsd_os_application_irq_handler+0xe4>
   122fc:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 123d4 <bsd_os_application_irq_handler+0xe8>
   12300:	f108 0908 	add.w	r9, r8, #8
   12304:	f858 7b04 	ldr.w	r7, [r8], #4
   12308:	6839      	ldr	r1, [r7, #0]
   1230a:	b361      	cbz	r1, 12366 <bsd_os_application_irq_handler+0x7a>
   1230c:	2400      	movs	r4, #0
   1230e:	e002      	b.n	12316 <bsd_os_application_irq_handler+0x2a>
   12310:	3401      	adds	r4, #1
   12312:	428c      	cmp	r4, r1
   12314:	d227      	bcs.n	12366 <bsd_os_application_irq_handler+0x7a>
   12316:	00e6      	lsls	r6, r4, #3
   12318:	19bd      	adds	r5, r7, r6
   1231a:	68aa      	ldr	r2, [r5, #8]
   1231c:	2a00      	cmp	r2, #0
   1231e:	d0f7      	beq.n	12310 <bsd_os_application_irq_handler+0x24>
   12320:	686a      	ldr	r2, [r5, #4]
   12322:	b2d2      	uxtb	r2, r2
   12324:	2a01      	cmp	r2, #1
   12326:	d1f3      	bne.n	12310 <bsd_os_application_irq_handler+0x24>
   12328:	6868      	ldr	r0, [r5, #4]
   1232a:	f8bb 2000 	ldrh.w	r2, [fp]
   1232e:	ebb2 4f10 	cmp.w	r2, r0, lsr #16
   12332:	d1ed      	bne.n	12310 <bsd_os_application_irq_handler+0x24>
   12334:	68a8      	ldr	r0, [r5, #8]
   12336:	6841      	ldr	r1, [r0, #4]
   12338:	b2c9      	uxtb	r1, r1
   1233a:	2902      	cmp	r1, #2
   1233c:	d02c      	beq.n	12398 <bsd_os_application_irq_handler+0xac>
   1233e:	2901      	cmp	r1, #1
   12340:	d015      	beq.n	1236e <bsd_os_application_irq_handler+0x82>
   12342:	3604      	adds	r6, #4
   12344:	59b9      	ldr	r1, [r7, r6]
   12346:	3201      	adds	r2, #1
   12348:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   1234c:	f041 0103 	orr.w	r1, r1, #3
   12350:	51b9      	str	r1, [r7, r6]
   12352:	f8ab 2000 	strh.w	r2, [fp]
   12356:	f7fd ffc5 	bl	102e4 <bsd_os_application_irq_set>
   1235a:	f858 7c04 	ldr.w	r7, [r8, #-4]
   1235e:	3401      	adds	r4, #1
   12360:	6839      	ldr	r1, [r7, #0]
   12362:	428c      	cmp	r4, r1
   12364:	d3d7      	bcc.n	12316 <bsd_os_application_irq_handler+0x2a>
   12366:	45c1      	cmp	r9, r8
   12368:	d1cc      	bne.n	12304 <bsd_os_application_irq_handler+0x18>
   1236a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1236e:	6801      	ldr	r1, [r0, #0]
   12370:	0c09      	lsrs	r1, r1, #16
   12372:	f002 fd7d 	bl	14e70 <rpc_handle_ctrl_message>
   12376:	2801      	cmp	r0, #1
   12378:	d014      	beq.n	123a4 <bsd_os_application_irq_handler+0xb8>
   1237a:	d310      	bcc.n	1239e <bsd_os_application_irq_handler+0xb2>
   1237c:	2802      	cmp	r0, #2
   1237e:	d007      	beq.n	12390 <bsd_os_application_irq_handler+0xa4>
   12380:	2203      	movs	r2, #3
   12382:	4b11      	ldr	r3, [pc, #68]	; (123c8 <bsd_os_application_irq_handler+0xdc>)
   12384:	4610      	mov	r0, r2
   12386:	f8ca 2000 	str.w	r2, [sl]
   1238a:	601a      	str	r2, [r3, #0]
   1238c:	f005 f916 	bl	175bc <rpc_transport_ipc_fault_handler>
   12390:	f858 7c04 	ldr.w	r7, [r8, #-4]
   12394:	6839      	ldr	r1, [r7, #0]
   12396:	e7bb      	b.n	12310 <bsd_os_application_irq_handler+0x24>
   12398:	f002 fd82 	bl	14ea0 <rpc_handle_data_message>
   1239c:	e7eb      	b.n	12376 <bsd_os_application_irq_handler+0x8a>
   1239e:	f8bb 2000 	ldrh.w	r2, [fp]
   123a2:	e7ce      	b.n	12342 <bsd_os_application_irq_handler+0x56>
   123a4:	686a      	ldr	r2, [r5, #4]
   123a6:	f8bb 1000 	ldrh.w	r1, [fp]
   123aa:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   123ae:	f042 0202 	orr.w	r2, r2, #2
   123b2:	606a      	str	r2, [r5, #4]
   123b4:	1c4a      	adds	r2, r1, #1
   123b6:	f8ab 2000 	strh.w	r2, [fp]
   123ba:	f7fd ff93 	bl	102e4 <bsd_os_application_irq_set>
   123be:	f858 7c04 	ldr.w	r7, [r8, #-4]
   123c2:	6839      	ldr	r1, [r7, #0]
   123c4:	e7a4      	b.n	12310 <bsd_os_application_irq_handler+0x24>
   123c6:	bf00      	nop
   123c8:	20020578 	.word	0x20020578
   123cc:	20020580 	.word	0x20020580
   123d0:	20022094 	.word	0x20022094
   123d4:	20020588 	.word	0x20020588

000123d8 <IPC_IRQHandler>:
   123d8:	b5f0      	push	{r4, r5, r6, r7, lr}
   123da:	f44f 6680 	mov.w	r6, #1024	; 0x400
   123de:	4d9f      	ldr	r5, [pc, #636]	; (1265c <IPC_IRQHandler+0x284>)
   123e0:	4c9f      	ldr	r4, [pc, #636]	; (12660 <IPC_IRQHandler+0x288>)
   123e2:	f8c5 6184 	str.w	r6, [r5, #388]	; 0x184
   123e6:	f8d4 330c 	ldr.w	r3, [r4, #780]	; 0x30c
   123ea:	b095      	sub	sp, #84	; 0x54
   123ec:	0618      	lsls	r0, r3, #24
   123ee:	d50b      	bpl.n	12408 <IPC_IRQHandler+0x30>
   123f0:	f7ff fdae 	bl	11f50 <ipc_trace_handle>
   123f4:	f7ff ff1e 	bl	12234 <rpc_trace_coredump_in_progress>
   123f8:	2800      	cmp	r0, #0
   123fa:	d158      	bne.n	124ae <IPC_IRQHandler+0xd6>
   123fc:	4b99      	ldr	r3, [pc, #612]	; (12664 <IPC_IRQHandler+0x28c>)
   123fe:	f8c4 011c 	str.w	r0, [r4, #284]	; 0x11c
   12402:	681b      	ldr	r3, [r3, #0]
   12404:	9301      	str	r3, [sp, #4]
   12406:	9b01      	ldr	r3, [sp, #4]
   12408:	4c95      	ldr	r4, [pc, #596]	; (12660 <IPC_IRQHandler+0x288>)
   1240a:	f8d4 530c 	ldr.w	r5, [r4, #780]	; 0x30c
   1240e:	f015 0501 	ands.w	r5, r5, #1
   12412:	d11e      	bne.n	12452 <IPC_IRQHandler+0x7a>
   12414:	f8d4 330c 	ldr.w	r3, [r4, #780]	; 0x30c
   12418:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   1241c:	d14c      	bne.n	124b8 <IPC_IRQHandler+0xe0>
   1241e:	f8d4 230c 	ldr.w	r2, [r4, #780]	; 0x30c
   12422:	0751      	lsls	r1, r2, #29
   12424:	d50e      	bpl.n	12444 <IPC_IRQHandler+0x6c>
   12426:	4a90      	ldr	r2, [pc, #576]	; (12668 <IPC_IRQHandler+0x290>)
   12428:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
   1242c:	6812      	ldr	r2, [r2, #0]
   1242e:	4b8f      	ldr	r3, [pc, #572]	; (1266c <IPC_IRQHandler+0x294>)
   12430:	9206      	str	r2, [sp, #24]
   12432:	9a06      	ldr	r2, [sp, #24]
   12434:	681a      	ldr	r2, [r3, #0]
   12436:	2a02      	cmp	r2, #2
   12438:	f000 80f2 	beq.w	12620 <IPC_IRQHandler+0x248>
   1243c:	681a      	ldr	r2, [r3, #0]
   1243e:	2a01      	cmp	r2, #1
   12440:	f000 80d3 	beq.w	125ea <IPC_IRQHandler+0x212>
   12444:	4b86      	ldr	r3, [pc, #536]	; (12660 <IPC_IRQHandler+0x288>)
   12446:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   1244a:	06d2      	lsls	r2, r2, #27
   1244c:	d423      	bmi.n	12496 <IPC_IRQHandler+0xbe>
   1244e:	b015      	add	sp, #84	; 0x54
   12450:	bdf0      	pop	{r4, r5, r6, r7, pc}
   12452:	2100      	movs	r1, #0
   12454:	f248 0202 	movw	r2, #32770	; 0x8002
   12458:	4b85      	ldr	r3, [pc, #532]	; (12670 <IPC_IRQHandler+0x298>)
   1245a:	f8c4 1100 	str.w	r1, [r4, #256]	; 0x100
   1245e:	681b      	ldr	r3, [r3, #0]
   12460:	9302      	str	r3, [sp, #8]
   12462:	9b02      	ldr	r3, [sp, #8]
   12464:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
   12468:	4293      	cmp	r3, r2
   1246a:	f000 80e2 	beq.w	12632 <IPC_IRQHandler+0x25a>
   1246e:	f200 80a0 	bhi.w	125b2 <IPC_IRQHandler+0x1da>
   12472:	2b00      	cmp	r3, #0
   12474:	f000 80d7 	beq.w	12626 <IPC_IRQHandler+0x24e>
   12478:	2b02      	cmp	r3, #2
   1247a:	f240 80ab 	bls.w	125d4 <IPC_IRQHandler+0x1fc>
   1247e:	f248 0201 	movw	r2, #32769	; 0x8001
   12482:	4293      	cmp	r3, r2
   12484:	f040 80cf 	bne.w	12626 <IPC_IRQHandler+0x24e>
   12488:	2003      	movs	r0, #3
   1248a:	2207      	movs	r2, #7
   1248c:	4977      	ldr	r1, [pc, #476]	; (1266c <IPC_IRQHandler+0x294>)
   1248e:	4b79      	ldr	r3, [pc, #484]	; (12674 <IPC_IRQHandler+0x29c>)
   12490:	6008      	str	r0, [r1, #0]
   12492:	601a      	str	r2, [r3, #0]
   12494:	e7db      	b.n	1244e <IPC_IRQHandler+0x76>
   12496:	2100      	movs	r1, #0
   12498:	4a77      	ldr	r2, [pc, #476]	; (12678 <IPC_IRQHandler+0x2a0>)
   1249a:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
   1249e:	6813      	ldr	r3, [r2, #0]
   124a0:	9307      	str	r3, [sp, #28]
   124a2:	9b07      	ldr	r3, [sp, #28]
   124a4:	b015      	add	sp, #84	; 0x54
   124a6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   124aa:	f7fd bf1b 	b.w	102e4 <bsd_os_application_irq_set>
   124ae:	23e0      	movs	r3, #224	; 0xe0
   124b0:	f885 332a 	strb.w	r3, [r5, #810]	; 0x32a
   124b4:	606e      	str	r6, [r5, #4]
   124b6:	e7ca      	b.n	1244e <IPC_IRQHandler+0x76>
   124b8:	4b70      	ldr	r3, [pc, #448]	; (1267c <IPC_IRQHandler+0x2a4>)
   124ba:	f8c4 5118 	str.w	r5, [r4, #280]	; 0x118
   124be:	681b      	ldr	r3, [r3, #0]
   124c0:	9305      	str	r3, [sp, #20]
   124c2:	9b05      	ldr	r3, [sp, #20]
   124c4:	f000 fc14 	bl	12cf0 <rpc_transport_ipc_tx_suspend>
   124c8:	2010      	movs	r0, #16
   124ca:	2201      	movs	r2, #1
   124cc:	210a      	movs	r1, #10
   124ce:	4b6c      	ldr	r3, [pc, #432]	; (12680 <IPC_IRQHandler+0x2a8>)
   124d0:	f8c4 55a0 	str.w	r5, [r4, #1440]	; 0x5a0
   124d4:	681b      	ldr	r3, [r3, #0]
   124d6:	9303      	str	r3, [sp, #12]
   124d8:	4b6a      	ldr	r3, [pc, #424]	; (12684 <IPC_IRQHandler+0x2ac>)
   124da:	9e03      	ldr	r6, [sp, #12]
   124dc:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
   124e0:	6818      	ldr	r0, [r3, #0]
   124e2:	4b69      	ldr	r3, [pc, #420]	; (12688 <IPC_IRQHandler+0x2b0>)
   124e4:	9004      	str	r0, [sp, #16]
   124e6:	9804      	ldr	r0, [sp, #16]
   124e8:	9508      	str	r5, [sp, #32]
   124ea:	f8c3 2610 	str.w	r2, [r3, #1552]	; 0x610
   124ee:	f8d3 0610 	ldr.w	r0, [r3, #1552]	; 0x610
   124f2:	9008      	str	r0, [sp, #32]
   124f4:	9808      	ldr	r0, [sp, #32]
   124f6:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
   124fa:	9109      	str	r1, [sp, #36]	; 0x24
   124fc:	9b09      	ldr	r3, [sp, #36]	; 0x24
   124fe:	b12b      	cbz	r3, 1250c <IPC_IRQHandler+0x134>
   12500:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12502:	3b01      	subs	r3, #1
   12504:	9309      	str	r3, [sp, #36]	; 0x24
   12506:	9b09      	ldr	r3, [sp, #36]	; 0x24
   12508:	2b00      	cmp	r3, #0
   1250a:	d1f9      	bne.n	12500 <IPC_IRQHandler+0x128>
   1250c:	2200      	movs	r2, #0
   1250e:	f04f 0c01 	mov.w	ip, #1
   12512:	2704      	movs	r7, #4
   12514:	2610      	movs	r6, #16
   12516:	495c      	ldr	r1, [pc, #368]	; (12688 <IPC_IRQHandler+0x2b0>)
   12518:	4b51      	ldr	r3, [pc, #324]	; (12660 <IPC_IRQHandler+0x288>)
   1251a:	f8c1 2614 	str.w	r2, [r1, #1556]	; 0x614
   1251e:	f501 3115 	add.w	r1, r1, #152576	; 0x25400
   12522:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   12526:	2540      	movs	r5, #64	; 0x40
   12528:	f501 71c8 	add.w	r1, r1, #400	; 0x190
   1252c:	6809      	ldr	r1, [r1, #0]
   1252e:	2480      	movs	r4, #128	; 0x80
   12530:	910a      	str	r1, [sp, #40]	; 0x28
   12532:	4956      	ldr	r1, [pc, #344]	; (1268c <IPC_IRQHandler+0x2b4>)
   12534:	980a      	ldr	r0, [sp, #40]	; 0x28
   12536:	f8c3 2598 	str.w	r2, [r3, #1432]	; 0x598
   1253a:	6809      	ldr	r1, [r1, #0]
   1253c:	910b      	str	r1, [sp, #44]	; 0x2c
   1253e:	4950      	ldr	r1, [pc, #320]	; (12680 <IPC_IRQHandler+0x2a8>)
   12540:	980b      	ldr	r0, [sp, #44]	; 0x2c
   12542:	f8c3 25a0 	str.w	r2, [r3, #1440]	; 0x5a0
   12546:	6809      	ldr	r1, [r1, #0]
   12548:	2005      	movs	r0, #5
   1254a:	910c      	str	r1, [sp, #48]	; 0x30
   1254c:	4950      	ldr	r1, [pc, #320]	; (12690 <IPC_IRQHandler+0x2b8>)
   1254e:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
   12552:	f8c3 25a8 	str.w	r2, [r3, #1448]	; 0x5a8
   12556:	6809      	ldr	r1, [r1, #0]
   12558:	910d      	str	r1, [sp, #52]	; 0x34
   1255a:	494e      	ldr	r1, [pc, #312]	; (12694 <IPC_IRQHandler+0x2bc>)
   1255c:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
   12560:	f8c3 25ac 	str.w	r2, [r3, #1452]	; 0x5ac
   12564:	6809      	ldr	r1, [r1, #0]
   12566:	910e      	str	r1, [sp, #56]	; 0x38
   12568:	4946      	ldr	r1, [pc, #280]	; (12684 <IPC_IRQHandler+0x2ac>)
   1256a:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
   1256e:	f8c3 c308 	str.w	ip, [r3, #776]	; 0x308
   12572:	f8d1 c000 	ldr.w	ip, [r1]
   12576:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
   1257a:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
   1257e:	f8c3 7308 	str.w	r7, [r3, #776]	; 0x308
   12582:	680f      	ldr	r7, [r1, #0]
   12584:	9710      	str	r7, [sp, #64]	; 0x40
   12586:	9f10      	ldr	r7, [sp, #64]	; 0x40
   12588:	f8c3 6308 	str.w	r6, [r3, #776]	; 0x308
   1258c:	680e      	ldr	r6, [r1, #0]
   1258e:	9611      	str	r6, [sp, #68]	; 0x44
   12590:	9e11      	ldr	r6, [sp, #68]	; 0x44
   12592:	f8c3 5308 	str.w	r5, [r3, #776]	; 0x308
   12596:	680d      	ldr	r5, [r1, #0]
   12598:	9512      	str	r5, [sp, #72]	; 0x48
   1259a:	9d12      	ldr	r5, [sp, #72]	; 0x48
   1259c:	f8c3 4308 	str.w	r4, [r3, #776]	; 0x308
   125a0:	680c      	ldr	r4, [r1, #0]
   125a2:	4b32      	ldr	r3, [pc, #200]	; (1266c <IPC_IRQHandler+0x294>)
   125a4:	9413      	str	r4, [sp, #76]	; 0x4c
   125a6:	493c      	ldr	r1, [pc, #240]	; (12698 <IPC_IRQHandler+0x2c0>)
   125a8:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   125aa:	800a      	strh	r2, [r1, #0]
   125ac:	6018      	str	r0, [r3, #0]
   125ae:	b015      	add	sp, #84	; 0x54
   125b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   125b2:	4a3a      	ldr	r2, [pc, #232]	; (1269c <IPC_IRQHandler+0x2c4>)
   125b4:	4293      	cmp	r3, r2
   125b6:	d82a      	bhi.n	1260e <IPC_IRQHandler+0x236>
   125b8:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   125bc:	d82a      	bhi.n	12614 <IPC_IRQHandler+0x23c>
   125be:	f248 0203 	movw	r2, #32771	; 0x8003
   125c2:	4293      	cmp	r3, r2
   125c4:	d12f      	bne.n	12626 <IPC_IRQHandler+0x24e>
   125c6:	2003      	movs	r0, #3
   125c8:	2204      	movs	r2, #4
   125ca:	4928      	ldr	r1, [pc, #160]	; (1266c <IPC_IRQHandler+0x294>)
   125cc:	4b29      	ldr	r3, [pc, #164]	; (12674 <IPC_IRQHandler+0x29c>)
   125ce:	6008      	str	r0, [r1, #0]
   125d0:	601a      	str	r2, [r3, #0]
   125d2:	e73c      	b.n	1244e <IPC_IRQHandler+0x76>
   125d4:	2303      	movs	r3, #3
   125d6:	4618      	mov	r0, r3
   125d8:	4924      	ldr	r1, [pc, #144]	; (1266c <IPC_IRQHandler+0x294>)
   125da:	4a26      	ldr	r2, [pc, #152]	; (12674 <IPC_IRQHandler+0x29c>)
   125dc:	600b      	str	r3, [r1, #0]
   125de:	6013      	str	r3, [r2, #0]
   125e0:	b015      	add	sp, #84	; 0x54
   125e2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   125e6:	f004 bfe9 	b.w	175bc <rpc_transport_ipc_fault_handler>
   125ea:	4a2d      	ldr	r2, [pc, #180]	; (126a0 <IPC_IRQHandler+0x2c8>)
   125ec:	482d      	ldr	r0, [pc, #180]	; (126a4 <IPC_IRQHandler+0x2cc>)
   125ee:	6811      	ldr	r1, [r2, #0]
   125f0:	688a      	ldr	r2, [r1, #8]
   125f2:	6002      	str	r2, [r0, #0]
   125f4:	6849      	ldr	r1, [r1, #4]
   125f6:	6041      	str	r1, [r0, #4]
   125f8:	b312      	cbz	r2, 12640 <IPC_IRQHandler+0x268>
   125fa:	b309      	cbz	r1, 12640 <IPC_IRQHandler+0x268>
   125fc:	6812      	ldr	r2, [r2, #0]
   125fe:	2a10      	cmp	r2, #16
   12600:	d824      	bhi.n	1264c <IPC_IRQHandler+0x274>
   12602:	680a      	ldr	r2, [r1, #0]
   12604:	2a10      	cmp	r2, #16
   12606:	d821      	bhi.n	1264c <IPC_IRQHandler+0x274>
   12608:	2202      	movs	r2, #2
   1260a:	601a      	str	r2, [r3, #0]
   1260c:	e71a      	b.n	12444 <IPC_IRQHandler+0x6c>
   1260e:	4a26      	ldr	r2, [pc, #152]	; (126a8 <IPC_IRQHandler+0x2d0>)
   12610:	4293      	cmp	r3, r2
   12612:	d108      	bne.n	12626 <IPC_IRQHandler+0x24e>
   12614:	2003      	movs	r0, #3
   12616:	4915      	ldr	r1, [pc, #84]	; (1266c <IPC_IRQHandler+0x294>)
   12618:	4a16      	ldr	r2, [pc, #88]	; (12674 <IPC_IRQHandler+0x29c>)
   1261a:	6008      	str	r0, [r1, #0]
   1261c:	6013      	str	r3, [r2, #0]
   1261e:	e716      	b.n	1244e <IPC_IRQHandler+0x76>
   12620:	f7fd fe60 	bl	102e4 <bsd_os_application_irq_set>
   12624:	e70e      	b.n	12444 <IPC_IRQHandler+0x6c>
   12626:	2303      	movs	r3, #3
   12628:	4910      	ldr	r1, [pc, #64]	; (1266c <IPC_IRQHandler+0x294>)
   1262a:	4a12      	ldr	r2, [pc, #72]	; (12674 <IPC_IRQHandler+0x29c>)
   1262c:	600b      	str	r3, [r1, #0]
   1262e:	6013      	str	r3, [r2, #0]
   12630:	e70d      	b.n	1244e <IPC_IRQHandler+0x76>
   12632:	2003      	movs	r0, #3
   12634:	2206      	movs	r2, #6
   12636:	490d      	ldr	r1, [pc, #52]	; (1266c <IPC_IRQHandler+0x294>)
   12638:	4b0e      	ldr	r3, [pc, #56]	; (12674 <IPC_IRQHandler+0x29c>)
   1263a:	6008      	str	r0, [r1, #0]
   1263c:	601a      	str	r2, [r3, #0]
   1263e:	e706      	b.n	1244e <IPC_IRQHandler+0x76>
   12640:	2003      	movs	r0, #3
   12642:	2110      	movs	r1, #16
   12644:	4a0b      	ldr	r2, [pc, #44]	; (12674 <IPC_IRQHandler+0x29c>)
   12646:	6018      	str	r0, [r3, #0]
   12648:	6011      	str	r1, [r2, #0]
   1264a:	e6fb      	b.n	12444 <IPC_IRQHandler+0x6c>
   1264c:	2003      	movs	r0, #3
   1264e:	f24c 0106 	movw	r1, #49158	; 0xc006
   12652:	4a08      	ldr	r2, [pc, #32]	; (12674 <IPC_IRQHandler+0x29c>)
   12654:	6018      	str	r0, [r3, #0]
   12656:	6011      	str	r1, [r2, #0]
   12658:	e6f4      	b.n	12444 <IPC_IRQHandler+0x6c>
   1265a:	bf00      	nop
   1265c:	e000e100 	.word	0xe000e100
   12660:	4002a000 	.word	0x4002a000
   12664:	4002a11c 	.word	0x4002a11c
   12668:	4002a108 	.word	0x4002a108
   1266c:	20020588 	.word	0x20020588
   12670:	4002a100 	.word	0x4002a100
   12674:	20020578 	.word	0x20020578
   12678:	4002a110 	.word	0x4002a110
   1267c:	4002a118 	.word	0x4002a118
   12680:	4002a5a0 	.word	0x4002a5a0
   12684:	4002a308 	.word	0x4002a308
   12688:	40005000 	.word	0x40005000
   1268c:	4002a598 	.word	0x4002a598
   12690:	4002a5a8 	.word	0x4002a5a8
   12694:	4002a5ac 	.word	0x4002a5ac
   12698:	20022094 	.word	0x20022094
   1269c:	04400004 	.word	0x04400004
   126a0:	2002058c 	.word	0x2002058c
   126a4:	20020580 	.word	0x20020580
   126a8:	05500001 	.word	0x05500001

000126ac <rpc_transport_ipc_rx_init>:
   126ac:	2800      	cmp	r0, #0
   126ae:	f000 80f7 	beq.w	128a0 <rpc_transport_ipc_rx_init+0x1f4>
   126b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   126b6:	6805      	ldr	r5, [r0, #0]
   126b8:	b095      	sub	sp, #84	; 0x54
   126ba:	2d00      	cmp	r5, #0
   126bc:	f000 80e6 	beq.w	1288c <rpc_transport_ipc_rx_init+0x1e0>
   126c0:	6883      	ldr	r3, [r0, #8]
   126c2:	2b00      	cmp	r3, #0
   126c4:	f000 80e2 	beq.w	1288c <rpc_transport_ipc_rx_init+0x1e0>
   126c8:	6906      	ldr	r6, [r0, #16]
   126ca:	2e00      	cmp	r6, #0
   126cc:	f000 80de 	beq.w	1288c <rpc_transport_ipc_rx_init+0x1e0>
   126d0:	6a84      	ldr	r4, [r0, #40]	; 0x28
   126d2:	2c00      	cmp	r4, #0
   126d4:	f000 80da 	beq.w	1288c <rpc_transport_ipc_rx_init+0x1e0>
   126d8:	6844      	ldr	r4, [r0, #4]
   126da:	2c1b      	cmp	r4, #27
   126dc:	f240 80db 	bls.w	12896 <rpc_transport_ipc_rx_init+0x1ea>
   126e0:	68c4      	ldr	r4, [r0, #12]
   126e2:	2c0b      	cmp	r4, #11
   126e4:	f240 80d7 	bls.w	12896 <rpc_transport_ipc_rx_init+0x1ea>
   126e8:	f8d0 c014 	ldr.w	ip, [r0, #20]
   126ec:	f1bc 0f17 	cmp.w	ip, #23
   126f0:	f240 80d1 	bls.w	12896 <rpc_transport_ipc_rx_init+0x1ea>
   126f4:	2700      	movs	r7, #0
   126f6:	4604      	mov	r4, r0
   126f8:	f8df a1c4 	ldr.w	sl, [pc, #452]	; 128c0 <rpc_transport_ipc_rx_init+0x214>
   126fc:	6b80      	ldr	r0, [r0, #56]	; 0x38
   126fe:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 128c4 <rpc_transport_ipc_rx_init+0x218>
   12702:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 128c8 <rpc_transport_ipc_rx_init+0x21c>
   12706:	f8df 91c4 	ldr.w	r9, [pc, #452]	; 128cc <rpc_transport_ipc_rx_init+0x220>
   1270a:	e9cd 1200 	strd	r1, r2, [sp]
   1270e:	f8ca 0000 	str.w	r0, [sl]
   12712:	4662      	mov	r2, ip
   12714:	4639      	mov	r1, r7
   12716:	4630      	mov	r0, r6
   12718:	f8cb 3000 	str.w	r3, [fp]
   1271c:	f8c8 7000 	str.w	r7, [r8]
   12720:	f8c9 7000 	str.w	r7, [r9]
   12724:	f009 fc89 	bl	1c03a <memset>
   12728:	69e3      	ldr	r3, [r4, #28]
   1272a:	4630      	mov	r0, r6
   1272c:	6033      	str	r3, [r6, #0]
   1272e:	69a3      	ldr	r3, [r4, #24]
   12730:	6073      	str	r3, [r6, #4]
   12732:	f7ff fb21 	bl	11d78 <ipc_trace_init>
   12736:	2201      	movs	r2, #1
   12738:	f04f 0c04 	mov.w	ip, #4
   1273c:	4b5a      	ldr	r3, [pc, #360]	; (128a8 <rpc_transport_ipc_rx_init+0x1fc>)
   1273e:	495b      	ldr	r1, [pc, #364]	; (128ac <rpc_transport_ipc_rx_init+0x200>)
   12740:	f8c3 5610 	str.w	r5, [r3, #1552]	; 0x610
   12744:	6809      	ldr	r1, [r1, #0]
   12746:	2080      	movs	r0, #128	; 0x80
   12748:	9104      	str	r1, [sp, #16]
   1274a:	4959      	ldr	r1, [pc, #356]	; (128b0 <rpc_transport_ipc_rx_init+0x204>)
   1274c:	f8dd e010 	ldr.w	lr, [sp, #16]
   12750:	f8c3 7614 	str.w	r7, [r3, #1556]	; 0x614
   12754:	6809      	ldr	r1, [r1, #0]
   12756:	702f      	strb	r7, [r5, #0]
   12758:	9103      	str	r1, [sp, #12]
   1275a:	706f      	strb	r7, [r5, #1]
   1275c:	70ef      	strb	r7, [r5, #3]
   1275e:	70aa      	strb	r2, [r5, #2]
   12760:	9903      	ldr	r1, [sp, #12]
   12762:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   12764:	f8db e000 	ldr.w	lr, [fp]
   12768:	6069      	str	r1, [r5, #4]
   1276a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   1276c:	9c01      	ldr	r4, [sp, #4]
   1276e:	60a9      	str	r1, [r5, #8]
   12770:	60ec      	str	r4, [r5, #12]
   12772:	9c00      	ldr	r4, [sp, #0]
   12774:	494f      	ldr	r1, [pc, #316]	; (128b4 <rpc_transport_ipc_rx_init+0x208>)
   12776:	61ae      	str	r6, [r5, #24]
   12778:	f8c5 e014 	str.w	lr, [r5, #20]
   1277c:	612c      	str	r4, [r5, #16]
   1277e:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   12782:	680c      	ldr	r4, [r1, #0]
   12784:	f5a1 6192 	sub.w	r1, r1, #1168	; 0x490
   12788:	9405      	str	r4, [sp, #20]
   1278a:	9c05      	ldr	r4, [sp, #20]
   1278c:	f8c3 c598 	str.w	ip, [r3, #1432]	; 0x598
   12790:	f8d1 4498 	ldr.w	r4, [r1, #1176]	; 0x498
   12794:	f44f 6680 	mov.w	r6, #1024	; 0x400
   12798:	9406      	str	r4, [sp, #24]
   1279a:	9c06      	ldr	r4, [sp, #24]
   1279c:	2410      	movs	r4, #16
   1279e:	f8c3 45a0 	str.w	r4, [r3, #1440]	; 0x5a0
   127a2:	f8d1 44a0 	ldr.w	r4, [r1, #1184]	; 0x4a0
   127a6:	4d44      	ldr	r5, [pc, #272]	; (128b8 <rpc_transport_ipc_rx_init+0x20c>)
   127a8:	9407      	str	r4, [sp, #28]
   127aa:	9c07      	ldr	r4, [sp, #28]
   127ac:	2440      	movs	r4, #64	; 0x40
   127ae:	f8c3 45a8 	str.w	r4, [r3, #1448]	; 0x5a8
   127b2:	f8d1 44a8 	ldr.w	r4, [r1, #1192]	; 0x4a8
   127b6:	9408      	str	r4, [sp, #32]
   127b8:	9c08      	ldr	r4, [sp, #32]
   127ba:	f8c3 05ac 	str.w	r0, [r3, #1452]	; 0x5ac
   127be:	f8d1 04ac 	ldr.w	r0, [r1, #1196]	; 0x4ac
   127c2:	9009      	str	r0, [sp, #36]	; 0x24
   127c4:	9809      	ldr	r0, [sp, #36]	; 0x24
   127c6:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
   127ca:	6808      	ldr	r0, [r1, #0]
   127cc:	900a      	str	r0, [sp, #40]	; 0x28
   127ce:	980a      	ldr	r0, [sp, #40]	; 0x28
   127d0:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
   127d4:	6888      	ldr	r0, [r1, #8]
   127d6:	900b      	str	r0, [sp, #44]	; 0x2c
   127d8:	980b      	ldr	r0, [sp, #44]	; 0x2c
   127da:	f8c3 7110 	str.w	r7, [r3, #272]	; 0x110
   127de:	6908      	ldr	r0, [r1, #16]
   127e0:	900c      	str	r0, [sp, #48]	; 0x30
   127e2:	980c      	ldr	r0, [sp, #48]	; 0x30
   127e4:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
   127e8:	6988      	ldr	r0, [r1, #24]
   127ea:	900d      	str	r0, [sp, #52]	; 0x34
   127ec:	980d      	ldr	r0, [sp, #52]	; 0x34
   127ee:	f8c3 711c 	str.w	r7, [r3, #284]	; 0x11c
   127f2:	69c8      	ldr	r0, [r1, #28]
   127f4:	f501 7101 	add.w	r1, r1, #516	; 0x204
   127f8:	900e      	str	r0, [sp, #56]	; 0x38
   127fa:	980e      	ldr	r0, [sp, #56]	; 0x38
   127fc:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   12800:	4310      	orrs	r0, r2
   12802:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
   12806:	680c      	ldr	r4, [r1, #0]
   12808:	482c      	ldr	r0, [pc, #176]	; (128bc <rpc_transport_ipc_rx_init+0x210>)
   1280a:	940f      	str	r4, [sp, #60]	; 0x3c
   1280c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
   1280e:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   12812:	ea44 040c 	orr.w	r4, r4, ip
   12816:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1281a:	680c      	ldr	r4, [r1, #0]
   1281c:	9410      	str	r4, [sp, #64]	; 0x40
   1281e:	9c10      	ldr	r4, [sp, #64]	; 0x40
   12820:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   12824:	f044 0410 	orr.w	r4, r4, #16
   12828:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1282c:	680c      	ldr	r4, [r1, #0]
   1282e:	9411      	str	r4, [sp, #68]	; 0x44
   12830:	9c11      	ldr	r4, [sp, #68]	; 0x44
   12832:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   12836:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   1283a:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   1283e:	680c      	ldr	r4, [r1, #0]
   12840:	9412      	str	r4, [sp, #72]	; 0x48
   12842:	9c12      	ldr	r4, [sp, #72]	; 0x48
   12844:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   12848:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   1284c:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   12850:	f8da 3000 	ldr.w	r3, [sl]
   12854:	6809      	ldr	r1, [r1, #0]
   12856:	015b      	lsls	r3, r3, #5
   12858:	9113      	str	r1, [sp, #76]	; 0x4c
   1285a:	b2db      	uxtb	r3, r3
   1285c:	9913      	ldr	r1, [sp, #76]	; 0x4c
   1285e:	f8c8 2000 	str.w	r2, [r8]
   12862:	f880 332a 	strb.w	r3, [r0, #810]	; 0x32a
   12866:	f8c0 6184 	str.w	r6, [r0, #388]	; 0x184
   1286a:	6046      	str	r6, [r0, #4]
   1286c:	9702      	str	r7, [sp, #8]
   1286e:	f8c5 7610 	str.w	r7, [r5, #1552]	; 0x610
   12872:	f8d5 3610 	ldr.w	r3, [r5, #1552]	; 0x610
   12876:	9302      	str	r3, [sp, #8]
   12878:	9b02      	ldr	r3, [sp, #8]
   1287a:	f8d8 3000 	ldr.w	r3, [r8]
   1287e:	2b01      	cmp	r3, #1
   12880:	d0fb      	beq.n	1287a <rpc_transport_ipc_rx_init+0x1ce>
   12882:	f8d9 0000 	ldr.w	r0, [r9]
   12886:	b015      	add	sp, #84	; 0x54
   12888:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1288c:	f24c 000e 	movw	r0, #49166	; 0xc00e
   12890:	b015      	add	sp, #84	; 0x54
   12892:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12896:	f24c 0009 	movw	r0, #49161	; 0xc009
   1289a:	b015      	add	sp, #84	; 0x54
   1289c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   128a0:	f24c 000e 	movw	r0, #49166	; 0xc00e
   128a4:	4770      	bx	lr
   128a6:	bf00      	nop
   128a8:	4002a000 	.word	0x4002a000
   128ac:	4002a610 	.word	0x4002a610
   128b0:	4002a614 	.word	0x4002a614
   128b4:	4002a590 	.word	0x4002a590
   128b8:	40005000 	.word	0x40005000
   128bc:	e000e100 	.word	0xe000e100
   128c0:	2002057c 	.word	0x2002057c
   128c4:	20020588 	.word	0x20020588
   128c8:	2002058c 	.word	0x2002058c
   128cc:	20020578 	.word	0x20020578

000128d0 <rpc_transport_ipc_msg_free>:
   128d0:	b470      	push	{r4, r5, r6}
   128d2:	4e17      	ldr	r6, [pc, #92]	; (12930 <rpc_transport_ipc_msg_free+0x60>)
   128d4:	6831      	ldr	r1, [r6, #0]
   128d6:	680d      	ldr	r5, [r1, #0]
   128d8:	b1ad      	cbz	r5, 12906 <rpc_transport_ipc_msg_free+0x36>
   128da:	688b      	ldr	r3, [r1, #8]
   128dc:	4283      	cmp	r3, r0
   128de:	d024      	beq.n	1292a <rpc_transport_ipc_msg_free+0x5a>
   128e0:	2300      	movs	r3, #0
   128e2:	3301      	adds	r3, #1
   128e4:	00da      	lsls	r2, r3, #3
   128e6:	429d      	cmp	r5, r3
   128e8:	eb01 0402 	add.w	r4, r1, r2
   128ec:	d00b      	beq.n	12906 <rpc_transport_ipc_msg_free+0x36>
   128ee:	68a4      	ldr	r4, [r4, #8]
   128f0:	42a0      	cmp	r0, r4
   128f2:	d1f6      	bne.n	128e2 <rpc_transport_ipc_msg_free+0x12>
   128f4:	3204      	adds	r2, #4
   128f6:	588b      	ldr	r3, [r1, r2]
   128f8:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   128fc:	f043 0303 	orr.w	r3, r3, #3
   12900:	508b      	str	r3, [r1, r2]
   12902:	bc70      	pop	{r4, r5, r6}
   12904:	4770      	bx	lr
   12906:	6871      	ldr	r1, [r6, #4]
   12908:	680d      	ldr	r5, [r1, #0]
   1290a:	2d00      	cmp	r5, #0
   1290c:	d0f9      	beq.n	12902 <rpc_transport_ipc_msg_free+0x32>
   1290e:	688b      	ldr	r3, [r1, #8]
   12910:	4283      	cmp	r3, r0
   12912:	d00a      	beq.n	1292a <rpc_transport_ipc_msg_free+0x5a>
   12914:	2300      	movs	r3, #0
   12916:	3301      	adds	r3, #1
   12918:	00da      	lsls	r2, r3, #3
   1291a:	429d      	cmp	r5, r3
   1291c:	eb01 0402 	add.w	r4, r1, r2
   12920:	d0ef      	beq.n	12902 <rpc_transport_ipc_msg_free+0x32>
   12922:	68a4      	ldr	r4, [r4, #8]
   12924:	42a0      	cmp	r0, r4
   12926:	d1f6      	bne.n	12916 <rpc_transport_ipc_msg_free+0x46>
   12928:	e7e4      	b.n	128f4 <rpc_transport_ipc_msg_free+0x24>
   1292a:	2204      	movs	r2, #4
   1292c:	e7e3      	b.n	128f6 <rpc_transport_ipc_msg_free+0x26>
   1292e:	bf00      	nop
   12930:	20020580 	.word	0x20020580

00012934 <rpc_transport_ipc_tx_init>:
   12934:	2800      	cmp	r0, #0
   12936:	f000 80b8 	beq.w	12aaa <_flash_used+0x146>
   1293a:	2900      	cmp	r1, #0
   1293c:	f000 80b5 	beq.w	12aaa <_flash_used+0x146>
   12940:	2a00      	cmp	r2, #0
   12942:	f000 80b2 	beq.w	12aaa <_flash_used+0x146>
   12946:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1294a:	6a04      	ldr	r4, [r0, #32]
   1294c:	b085      	sub	sp, #20
   1294e:	2c00      	cmp	r4, #0
   12950:	f000 80a6 	beq.w	12aa0 <_flash_used+0x13c>
   12954:	6a40      	ldr	r0, [r0, #36]	; 0x24
   12956:	2800      	cmp	r0, #0
   12958:	f000 80a2 	beq.w	12aa0 <_flash_used+0x13c>
   1295c:	f642 4587 	movw	r5, #11399	; 0x2c87
   12960:	f04f 0a00 	mov.w	sl, #0
   12964:	4e55      	ldr	r6, [pc, #340]	; (12abc <_flash_used+0x158>)
   12966:	42a8      	cmp	r0, r5
   12968:	f886 a000 	strb.w	sl, [r6]
   1296c:	f240 80a0 	bls.w	12ab0 <_flash_used+0x14c>
   12970:	2708      	movs	r7, #8
   12972:	f8df 9180 	ldr.w	r9, [pc, #384]	; 12af4 <_flash_used+0x190>
   12976:	4620      	mov	r0, r4
   12978:	4616      	mov	r6, r2
   1297a:	460d      	mov	r5, r1
   1297c:	2244      	movs	r2, #68	; 0x44
   1297e:	4651      	mov	r1, sl
   12980:	f8c9 4000 	str.w	r4, [r9]
   12984:	f009 fb59 	bl	1c03a <memset>
   12988:	f8d9 2000 	ldr.w	r2, [r9]
   1298c:	f104 0344 	add.w	r3, r4, #68	; 0x44
   12990:	f8df 8164 	ldr.w	r8, [pc, #356]	; 12af8 <_flash_used+0x194>
   12994:	f882 a001 	strb.w	sl, [r2, #1]
   12998:	f882 a002 	strb.w	sl, [r2, #2]
   1299c:	f882 a003 	strb.w	sl, [r2, #3]
   129a0:	7017      	strb	r7, [r2, #0]
   129a2:	4618      	mov	r0, r3
   129a4:	2244      	movs	r2, #68	; 0x44
   129a6:	4651      	mov	r1, sl
   129a8:	f8c8 3000 	str.w	r3, [r8]
   129ac:	f009 fb45 	bl	1c03a <memset>
   129b0:	f8d8 2000 	ldr.w	r2, [r8]
   129b4:	f104 0388 	add.w	r3, r4, #136	; 0x88
   129b8:	f8df b140 	ldr.w	fp, [pc, #320]	; 12afc <_flash_used+0x198>
   129bc:	7017      	strb	r7, [r2, #0]
   129be:	f882 a001 	strb.w	sl, [r2, #1]
   129c2:	f882 a002 	strb.w	sl, [r2, #2]
   129c6:	f882 a003 	strb.w	sl, [r2, #3]
   129ca:	4618      	mov	r0, r3
   129cc:	f44f 7200 	mov.w	r2, #512	; 0x200
   129d0:	4651      	mov	r1, sl
   129d2:	f8cb 3000 	str.w	r3, [fp]
   129d6:	f009 fb30 	bl	1c03a <memset>
   129da:	4b39      	ldr	r3, [pc, #228]	; (12ac0 <_flash_used+0x15c>)
   129dc:	f504 7c22 	add.w	ip, r4, #648	; 0x288
   129e0:	f8c3 c000 	str.w	ip, [r3]
   129e4:	4651      	mov	r1, sl
   129e6:	4660      	mov	r0, ip
   129e8:	f44f 7200 	mov.w	r2, #512	; 0x200
   129ec:	f009 fb25 	bl	1c03a <memset>
   129f0:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
   129f4:	2106      	movs	r1, #6
   129f6:	f04f 0e01 	mov.w	lr, #1
   129fa:	f44f 3001 	mov.w	r0, #132096	; 0x20400
   129fe:	f44f 3288 	mov.w	r2, #69632	; 0x11000
   12a02:	4b30      	ldr	r3, [pc, #192]	; (12ac4 <_flash_used+0x160>)
   12a04:	f504 6491 	add.w	r4, r4, #1160	; 0x488
   12a08:	605c      	str	r4, [r3, #4]
   12a0a:	4c2f      	ldr	r4, [pc, #188]	; (12ac8 <_flash_used+0x164>)
   12a0c:	f8c3 c008 	str.w	ip, [r3, #8]
   12a10:	8199      	strh	r1, [r3, #12]
   12a12:	f8a3 e000 	strh.w	lr, [r3]
   12a16:	4619      	mov	r1, r3
   12a18:	611c      	str	r4, [r3, #16]
   12a1a:	4b2c      	ldr	r3, [pc, #176]	; (12acc <_flash_used+0x168>)
   12a1c:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 12b00 <_flash_used+0x19c>
   12a20:	6120      	str	r0, [r4, #16]
   12a22:	482b      	ldr	r0, [pc, #172]	; (12ad0 <_flash_used+0x16c>)
   12a24:	6063      	str	r3, [r4, #4]
   12a26:	f503 73c0 	add.w	r3, r3, #384	; 0x180
   12a2a:	60a0      	str	r0, [r4, #8]
   12a2c:	f8c4 c000 	str.w	ip, [r4]
   12a30:	4828      	ldr	r0, [pc, #160]	; (12ad4 <_flash_used+0x170>)
   12a32:	60e3      	str	r3, [r4, #12]
   12a34:	6162      	str	r2, [r4, #20]
   12a36:	f005 fedb 	bl	187f0 <nrf_mem_register>
   12a3a:	2800      	cmp	r0, #0
   12a3c:	d132      	bne.n	12aa4 <_flash_used+0x140>
   12a3e:	f04f 0c02 	mov.w	ip, #2
   12a42:	2420      	movs	r4, #32
   12a44:	f8d9 1000 	ldr.w	r1, [r9]
   12a48:	f8db 2000 	ldr.w	r2, [fp]
   12a4c:	6029      	str	r1, [r5, #0]
   12a4e:	4b1c      	ldr	r3, [pc, #112]	; (12ac0 <_flash_used+0x15c>)
   12a50:	f8d8 1000 	ldr.w	r1, [r8]
   12a54:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 12b04 <_flash_used+0x1a0>
   12a58:	4d1f      	ldr	r5, [pc, #124]	; (12ad8 <_flash_used+0x174>)
   12a5a:	6031      	str	r1, [r6, #0]
   12a5c:	f8ce 2000 	str.w	r2, [lr]
   12a60:	681b      	ldr	r3, [r3, #0]
   12a62:	491e      	ldr	r1, [pc, #120]	; (12adc <_flash_used+0x178>)
   12a64:	f502 7200 	add.w	r2, r2, #512	; 0x200
   12a68:	602a      	str	r2, [r5, #0]
   12a6a:	4e1d      	ldr	r6, [pc, #116]	; (12ae0 <_flash_used+0x17c>)
   12a6c:	4a1d      	ldr	r2, [pc, #116]	; (12ae4 <_flash_used+0x180>)
   12a6e:	4d1e      	ldr	r5, [pc, #120]	; (12ae8 <_flash_used+0x184>)
   12a70:	600b      	str	r3, [r1, #0]
   12a72:	f503 7300 	add.w	r3, r3, #512	; 0x200
   12a76:	491d      	ldr	r1, [pc, #116]	; (12aec <_flash_used+0x188>)
   12a78:	6033      	str	r3, [r6, #0]
   12a7a:	8028      	strh	r0, [r5, #0]
   12a7c:	f8c2 c514 	str.w	ip, [r2, #1300]	; 0x514
   12a80:	6809      	ldr	r1, [r1, #0]
   12a82:	4b1b      	ldr	r3, [pc, #108]	; (12af0 <_flash_used+0x18c>)
   12a84:	9103      	str	r1, [sp, #12]
   12a86:	9903      	ldr	r1, [sp, #12]
   12a88:	f8c2 751c 	str.w	r7, [r2, #1308]	; 0x51c
   12a8c:	6819      	ldr	r1, [r3, #0]
   12a8e:	443b      	add	r3, r7
   12a90:	9102      	str	r1, [sp, #8]
   12a92:	9902      	ldr	r1, [sp, #8]
   12a94:	f8c2 4524 	str.w	r4, [r2, #1316]	; 0x524
   12a98:	681b      	ldr	r3, [r3, #0]
   12a9a:	9301      	str	r3, [sp, #4]
   12a9c:	9b01      	ldr	r3, [sp, #4]
   12a9e:	e001      	b.n	12aa4 <_flash_used+0x140>
   12aa0:	f24c 0007 	movw	r0, #49159	; 0xc007
   12aa4:	b005      	add	sp, #20
   12aa6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12aaa:	f24c 000e 	movw	r0, #49166	; 0xc00e
   12aae:	4770      	bx	lr
   12ab0:	f24c 0004 	movw	r0, #49156	; 0xc004
   12ab4:	b005      	add	sp, #20
   12ab6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12aba:	bf00      	nop
   12abc:	2002366b 	.word	0x2002366b
   12ac0:	200205b8 	.word	0x200205b8
   12ac4:	200205a4 	.word	0x200205a4
   12ac8:	200205c8 	.word	0x200205c8
   12acc:	00040080 	.word	0x00040080
   12ad0:	00040100 	.word	0x00040100
   12ad4:	20020590 	.word	0x20020590
   12ad8:	2002059c 	.word	0x2002059c
   12adc:	20020598 	.word	0x20020598
   12ae0:	20020594 	.word	0x20020594
   12ae4:	4002a000 	.word	0x4002a000
   12ae8:	20022096 	.word	0x20022096
   12aec:	4002a514 	.word	0x4002a514
   12af0:	4002a51c 	.word	0x4002a51c
   12af4:	200205c4 	.word	0x200205c4
   12af8:	200205bc 	.word	0x200205bc
   12afc:	200205c0 	.word	0x200205c0
   12b00:	00080040 	.word	0x00080040
   12b04:	200205a0 	.word	0x200205a0

00012b08 <rpc_transport_ipc_send>:
   12b08:	2800      	cmp	r0, #0
   12b0a:	d061      	beq.n	12bd0 <rpc_transport_ipc_send+0xc8>
   12b0c:	b4f0      	push	{r4, r5, r6, r7}
   12b0e:	4b34      	ldr	r3, [pc, #208]	; (12be0 <rpc_transport_ipc_send+0xd8>)
   12b10:	b082      	sub	sp, #8
   12b12:	681a      	ldr	r2, [r3, #0]
   12b14:	4b33      	ldr	r3, [pc, #204]	; (12be4 <rpc_transport_ipc_send+0xdc>)
   12b16:	4282      	cmp	r2, r0
   12b18:	d81e      	bhi.n	12b58 <rpc_transport_ipc_send+0x50>
   12b1a:	681b      	ldr	r3, [r3, #0]
   12b1c:	4932      	ldr	r1, [pc, #200]	; (12be8 <rpc_transport_ipc_send+0xe0>)
   12b1e:	4283      	cmp	r3, r0
   12b20:	6809      	ldr	r1, [r1, #0]
   12b22:	d803      	bhi.n	12b2c <rpc_transport_ipc_send+0x24>
   12b24:	4c31      	ldr	r4, [pc, #196]	; (12bec <rpc_transport_ipc_send+0xe4>)
   12b26:	6824      	ldr	r4, [r4, #0]
   12b28:	4284      	cmp	r4, r0
   12b2a:	d849      	bhi.n	12bc0 <rpc_transport_ipc_send+0xb8>
   12b2c:	4281      	cmp	r1, r0
   12b2e:	d90e      	bls.n	12b4e <rpc_transport_ipc_send+0x46>
   12b30:	4b2f      	ldr	r3, [pc, #188]	; (12bf0 <rpc_transport_ipc_send+0xe8>)
   12b32:	781b      	ldrb	r3, [r3, #0]
   12b34:	2b00      	cmp	r3, #0
   12b36:	d14e      	bne.n	12bd6 <rpc_transport_ipc_send+0xce>
   12b38:	1a83      	subs	r3, r0, r2
   12b3a:	492e      	ldr	r1, [pc, #184]	; (12bf4 <rpc_transport_ipc_send+0xec>)
   12b3c:	099f      	lsrs	r7, r3, #6
   12b3e:	069b      	lsls	r3, r3, #26
   12b40:	680a      	ldr	r2, [r1, #0]
   12b42:	4d2d      	ldr	r5, [pc, #180]	; (12bf8 <rpc_transport_ipc_send+0xf0>)
   12b44:	f04f 0403 	mov.w	r4, #3
   12b48:	f04f 0602 	mov.w	r6, #2
   12b4c:	d014      	beq.n	12b78 <rpc_transport_ipc_send+0x70>
   12b4e:	f24c 0010 	movw	r0, #49168	; 0xc010
   12b52:	b002      	add	sp, #8
   12b54:	bcf0      	pop	{r4, r5, r6, r7}
   12b56:	4770      	bx	lr
   12b58:	681b      	ldr	r3, [r3, #0]
   12b5a:	4298      	cmp	r0, r3
   12b5c:	d3f7      	bcc.n	12b4e <rpc_transport_ipc_send+0x46>
   12b5e:	4a23      	ldr	r2, [pc, #140]	; (12bec <rpc_transport_ipc_send+0xe4>)
   12b60:	6812      	ldr	r2, [r2, #0]
   12b62:	4290      	cmp	r0, r2
   12b64:	d2f3      	bcs.n	12b4e <rpc_transport_ipc_send+0x46>
   12b66:	2401      	movs	r4, #1
   12b68:	1ac3      	subs	r3, r0, r3
   12b6a:	4a24      	ldr	r2, [pc, #144]	; (12bfc <rpc_transport_ipc_send+0xf4>)
   12b6c:	099f      	lsrs	r7, r3, #6
   12b6e:	069b      	lsls	r3, r3, #26
   12b70:	4626      	mov	r6, r4
   12b72:	6812      	ldr	r2, [r2, #0]
   12b74:	4d22      	ldr	r5, [pc, #136]	; (12c00 <rpc_transport_ipc_send+0xf8>)
   12b76:	d1ea      	bne.n	12b4e <rpc_transport_ipc_send+0x46>
   12b78:	6841      	ldr	r1, [r0, #4]
   12b7a:	b2c9      	uxtb	r1, r1
   12b7c:	428e      	cmp	r6, r1
   12b7e:	d122      	bne.n	12bc6 <rpc_transport_ipc_send+0xbe>
   12b80:	2020      	movs	r0, #32
   12b82:	eb02 03c7 	add.w	r3, r2, r7, lsl #3
   12b86:	491f      	ldr	r1, [pc, #124]	; (12c04 <rpc_transport_ipc_send+0xfc>)
   12b88:	685a      	ldr	r2, [r3, #4]
   12b8a:	880e      	ldrh	r6, [r1, #0]
   12b8c:	b292      	uxth	r2, r2
   12b8e:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
   12b92:	605a      	str	r2, [r3, #4]
   12b94:	685a      	ldr	r2, [r3, #4]
   12b96:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   12b9a:	f042 0201 	orr.w	r2, r2, #1
   12b9e:	605a      	str	r2, [r3, #4]
   12ba0:	bf00      	nop
   12ba2:	3801      	subs	r0, #1
   12ba4:	d1fc      	bne.n	12ba0 <rpc_transport_ipc_send+0x98>
   12ba6:	2201      	movs	r2, #1
   12ba8:	4b17      	ldr	r3, [pc, #92]	; (12c08 <rpc_transport_ipc_send+0x100>)
   12baa:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   12bae:	682a      	ldr	r2, [r5, #0]
   12bb0:	880b      	ldrh	r3, [r1, #0]
   12bb2:	9201      	str	r2, [sp, #4]
   12bb4:	9a01      	ldr	r2, [sp, #4]
   12bb6:	3301      	adds	r3, #1
   12bb8:	800b      	strh	r3, [r1, #0]
   12bba:	b002      	add	sp, #8
   12bbc:	bcf0      	pop	{r4, r5, r6, r7}
   12bbe:	4770      	bx	lr
   12bc0:	4281      	cmp	r1, r0
   12bc2:	d9d0      	bls.n	12b66 <rpc_transport_ipc_send+0x5e>
   12bc4:	e7b4      	b.n	12b30 <rpc_transport_ipc_send+0x28>
   12bc6:	f24c 0007 	movw	r0, #49159	; 0xc007
   12bca:	b002      	add	sp, #8
   12bcc:	bcf0      	pop	{r4, r5, r6, r7}
   12bce:	4770      	bx	lr
   12bd0:	f24c 000e 	movw	r0, #49166	; 0xc00e
   12bd4:	4770      	bx	lr
   12bd6:	f24c 000f 	movw	r0, #49167	; 0xc00f
   12bda:	b002      	add	sp, #8
   12bdc:	bcf0      	pop	{r4, r5, r6, r7}
   12bde:	4770      	bx	lr
   12be0:	200205a0 	.word	0x200205a0
   12be4:	20020598 	.word	0x20020598
   12be8:	2002059c 	.word	0x2002059c
   12bec:	20020594 	.word	0x20020594
   12bf0:	2002366b 	.word	0x2002366b
   12bf4:	200205c4 	.word	0x200205c4
   12bf8:	4002a00c 	.word	0x4002a00c
   12bfc:	200205bc 	.word	0x200205bc
   12c00:	4002a004 	.word	0x4002a004
   12c04:	20022096 	.word	0x20022096
   12c08:	4002a000 	.word	0x4002a000

00012c0c <rpc_transport_ipc_tx_rpc_data_alloc>:
   12c0c:	4b18      	ldr	r3, [pc, #96]	; (12c70 <rpc_transport_ipc_tx_rpc_data_alloc+0x64>)
   12c0e:	781b      	ldrb	r3, [r3, #0]
   12c10:	bb63      	cbnz	r3, 12c6c <rpc_transport_ipc_tx_rpc_data_alloc+0x60>
   12c12:	b4f0      	push	{r4, r5, r6, r7}
   12c14:	4a17      	ldr	r2, [pc, #92]	; (12c74 <rpc_transport_ipc_tx_rpc_data_alloc+0x68>)
   12c16:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   12c1a:	6814      	ldr	r4, [r2, #0]
   12c1c:	4b16      	ldr	r3, [pc, #88]	; (12c78 <rpc_transport_ipc_tx_rpc_data_alloc+0x6c>)
   12c1e:	6825      	ldr	r5, [r4, #0]
   12c20:	681e      	ldr	r6, [r3, #0]
   12c22:	b1a5      	cbz	r5, 12c4e <rpc_transport_ipc_tx_rpc_data_alloc+0x42>
   12c24:	4607      	mov	r7, r0
   12c26:	00c1      	lsls	r1, r0, #3
   12c28:	1863      	adds	r3, r4, r1
   12c2a:	685a      	ldr	r2, [r3, #4]
   12c2c:	b2d2      	uxtb	r2, r2
   12c2e:	2a03      	cmp	r2, #3
   12c30:	d104      	bne.n	12c3c <rpc_transport_ipc_tx_rpc_data_alloc+0x30>
   12c32:	609f      	str	r7, [r3, #8]
   12c34:	685a      	ldr	r2, [r3, #4]
   12c36:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   12c3a:	605a      	str	r2, [r3, #4]
   12c3c:	685a      	ldr	r2, [r3, #4]
   12c3e:	f012 0fff 	tst.w	r2, #255	; 0xff
   12c42:	d101      	bne.n	12c48 <rpc_transport_ipc_tx_rpc_data_alloc+0x3c>
   12c44:	689b      	ldr	r3, [r3, #8]
   12c46:	b12b      	cbz	r3, 12c54 <rpc_transport_ipc_tx_rpc_data_alloc+0x48>
   12c48:	3001      	adds	r0, #1
   12c4a:	42a8      	cmp	r0, r5
   12c4c:	d1eb      	bne.n	12c26 <rpc_transport_ipc_tx_rpc_data_alloc+0x1a>
   12c4e:	2000      	movs	r0, #0
   12c50:	bcf0      	pop	{r4, r5, r6, r7}
   12c52:	4770      	bx	lr
   12c54:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   12c58:	4421      	add	r1, r4
   12c5a:	6088      	str	r0, [r1, #8]
   12c5c:	6843      	ldr	r3, [r0, #4]
   12c5e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   12c62:	f043 0302 	orr.w	r3, r3, #2
   12c66:	6043      	str	r3, [r0, #4]
   12c68:	bcf0      	pop	{r4, r5, r6, r7}
   12c6a:	4770      	bx	lr
   12c6c:	2000      	movs	r0, #0
   12c6e:	4770      	bx	lr
   12c70:	2002366b 	.word	0x2002366b
   12c74:	200205c4 	.word	0x200205c4
   12c78:	200205c0 	.word	0x200205c0

00012c7c <rpc_transport_ipc_tx_rpc_ctrl_alloc>:
   12c7c:	b4f0      	push	{r4, r5, r6, r7}
   12c7e:	4a15      	ldr	r2, [pc, #84]	; (12cd4 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x58>)
   12c80:	4b15      	ldr	r3, [pc, #84]	; (12cd8 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x5c>)
   12c82:	6814      	ldr	r4, [r2, #0]
   12c84:	681e      	ldr	r6, [r3, #0]
   12c86:	6825      	ldr	r5, [r4, #0]
   12c88:	b1ad      	cbz	r5, 12cb6 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x3a>
   12c8a:	2000      	movs	r0, #0
   12c8c:	4607      	mov	r7, r0
   12c8e:	00c1      	lsls	r1, r0, #3
   12c90:	1863      	adds	r3, r4, r1
   12c92:	685a      	ldr	r2, [r3, #4]
   12c94:	b2d2      	uxtb	r2, r2
   12c96:	2a03      	cmp	r2, #3
   12c98:	d104      	bne.n	12ca4 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x28>
   12c9a:	609f      	str	r7, [r3, #8]
   12c9c:	685a      	ldr	r2, [r3, #4]
   12c9e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   12ca2:	605a      	str	r2, [r3, #4]
   12ca4:	685a      	ldr	r2, [r3, #4]
   12ca6:	f012 0fff 	tst.w	r2, #255	; 0xff
   12caa:	d101      	bne.n	12cb0 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x34>
   12cac:	689b      	ldr	r3, [r3, #8]
   12cae:	b12b      	cbz	r3, 12cbc <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x40>
   12cb0:	3001      	adds	r0, #1
   12cb2:	4285      	cmp	r5, r0
   12cb4:	d1eb      	bne.n	12c8e <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x12>
   12cb6:	2000      	movs	r0, #0
   12cb8:	bcf0      	pop	{r4, r5, r6, r7}
   12cba:	4770      	bx	lr
   12cbc:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   12cc0:	4421      	add	r1, r4
   12cc2:	6088      	str	r0, [r1, #8]
   12cc4:	6843      	ldr	r3, [r0, #4]
   12cc6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   12cca:	f043 0301 	orr.w	r3, r3, #1
   12cce:	6043      	str	r3, [r0, #4]
   12cd0:	bcf0      	pop	{r4, r5, r6, r7}
   12cd2:	4770      	bx	lr
   12cd4:	200205bc 	.word	0x200205bc
   12cd8:	200205b8 	.word	0x200205b8

00012cdc <rpc_transport_ipc_tx_data_alloc>:
   12cdc:	4b03      	ldr	r3, [pc, #12]	; (12cec <rpc_transport_ipc_tx_data_alloc+0x10>)
   12cde:	781b      	ldrb	r3, [r3, #0]
   12ce0:	b90b      	cbnz	r3, 12ce6 <rpc_transport_ipc_tx_data_alloc+0xa>
   12ce2:	f005 beb5 	b.w	18a50 <nrf_shared_malloc>
   12ce6:	2000      	movs	r0, #0
   12ce8:	4770      	bx	lr
   12cea:	bf00      	nop
   12cec:	2002366b 	.word	0x2002366b

00012cf0 <rpc_transport_ipc_tx_suspend>:
   12cf0:	2201      	movs	r2, #1
   12cf2:	4b01      	ldr	r3, [pc, #4]	; (12cf8 <rpc_transport_ipc_tx_suspend+0x8>)
   12cf4:	701a      	strb	r2, [r3, #0]
   12cf6:	4770      	bx	lr
   12cf8:	2002366b 	.word	0x2002366b

00012cfc <secure_client_socket>:
   12cfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12d00:	f04f 3cff 	mov.w	ip, #4294967295
   12d04:	460c      	mov	r4, r1
   12d06:	680b      	ldr	r3, [r1, #0]
   12d08:	4f46      	ldr	r7, [pc, #280]	; (12e24 <secure_client_socket+0x128>)
   12d0a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   12d0e:	600b      	str	r3, [r1, #0]
   12d10:	680b      	ldr	r3, [r1, #0]
   12d12:	00c6      	lsls	r6, r0, #3
   12d14:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   12d18:	600b      	str	r3, [r1, #0]
   12d1a:	eb07 0a06 	add.w	sl, r7, r6
   12d1e:	b084      	sub	sp, #16
   12d20:	f8da 3004 	ldr.w	r3, [sl, #4]
   12d24:	6989      	ldr	r1, [r1, #24]
   12d26:	f247 0281 	movw	r2, #28801	; 0x7081
   12d2a:	4605      	mov	r5, r0
   12d2c:	f8d4 8000 	ldr.w	r8, [r4]
   12d30:	e9cd cc02 	strd	ip, ip, [sp, #8]
   12d34:	f000 fcfc 	bl	13730 <ip_interface_request_create>
   12d38:	2800      	cmp	r0, #0
   12d3a:	d06d      	beq.n	12e18 <secure_client_socket+0x11c>
   12d3c:	f8da 2004 	ldr.w	r2, [sl, #4]
   12d40:	4681      	mov	r9, r0
   12d42:	2a00      	cmp	r2, #0
   12d44:	d15d      	bne.n	12e02 <secure_client_socket+0x106>
   12d46:	4b38      	ldr	r3, [pc, #224]	; (12e28 <secure_client_socket+0x12c>)
   12d48:	1971      	adds	r1, r6, r5
   12d4a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   12d4e:	2224      	movs	r2, #36	; 0x24
   12d50:	f109 0014 	add.w	r0, r9, #20
   12d54:	f009 f946 	bl	1bfe4 <memcpy>
   12d58:	f8d9 3008 	ldr.w	r3, [r9, #8]
   12d5c:	4649      	mov	r1, r9
   12d5e:	3324      	adds	r3, #36	; 0x24
   12d60:	f8c9 3008 	str.w	r3, [r9, #8]
   12d64:	6822      	ldr	r2, [r4, #0]
   12d66:	4643      	mov	r3, r8
   12d68:	0c12      	lsrs	r2, r2, #16
   12d6a:	0412      	lsls	r2, r2, #16
   12d6c:	f042 020a 	orr.w	r2, r2, #10
   12d70:	6022      	str	r2, [r4, #0]
   12d72:	4620      	mov	r0, r4
   12d74:	f247 0281 	movw	r2, #28801	; 0x7081
   12d78:	f000 fcfa 	bl	13770 <ip_interface_request_send>
   12d7c:	4603      	mov	r3, r0
   12d7e:	b968      	cbnz	r0, 12d9c <secure_client_socket+0xa0>
   12d80:	6823      	ldr	r3, [r4, #0]
   12d82:	00db      	lsls	r3, r3, #3
   12d84:	d40e      	bmi.n	12da4 <secure_client_socket+0xa8>
   12d86:	ab03      	add	r3, sp, #12
   12d88:	f64f 72ff 	movw	r2, #65535	; 0xffff
   12d8c:	210b      	movs	r1, #11
   12d8e:	4628      	mov	r0, r5
   12d90:	f000 fd02 	bl	13798 <ip_interface_wait>
   12d94:	4603      	mov	r3, r0
   12d96:	b150      	cbz	r0, 12dae <secure_client_socket+0xb2>
   12d98:	f8c4 8000 	str.w	r8, [r4]
   12d9c:	4618      	mov	r0, r3
   12d9e:	b004      	add	sp, #16
   12da0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12da4:	2373      	movs	r3, #115	; 0x73
   12da6:	4618      	mov	r0, r3
   12da8:	b004      	add	sp, #16
   12daa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12dae:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   12db2:	ab02      	add	r3, sp, #8
   12db4:	4611      	mov	r1, r2
   12db6:	4628      	mov	r0, r5
   12db8:	f000 fcee 	bl	13798 <ip_interface_wait>
   12dbc:	4603      	mov	r3, r0
   12dbe:	bb30      	cbnz	r0, 12e0e <secure_client_socket+0x112>
   12dc0:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
   12dc4:	b138      	cbz	r0, 12dd6 <secure_client_socket+0xda>
   12dc6:	9301      	str	r3, [sp, #4]
   12dc8:	f005 fe36 	bl	18a38 <nrf_free>
   12dcc:	9b01      	ldr	r3, [sp, #4]
   12dce:	443e      	add	r6, r7
   12dd0:	6073      	str	r3, [r6, #4]
   12dd2:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
   12dd6:	4618      	mov	r0, r3
   12dd8:	6822      	ldr	r2, [r4, #0]
   12dda:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
   12dde:	6022      	str	r2, [r4, #0]
   12de0:	6822      	ldr	r2, [r4, #0]
   12de2:	0c12      	lsrs	r2, r2, #16
   12de4:	0412      	lsls	r2, r2, #16
   12de6:	f042 020c 	orr.w	r2, r2, #12
   12dea:	6022      	str	r2, [r4, #0]
   12dec:	6822      	ldr	r2, [r4, #0]
   12dee:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   12df2:	6022      	str	r2, [r4, #0]
   12df4:	6822      	ldr	r2, [r4, #0]
   12df6:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   12dfa:	6022      	str	r2, [r4, #0]
   12dfc:	b004      	add	sp, #16
   12dfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12e02:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
   12e06:	6800      	ldr	r0, [r0, #0]
   12e08:	f009 f8ec 	bl	1bfe4 <memcpy>
   12e0c:	e79b      	b.n	12d46 <secure_client_socket+0x4a>
   12e0e:	2b73      	cmp	r3, #115	; 0x73
   12e10:	d0c4      	beq.n	12d9c <secure_client_socket+0xa0>
   12e12:	f8c4 8000 	str.w	r8, [r4]
   12e16:	e7c1      	b.n	12d9c <secure_client_socket+0xa0>
   12e18:	230c      	movs	r3, #12
   12e1a:	4618      	mov	r0, r3
   12e1c:	b004      	add	sp, #16
   12e1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12e22:	bf00      	nop
   12e24:	20020724 	.word	0x20020724
   12e28:	200205e0 	.word	0x200205e0

00012e2c <tls_interface_init>:
   12e2c:	2000      	movs	r0, #0
   12e2e:	4770      	bx	lr

00012e30 <tls_interface_open>:
   12e30:	b538      	push	{r3, r4, r5, lr}
   12e32:	1e4b      	subs	r3, r1, #1
   12e34:	2b01      	cmp	r3, #1
   12e36:	d808      	bhi.n	12e4a <tls_interface_open+0x1a>
   12e38:	4614      	mov	r4, r2
   12e3a:	b162      	cbz	r2, 12e56 <tls_interface_open+0x26>
   12e3c:	2901      	cmp	r1, #1
   12e3e:	d02d      	beq.n	12e9c <tls_interface_open+0x6c>
   12e40:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   12e44:	bf08      	it	eq
   12e46:	2202      	moveq	r2, #2
   12e48:	d00d      	beq.n	12e66 <tls_interface_open+0x36>
   12e4a:	2029      	movs	r0, #41	; 0x29
   12e4c:	f7fd f8ee 	bl	1002c <bsd_os_errno_set>
   12e50:	f04f 35ff 	mov.w	r5, #4294967295
   12e54:	e020      	b.n	12e98 <tls_interface_open+0x68>
   12e56:	2901      	cmp	r1, #1
   12e58:	bf0b      	itete	eq
   12e5a:	2201      	moveq	r2, #1
   12e5c:	2202      	movne	r2, #2
   12e5e:	f44f 7482 	moveq.w	r4, #260	; 0x104
   12e62:	f44f 7487 	movne.w	r4, #270	; 0x10e
   12e66:	f000 fcc9 	bl	137fc <ip_interface_open>
   12e6a:	1e05      	subs	r5, r0, #0
   12e6c:	db1b      	blt.n	12ea6 <tls_interface_open+0x76>
   12e6e:	4b0f      	ldr	r3, [pc, #60]	; (12eac <tls_interface_open+0x7c>)
   12e70:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
   12e74:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   12e78:	2224      	movs	r2, #36	; 0x24
   12e7a:	490d      	ldr	r1, [pc, #52]	; (12eb0 <tls_interface_open+0x80>)
   12e7c:	f009 f8b2 	bl	1bfe4 <memcpy>
   12e80:	4628      	mov	r0, r5
   12e82:	f006 fa33 	bl	192ec <interface_socket_from_handle_get>
   12e86:	6803      	ldr	r3, [r0, #0]
   12e88:	6144      	str	r4, [r0, #20]
   12e8a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   12e8e:	6003      	str	r3, [r0, #0]
   12e90:	6803      	ldr	r3, [r0, #0]
   12e92:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   12e96:	6003      	str	r3, [r0, #0]
   12e98:	4628      	mov	r0, r5
   12e9a:	bd38      	pop	{r3, r4, r5, pc}
   12e9c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   12ea0:	d1d3      	bne.n	12e4a <tls_interface_open+0x1a>
   12ea2:	460a      	mov	r2, r1
   12ea4:	e7df      	b.n	12e66 <tls_interface_open+0x36>
   12ea6:	f04f 35ff 	mov.w	r5, #4294967295
   12eaa:	e7f5      	b.n	12e98 <tls_interface_open+0x68>
   12eac:	200205e0 	.word	0x200205e0
   12eb0:	0001ddcc 	.word	0x0001ddcc

00012eb4 <tls_interface_close>:
   12eb4:	b538      	push	{r3, r4, r5, lr}
   12eb6:	4604      	mov	r4, r0
   12eb8:	f006 fa18 	bl	192ec <interface_socket_from_handle_get>
   12ebc:	b180      	cbz	r0, 12ee0 <tls_interface_close+0x2c>
   12ebe:	4d0b      	ldr	r5, [pc, #44]	; (12eec <tls_interface_close+0x38>)
   12ec0:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
   12ec4:	b138      	cbz	r0, 12ed6 <tls_interface_close+0x22>
   12ec6:	f005 fdb7 	bl	18a38 <nrf_free>
   12eca:	2300      	movs	r3, #0
   12ecc:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   12ed0:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   12ed4:	6053      	str	r3, [r2, #4]
   12ed6:	4620      	mov	r0, r4
   12ed8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   12edc:	f000 bd54 	b.w	13988 <ip_interface_close>
   12ee0:	2009      	movs	r0, #9
   12ee2:	f7fd f8a3 	bl	1002c <bsd_os_errno_set>
   12ee6:	f04f 30ff 	mov.w	r0, #4294967295
   12eea:	bd38      	pop	{r3, r4, r5, pc}
   12eec:	20020724 	.word	0x20020724

00012ef0 <tls_interface_sendto>:
   12ef0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12ef4:	460d      	mov	r5, r1
   12ef6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   12efa:	4616      	mov	r6, r2
   12efc:	461f      	mov	r7, r3
   12efe:	4604      	mov	r4, r0
   12f00:	f006 f9f4 	bl	192ec <interface_socket_from_handle_get>
   12f04:	2800      	cmp	r0, #0
   12f06:	d03b      	beq.n	12f80 <tls_interface_sendto+0x90>
   12f08:	6803      	ldr	r3, [r0, #0]
   12f0a:	b29b      	uxth	r3, r3
   12f0c:	2b0c      	cmp	r3, #12
   12f0e:	d039      	beq.n	12f84 <tls_interface_sendto+0x94>
   12f10:	6803      	ldr	r3, [r0, #0]
   12f12:	b29b      	uxth	r3, r3
   12f14:	2b0b      	cmp	r3, #11
   12f16:	d111      	bne.n	12f3c <tls_interface_sendto+0x4c>
   12f18:	4b20      	ldr	r3, [pc, #128]	; (12f9c <tls_interface_sendto+0xac>)
   12f1a:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   12f1e:	f813 3024 	ldrb.w	r3, [r3, r4, lsl #2]
   12f22:	2b02      	cmp	r3, #2
   12f24:	d038      	beq.n	12f98 <tls_interface_sendto+0xa8>
   12f26:	6903      	ldr	r3, [r0, #16]
   12f28:	2b01      	cmp	r3, #1
   12f2a:	bf14      	ite	ne
   12f2c:	2039      	movne	r0, #57	; 0x39
   12f2e:	202a      	moveq	r0, #42	; 0x2a
   12f30:	f7fd f87c 	bl	1002c <bsd_os_errno_set>
   12f34:	f04f 30ff 	mov.w	r0, #4294967295
   12f38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12f3c:	6903      	ldr	r3, [r0, #16]
   12f3e:	2b01      	cmp	r3, #1
   12f40:	d00b      	beq.n	12f5a <tls_interface_sendto+0x6a>
   12f42:	2b02      	cmp	r3, #2
   12f44:	d001      	beq.n	12f4a <tls_interface_sendto+0x5a>
   12f46:	2039      	movs	r0, #57	; 0x39
   12f48:	e7f2      	b.n	12f30 <tls_interface_sendto+0x40>
   12f4a:	6803      	ldr	r3, [r0, #0]
   12f4c:	b29b      	uxth	r3, r3
   12f4e:	2b02      	cmp	r3, #2
   12f50:	d007      	beq.n	12f62 <tls_interface_sendto+0x72>
   12f52:	6803      	ldr	r3, [r0, #0]
   12f54:	b29b      	uxth	r3, r3
   12f56:	2b04      	cmp	r3, #4
   12f58:	d003      	beq.n	12f62 <tls_interface_sendto+0x72>
   12f5a:	6803      	ldr	r3, [r0, #0]
   12f5c:	b29b      	uxth	r3, r3
   12f5e:	2b05      	cmp	r3, #5
   12f60:	d1f1      	bne.n	12f46 <tls_interface_sendto+0x56>
   12f62:	4b0e      	ldr	r3, [pc, #56]	; (12f9c <tls_interface_sendto+0xac>)
   12f64:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   12f68:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   12f6c:	2b02      	cmp	r3, #2
   12f6e:	d1ea      	bne.n	12f46 <tls_interface_sendto+0x56>
   12f70:	4601      	mov	r1, r0
   12f72:	4620      	mov	r0, r4
   12f74:	f7ff fec2 	bl	12cfc <secure_client_socket>
   12f78:	2800      	cmp	r0, #0
   12f7a:	d003      	beq.n	12f84 <tls_interface_sendto+0x94>
   12f7c:	dcd8      	bgt.n	12f30 <tls_interface_sendto+0x40>
   12f7e:	e7d9      	b.n	12f34 <tls_interface_sendto+0x44>
   12f80:	2009      	movs	r0, #9
   12f82:	e7d5      	b.n	12f30 <tls_interface_sendto+0x40>
   12f84:	e9cd 8908 	strd	r8, r9, [sp, #32]
   12f88:	463b      	mov	r3, r7
   12f8a:	4632      	mov	r2, r6
   12f8c:	4629      	mov	r1, r5
   12f8e:	4620      	mov	r0, r4
   12f90:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12f94:	f000 bd6a 	b.w	13a6c <ip_interface_sendto>
   12f98:	2023      	movs	r0, #35	; 0x23
   12f9a:	e7c9      	b.n	12f30 <tls_interface_sendto+0x40>
   12f9c:	200205e0 	.word	0x200205e0

00012fa0 <tls_interface_recvfrom>:
   12fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12fa4:	460d      	mov	r5, r1
   12fa6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   12faa:	4616      	mov	r6, r2
   12fac:	461f      	mov	r7, r3
   12fae:	4604      	mov	r4, r0
   12fb0:	f006 f99c 	bl	192ec <interface_socket_from_handle_get>
   12fb4:	2800      	cmp	r0, #0
   12fb6:	d038      	beq.n	1302a <tls_interface_recvfrom+0x8a>
   12fb8:	6803      	ldr	r3, [r0, #0]
   12fba:	b29b      	uxth	r3, r3
   12fbc:	2b0c      	cmp	r3, #12
   12fbe:	d00f      	beq.n	12fe0 <tls_interface_recvfrom+0x40>
   12fc0:	6803      	ldr	r3, [r0, #0]
   12fc2:	b29b      	uxth	r3, r3
   12fc4:	2b0d      	cmp	r3, #13
   12fc6:	d00b      	beq.n	12fe0 <tls_interface_recvfrom+0x40>
   12fc8:	6903      	ldr	r3, [r0, #16]
   12fca:	2b01      	cmp	r3, #1
   12fcc:	d01a      	beq.n	13004 <tls_interface_recvfrom+0x64>
   12fce:	2b02      	cmp	r3, #2
   12fd0:	d010      	beq.n	12ff4 <tls_interface_recvfrom+0x54>
   12fd2:	2023      	movs	r0, #35	; 0x23
   12fd4:	f7fd f82a 	bl	1002c <bsd_os_errno_set>
   12fd8:	f04f 30ff 	mov.w	r0, #4294967295
   12fdc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   12fe0:	e9cd 8908 	strd	r8, r9, [sp, #32]
   12fe4:	463b      	mov	r3, r7
   12fe6:	4632      	mov	r2, r6
   12fe8:	4629      	mov	r1, r5
   12fea:	4620      	mov	r0, r4
   12fec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   12ff0:	f000 bea2 	b.w	13d38 <ip_interface_recvfrom>
   12ff4:	6803      	ldr	r3, [r0, #0]
   12ff6:	b29b      	uxth	r3, r3
   12ff8:	2b02      	cmp	r3, #2
   12ffa:	d007      	beq.n	1300c <tls_interface_recvfrom+0x6c>
   12ffc:	6803      	ldr	r3, [r0, #0]
   12ffe:	b29b      	uxth	r3, r3
   13000:	2b04      	cmp	r3, #4
   13002:	d003      	beq.n	1300c <tls_interface_recvfrom+0x6c>
   13004:	6803      	ldr	r3, [r0, #0]
   13006:	b29b      	uxth	r3, r3
   13008:	2b05      	cmp	r3, #5
   1300a:	d1e2      	bne.n	12fd2 <tls_interface_recvfrom+0x32>
   1300c:	4b08      	ldr	r3, [pc, #32]	; (13030 <tls_interface_recvfrom+0x90>)
   1300e:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   13012:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   13016:	2b02      	cmp	r3, #2
   13018:	d1db      	bne.n	12fd2 <tls_interface_recvfrom+0x32>
   1301a:	4601      	mov	r1, r0
   1301c:	4620      	mov	r0, r4
   1301e:	f7ff fe6d 	bl	12cfc <secure_client_socket>
   13022:	2800      	cmp	r0, #0
   13024:	d0dc      	beq.n	12fe0 <tls_interface_recvfrom+0x40>
   13026:	dcd5      	bgt.n	12fd4 <tls_interface_recvfrom+0x34>
   13028:	e7d6      	b.n	12fd8 <tls_interface_recvfrom+0x38>
   1302a:	2009      	movs	r0, #9
   1302c:	e7d2      	b.n	12fd4 <tls_interface_recvfrom+0x34>
   1302e:	bf00      	nop
   13030:	200205e0 	.word	0x200205e0

00013034 <tls_interface_bind>:
   13034:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13038:	b082      	sub	sp, #8
   1303a:	460e      	mov	r6, r1
   1303c:	4617      	mov	r7, r2
   1303e:	4605      	mov	r5, r0
   13040:	f006 f954 	bl	192ec <interface_socket_from_handle_get>
   13044:	2800      	cmp	r0, #0
   13046:	d069      	beq.n	1311c <tls_interface_bind+0xe8>
   13048:	6803      	ldr	r3, [r0, #0]
   1304a:	4604      	mov	r4, r0
   1304c:	b29b      	uxth	r3, r3
   1304e:	2b02      	cmp	r3, #2
   13050:	d158      	bne.n	13104 <tls_interface_bind+0xd0>
   13052:	463a      	mov	r2, r7
   13054:	4631      	mov	r1, r6
   13056:	4628      	mov	r0, r5
   13058:	f001 f858 	bl	1410c <ip_interface_bind>
   1305c:	2800      	cmp	r0, #0
   1305e:	d148      	bne.n	130f2 <tls_interface_bind+0xbe>
   13060:	00ee      	lsls	r6, r5, #3
   13062:	4f2f      	ldr	r7, [pc, #188]	; (13120 <tls_interface_bind+0xec>)
   13064:	1973      	adds	r3, r6, r5
   13066:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   1306a:	2b01      	cmp	r3, #1
   1306c:	d002      	beq.n	13074 <tls_interface_bind+0x40>
   1306e:	b002      	add	sp, #8
   13070:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13074:	f04f 3cff 	mov.w	ip, #4294967295
   13078:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 13124 <tls_interface_bind+0xf0>
   1307c:	f247 0281 	movw	r2, #28801	; 0x7081
   13080:	eb0a 0906 	add.w	r9, sl, r6
   13084:	f8d9 3004 	ldr.w	r3, [r9, #4]
   13088:	69a1      	ldr	r1, [r4, #24]
   1308a:	4628      	mov	r0, r5
   1308c:	f8cd c004 	str.w	ip, [sp, #4]
   13090:	f000 fb4e 	bl	13730 <ip_interface_request_create>
   13094:	4680      	mov	r8, r0
   13096:	2800      	cmp	r0, #0
   13098:	d03e      	beq.n	13118 <tls_interface_bind+0xe4>
   1309a:	f8d9 2004 	ldr.w	r2, [r9, #4]
   1309e:	bbaa      	cbnz	r2, 1310c <tls_interface_bind+0xd8>
   130a0:	1971      	adds	r1, r6, r5
   130a2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   130a6:	2224      	movs	r2, #36	; 0x24
   130a8:	f108 0014 	add.w	r0, r8, #20
   130ac:	f008 ff9a 	bl	1bfe4 <memcpy>
   130b0:	f8d8 3008 	ldr.w	r3, [r8, #8]
   130b4:	4641      	mov	r1, r8
   130b6:	3324      	adds	r3, #36	; 0x24
   130b8:	f8c8 3008 	str.w	r3, [r8, #8]
   130bc:	6822      	ldr	r2, [r4, #0]
   130be:	2304      	movs	r3, #4
   130c0:	0c12      	lsrs	r2, r2, #16
   130c2:	0412      	lsls	r2, r2, #16
   130c4:	f042 020a 	orr.w	r2, r2, #10
   130c8:	6022      	str	r2, [r4, #0]
   130ca:	4620      	mov	r0, r4
   130cc:	f247 0281 	movw	r2, #28801	; 0x7081
   130d0:	f000 fb4e 	bl	13770 <ip_interface_request_send>
   130d4:	b968      	cbnz	r0, 130f2 <tls_interface_bind+0xbe>
   130d6:	6823      	ldr	r3, [r4, #0]
   130d8:	00db      	lsls	r3, r3, #3
   130da:	d415      	bmi.n	13108 <tls_interface_bind+0xd4>
   130dc:	4628      	mov	r0, r5
   130de:	ab01      	add	r3, sp, #4
   130e0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   130e4:	210b      	movs	r1, #11
   130e6:	f000 fb57 	bl	13798 <ip_interface_wait>
   130ea:	2800      	cmp	r0, #0
   130ec:	d0bf      	beq.n	1306e <tls_interface_bind+0x3a>
   130ee:	2304      	movs	r3, #4
   130f0:	6023      	str	r3, [r4, #0]
   130f2:	2800      	cmp	r0, #0
   130f4:	ddbb      	ble.n	1306e <tls_interface_bind+0x3a>
   130f6:	f7fc ff99 	bl	1002c <bsd_os_errno_set>
   130fa:	f04f 30ff 	mov.w	r0, #4294967295
   130fe:	b002      	add	sp, #8
   13100:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   13104:	202d      	movs	r0, #45	; 0x2d
   13106:	e7f6      	b.n	130f6 <tls_interface_bind+0xc2>
   13108:	2073      	movs	r0, #115	; 0x73
   1310a:	e7f4      	b.n	130f6 <tls_interface_bind+0xc2>
   1310c:	f85a 1035 	ldr.w	r1, [sl, r5, lsl #3]
   13110:	6800      	ldr	r0, [r0, #0]
   13112:	f008 ff67 	bl	1bfe4 <memcpy>
   13116:	e7c3      	b.n	130a0 <tls_interface_bind+0x6c>
   13118:	200c      	movs	r0, #12
   1311a:	e7ec      	b.n	130f6 <tls_interface_bind+0xc2>
   1311c:	2009      	movs	r0, #9
   1311e:	e7ea      	b.n	130f6 <tls_interface_bind+0xc2>
   13120:	200205e0 	.word	0x200205e0
   13124:	20020724 	.word	0x20020724

00013128 <tls_interface_connect>:
   13128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1312a:	460e      	mov	r6, r1
   1312c:	4617      	mov	r7, r2
   1312e:	4604      	mov	r4, r0
   13130:	f006 f8dc 	bl	192ec <interface_socket_from_handle_get>
   13134:	b1e8      	cbz	r0, 13172 <tls_interface_connect+0x4a>
   13136:	4b13      	ldr	r3, [pc, #76]	; (13184 <tls_interface_connect+0x5c>)
   13138:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   1313c:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   13140:	2b02      	cmp	r3, #2
   13142:	d11c      	bne.n	1317e <tls_interface_connect+0x56>
   13144:	6803      	ldr	r3, [r0, #0]
   13146:	4605      	mov	r5, r0
   13148:	b29b      	uxth	r3, r3
   1314a:	2b02      	cmp	r3, #2
   1314c:	d003      	beq.n	13156 <tls_interface_connect+0x2e>
   1314e:	6803      	ldr	r3, [r0, #0]
   13150:	b29b      	uxth	r3, r3
   13152:	2b04      	cmp	r3, #4
   13154:	d113      	bne.n	1317e <tls_interface_connect+0x56>
   13156:	463a      	mov	r2, r7
   13158:	4631      	mov	r1, r6
   1315a:	4620      	mov	r0, r4
   1315c:	f000 ff14 	bl	13f88 <ip_interface_connect>
   13160:	b110      	cbz	r0, 13168 <tls_interface_connect+0x40>
   13162:	2800      	cmp	r0, #0
   13164:	dc06      	bgt.n	13174 <tls_interface_connect+0x4c>
   13166:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13168:	4629      	mov	r1, r5
   1316a:	4620      	mov	r0, r4
   1316c:	f7ff fdc6 	bl	12cfc <secure_client_socket>
   13170:	e7f7      	b.n	13162 <tls_interface_connect+0x3a>
   13172:	2009      	movs	r0, #9
   13174:	f7fc ff5a 	bl	1002c <bsd_os_errno_set>
   13178:	f04f 30ff 	mov.w	r0, #4294967295
   1317c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1317e:	202d      	movs	r0, #45	; 0x2d
   13180:	e7f8      	b.n	13174 <tls_interface_connect+0x4c>
   13182:	bf00      	nop
   13184:	200205e0 	.word	0x200205e0

00013188 <tls_interface_listen>:
   13188:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1318c:	b085      	sub	sp, #20
   1318e:	9101      	str	r1, [sp, #4]
   13190:	4605      	mov	r5, r0
   13192:	f006 f8ab 	bl	192ec <interface_socket_from_handle_get>
   13196:	2800      	cmp	r0, #0
   13198:	d07c      	beq.n	13294 <tls_interface_listen+0x10c>
   1319a:	6903      	ldr	r3, [r0, #16]
   1319c:	4604      	mov	r4, r0
   1319e:	2b01      	cmp	r3, #1
   131a0:	d176      	bne.n	13290 <tls_interface_listen+0x108>
   131a2:	6803      	ldr	r3, [r0, #0]
   131a4:	b29b      	uxth	r3, r3
   131a6:	2b04      	cmp	r3, #4
   131a8:	d062      	beq.n	13270 <tls_interface_listen+0xe8>
   131aa:	6823      	ldr	r3, [r4, #0]
   131ac:	b29b      	uxth	r3, r3
   131ae:	2b0b      	cmp	r3, #11
   131b0:	d16e      	bne.n	13290 <tls_interface_listen+0x108>
   131b2:	00ee      	lsls	r6, r5, #3
   131b4:	4f38      	ldr	r7, [pc, #224]	; (13298 <tls_interface_listen+0x110>)
   131b6:	1973      	adds	r3, r6, r5
   131b8:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   131bc:	2b01      	cmp	r3, #1
   131be:	d167      	bne.n	13290 <tls_interface_listen+0x108>
   131c0:	2201      	movs	r2, #1
   131c2:	f04f 3cff 	mov.w	ip, #4294967295
   131c6:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 1329c <tls_interface_listen+0x114>
   131ca:	1973      	adds	r3, r6, r5
   131cc:	00ee      	lsls	r6, r5, #3
   131ce:	f807 2023 	strb.w	r2, [r7, r3, lsl #2]
   131d2:	eb09 0806 	add.w	r8, r9, r6
   131d6:	69a1      	ldr	r1, [r4, #24]
   131d8:	f8d8 3004 	ldr.w	r3, [r8, #4]
   131dc:	f247 0281 	movw	r2, #28801	; 0x7081
   131e0:	4628      	mov	r0, r5
   131e2:	f8d4 a000 	ldr.w	sl, [r4]
   131e6:	f8cd c00c 	str.w	ip, [sp, #12]
   131ea:	f000 faa1 	bl	13730 <ip_interface_request_create>
   131ee:	4683      	mov	fp, r0
   131f0:	2800      	cmp	r0, #0
   131f2:	d04b      	beq.n	1328c <tls_interface_listen+0x104>
   131f4:	f8d8 2004 	ldr.w	r2, [r8, #4]
   131f8:	2a00      	cmp	r2, #0
   131fa:	d141      	bne.n	13280 <tls_interface_listen+0xf8>
   131fc:	1971      	adds	r1, r6, r5
   131fe:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   13202:	2224      	movs	r2, #36	; 0x24
   13204:	f10b 0014 	add.w	r0, fp, #20
   13208:	f008 feec 	bl	1bfe4 <memcpy>
   1320c:	f8db 2008 	ldr.w	r2, [fp, #8]
   13210:	4659      	mov	r1, fp
   13212:	3224      	adds	r2, #36	; 0x24
   13214:	f8cb 2008 	str.w	r2, [fp, #8]
   13218:	6822      	ldr	r2, [r4, #0]
   1321a:	4653      	mov	r3, sl
   1321c:	0c12      	lsrs	r2, r2, #16
   1321e:	0412      	lsls	r2, r2, #16
   13220:	f042 020a 	orr.w	r2, r2, #10
   13224:	6022      	str	r2, [r4, #0]
   13226:	4620      	mov	r0, r4
   13228:	f247 0281 	movw	r2, #28801	; 0x7081
   1322c:	f000 faa0 	bl	13770 <ip_interface_request_send>
   13230:	b960      	cbnz	r0, 1324c <tls_interface_listen+0xc4>
   13232:	6823      	ldr	r3, [r4, #0]
   13234:	00db      	lsls	r3, r3, #3
   13236:	d40e      	bmi.n	13256 <tls_interface_listen+0xce>
   13238:	ab03      	add	r3, sp, #12
   1323a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1323e:	210b      	movs	r1, #11
   13240:	4628      	mov	r0, r5
   13242:	f000 faa9 	bl	13798 <ip_interface_wait>
   13246:	b170      	cbz	r0, 13266 <tls_interface_listen+0xde>
   13248:	f8c4 a000 	str.w	sl, [r4]
   1324c:	2800      	cmp	r0, #0
   1324e:	dc03      	bgt.n	13258 <tls_interface_listen+0xd0>
   13250:	b005      	add	sp, #20
   13252:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13256:	2073      	movs	r0, #115	; 0x73
   13258:	f7fc fee8 	bl	1002c <bsd_os_errno_set>
   1325c:	f04f 30ff 	mov.w	r0, #4294967295
   13260:	b005      	add	sp, #20
   13262:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13266:	9901      	ldr	r1, [sp, #4]
   13268:	4628      	mov	r0, r5
   1326a:	f000 fff1 	bl	14250 <ip_interface_listen>
   1326e:	e7ed      	b.n	1324c <tls_interface_listen+0xc4>
   13270:	00ee      	lsls	r6, r5, #3
   13272:	4f09      	ldr	r7, [pc, #36]	; (13298 <tls_interface_listen+0x110>)
   13274:	1973      	adds	r3, r6, r5
   13276:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   1327a:	2b02      	cmp	r3, #2
   1327c:	d195      	bne.n	131aa <tls_interface_listen+0x22>
   1327e:	e79f      	b.n	131c0 <tls_interface_listen+0x38>
   13280:	f859 1035 	ldr.w	r1, [r9, r5, lsl #3]
   13284:	6800      	ldr	r0, [r0, #0]
   13286:	f008 fead 	bl	1bfe4 <memcpy>
   1328a:	e7b7      	b.n	131fc <tls_interface_listen+0x74>
   1328c:	200c      	movs	r0, #12
   1328e:	e7e3      	b.n	13258 <tls_interface_listen+0xd0>
   13290:	202d      	movs	r0, #45	; 0x2d
   13292:	e7e1      	b.n	13258 <tls_interface_listen+0xd0>
   13294:	2009      	movs	r0, #9
   13296:	e7df      	b.n	13258 <tls_interface_listen+0xd0>
   13298:	200205e0 	.word	0x200205e0
   1329c:	20020724 	.word	0x20020724

000132a0 <tls_interface_accept>:
   132a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   132a4:	b082      	sub	sp, #8
   132a6:	460e      	mov	r6, r1
   132a8:	4617      	mov	r7, r2
   132aa:	4698      	mov	r8, r3
   132ac:	4605      	mov	r5, r0
   132ae:	f04f 34ff 	mov.w	r4, #4294967295
   132b2:	f006 f81b 	bl	192ec <interface_socket_from_handle_get>
   132b6:	9401      	str	r4, [sp, #4]
   132b8:	2800      	cmp	r0, #0
   132ba:	d03c      	beq.n	13336 <tls_interface_accept+0x96>
   132bc:	6800      	ldr	r0, [r0, #0]
   132be:	b280      	uxth	r0, r0
   132c0:	2806      	cmp	r0, #6
   132c2:	d138      	bne.n	13336 <tls_interface_accept+0x96>
   132c4:	4643      	mov	r3, r8
   132c6:	463a      	mov	r2, r7
   132c8:	4631      	mov	r1, r6
   132ca:	4628      	mov	r0, r5
   132cc:	f001 f838 	bl	14340 <ip_interface_accept>
   132d0:	4604      	mov	r4, r0
   132d2:	b128      	cbz	r0, 132e0 <tls_interface_accept+0x40>
   132d4:	2c00      	cmp	r4, #0
   132d6:	dc2f      	bgt.n	13338 <tls_interface_accept+0x98>
   132d8:	4620      	mov	r0, r4
   132da:	b002      	add	sp, #8
   132dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   132e0:	4628      	mov	r0, r5
   132e2:	f006 f803 	bl	192ec <interface_socket_from_handle_get>
   132e6:	6803      	ldr	r3, [r0, #0]
   132e8:	4f18      	ldr	r7, [pc, #96]	; (1334c <tls_interface_accept+0xac>)
   132ea:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   132ee:	6003      	str	r3, [r0, #0]
   132f0:	6803      	ldr	r3, [r0, #0]
   132f2:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   132f6:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   132fa:	4606      	mov	r6, r0
   132fc:	6003      	str	r3, [r0, #0]
   132fe:	eb07 0185 	add.w	r1, r7, r5, lsl #2
   13302:	2224      	movs	r2, #36	; 0x24
   13304:	4638      	mov	r0, r7
   13306:	f008 fe6d 	bl	1bfe4 <memcpy>
   1330a:	2302      	movs	r3, #2
   1330c:	703b      	strb	r3, [r7, #0]
   1330e:	6833      	ldr	r3, [r6, #0]
   13310:	4620      	mov	r0, r4
   13312:	0c1b      	lsrs	r3, r3, #16
   13314:	041b      	lsls	r3, r3, #16
   13316:	f043 030b 	orr.w	r3, r3, #11
   1331a:	6033      	str	r3, [r6, #0]
   1331c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13320:	ab01      	add	r3, sp, #4
   13322:	210c      	movs	r1, #12
   13324:	f000 fa38 	bl	13798 <ip_interface_wait>
   13328:	4604      	mov	r4, r0
   1332a:	2800      	cmp	r0, #0
   1332c:	d0d4      	beq.n	132d8 <tls_interface_accept+0x38>
   1332e:	2000      	movs	r0, #0
   13330:	f000 fb2a 	bl	13988 <ip_interface_close>
   13334:	e7ce      	b.n	132d4 <tls_interface_accept+0x34>
   13336:	2409      	movs	r4, #9
   13338:	4620      	mov	r0, r4
   1333a:	f04f 34ff 	mov.w	r4, #4294967295
   1333e:	f7fc fe75 	bl	1002c <bsd_os_errno_set>
   13342:	4620      	mov	r0, r4
   13344:	b002      	add	sp, #8
   13346:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1334a:	bf00      	nop
   1334c:	200205e0 	.word	0x200205e0

00013350 <tls_interface_setopt>:
   13350:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13354:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   13358:	9e06      	ldr	r6, [sp, #24]
   1335a:	d11e      	bne.n	1339a <tls_interface_setopt+0x4a>
   1335c:	461f      	mov	r7, r3
   1335e:	4605      	mov	r5, r0
   13360:	2b00      	cmp	r3, #0
   13362:	f000 808c 	beq.w	1347e <tls_interface_setopt+0x12e>
   13366:	4690      	mov	r8, r2
   13368:	f005 ffc0 	bl	192ec <interface_socket_from_handle_get>
   1336c:	2800      	cmp	r0, #0
   1336e:	d07b      	beq.n	13468 <tls_interface_setopt+0x118>
   13370:	6804      	ldr	r4, [r0, #0]
   13372:	b2a4      	uxth	r4, r4
   13374:	2c02      	cmp	r4, #2
   13376:	d007      	beq.n	13388 <tls_interface_setopt+0x38>
   13378:	6803      	ldr	r3, [r0, #0]
   1337a:	b29b      	uxth	r3, r3
   1337c:	2b04      	cmp	r3, #4
   1337e:	d003      	beq.n	13388 <tls_interface_setopt+0x38>
   13380:	6803      	ldr	r3, [r0, #0]
   13382:	b29b      	uxth	r3, r3
   13384:	2b05      	cmp	r3, #5
   13386:	d16f      	bne.n	13468 <tls_interface_setopt+0x118>
   13388:	f108 32ff 	add.w	r2, r8, #4294967295
   1338c:	2a04      	cmp	r2, #4
   1338e:	d87c      	bhi.n	1348a <tls_interface_setopt+0x13a>
   13390:	e8df f002 	tbb	[pc, r2]
   13394:	41324e24 	.word	0x41324e24
   13398:	07          	.byte	0x07
   13399:	00          	.byte	0x00
   1339a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1339e:	f001 b911 	b.w	145c4 <ip_interface_setopt>
   133a2:	4c3b      	ldr	r4, [pc, #236]	; (13490 <tls_interface_setopt+0x140>)
   133a4:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
   133a8:	b138      	cbz	r0, 133ba <tls_interface_setopt+0x6a>
   133aa:	f005 fb45 	bl	18a38 <nrf_free>
   133ae:	2200      	movs	r2, #0
   133b0:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   133b4:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
   133b8:	605a      	str	r2, [r3, #4]
   133ba:	4630      	mov	r0, r6
   133bc:	b34e      	cbz	r6, 13412 <tls_interface_setopt+0xc2>
   133be:	f005 fb31 	bl	18a24 <nrf_malloc>
   133c2:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
   133c6:	2800      	cmp	r0, #0
   133c8:	d057      	beq.n	1347a <tls_interface_setopt+0x12a>
   133ca:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   133ce:	4632      	mov	r2, r6
   133d0:	4639      	mov	r1, r7
   133d2:	6066      	str	r6, [r4, #4]
   133d4:	f008 fe06 	bl	1bfe4 <memcpy>
   133d8:	2000      	movs	r0, #0
   133da:	e01a      	b.n	13412 <tls_interface_setopt+0xc2>
   133dc:	2e04      	cmp	r6, #4
   133de:	d14a      	bne.n	13476 <tls_interface_setopt+0x126>
   133e0:	6838      	ldr	r0, [r7, #0]
   133e2:	2800      	cmp	r0, #0
   133e4:	d039      	beq.n	1345a <tls_interface_setopt+0x10a>
   133e6:	2801      	cmp	r0, #1
   133e8:	d145      	bne.n	13476 <tls_interface_setopt+0x126>
   133ea:	4a2a      	ldr	r2, [pc, #168]	; (13494 <tls_interface_setopt+0x144>)
   133ec:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   133f0:	f802 0024 	strb.w	r0, [r2, r4, lsl #2]
   133f4:	2000      	movs	r0, #0
   133f6:	e00c      	b.n	13412 <tls_interface_setopt+0xc2>
   133f8:	2e01      	cmp	r6, #1
   133fa:	d13c      	bne.n	13476 <tls_interface_setopt+0x126>
   133fc:	783a      	ldrb	r2, [r7, #0]
   133fe:	2000      	movs	r0, #0
   13400:	3200      	adds	r2, #0
   13402:	bf18      	it	ne
   13404:	2201      	movne	r2, #1
   13406:	4b23      	ldr	r3, [pc, #140]	; (13494 <tls_interface_setopt+0x144>)
   13408:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   1340c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   13410:	7062      	strb	r2, [r4, #1]
   13412:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13416:	2e04      	cmp	r6, #4
   13418:	d12d      	bne.n	13476 <tls_interface_setopt+0x126>
   1341a:	683a      	ldr	r2, [r7, #0]
   1341c:	2a02      	cmp	r2, #2
   1341e:	d82a      	bhi.n	13476 <tls_interface_setopt+0x126>
   13420:	4b1c      	ldr	r3, [pc, #112]	; (13494 <tls_interface_setopt+0x144>)
   13422:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   13426:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   1342a:	70a2      	strb	r2, [r4, #2]
   1342c:	2000      	movs	r0, #0
   1342e:	e7f0      	b.n	13412 <tls_interface_setopt+0xc2>
   13430:	ea5f 0c96 	movs.w	ip, r6, lsr #2
   13434:	d01f      	beq.n	13476 <tls_interface_setopt+0x126>
   13436:	f016 0403 	ands.w	r4, r6, #3
   1343a:	d11c      	bne.n	13476 <tls_interface_setopt+0x126>
   1343c:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   13440:	00ad      	lsls	r5, r5, #2
   13442:	4b14      	ldr	r3, [pc, #80]	; (13494 <tls_interface_setopt+0x144>)
   13444:	1d28      	adds	r0, r5, #4
   13446:	4418      	add	r0, r3
   13448:	442b      	add	r3, r5
   1344a:	4632      	mov	r2, r6
   1344c:	4639      	mov	r1, r7
   1344e:	f883 c003 	strb.w	ip, [r3, #3]
   13452:	f008 fdc7 	bl	1bfe4 <memcpy>
   13456:	4620      	mov	r0, r4
   13458:	e7db      	b.n	13412 <tls_interface_setopt+0xc2>
   1345a:	2102      	movs	r1, #2
   1345c:	4a0d      	ldr	r2, [pc, #52]	; (13494 <tls_interface_setopt+0x144>)
   1345e:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   13462:	f802 1024 	strb.w	r1, [r2, r4, lsl #2]
   13466:	e7d4      	b.n	13412 <tls_interface_setopt+0xc2>
   13468:	2009      	movs	r0, #9
   1346a:	f7fc fddf 	bl	1002c <bsd_os_errno_set>
   1346e:	f04f 30ff 	mov.w	r0, #4294967295
   13472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13476:	2016      	movs	r0, #22
   13478:	e7f7      	b.n	1346a <tls_interface_setopt+0x11a>
   1347a:	200c      	movs	r0, #12
   1347c:	e7f5      	b.n	1346a <tls_interface_setopt+0x11a>
   1347e:	200e      	movs	r0, #14
   13480:	f7fc fdd4 	bl	1002c <bsd_os_errno_set>
   13484:	f04f 30ff 	mov.w	r0, #4294967295
   13488:	e7c3      	b.n	13412 <tls_interface_setopt+0xc2>
   1348a:	202a      	movs	r0, #42	; 0x2a
   1348c:	e7ed      	b.n	1346a <tls_interface_setopt+0x11a>
   1348e:	bf00      	nop
   13490:	20020724 	.word	0x20020724
   13494:	200205e0 	.word	0x200205e0

00013498 <tls_interface_getopt>:
   13498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1349c:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   134a0:	9f06      	ldr	r7, [sp, #24]
   134a2:	d112      	bne.n	134ca <tls_interface_getopt+0x32>
   134a4:	461d      	mov	r5, r3
   134a6:	b16b      	cbz	r3, 134c4 <tls_interface_getopt+0x2c>
   134a8:	b167      	cbz	r7, 134c4 <tls_interface_getopt+0x2c>
   134aa:	4606      	mov	r6, r0
   134ac:	4614      	mov	r4, r2
   134ae:	f005 ff1d 	bl	192ec <interface_socket_from_handle_get>
   134b2:	2800      	cmp	r0, #0
   134b4:	d04f      	beq.n	13556 <tls_interface_getopt+0xbe>
   134b6:	3c01      	subs	r4, #1
   134b8:	2c03      	cmp	r4, #3
   134ba:	d852      	bhi.n	13562 <tls_interface_getopt+0xca>
   134bc:	e8df f004 	tbb	[pc, r4]
   134c0:	09152139 	.word	0x09152139
   134c4:	200e      	movs	r0, #14
   134c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   134ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   134ce:	f001 b935 	b.w	1473c <ip_interface_getopt>
   134d2:	683b      	ldr	r3, [r7, #0]
   134d4:	2b04      	cmp	r3, #4
   134d6:	d13c      	bne.n	13552 <tls_interface_getopt+0xba>
   134d8:	4b23      	ldr	r3, [pc, #140]	; (13568 <tls_interface_getopt+0xd0>)
   134da:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   134de:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   134e2:	78b3      	ldrb	r3, [r6, #2]
   134e4:	2000      	movs	r0, #0
   134e6:	602b      	str	r3, [r5, #0]
   134e8:	e7ed      	b.n	134c6 <tls_interface_getopt+0x2e>
   134ea:	683b      	ldr	r3, [r7, #0]
   134ec:	2b01      	cmp	r3, #1
   134ee:	d130      	bne.n	13552 <tls_interface_getopt+0xba>
   134f0:	4b1d      	ldr	r3, [pc, #116]	; (13568 <tls_interface_getopt+0xd0>)
   134f2:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   134f6:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   134fa:	7873      	ldrb	r3, [r6, #1]
   134fc:	2000      	movs	r0, #0
   134fe:	702b      	strb	r3, [r5, #0]
   13500:	e7e1      	b.n	134c6 <tls_interface_getopt+0x2e>
   13502:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   13506:	4918      	ldr	r1, [pc, #96]	; (13568 <tls_interface_getopt+0xd0>)
   13508:	683b      	ldr	r3, [r7, #0]
   1350a:	00b6      	lsls	r6, r6, #2
   1350c:	198a      	adds	r2, r1, r6
   1350e:	f013 0403 	ands.w	r4, r3, #3
   13512:	78d0      	ldrb	r0, [r2, #3]
   13514:	d121      	bne.n	1355a <tls_interface_getopt+0xc2>
   13516:	089b      	lsrs	r3, r3, #2
   13518:	4283      	cmp	r3, r0
   1351a:	bf28      	it	cs
   1351c:	4603      	movcs	r3, r0
   1351e:	009a      	lsls	r2, r3, #2
   13520:	b1db      	cbz	r3, 1355a <tls_interface_getopt+0xc2>
   13522:	3604      	adds	r6, #4
   13524:	4431      	add	r1, r6
   13526:	603a      	str	r2, [r7, #0]
   13528:	4628      	mov	r0, r5
   1352a:	f008 fd5b 	bl	1bfe4 <memcpy>
   1352e:	4620      	mov	r0, r4
   13530:	e7c9      	b.n	134c6 <tls_interface_getopt+0x2e>
   13532:	683b      	ldr	r3, [r7, #0]
   13534:	2b04      	cmp	r3, #4
   13536:	d10c      	bne.n	13552 <tls_interface_getopt+0xba>
   13538:	4b0b      	ldr	r3, [pc, #44]	; (13568 <tls_interface_getopt+0xd0>)
   1353a:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   1353e:	f813 3026 	ldrb.w	r3, [r3, r6, lsl #2]
   13542:	2000      	movs	r0, #0
   13544:	f1a3 0301 	sub.w	r3, r3, #1
   13548:	fab3 f383 	clz	r3, r3
   1354c:	095b      	lsrs	r3, r3, #5
   1354e:	602b      	str	r3, [r5, #0]
   13550:	e7b9      	b.n	134c6 <tls_interface_getopt+0x2e>
   13552:	2016      	movs	r0, #22
   13554:	e7b7      	b.n	134c6 <tls_interface_getopt+0x2e>
   13556:	2009      	movs	r0, #9
   13558:	e7b5      	b.n	134c6 <tls_interface_getopt+0x2e>
   1355a:	2800      	cmp	r0, #0
   1355c:	d1f9      	bne.n	13552 <tls_interface_getopt+0xba>
   1355e:	6038      	str	r0, [r7, #0]
   13560:	e7b1      	b.n	134c6 <tls_interface_getopt+0x2e>
   13562:	202a      	movs	r0, #42	; 0x2a
   13564:	e7af      	b.n	134c6 <tls_interface_getopt+0x2e>
   13566:	bf00      	nop
   13568:	200205e0 	.word	0x200205e0

0001356c <tls_rpc_ip_event_handler>:
   1356c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1356e:	f248 0581 	movw	r5, #32897	; 0x8081
   13572:	42ab      	cmp	r3, r5
   13574:	460c      	mov	r4, r1
   13576:	d062      	beq.n	1363e <tls_rpc_ip_event_handler+0xd2>
   13578:	f249 0182 	movw	r1, #36994	; 0x9082
   1357c:	428b      	cmp	r3, r1
   1357e:	4606      	mov	r6, r0
   13580:	d02e      	beq.n	135e0 <tls_rpc_ip_event_handler+0x74>
   13582:	f248 0102 	movw	r1, #32770	; 0x8002
   13586:	428b      	cmp	r3, r1
   13588:	d001      	beq.n	1358e <tls_rpc_ip_event_handler+0x22>
   1358a:	2001      	movs	r0, #1
   1358c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1358e:	2c00      	cmp	r4, #0
   13590:	d0fb      	beq.n	1358a <tls_rpc_ip_event_handler+0x1e>
   13592:	6963      	ldr	r3, [r4, #20]
   13594:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   13598:	d002      	beq.n	135a0 <tls_rpc_ip_event_handler+0x34>
   1359a:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   1359e:	d1f4      	bne.n	1358a <tls_rpc_ip_event_handler+0x1e>
   135a0:	6823      	ldr	r3, [r4, #0]
   135a2:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   135a6:	6023      	str	r3, [r4, #0]
   135a8:	6955      	ldr	r5, [r2, #20]
   135aa:	2d00      	cmp	r5, #0
   135ac:	d156      	bne.n	1365c <tls_rpc_ip_event_handler+0xf0>
   135ae:	6823      	ldr	r3, [r4, #0]
   135b0:	0c1b      	lsrs	r3, r3, #16
   135b2:	041b      	lsls	r3, r3, #16
   135b4:	f043 0305 	orr.w	r3, r3, #5
   135b8:	6023      	str	r3, [r4, #0]
   135ba:	6823      	ldr	r3, [r4, #0]
   135bc:	00da      	lsls	r2, r3, #3
   135be:	d50d      	bpl.n	135dc <tls_rpc_ip_event_handler+0x70>
   135c0:	4b2b      	ldr	r3, [pc, #172]	; (13670 <tls_rpc_ip_event_handler+0x104>)
   135c2:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
   135c6:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   135ca:	2b02      	cmp	r3, #2
   135cc:	d106      	bne.n	135dc <tls_rpc_ip_event_handler+0x70>
   135ce:	4630      	mov	r0, r6
   135d0:	4621      	mov	r1, r4
   135d2:	f7ff fb93 	bl	12cfc <secure_client_socket>
   135d6:	b108      	cbz	r0, 135dc <tls_rpc_ip_event_handler+0x70>
   135d8:	2873      	cmp	r0, #115	; 0x73
   135da:	d142      	bne.n	13662 <tls_rpc_ip_event_handler+0xf6>
   135dc:	2000      	movs	r0, #0
   135de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   135e0:	2c00      	cmp	r4, #0
   135e2:	d0fb      	beq.n	135dc <tls_rpc_ip_event_handler+0x70>
   135e4:	6823      	ldr	r3, [r4, #0]
   135e6:	b29b      	uxth	r3, r3
   135e8:	2b0b      	cmp	r3, #11
   135ea:	d1f7      	bne.n	135dc <tls_rpc_ip_event_handler+0x70>
   135ec:	6915      	ldr	r5, [r2, #16]
   135ee:	2d00      	cmp	r5, #0
   135f0:	d134      	bne.n	1365c <tls_rpc_ip_event_handler+0xf0>
   135f2:	6823      	ldr	r3, [r4, #0]
   135f4:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   135f8:	6023      	str	r3, [r4, #0]
   135fa:	6823      	ldr	r3, [r4, #0]
   135fc:	00db      	lsls	r3, r3, #3
   135fe:	d5ed      	bpl.n	135dc <tls_rpc_ip_event_handler+0x70>
   13600:	4f1c      	ldr	r7, [pc, #112]	; (13674 <tls_rpc_ip_event_handler+0x108>)
   13602:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
   13606:	b130      	cbz	r0, 13616 <tls_rpc_ip_event_handler+0xaa>
   13608:	f005 fa16 	bl	18a38 <nrf_free>
   1360c:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   13610:	f847 5036 	str.w	r5, [r7, r6, lsl #3]
   13614:	605d      	str	r5, [r3, #4]
   13616:	6823      	ldr	r3, [r4, #0]
   13618:	2000      	movs	r0, #0
   1361a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   1361e:	6023      	str	r3, [r4, #0]
   13620:	6823      	ldr	r3, [r4, #0]
   13622:	0c1b      	lsrs	r3, r3, #16
   13624:	041b      	lsls	r3, r3, #16
   13626:	f043 030c 	orr.w	r3, r3, #12
   1362a:	6023      	str	r3, [r4, #0]
   1362c:	6823      	ldr	r3, [r4, #0]
   1362e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   13632:	6023      	str	r3, [r4, #0]
   13634:	6823      	ldr	r3, [r4, #0]
   13636:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1363a:	6023      	str	r3, [r4, #0]
   1363c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1363e:	2900      	cmp	r1, #0
   13640:	d0cc      	beq.n	135dc <tls_rpc_ip_event_handler+0x70>
   13642:	680b      	ldr	r3, [r1, #0]
   13644:	b29b      	uxth	r3, r3
   13646:	2b0a      	cmp	r3, #10
   13648:	d1c8      	bne.n	135dc <tls_rpc_ip_event_handler+0x70>
   1364a:	6950      	ldr	r0, [r2, #20]
   1364c:	b938      	cbnz	r0, 1365e <tls_rpc_ip_event_handler+0xf2>
   1364e:	680b      	ldr	r3, [r1, #0]
   13650:	0c1b      	lsrs	r3, r3, #16
   13652:	041b      	lsls	r3, r3, #16
   13654:	f043 030b 	orr.w	r3, r3, #11
   13658:	600b      	str	r3, [r1, #0]
   1365a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1365c:	4628      	mov	r0, r5
   1365e:	f000 f85d 	bl	1371c <rpc_error_to_nrf_bsd_error>
   13662:	6060      	str	r0, [r4, #4]
   13664:	6823      	ldr	r3, [r4, #0]
   13666:	2000      	movs	r0, #0
   13668:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   1366c:	6023      	str	r3, [r4, #0]
   1366e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13670:	200205e0 	.word	0x200205e0
   13674:	20020724 	.word	0x20020724

00013678 <ip_client_event_handler>:
   13678:	f850 1b08 	ldr.w	r1, [r0], #8
   1367c:	0c09      	lsrs	r1, r1, #16
   1367e:	f001 b971 	b.w	14964 <rpc_ip_event_handler>
   13682:	bf00      	nop

00013684 <rpc_ip_client_init>:
   13684:	4801      	ldr	r0, [pc, #4]	; (1368c <rpc_ip_client_init+0x8>)
   13686:	f001 bc5f 	b.w	14f48 <rpc_client_register>
   1368a:	bf00      	nop
   1368c:	0001ddf0 	.word	0x0001ddf0

00013690 <rpc_ip_client_request_alloc>:
   13690:	2300      	movs	r3, #0
   13692:	b510      	push	{r4, lr}
   13694:	b082      	sub	sp, #8
   13696:	9301      	str	r3, [sp, #4]
   13698:	b158      	cbz	r0, 136b2 <rpc_ip_client_request_alloc+0x22>
   1369a:	4604      	mov	r4, r0
   1369c:	aa01      	add	r2, sp, #4
   1369e:	2004      	movs	r0, #4
   136a0:	f001 fccc 	bl	1503c <rpc_message_alloc>
   136a4:	b918      	cbnz	r0, 136ae <rpc_ip_client_request_alloc+0x1e>
   136a6:	9b01      	ldr	r3, [sp, #4]
   136a8:	b10b      	cbz	r3, 136ae <rpc_ip_client_request_alloc+0x1e>
   136aa:	3308      	adds	r3, #8
   136ac:	6023      	str	r3, [r4, #0]
   136ae:	b002      	add	sp, #8
   136b0:	bd10      	pop	{r4, pc}
   136b2:	2007      	movs	r0, #7
   136b4:	b002      	add	sp, #8
   136b6:	bd10      	pop	{r4, pc}

000136b8 <rpc_ip_client_request_send>:
   136b8:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   136bc:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   136c0:	d10b      	bne.n	136da <rpc_ip_client_request_send+0x22>
   136c2:	b160      	cbz	r0, 136de <rpc_ip_client_request_send+0x26>
   136c4:	4603      	mov	r3, r0
   136c6:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   136ca:	2004      	movs	r0, #4
   136cc:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   136d0:	f843 1d08 	str.w	r1, [r3, #-8]!
   136d4:	4619      	mov	r1, r3
   136d6:	f001 bca1 	b.w	1501c <rpc_message_send>
   136da:	200f      	movs	r0, #15
   136dc:	4770      	bx	lr
   136de:	2007      	movs	r0, #7
   136e0:	4770      	bx	lr
   136e2:	bf00      	nop

000136e4 <rpc_ip_client_message_free>:
   136e4:	b120      	cbz	r0, 136f0 <rpc_ip_client_message_free+0xc>
   136e6:	f1a0 0108 	sub.w	r1, r0, #8
   136ea:	2004      	movs	r0, #4
   136ec:	f001 bcd2 	b.w	15094 <rpc_message_free>
   136f0:	2007      	movs	r0, #7
   136f2:	4770      	bx	lr

000136f4 <rpc_ip_client_data_free>:
   136f4:	b118      	cbz	r0, 136fe <rpc_ip_client_data_free+0xa>
   136f6:	4601      	mov	r1, r0
   136f8:	2004      	movs	r0, #4
   136fa:	f001 bcd7 	b.w	150ac <rpc_message_data_free>
   136fe:	2007      	movs	r0, #7
   13700:	4770      	bx	lr
   13702:	bf00      	nop

00013704 <ip_recvd_packet_free_cb>:
   13704:	b510      	push	{r4, lr}
   13706:	4604      	mov	r4, r0
   13708:	6800      	ldr	r0, [r0, #0]
   1370a:	f7ff fff3 	bl	136f4 <rpc_ip_client_data_free>
   1370e:	68a0      	ldr	r0, [r4, #8]
   13710:	b118      	cbz	r0, 1371a <ip_recvd_packet_free_cb+0x16>
   13712:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   13716:	f005 b98f 	b.w	18a38 <nrf_free>
   1371a:	bd10      	pop	{r4, pc}

0001371c <rpc_error_to_nrf_bsd_error>:
   1371c:	2810      	cmp	r0, #16
   1371e:	bf9a      	itte	ls
   13720:	4b02      	ldrls	r3, [pc, #8]	; (1372c <rpc_error_to_nrf_bsd_error+0x10>)
   13722:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   13726:	202d      	movhi	r0, #45	; 0x2d
   13728:	4770      	bx	lr
   1372a:	bf00      	nop
   1372c:	0001de00 	.word	0x0001de00

00013730 <ip_interface_request_create>:
   13730:	b570      	push	{r4, r5, r6, lr}
   13732:	2500      	movs	r5, #0
   13734:	b082      	sub	sp, #8
   13736:	ac02      	add	r4, sp, #8
   13738:	f844 5d04 	str.w	r5, [r4, #-4]!
   1373c:	4606      	mov	r6, r0
   1373e:	460d      	mov	r5, r1
   13740:	4620      	mov	r0, r4
   13742:	4619      	mov	r1, r3
   13744:	4614      	mov	r4, r2
   13746:	f7ff ffa3 	bl	13690 <rpc_ip_client_request_alloc>
   1374a:	b960      	cbnz	r0, 13766 <ip_interface_request_create+0x36>
   1374c:	9b01      	ldr	r3, [sp, #4]
   1374e:	2208      	movs	r2, #8
   13750:	7258      	strb	r0, [r3, #9]
   13752:	7298      	strb	r0, [r3, #10]
   13754:	72d8      	strb	r0, [r3, #11]
   13756:	4618      	mov	r0, r3
   13758:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   1375c:	60dc      	str	r4, [r3, #12]
   1375e:	611d      	str	r5, [r3, #16]
   13760:	721a      	strb	r2, [r3, #8]
   13762:	b002      	add	sp, #8
   13764:	bd70      	pop	{r4, r5, r6, pc}
   13766:	9b01      	ldr	r3, [sp, #4]
   13768:	4618      	mov	r0, r3
   1376a:	b002      	add	sp, #8
   1376c:	bd70      	pop	{r4, r5, r6, pc}
   1376e:	bf00      	nop

00013770 <ip_interface_request_send>:
   13770:	b570      	push	{r4, r5, r6, lr}
   13772:	460c      	mov	r4, r1
   13774:	4605      	mov	r5, r0
   13776:	4611      	mov	r1, r2
   13778:	4620      	mov	r0, r4
   1377a:	461e      	mov	r6, r3
   1377c:	f7ff ff9c 	bl	136b8 <rpc_ip_client_request_send>
   13780:	b900      	cbnz	r0, 13784 <ip_interface_request_send+0x14>
   13782:	bd70      	pop	{r4, r5, r6, pc}
   13784:	6820      	ldr	r0, [r4, #0]
   13786:	b108      	cbz	r0, 1378c <ip_interface_request_send+0x1c>
   13788:	f7ff ffb4 	bl	136f4 <rpc_ip_client_data_free>
   1378c:	4620      	mov	r0, r4
   1378e:	f7ff ffa9 	bl	136e4 <rpc_ip_client_message_free>
   13792:	602e      	str	r6, [r5, #0]
   13794:	2023      	movs	r0, #35	; 0x23
   13796:	bd70      	pop	{r4, r5, r6, pc}

00013798 <ip_interface_wait>:
   13798:	b538      	push	{r3, r4, r5, lr}
   1379a:	4605      	mov	r5, r0
   1379c:	f005 fd26 	bl	191ec <interface_socket_wait>
   137a0:	4604      	mov	r4, r0
   137a2:	b108      	cbz	r0, 137a8 <ip_interface_wait+0x10>
   137a4:	4620      	mov	r0, r4
   137a6:	bd38      	pop	{r3, r4, r5, pc}
   137a8:	4628      	mov	r0, r5
   137aa:	f005 fd9f 	bl	192ec <interface_socket_from_handle_get>
   137ae:	2800      	cmp	r0, #0
   137b0:	d0f8      	beq.n	137a4 <ip_interface_wait+0xc>
   137b2:	6844      	ldr	r4, [r0, #4]
   137b4:	2c00      	cmp	r4, #0
   137b6:	d0f5      	beq.n	137a4 <ip_interface_wait+0xc>
   137b8:	2300      	movs	r3, #0
   137ba:	6043      	str	r3, [r0, #4]
   137bc:	4620      	mov	r0, r4
   137be:	bd38      	pop	{r3, r4, r5, pc}

000137c0 <ip_interface_init>:
   137c0:	b538      	push	{r3, r4, r5, lr}
   137c2:	2300      	movs	r3, #0
   137c4:	4d09      	ldr	r5, [pc, #36]	; (137ec <ip_interface_init+0x2c>)
   137c6:	4c0a      	ldr	r4, [pc, #40]	; (137f0 <ip_interface_init+0x30>)
   137c8:	4619      	mov	r1, r3
   137ca:	2224      	movs	r2, #36	; 0x24
   137cc:	4809      	ldr	r0, [pc, #36]	; (137f4 <ip_interface_init+0x34>)
   137ce:	602b      	str	r3, [r5, #0]
   137d0:	6023      	str	r3, [r4, #0]
   137d2:	f008 fc32 	bl	1c03a <memset>
   137d6:	f7ff ff55 	bl	13684 <rpc_ip_client_init>
   137da:	b918      	cbnz	r0, 137e4 <ip_interface_init+0x24>
   137dc:	2201      	movs	r2, #1
   137de:	4b06      	ldr	r3, [pc, #24]	; (137f8 <ip_interface_init+0x38>)
   137e0:	701a      	strb	r2, [r3, #0]
   137e2:	bd38      	pop	{r3, r4, r5, pc}
   137e4:	f04f 30ff 	mov.w	r0, #4294967295
   137e8:	bd38      	pop	{r3, r4, r5, pc}
   137ea:	bf00      	nop
   137ec:	20020774 	.word	0x20020774
   137f0:	20020770 	.word	0x20020770
   137f4:	20020778 	.word	0x20020778
   137f8:	2002366c 	.word	0x2002366c

000137fc <ip_interface_open>:
   137fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13800:	2500      	movs	r5, #0
   13802:	f04f 37ff 	mov.w	r7, #4294967295
   13806:	4c5e      	ldr	r4, [pc, #376]	; (13980 <ip_interface_open+0x184>)
   13808:	4606      	mov	r6, r0
   1380a:	7820      	ldrb	r0, [r4, #0]
   1380c:	b084      	sub	sp, #16
   1380e:	e9cd 5701 	strd	r5, r7, [sp, #4]
   13812:	2800      	cmp	r0, #0
   13814:	f000 80b0 	beq.w	13978 <ip_interface_open+0x17c>
   13818:	4690      	mov	r8, r2
   1381a:	f026 0208 	bic.w	r2, r6, #8
   1381e:	2a02      	cmp	r2, #2
   13820:	460c      	mov	r4, r1
   13822:	d002      	beq.n	1382a <ip_interface_open+0x2e>
   13824:	2e05      	cmp	r6, #5
   13826:	f040 808d 	bne.w	13944 <ip_interface_open+0x148>
   1382a:	1e63      	subs	r3, r4, #1
   1382c:	2b02      	cmp	r3, #2
   1382e:	f200 809d 	bhi.w	1396c <ip_interface_open+0x170>
   13832:	f1b8 0f00 	cmp.w	r8, #0
   13836:	d159      	bne.n	138ec <ip_interface_open+0xf0>
   13838:	2c01      	cmp	r4, #1
   1383a:	d06f      	beq.n	1391c <ip_interface_open+0x120>
   1383c:	2c03      	cmp	r4, #3
   1383e:	bf18      	it	ne
   13840:	f04f 0802 	movne.w	r8, #2
   13844:	4a4f      	ldr	r2, [pc, #316]	; (13984 <ip_interface_open+0x188>)
   13846:	4621      	mov	r1, r4
   13848:	a801      	add	r0, sp, #4
   1384a:	f005 fc1d 	bl	19088 <interface_socket_allocate>
   1384e:	9b01      	ldr	r3, [sp, #4]
   13850:	4607      	mov	r7, r0
   13852:	2b00      	cmp	r3, #0
   13854:	d060      	beq.n	13918 <ip_interface_open+0x11c>
   13856:	2100      	movs	r1, #0
   13858:	a804      	add	r0, sp, #16
   1385a:	f840 1d04 	str.w	r1, [r0, #-4]!
   1385e:	e9c3 6403 	strd	r6, r4, [r3, #12]
   13862:	f8c3 8014 	str.w	r8, [r3, #20]
   13866:	f7ff ff13 	bl	13690 <rpc_ip_client_request_alloc>
   1386a:	2800      	cmp	r0, #0
   1386c:	d151      	bne.n	13912 <ip_interface_open+0x116>
   1386e:	f247 0201 	movw	r2, #28673	; 0x7001
   13872:	f04f 33ff 	mov.w	r3, #4294967295
   13876:	2108      	movs	r1, #8
   13878:	9d03      	ldr	r5, [sp, #12]
   1387a:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   1387e:	60ea      	str	r2, [r5, #12]
   13880:	7268      	strb	r0, [r5, #9]
   13882:	72a8      	strb	r0, [r5, #10]
   13884:	72e8      	strb	r0, [r5, #11]
   13886:	7229      	strb	r1, [r5, #8]
   13888:	742b      	strb	r3, [r5, #16]
   1388a:	746b      	strb	r3, [r5, #17]
   1388c:	74ab      	strb	r3, [r5, #18]
   1388e:	74eb      	strb	r3, [r5, #19]
   13890:	68ab      	ldr	r3, [r5, #8]
   13892:	2e05      	cmp	r6, #5
   13894:	f103 030c 	add.w	r3, r3, #12
   13898:	60ab      	str	r3, [r5, #8]
   1389a:	d003      	beq.n	138a4 <ip_interface_open+0xa8>
   1389c:	2e0a      	cmp	r6, #10
   1389e:	bf14      	ite	ne
   138a0:	2601      	movne	r6, #1
   138a2:	2602      	moveq	r6, #2
   138a4:	616e      	str	r6, [r5, #20]
   138a6:	f8c5 801c 	str.w	r8, [r5, #28]
   138aa:	61ac      	str	r4, [r5, #24]
   138ac:	f247 0101 	movw	r1, #28673	; 0x7001
   138b0:	4628      	mov	r0, r5
   138b2:	f8dd 8004 	ldr.w	r8, [sp, #4]
   138b6:	f7ff feff 	bl	136b8 <rpc_ip_client_request_send>
   138ba:	4606      	mov	r6, r0
   138bc:	b380      	cbz	r0, 13920 <ip_interface_open+0x124>
   138be:	6828      	ldr	r0, [r5, #0]
   138c0:	b108      	cbz	r0, 138c6 <ip_interface_open+0xca>
   138c2:	f7ff ff17 	bl	136f4 <rpc_ip_client_data_free>
   138c6:	4628      	mov	r0, r5
   138c8:	f7ff ff0c 	bl	136e4 <rpc_ip_client_message_free>
   138cc:	2301      	movs	r3, #1
   138ce:	2523      	movs	r5, #35	; 0x23
   138d0:	f8c8 3000 	str.w	r3, [r8]
   138d4:	4638      	mov	r0, r7
   138d6:	f005 fc3b 	bl	19150 <interface_socket_free>
   138da:	4628      	mov	r0, r5
   138dc:	f7fc fba6 	bl	1002c <bsd_os_errno_set>
   138e0:	f04f 37ff 	mov.w	r7, #4294967295
   138e4:	4638      	mov	r0, r7
   138e6:	b004      	add	sp, #16
   138e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   138ec:	2c01      	cmp	r4, #1
   138ee:	d00a      	beq.n	13906 <ip_interface_open+0x10a>
   138f0:	2c02      	cmp	r4, #2
   138f2:	d10b      	bne.n	1390c <ip_interface_open+0x110>
   138f4:	f1b8 0f02 	cmp.w	r8, #2
   138f8:	d0a4      	beq.n	13844 <ip_interface_open+0x48>
   138fa:	2029      	movs	r0, #41	; 0x29
   138fc:	f7fc fb96 	bl	1002c <bsd_os_errno_set>
   13900:	f04f 37ff 	mov.w	r7, #4294967295
   13904:	e7ee      	b.n	138e4 <ip_interface_open+0xe8>
   13906:	f1b8 0f01 	cmp.w	r8, #1
   1390a:	d1f6      	bne.n	138fa <ip_interface_open+0xfe>
   1390c:	f04f 0802 	mov.w	r8, #2
   13910:	e798      	b.n	13844 <ip_interface_open+0x48>
   13912:	9d03      	ldr	r5, [sp, #12]
   13914:	2d00      	cmp	r5, #0
   13916:	d1bb      	bne.n	13890 <ip_interface_open+0x94>
   13918:	2569      	movs	r5, #105	; 0x69
   1391a:	e7db      	b.n	138d4 <ip_interface_open+0xd8>
   1391c:	46a0      	mov	r8, r4
   1391e:	e791      	b.n	13844 <ip_interface_open+0x48>
   13920:	ab02      	add	r3, sp, #8
   13922:	f64f 72ff 	movw	r2, #65535	; 0xffff
   13926:	2102      	movs	r1, #2
   13928:	4638      	mov	r0, r7
   1392a:	f005 fc5f 	bl	191ec <interface_socket_wait>
   1392e:	4605      	mov	r5, r0
   13930:	2800      	cmp	r0, #0
   13932:	d1cf      	bne.n	138d4 <ip_interface_open+0xd8>
   13934:	4638      	mov	r0, r7
   13936:	f005 fcd9 	bl	192ec <interface_socket_from_handle_get>
   1393a:	b138      	cbz	r0, 1394c <ip_interface_open+0x150>
   1393c:	6845      	ldr	r5, [r0, #4]
   1393e:	b12d      	cbz	r5, 1394c <ip_interface_open+0x150>
   13940:	6046      	str	r6, [r0, #4]
   13942:	e7c7      	b.n	138d4 <ip_interface_open+0xd8>
   13944:	202f      	movs	r0, #47	; 0x2f
   13946:	f7fc fb71 	bl	1002c <bsd_os_errno_set>
   1394a:	e7cb      	b.n	138e4 <ip_interface_open+0xe8>
   1394c:	3c02      	subs	r4, #2
   1394e:	2c01      	cmp	r4, #1
   13950:	d8c8      	bhi.n	138e4 <ip_interface_open+0xe8>
   13952:	4638      	mov	r0, r7
   13954:	9b01      	ldr	r3, [sp, #4]
   13956:	681a      	ldr	r2, [r3, #0]
   13958:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   1395c:	601a      	str	r2, [r3, #0]
   1395e:	681a      	ldr	r2, [r3, #0]
   13960:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   13964:	601a      	str	r2, [r3, #0]
   13966:	b004      	add	sp, #16
   13968:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1396c:	2016      	movs	r0, #22
   1396e:	f7fc fb5d 	bl	1002c <bsd_os_errno_set>
   13972:	f04f 37ff 	mov.w	r7, #4294967295
   13976:	e7b5      	b.n	138e4 <ip_interface_open+0xe8>
   13978:	2005      	movs	r0, #5
   1397a:	f7fc fb57 	bl	1002c <bsd_os_errno_set>
   1397e:	e7b1      	b.n	138e4 <ip_interface_open+0xe8>
   13980:	2002366c 	.word	0x2002366c
   13984:	00013705 	.word	0x00013705

00013988 <ip_interface_close>:
   13988:	f04f 33ff 	mov.w	r3, #4294967295
   1398c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   13990:	b082      	sub	sp, #8
   13992:	4606      	mov	r6, r0
   13994:	9300      	str	r3, [sp, #0]
   13996:	f005 fca9 	bl	192ec <interface_socket_from_handle_get>
   1399a:	2800      	cmp	r0, #0
   1399c:	d062      	beq.n	13a64 <ip_interface_close+0xdc>
   1399e:	4604      	mov	r4, r0
   139a0:	2100      	movs	r1, #0
   139a2:	a802      	add	r0, sp, #8
   139a4:	6827      	ldr	r7, [r4, #0]
   139a6:	f840 1d04 	str.w	r1, [r0, #-4]!
   139aa:	f8d4 8018 	ldr.w	r8, [r4, #24]
   139ae:	f7ff fe6f 	bl	13690 <rpc_ip_client_request_alloc>
   139b2:	2800      	cmp	r0, #0
   139b4:	d139      	bne.n	13a2a <ip_interface_close+0xa2>
   139b6:	f247 0309 	movw	r3, #28681	; 0x7009
   139ba:	2208      	movs	r2, #8
   139bc:	9d01      	ldr	r5, [sp, #4]
   139be:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   139c2:	60eb      	str	r3, [r5, #12]
   139c4:	f8c5 8010 	str.w	r8, [r5, #16]
   139c8:	7268      	strb	r0, [r5, #9]
   139ca:	72a8      	strb	r0, [r5, #10]
   139cc:	72e8      	strb	r0, [r5, #11]
   139ce:	722a      	strb	r2, [r5, #8]
   139d0:	6823      	ldr	r3, [r4, #0]
   139d2:	f247 0109 	movw	r1, #28681	; 0x7009
   139d6:	0c1b      	lsrs	r3, r3, #16
   139d8:	041b      	lsls	r3, r3, #16
   139da:	f043 030d 	orr.w	r3, r3, #13
   139de:	6023      	str	r3, [r4, #0]
   139e0:	6823      	ldr	r3, [r4, #0]
   139e2:	4628      	mov	r0, r5
   139e4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   139e8:	6023      	str	r3, [r4, #0]
   139ea:	6823      	ldr	r3, [r4, #0]
   139ec:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   139f0:	6023      	str	r3, [r4, #0]
   139f2:	f7ff fe61 	bl	136b8 <rpc_ip_client_request_send>
   139f6:	bb38      	cbnz	r0, 13a48 <ip_interface_close+0xc0>
   139f8:	466b      	mov	r3, sp
   139fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
   139fe:	210e      	movs	r1, #14
   13a00:	4630      	mov	r0, r6
   13a02:	f005 fbf3 	bl	191ec <interface_socket_wait>
   13a06:	4604      	mov	r4, r0
   13a08:	b1a0      	cbz	r0, 13a34 <ip_interface_close+0xac>
   13a0a:	4c17      	ldr	r4, [pc, #92]	; (13a68 <ip_interface_close+0xe0>)
   13a0c:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
   13a10:	b120      	cbz	r0, 13a1c <ip_interface_close+0x94>
   13a12:	f7ff fe67 	bl	136e4 <rpc_ip_client_message_free>
   13a16:	2300      	movs	r3, #0
   13a18:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   13a1c:	4630      	mov	r0, r6
   13a1e:	f005 fb97 	bl	19150 <interface_socket_free>
   13a22:	2000      	movs	r0, #0
   13a24:	b002      	add	sp, #8
   13a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   13a2a:	9d01      	ldr	r5, [sp, #4]
   13a2c:	200c      	movs	r0, #12
   13a2e:	2d00      	cmp	r5, #0
   13a30:	d1ce      	bne.n	139d0 <ip_interface_close+0x48>
   13a32:	e012      	b.n	13a5a <ip_interface_close+0xd2>
   13a34:	4630      	mov	r0, r6
   13a36:	f005 fc59 	bl	192ec <interface_socket_from_handle_get>
   13a3a:	2800      	cmp	r0, #0
   13a3c:	d0e5      	beq.n	13a0a <ip_interface_close+0x82>
   13a3e:	6843      	ldr	r3, [r0, #4]
   13a40:	2b00      	cmp	r3, #0
   13a42:	d0e2      	beq.n	13a0a <ip_interface_close+0x82>
   13a44:	6044      	str	r4, [r0, #4]
   13a46:	e7e0      	b.n	13a0a <ip_interface_close+0x82>
   13a48:	6828      	ldr	r0, [r5, #0]
   13a4a:	b108      	cbz	r0, 13a50 <ip_interface_close+0xc8>
   13a4c:	f7ff fe52 	bl	136f4 <rpc_ip_client_data_free>
   13a50:	4628      	mov	r0, r5
   13a52:	f7ff fe47 	bl	136e4 <rpc_ip_client_message_free>
   13a56:	2023      	movs	r0, #35	; 0x23
   13a58:	6027      	str	r7, [r4, #0]
   13a5a:	f7fc fae7 	bl	1002c <bsd_os_errno_set>
   13a5e:	f04f 30ff 	mov.w	r0, #4294967295
   13a62:	e7df      	b.n	13a24 <ip_interface_close+0x9c>
   13a64:	2009      	movs	r0, #9
   13a66:	e7f8      	b.n	13a5a <ip_interface_close+0xd2>
   13a68:	20020778 	.word	0x20020778

00013a6c <ip_interface_sendto>:
   13a6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13a70:	2400      	movs	r4, #0
   13a72:	b089      	sub	sp, #36	; 0x24
   13a74:	9102      	str	r1, [sp, #8]
   13a76:	4615      	mov	r5, r2
   13a78:	4699      	mov	r9, r3
   13a7a:	9406      	str	r4, [sp, #24]
   13a7c:	4607      	mov	r7, r0
   13a7e:	9e12      	ldr	r6, [sp, #72]	; 0x48
   13a80:	f005 fc34 	bl	192ec <interface_socket_from_handle_get>
   13a84:	2800      	cmp	r0, #0
   13a86:	f000 814c 	beq.w	13d22 <ip_interface_sendto+0x2b6>
   13a8a:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   13a8e:	f300 8139 	bgt.w	13d04 <ip_interface_sendto+0x298>
   13a92:	6903      	ldr	r3, [r0, #16]
   13a94:	4604      	mov	r4, r0
   13a96:	2b01      	cmp	r3, #1
   13a98:	f000 80ea 	beq.w	13c70 <ip_interface_sendto+0x204>
   13a9c:	6822      	ldr	r2, [r4, #0]
   13a9e:	0391      	lsls	r1, r2, #14
   13aa0:	d56a      	bpl.n	13b78 <ip_interface_sendto+0x10c>
   13aa2:	f1b9 0f00 	cmp.w	r9, #0
   13aa6:	f000 80f3 	beq.w	13c90 <ip_interface_sendto+0x224>
   13aaa:	f019 0f02 	tst.w	r9, #2
   13aae:	f000 8133 	beq.w	13d18 <ip_interface_sendto+0x2ac>
   13ab2:	2300      	movs	r3, #0
   13ab4:	9303      	str	r3, [sp, #12]
   13ab6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   13ab8:	f247 0806 	movw	r8, #28678	; 0x7006
   13abc:	2b00      	cmp	r3, #0
   13abe:	bf08      	it	eq
   13ac0:	f04f 33ff 	moveq.w	r3, #4294967295
   13ac4:	f04f 0b0c 	mov.w	fp, #12
   13ac8:	4a9a      	ldr	r2, [pc, #616]	; (13d34 <ip_interface_sendto+0x2c8>)
   13aca:	9307      	str	r3, [sp, #28]
   13acc:	043b      	lsls	r3, r7, #16
   13ace:	9200      	str	r2, [sp, #0]
   13ad0:	9304      	str	r3, [sp, #16]
   13ad2:	4629      	mov	r1, r5
   13ad4:	a806      	add	r0, sp, #24
   13ad6:	f7ff fddb 	bl	13690 <rpc_ip_client_request_alloc>
   13ada:	2804      	cmp	r0, #4
   13adc:	f000 8098 	beq.w	13c10 <ip_interface_sendto+0x1a4>
   13ae0:	2800      	cmp	r0, #0
   13ae2:	f040 8123 	bne.w	13d2c <ip_interface_sendto+0x2c0>
   13ae6:	9b06      	ldr	r3, [sp, #24]
   13ae8:	f883 b008 	strb.w	fp, [r3, #8]
   13aec:	7258      	strb	r0, [r3, #9]
   13aee:	7298      	strb	r0, [r3, #10]
   13af0:	72d8      	strb	r0, [r3, #11]
   13af2:	2e00      	cmp	r6, #0
   13af4:	d053      	beq.n	13b9e <ip_interface_sendto+0x132>
   13af6:	68e2      	ldr	r2, [r4, #12]
   13af8:	6871      	ldr	r1, [r6, #4]
   13afa:	428a      	cmp	r2, r1
   13afc:	f040 809a 	bne.w	13c34 <ip_interface_sendto+0x1c8>
   13b00:	7831      	ldrb	r1, [r6, #0]
   13b02:	9813      	ldr	r0, [sp, #76]	; 0x4c
   13b04:	4288      	cmp	r0, r1
   13b06:	d10a      	bne.n	13b1e <ip_interface_sendto+0xb2>
   13b08:	2a02      	cmp	r2, #2
   13b0a:	f103 001c 	add.w	r0, r3, #28
   13b0e:	f000 80e7 	beq.w	13ce0 <ip_interface_sendto+0x274>
   13b12:	2a0a      	cmp	r2, #10
   13b14:	d103      	bne.n	13b1e <ip_interface_sendto+0xb2>
   13b16:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   13b18:	2a24      	cmp	r2, #36	; 0x24
   13b1a:	f000 80ce 	beq.w	13cba <ip_interface_sendto+0x24e>
   13b1e:	f04f 0a16 	mov.w	sl, #22
   13b22:	6818      	ldr	r0, [r3, #0]
   13b24:	b110      	cbz	r0, 13b2c <ip_interface_sendto+0xc0>
   13b26:	f7ff fde5 	bl	136f4 <rpc_ip_client_data_free>
   13b2a:	9b06      	ldr	r3, [sp, #24]
   13b2c:	4618      	mov	r0, r3
   13b2e:	f7ff fdd9 	bl	136e4 <rpc_ip_client_message_free>
   13b32:	6823      	ldr	r3, [r4, #0]
   13b34:	0318      	lsls	r0, r3, #12
   13b36:	d40b      	bmi.n	13b50 <ip_interface_sendto+0xe4>
   13b38:	6823      	ldr	r3, [r4, #0]
   13b3a:	b29b      	uxth	r3, r3
   13b3c:	2b0d      	cmp	r3, #13
   13b3e:	d007      	beq.n	13b50 <ip_interface_sendto+0xe4>
   13b40:	6823      	ldr	r3, [r4, #0]
   13b42:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   13b46:	6023      	str	r3, [r4, #0]
   13b48:	6823      	ldr	r3, [r4, #0]
   13b4a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   13b4e:	6023      	str	r3, [r4, #0]
   13b50:	f1ba 0f00 	cmp.w	sl, #0
   13b54:	f040 8093 	bne.w	13c7e <ip_interface_sendto+0x212>
   13b58:	6823      	ldr	r3, [r4, #0]
   13b5a:	0119      	lsls	r1, r3, #4
   13b5c:	d56d      	bpl.n	13c3a <ip_interface_sendto+0x1ce>
   13b5e:	6823      	ldr	r3, [r4, #0]
   13b60:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   13b64:	6023      	str	r3, [r4, #0]
   13b66:	9b00      	ldr	r3, [sp, #0]
   13b68:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   13b6c:	2800      	cmp	r0, #0
   13b6e:	d168      	bne.n	13c42 <ip_interface_sendto+0x1d6>
   13b70:	4628      	mov	r0, r5
   13b72:	b009      	add	sp, #36	; 0x24
   13b74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13b78:	6822      	ldr	r2, [r4, #0]
   13b7a:	0092      	lsls	r2, r2, #2
   13b7c:	d406      	bmi.n	13b8c <ip_interface_sendto+0x120>
   13b7e:	2b01      	cmp	r3, #1
   13b80:	f000 8095 	beq.w	13cae <ip_interface_sendto+0x242>
   13b84:	6823      	ldr	r3, [r4, #0]
   13b86:	031b      	lsls	r3, r3, #12
   13b88:	f140 80b7 	bpl.w	13cfa <ip_interface_sendto+0x28e>
   13b8c:	6823      	ldr	r3, [r4, #0]
   13b8e:	031e      	lsls	r6, r3, #12
   13b90:	f140 80bd 	bpl.w	13d0e <ip_interface_sendto+0x2a2>
   13b94:	4b67      	ldr	r3, [pc, #412]	; (13d34 <ip_interface_sendto+0x2c8>)
   13b96:	f8d4 a008 	ldr.w	sl, [r4, #8]
   13b9a:	9300      	str	r3, [sp, #0]
   13b9c:	e7d8      	b.n	13b50 <ip_interface_sendto+0xe4>
   13b9e:	4642      	mov	r2, r8
   13ba0:	f8c3 9014 	str.w	r9, [r3, #20]
   13ba4:	69a1      	ldr	r1, [r4, #24]
   13ba6:	9804      	ldr	r0, [sp, #16]
   13ba8:	6119      	str	r1, [r3, #16]
   13baa:	9902      	ldr	r1, [sp, #8]
   13bac:	4302      	orrs	r2, r0
   13bae:	60da      	str	r2, [r3, #12]
   13bb0:	605d      	str	r5, [r3, #4]
   13bb2:	b119      	cbz	r1, 13bbc <ip_interface_sendto+0x150>
   13bb4:	6818      	ldr	r0, [r3, #0]
   13bb6:	462a      	mov	r2, r5
   13bb8:	f008 fa14 	bl	1bfe4 <memcpy>
   13bbc:	6823      	ldr	r3, [r4, #0]
   13bbe:	4641      	mov	r1, r8
   13bc0:	9305      	str	r3, [sp, #20]
   13bc2:	6823      	ldr	r3, [r4, #0]
   13bc4:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   13bc8:	6023      	str	r3, [r4, #0]
   13bca:	6823      	ldr	r3, [r4, #0]
   13bcc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   13bd0:	6023      	str	r3, [r4, #0]
   13bd2:	9b06      	ldr	r3, [sp, #24]
   13bd4:	4618      	mov	r0, r3
   13bd6:	9301      	str	r3, [sp, #4]
   13bd8:	f7ff fd6e 	bl	136b8 <rpc_ip_client_request_send>
   13bdc:	9b01      	ldr	r3, [sp, #4]
   13bde:	4682      	mov	sl, r0
   13be0:	2800      	cmp	r0, #0
   13be2:	d138      	bne.n	13c56 <ip_interface_sendto+0x1ea>
   13be4:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   13be8:	ab07      	add	r3, sp, #28
   13bea:	4611      	mov	r1, r2
   13bec:	4638      	mov	r0, r7
   13bee:	f005 fafd 	bl	191ec <interface_socket_wait>
   13bf2:	4603      	mov	r3, r0
   13bf4:	b198      	cbz	r0, 13c1e <ip_interface_sendto+0x1b2>
   13bf6:	6822      	ldr	r2, [r4, #0]
   13bf8:	0312      	lsls	r2, r2, #12
   13bfa:	d455      	bmi.n	13ca8 <ip_interface_sendto+0x23c>
   13bfc:	2b3c      	cmp	r3, #60	; 0x3c
   13bfe:	d017      	beq.n	13c30 <ip_interface_sendto+0x1c4>
   13c00:	2b0c      	cmp	r3, #12
   13c02:	d115      	bne.n	13c30 <ip_interface_sendto+0x1c4>
   13c04:	9b00      	ldr	r3, [sp, #0]
   13c06:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   13c0a:	b108      	cbz	r0, 13c10 <ip_interface_sendto+0x1a4>
   13c0c:	f7ff fd6a 	bl	136e4 <rpc_ip_client_message_free>
   13c10:	9b03      	ldr	r3, [sp, #12]
   13c12:	2b00      	cmp	r3, #0
   13c14:	f47f af5d 	bne.w	13ad2 <ip_interface_sendto+0x66>
   13c18:	f04f 0a23 	mov.w	sl, #35	; 0x23
   13c1c:	e789      	b.n	13b32 <ip_interface_sendto+0xc6>
   13c1e:	9001      	str	r0, [sp, #4]
   13c20:	4638      	mov	r0, r7
   13c22:	f005 fb63 	bl	192ec <interface_socket_from_handle_get>
   13c26:	9b01      	ldr	r3, [sp, #4]
   13c28:	b110      	cbz	r0, 13c30 <ip_interface_sendto+0x1c4>
   13c2a:	6843      	ldr	r3, [r0, #4]
   13c2c:	2b00      	cmp	r3, #0
   13c2e:	d136      	bne.n	13c9e <ip_interface_sendto+0x232>
   13c30:	469a      	mov	sl, r3
   13c32:	e77e      	b.n	13b32 <ip_interface_sendto+0xc6>
   13c34:	f04f 0a2f 	mov.w	sl, #47	; 0x2f
   13c38:	e773      	b.n	13b22 <ip_interface_sendto+0xb6>
   13c3a:	9b00      	ldr	r3, [sp, #0]
   13c3c:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   13c40:	6985      	ldr	r5, [r0, #24]
   13c42:	f7ff fd4f 	bl	136e4 <rpc_ip_client_message_free>
   13c46:	2300      	movs	r3, #0
   13c48:	4628      	mov	r0, r5
   13c4a:	9a00      	ldr	r2, [sp, #0]
   13c4c:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   13c50:	b009      	add	sp, #36	; 0x24
   13c52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13c56:	6818      	ldr	r0, [r3, #0]
   13c58:	469a      	mov	sl, r3
   13c5a:	b108      	cbz	r0, 13c60 <ip_interface_sendto+0x1f4>
   13c5c:	f7ff fd4a 	bl	136f4 <rpc_ip_client_data_free>
   13c60:	4650      	mov	r0, sl
   13c62:	f7ff fd3f 	bl	136e4 <rpc_ip_client_message_free>
   13c66:	9b05      	ldr	r3, [sp, #20]
   13c68:	f04f 0a23 	mov.w	sl, #35	; 0x23
   13c6c:	6023      	str	r3, [r4, #0]
   13c6e:	e760      	b.n	13b32 <ip_interface_sendto+0xc6>
   13c70:	2e00      	cmp	r6, #0
   13c72:	f43f af13 	beq.w	13a9c <ip_interface_sendto+0x30>
   13c76:	f04f 0a38 	mov.w	sl, #56	; 0x38
   13c7a:	4b2e      	ldr	r3, [pc, #184]	; (13d34 <ip_interface_sendto+0x2c8>)
   13c7c:	9300      	str	r3, [sp, #0]
   13c7e:	4650      	mov	r0, sl
   13c80:	f7fc f9d4 	bl	1002c <bsd_os_errno_set>
   13c84:	9b00      	ldr	r3, [sp, #0]
   13c86:	f04f 35ff 	mov.w	r5, #4294967295
   13c8a:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   13c8e:	e76d      	b.n	13b6c <ip_interface_sendto+0x100>
   13c90:	6823      	ldr	r3, [r4, #0]
   13c92:	f083 5380 	eor.w	r3, r3, #268435456	; 0x10000000
   13c96:	f3c3 7300 	ubfx	r3, r3, #28, #1
   13c9a:	9303      	str	r3, [sp, #12]
   13c9c:	e70b      	b.n	13ab6 <ip_interface_sendto+0x4a>
   13c9e:	f8c0 a004 	str.w	sl, [r0, #4]
   13ca2:	6822      	ldr	r2, [r4, #0]
   13ca4:	0312      	lsls	r2, r2, #12
   13ca6:	d5a9      	bpl.n	13bfc <ip_interface_sendto+0x190>
   13ca8:	f8d4 a008 	ldr.w	sl, [r4, #8]
   13cac:	e741      	b.n	13b32 <ip_interface_sendto+0xc6>
   13cae:	6823      	ldr	r3, [r4, #0]
   13cb0:	b29b      	uxth	r3, r3
   13cb2:	2b05      	cmp	r3, #5
   13cb4:	f47f af6a 	bne.w	13b8c <ip_interface_sendto+0x120>
   13cb8:	e764      	b.n	13b84 <ip_interface_sendto+0x118>
   13cba:	2210      	movs	r2, #16
   13cbc:	8931      	ldrh	r1, [r6, #8]
   13cbe:	835a      	strh	r2, [r3, #26]
   13cc0:	8319      	strh	r1, [r3, #24]
   13cc2:	18b1      	adds	r1, r6, r2
   13cc4:	f008 f98e 	bl	1bfe4 <memcpy>
   13cc8:	f247 0207 	movw	r2, #28679	; 0x7007
   13ccc:	9b06      	ldr	r3, [sp, #24]
   13cce:	4690      	mov	r8, r2
   13cd0:	6899      	ldr	r1, [r3, #8]
   13cd2:	8b58      	ldrh	r0, [r3, #26]
   13cd4:	3104      	adds	r1, #4
   13cd6:	4401      	add	r1, r0
   13cd8:	f8c3 9014 	str.w	r9, [r3, #20]
   13cdc:	6099      	str	r1, [r3, #8]
   13cde:	e761      	b.n	13ba4 <ip_interface_sendto+0x138>
   13ce0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   13ce2:	2a10      	cmp	r2, #16
   13ce4:	f47f af1b 	bne.w	13b1e <ip_interface_sendto+0xb2>
   13ce8:	2204      	movs	r2, #4
   13cea:	8931      	ldrh	r1, [r6, #8]
   13cec:	835a      	strh	r2, [r3, #26]
   13cee:	8319      	strh	r1, [r3, #24]
   13cf0:	f106 010c 	add.w	r1, r6, #12
   13cf4:	f008 f976 	bl	1bfe4 <memcpy>
   13cf8:	e7e6      	b.n	13cc8 <ip_interface_sendto+0x25c>
   13cfa:	4b0e      	ldr	r3, [pc, #56]	; (13d34 <ip_interface_sendto+0x2c8>)
   13cfc:	f04f 0a23 	mov.w	sl, #35	; 0x23
   13d00:	9300      	str	r3, [sp, #0]
   13d02:	e7bc      	b.n	13c7e <ip_interface_sendto+0x212>
   13d04:	4b0b      	ldr	r3, [pc, #44]	; (13d34 <ip_interface_sendto+0x2c8>)
   13d06:	f04f 0a28 	mov.w	sl, #40	; 0x28
   13d0a:	9300      	str	r3, [sp, #0]
   13d0c:	e7b7      	b.n	13c7e <ip_interface_sendto+0x212>
   13d0e:	4b09      	ldr	r3, [pc, #36]	; (13d34 <ip_interface_sendto+0x2c8>)
   13d10:	f04f 0a39 	mov.w	sl, #57	; 0x39
   13d14:	9300      	str	r3, [sp, #0]
   13d16:	e7b2      	b.n	13c7e <ip_interface_sendto+0x212>
   13d18:	4b06      	ldr	r3, [pc, #24]	; (13d34 <ip_interface_sendto+0x2c8>)
   13d1a:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   13d1e:	9300      	str	r3, [sp, #0]
   13d20:	e7ad      	b.n	13c7e <ip_interface_sendto+0x212>
   13d22:	4b04      	ldr	r3, [pc, #16]	; (13d34 <ip_interface_sendto+0x2c8>)
   13d24:	f04f 0a09 	mov.w	sl, #9
   13d28:	9300      	str	r3, [sp, #0]
   13d2a:	e7a8      	b.n	13c7e <ip_interface_sendto+0x212>
   13d2c:	f04f 0a0c 	mov.w	sl, #12
   13d30:	e6ff      	b.n	13b32 <ip_interface_sendto+0xc6>
   13d32:	bf00      	nop
   13d34:	20020778 	.word	0x20020778

00013d38 <ip_interface_recvfrom>:
   13d38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13d3c:	b087      	sub	sp, #28
   13d3e:	2a00      	cmp	r2, #0
   13d40:	f000 8112 	beq.w	13f68 <ip_interface_recvfrom+0x230>
   13d44:	4680      	mov	r8, r0
   13d46:	468b      	mov	fp, r1
   13d48:	469a      	mov	sl, r3
   13d4a:	4691      	mov	r9, r2
   13d4c:	b11b      	cbz	r3, 13d56 <ip_interface_recvfrom+0x1e>
   13d4e:	f013 0f3a 	tst.w	r3, #58	; 0x3a
   13d52:	f000 8107 	beq.w	13f64 <ip_interface_recvfrom+0x22c>
   13d56:	4640      	mov	r0, r8
   13d58:	f005 fac8 	bl	192ec <interface_socket_from_handle_get>
   13d5c:	4604      	mov	r4, r0
   13d5e:	2800      	cmp	r0, #0
   13d60:	f000 8104 	beq.w	13f6c <ip_interface_recvfrom+0x234>
   13d64:	6803      	ldr	r3, [r0, #0]
   13d66:	02db      	lsls	r3, r3, #11
   13d68:	d562      	bpl.n	13e30 <ip_interface_recvfrom+0xf8>
   13d6a:	f01a 0f02 	tst.w	sl, #2
   13d6e:	bf18      	it	ne
   13d70:	2600      	movne	r6, #0
   13d72:	f04f 35ff 	mov.w	r5, #4294967295
   13d76:	bf08      	it	eq
   13d78:	6806      	ldreq	r6, [r0, #0]
   13d7a:	f00a 0310 	and.w	r3, sl, #16
   13d7e:	bf04      	itt	eq
   13d80:	f086 5680 	eoreq.w	r6, r6, #268435456	; 0x10000000
   13d84:	f3c6 7600 	ubfxeq	r6, r6, #28, #1
   13d88:	9301      	str	r3, [sp, #4]
   13d8a:	6823      	ldr	r3, [r4, #0]
   13d8c:	03df      	lsls	r7, r3, #15
   13d8e:	d567      	bpl.n	13e60 <ip_interface_recvfrom+0x128>
   13d90:	6823      	ldr	r3, [r4, #0]
   13d92:	69e0      	ldr	r0, [r4, #28]
   13d94:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   13d98:	6023      	str	r3, [r4, #0]
   13d9a:	6803      	ldr	r3, [r0, #0]
   13d9c:	68db      	ldr	r3, [r3, #12]
   13d9e:	4798      	blx	r3
   13da0:	4605      	mov	r5, r0
   13da2:	3001      	adds	r0, #1
   13da4:	d07d      	beq.n	13ea2 <ip_interface_recvfrom+0x16a>
   13da6:	45a9      	cmp	r9, r5
   13da8:	dd03      	ble.n	13db2 <ip_interface_recvfrom+0x7a>
   13daa:	6923      	ldr	r3, [r4, #16]
   13dac:	2b01      	cmp	r3, #1
   13dae:	f000 80a3 	beq.w	13ef8 <ip_interface_recvfrom+0x1c0>
   13db2:	f04f 0800 	mov.w	r8, #0
   13db6:	af02      	add	r7, sp, #8
   13db8:	9b11      	ldr	r3, [sp, #68]	; 0x44
   13dba:	b103      	cbz	r3, 13dbe <ip_interface_recvfrom+0x86>
   13dbc:	681b      	ldr	r3, [r3, #0]
   13dbe:	9a10      	ldr	r2, [sp, #64]	; 0x40
   13dc0:	e9cd b902 	strd	fp, r9, [sp, #8]
   13dc4:	e9cd 2304 	strd	r2, r3, [sp, #16]
   13dc8:	69e0      	ldr	r0, [r4, #28]
   13dca:	4639      	mov	r1, r7
   13dcc:	6803      	ldr	r3, [r0, #0]
   13dce:	4652      	mov	r2, sl
   13dd0:	689b      	ldr	r3, [r3, #8]
   13dd2:	4798      	blx	r3
   13dd4:	4605      	mov	r5, r0
   13dd6:	69e0      	ldr	r0, [r4, #28]
   13dd8:	1c6b      	adds	r3, r5, #1
   13dda:	6803      	ldr	r3, [r0, #0]
   13ddc:	bf18      	it	ne
   13dde:	2701      	movne	r7, #1
   13de0:	68db      	ldr	r3, [r3, #12]
   13de2:	bf0a      	itet	eq
   13de4:	2700      	moveq	r7, #0
   13de6:	2600      	movne	r6, #0
   13de8:	2623      	moveq	r6, #35	; 0x23
   13dea:	4798      	blx	r3
   13dec:	3001      	adds	r0, #1
   13dee:	d132      	bne.n	13e56 <ip_interface_recvfrom+0x11e>
   13df0:	f1b8 0f00 	cmp.w	r8, #0
   13df4:	f000 80b0 	beq.w	13f58 <ip_interface_recvfrom+0x220>
   13df8:	2f00      	cmp	r7, #0
   13dfa:	f000 80a1 	beq.w	13f40 <ip_interface_recvfrom+0x208>
   13dfe:	6823      	ldr	r3, [r4, #0]
   13e00:	0318      	lsls	r0, r3, #12
   13e02:	d506      	bpl.n	13e12 <ip_interface_recvfrom+0xda>
   13e04:	6823      	ldr	r3, [r4, #0]
   13e06:	b29b      	uxth	r3, r3
   13e08:	2b0d      	cmp	r3, #13
   13e0a:	d002      	beq.n	13e12 <ip_interface_recvfrom+0xda>
   13e0c:	6923      	ldr	r3, [r4, #16]
   13e0e:	2b01      	cmp	r3, #1
   13e10:	d021      	beq.n	13e56 <ip_interface_recvfrom+0x11e>
   13e12:	6823      	ldr	r3, [r4, #0]
   13e14:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   13e18:	6823      	ldr	r3, [r4, #0]
   13e1a:	f040 80a9 	bne.w	13f70 <ip_interface_recvfrom+0x238>
   13e1e:	0319      	lsls	r1, r3, #12
   13e20:	d473      	bmi.n	13f0a <ip_interface_recvfrom+0x1d2>
   13e22:	2e00      	cmp	r6, #0
   13e24:	f040 8086 	bne.w	13f34 <ip_interface_recvfrom+0x1fc>
   13e28:	4628      	mov	r0, r5
   13e2a:	b007      	add	sp, #28
   13e2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13e30:	6803      	ldr	r3, [r0, #0]
   13e32:	b29b      	uxth	r3, r3
   13e34:	2b06      	cmp	r3, #6
   13e36:	d071      	beq.n	13f1c <ip_interface_recvfrom+0x1e4>
   13e38:	6803      	ldr	r3, [r0, #0]
   13e3a:	b29b      	uxth	r3, r3
   13e3c:	2b07      	cmp	r3, #7
   13e3e:	bf0c      	ite	eq
   13e40:	2609      	moveq	r6, #9
   13e42:	2639      	movne	r6, #57	; 0x39
   13e44:	69e0      	ldr	r0, [r4, #28]
   13e46:	6803      	ldr	r3, [r0, #0]
   13e48:	68db      	ldr	r3, [r3, #12]
   13e4a:	4798      	blx	r3
   13e4c:	1c43      	adds	r3, r0, #1
   13e4e:	4605      	mov	r5, r0
   13e50:	d0df      	beq.n	13e12 <ip_interface_recvfrom+0xda>
   13e52:	f04f 35ff 	mov.w	r5, #4294967295
   13e56:	6823      	ldr	r3, [r4, #0]
   13e58:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   13e5c:	6023      	str	r3, [r4, #0]
   13e5e:	e7e0      	b.n	13e22 <ip_interface_recvfrom+0xea>
   13e60:	2e00      	cmp	r6, #0
   13e62:	d07d      	beq.n	13f60 <ip_interface_recvfrom+0x228>
   13e64:	6a26      	ldr	r6, [r4, #32]
   13e66:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   13e6a:	2e00      	cmp	r6, #0
   13e6c:	bf08      	it	eq
   13e6e:	f04f 36ff 	moveq.w	r6, #4294967295
   13e72:	af02      	add	r7, sp, #8
   13e74:	463b      	mov	r3, r7
   13e76:	4611      	mov	r1, r2
   13e78:	4640      	mov	r0, r8
   13e7a:	9602      	str	r6, [sp, #8]
   13e7c:	f005 f9b6 	bl	191ec <interface_socket_wait>
   13e80:	4606      	mov	r6, r0
   13e82:	b350      	cbz	r0, 13eda <ip_interface_recvfrom+0x1a2>
   13e84:	6823      	ldr	r3, [r4, #0]
   13e86:	031a      	lsls	r2, r3, #12
   13e88:	d532      	bpl.n	13ef0 <ip_interface_recvfrom+0x1b8>
   13e8a:	6823      	ldr	r3, [r4, #0]
   13e8c:	b29b      	uxth	r3, r3
   13e8e:	2b0d      	cmp	r3, #13
   13e90:	d02e      	beq.n	13ef0 <ip_interface_recvfrom+0x1b8>
   13e92:	6923      	ldr	r3, [r4, #16]
   13e94:	f1a3 0801 	sub.w	r8, r3, #1
   13e98:	fab8 f888 	clz	r8, r8
   13e9c:	ea4f 1858 	mov.w	r8, r8, lsr #5
   13ea0:	e78a      	b.n	13db8 <ip_interface_recvfrom+0x80>
   13ea2:	6823      	ldr	r3, [r4, #0]
   13ea4:	031a      	lsls	r2, r3, #12
   13ea6:	d5db      	bpl.n	13e60 <ip_interface_recvfrom+0x128>
   13ea8:	6823      	ldr	r3, [r4, #0]
   13eaa:	b29b      	uxth	r3, r3
   13eac:	2b0d      	cmp	r3, #13
   13eae:	d0d7      	beq.n	13e60 <ip_interface_recvfrom+0x128>
   13eb0:	6923      	ldr	r3, [r4, #16]
   13eb2:	69e0      	ldr	r0, [r4, #28]
   13eb4:	2b01      	cmp	r3, #1
   13eb6:	d033      	beq.n	13f20 <ip_interface_recvfrom+0x1e8>
   13eb8:	2639      	movs	r6, #57	; 0x39
   13eba:	6823      	ldr	r3, [r4, #0]
   13ebc:	0c1b      	lsrs	r3, r3, #16
   13ebe:	041b      	lsls	r3, r3, #16
   13ec0:	f043 030d 	orr.w	r3, r3, #13
   13ec4:	6023      	str	r3, [r4, #0]
   13ec6:	6823      	ldr	r3, [r4, #0]
   13ec8:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   13ecc:	6023      	str	r3, [r4, #0]
   13ece:	6803      	ldr	r3, [r0, #0]
   13ed0:	68db      	ldr	r3, [r3, #12]
   13ed2:	4798      	blx	r3
   13ed4:	3001      	adds	r0, #1
   13ed6:	d1be      	bne.n	13e56 <ip_interface_recvfrom+0x11e>
   13ed8:	e79b      	b.n	13e12 <ip_interface_recvfrom+0xda>
   13eda:	4640      	mov	r0, r8
   13edc:	f005 fa06 	bl	192ec <interface_socket_from_handle_get>
   13ee0:	b140      	cbz	r0, 13ef4 <ip_interface_recvfrom+0x1bc>
   13ee2:	6846      	ldr	r6, [r0, #4]
   13ee4:	b136      	cbz	r6, 13ef4 <ip_interface_recvfrom+0x1bc>
   13ee6:	2300      	movs	r3, #0
   13ee8:	6043      	str	r3, [r0, #4]
   13eea:	6823      	ldr	r3, [r4, #0]
   13eec:	031a      	lsls	r2, r3, #12
   13eee:	d4cc      	bmi.n	13e8a <ip_interface_recvfrom+0x152>
   13ef0:	69e0      	ldr	r0, [r4, #28]
   13ef2:	e7ec      	b.n	13ece <ip_interface_recvfrom+0x196>
   13ef4:	2601      	movs	r6, #1
   13ef6:	e748      	b.n	13d8a <ip_interface_recvfrom+0x52>
   13ef8:	9b01      	ldr	r3, [sp, #4]
   13efa:	b11b      	cbz	r3, 13f04 <ip_interface_recvfrom+0x1cc>
   13efc:	6823      	ldr	r3, [r4, #0]
   13efe:	00d9      	lsls	r1, r3, #3
   13f00:	d5b0      	bpl.n	13e64 <ip_interface_recvfrom+0x12c>
   13f02:	e756      	b.n	13db2 <ip_interface_recvfrom+0x7a>
   13f04:	4698      	mov	r8, r3
   13f06:	af02      	add	r7, sp, #8
   13f08:	e756      	b.n	13db8 <ip_interface_recvfrom+0x80>
   13f0a:	6823      	ldr	r3, [r4, #0]
   13f0c:	b29b      	uxth	r3, r3
   13f0e:	2b0d      	cmp	r3, #13
   13f10:	d187      	bne.n	13e22 <ip_interface_recvfrom+0xea>
   13f12:	68a3      	ldr	r3, [r4, #8]
   13f14:	2b00      	cmp	r3, #0
   13f16:	d084      	beq.n	13e22 <ip_interface_recvfrom+0xea>
   13f18:	68a6      	ldr	r6, [r4, #8]
   13f1a:	e782      	b.n	13e22 <ip_interface_recvfrom+0xea>
   13f1c:	2609      	movs	r6, #9
   13f1e:	e791      	b.n	13e44 <ip_interface_recvfrom+0x10c>
   13f20:	6803      	ldr	r3, [r0, #0]
   13f22:	68db      	ldr	r3, [r3, #12]
   13f24:	4798      	blx	r3
   13f26:	3001      	adds	r0, #1
   13f28:	d00a      	beq.n	13f40 <ip_interface_recvfrom+0x208>
   13f2a:	2623      	movs	r6, #35	; 0x23
   13f2c:	6823      	ldr	r3, [r4, #0]
   13f2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   13f32:	6023      	str	r3, [r4, #0]
   13f34:	4630      	mov	r0, r6
   13f36:	f7fc f879 	bl	1002c <bsd_os_errno_set>
   13f3a:	f04f 35ff 	mov.w	r5, #4294967295
   13f3e:	e773      	b.n	13e28 <ip_interface_recvfrom+0xf0>
   13f40:	6823      	ldr	r3, [r4, #0]
   13f42:	2500      	movs	r5, #0
   13f44:	0c1b      	lsrs	r3, r3, #16
   13f46:	041b      	lsls	r3, r3, #16
   13f48:	f043 030d 	orr.w	r3, r3, #13
   13f4c:	6023      	str	r3, [r4, #0]
   13f4e:	6823      	ldr	r3, [r4, #0]
   13f50:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   13f54:	6023      	str	r3, [r4, #0]
   13f56:	e767      	b.n	13e28 <ip_interface_recvfrom+0xf0>
   13f58:	2f00      	cmp	r7, #0
   13f5a:	f47f af50 	bne.w	13dfe <ip_interface_recvfrom+0xc6>
   13f5e:	e758      	b.n	13e12 <ip_interface_recvfrom+0xda>
   13f60:	2623      	movs	r6, #35	; 0x23
   13f62:	e7c5      	b.n	13ef0 <ip_interface_recvfrom+0x1b8>
   13f64:	262d      	movs	r6, #45	; 0x2d
   13f66:	e7e5      	b.n	13f34 <ip_interface_recvfrom+0x1fc>
   13f68:	2616      	movs	r6, #22
   13f6a:	e7e3      	b.n	13f34 <ip_interface_recvfrom+0x1fc>
   13f6c:	2609      	movs	r6, #9
   13f6e:	e7e1      	b.n	13f34 <ip_interface_recvfrom+0x1fc>
   13f70:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   13f74:	6023      	str	r3, [r4, #0]
   13f76:	6823      	ldr	r3, [r4, #0]
   13f78:	2669      	movs	r6, #105	; 0x69
   13f7a:	0c1b      	lsrs	r3, r3, #16
   13f7c:	041b      	lsls	r3, r3, #16
   13f7e:	f043 030d 	orr.w	r3, r3, #13
   13f82:	6023      	str	r3, [r4, #0]
   13f84:	e7d6      	b.n	13f34 <ip_interface_recvfrom+0x1fc>
   13f86:	bf00      	nop

00013f88 <ip_interface_connect>:
   13f88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   13f8c:	b082      	sub	sp, #8
   13f8e:	2900      	cmp	r1, #0
   13f90:	d04b      	beq.n	1402a <ip_interface_connect+0xa2>
   13f92:	4617      	mov	r7, r2
   13f94:	2a00      	cmp	r2, #0
   13f96:	d048      	beq.n	1402a <ip_interface_connect+0xa2>
   13f98:	4680      	mov	r8, r0
   13f9a:	4689      	mov	r9, r1
   13f9c:	f005 f9a6 	bl	192ec <interface_socket_from_handle_get>
   13fa0:	4605      	mov	r5, r0
   13fa2:	2800      	cmp	r0, #0
   13fa4:	f000 80af 	beq.w	14106 <ip_interface_connect+0x17e>
   13fa8:	6803      	ldr	r3, [r0, #0]
   13faa:	b29b      	uxth	r3, r3
   13fac:	2b02      	cmp	r3, #2
   13fae:	d004      	beq.n	13fba <ip_interface_connect+0x32>
   13fb0:	6803      	ldr	r3, [r0, #0]
   13fb2:	b29b      	uxth	r3, r3
   13fb4:	2b04      	cmp	r3, #4
   13fb6:	f040 809d 	bne.w	140f4 <ip_interface_connect+0x16c>
   13fba:	6829      	ldr	r1, [r5, #0]
   13fbc:	f011 5100 	ands.w	r1, r1, #536870912	; 0x20000000
   13fc0:	f040 8089 	bne.w	140d6 <ip_interface_connect+0x14e>
   13fc4:	ae02      	add	r6, sp, #8
   13fc6:	f8d5 a018 	ldr.w	sl, [r5, #24]
   13fca:	f846 1d04 	str.w	r1, [r6, #-4]!
   13fce:	4630      	mov	r0, r6
   13fd0:	f7ff fb5e 	bl	13690 <rpc_ip_client_request_alloc>
   13fd4:	bb98      	cbnz	r0, 1403e <ip_interface_connect+0xb6>
   13fd6:	2108      	movs	r1, #8
   13fd8:	ea4f 4208 	mov.w	r2, r8, lsl #16
   13fdc:	9c01      	ldr	r4, [sp, #4]
   13fde:	f442 43e0 	orr.w	r3, r2, #28672	; 0x7000
   13fe2:	f043 0302 	orr.w	r3, r3, #2
   13fe6:	60e3      	str	r3, [r4, #12]
   13fe8:	f8c4 a010 	str.w	sl, [r4, #16]
   13fec:	7260      	strb	r0, [r4, #9]
   13fee:	72a0      	strb	r0, [r4, #10]
   13ff0:	72e0      	strb	r0, [r4, #11]
   13ff2:	7221      	strb	r1, [r4, #8]
   13ff4:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
   13ff8:	f042 0202 	orr.w	r2, r2, #2
   13ffc:	60e2      	str	r2, [r4, #12]
   13ffe:	68a3      	ldr	r3, [r4, #8]
   14000:	69aa      	ldr	r2, [r5, #24]
   14002:	3304      	adds	r3, #4
   14004:	6122      	str	r2, [r4, #16]
   14006:	60a3      	str	r3, [r4, #8]
   14008:	68eb      	ldr	r3, [r5, #12]
   1400a:	f8d9 2004 	ldr.w	r2, [r9, #4]
   1400e:	4293      	cmp	r3, r2
   14010:	d11b      	bne.n	1404a <ip_interface_connect+0xc2>
   14012:	f899 2000 	ldrb.w	r2, [r9]
   14016:	4297      	cmp	r7, r2
   14018:	d107      	bne.n	1402a <ip_interface_connect+0xa2>
   1401a:	2b02      	cmp	r3, #2
   1401c:	f104 0018 	add.w	r0, r4, #24
   14020:	d015      	beq.n	1404e <ip_interface_connect+0xc6>
   14022:	2b0a      	cmp	r3, #10
   14024:	d101      	bne.n	1402a <ip_interface_connect+0xa2>
   14026:	2f24      	cmp	r7, #36	; 0x24
   14028:	d01d      	beq.n	14066 <ip_interface_connect+0xde>
   1402a:	2416      	movs	r4, #22
   1402c:	4620      	mov	r0, r4
   1402e:	f7fb fffd 	bl	1002c <bsd_os_errno_set>
   14032:	f04f 34ff 	mov.w	r4, #4294967295
   14036:	4620      	mov	r0, r4
   14038:	b002      	add	sp, #8
   1403a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1403e:	9c01      	ldr	r4, [sp, #4]
   14040:	2c00      	cmp	r4, #0
   14042:	d05e      	beq.n	14102 <ip_interface_connect+0x17a>
   14044:	ea4f 4208 	mov.w	r2, r8, lsl #16
   14048:	e7d4      	b.n	13ff4 <ip_interface_connect+0x6c>
   1404a:	242f      	movs	r4, #47	; 0x2f
   1404c:	e7ee      	b.n	1402c <ip_interface_connect+0xa4>
   1404e:	2f10      	cmp	r7, #16
   14050:	d1eb      	bne.n	1402a <ip_interface_connect+0xa2>
   14052:	2204      	movs	r2, #4
   14054:	f8b9 3008 	ldrh.w	r3, [r9, #8]
   14058:	f109 010c 	add.w	r1, r9, #12
   1405c:	82e2      	strh	r2, [r4, #22]
   1405e:	82a3      	strh	r3, [r4, #20]
   14060:	f007 ffc0 	bl	1bfe4 <memcpy>
   14064:	e008      	b.n	14078 <ip_interface_connect+0xf0>
   14066:	2210      	movs	r2, #16
   14068:	f8b9 3008 	ldrh.w	r3, [r9, #8]
   1406c:	eb09 0102 	add.w	r1, r9, r2
   14070:	82e2      	strh	r2, [r4, #22]
   14072:	82a3      	strh	r3, [r4, #20]
   14074:	f007 ffb6 	bl	1bfe4 <memcpy>
   14078:	68a3      	ldr	r3, [r4, #8]
   1407a:	8ae2      	ldrh	r2, [r4, #22]
   1407c:	f247 0102 	movw	r1, #28674	; 0x7002
   14080:	4413      	add	r3, r2
   14082:	60a3      	str	r3, [r4, #8]
   14084:	682f      	ldr	r7, [r5, #0]
   14086:	682b      	ldr	r3, [r5, #0]
   14088:	4620      	mov	r0, r4
   1408a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   1408e:	602b      	str	r3, [r5, #0]
   14090:	f7ff fb12 	bl	136b8 <rpc_ip_client_request_send>
   14094:	b9a8      	cbnz	r0, 140c2 <ip_interface_connect+0x13a>
   14096:	682b      	ldr	r3, [r5, #0]
   14098:	00db      	lsls	r3, r3, #3
   1409a:	d429      	bmi.n	140f0 <ip_interface_connect+0x168>
   1409c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
   1409e:	4633      	mov	r3, r6
   140a0:	2c00      	cmp	r4, #0
   140a2:	bf08      	it	eq
   140a4:	f04f 34ff 	moveq.w	r4, #4294967295
   140a8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   140ac:	2105      	movs	r1, #5
   140ae:	4640      	mov	r0, r8
   140b0:	9401      	str	r4, [sp, #4]
   140b2:	f005 f89b 	bl	191ec <interface_socket_wait>
   140b6:	4604      	mov	r4, r0
   140b8:	b178      	cbz	r0, 140da <ip_interface_connect+0x152>
   140ba:	2c73      	cmp	r4, #115	; 0x73
   140bc:	d0b6      	beq.n	1402c <ip_interface_connect+0xa4>
   140be:	602f      	str	r7, [r5, #0]
   140c0:	e7b4      	b.n	1402c <ip_interface_connect+0xa4>
   140c2:	6820      	ldr	r0, [r4, #0]
   140c4:	b108      	cbz	r0, 140ca <ip_interface_connect+0x142>
   140c6:	f7ff fb15 	bl	136f4 <rpc_ip_client_data_free>
   140ca:	4620      	mov	r0, r4
   140cc:	f7ff fb0a 	bl	136e4 <rpc_ip_client_message_free>
   140d0:	2423      	movs	r4, #35	; 0x23
   140d2:	602f      	str	r7, [r5, #0]
   140d4:	e7aa      	b.n	1402c <ip_interface_connect+0xa4>
   140d6:	2472      	movs	r4, #114	; 0x72
   140d8:	e7a8      	b.n	1402c <ip_interface_connect+0xa4>
   140da:	4640      	mov	r0, r8
   140dc:	f005 f906 	bl	192ec <interface_socket_from_handle_get>
   140e0:	2800      	cmp	r0, #0
   140e2:	d0a8      	beq.n	14036 <ip_interface_connect+0xae>
   140e4:	6843      	ldr	r3, [r0, #4]
   140e6:	2b00      	cmp	r3, #0
   140e8:	d0a5      	beq.n	14036 <ip_interface_connect+0xae>
   140ea:	6044      	str	r4, [r0, #4]
   140ec:	461c      	mov	r4, r3
   140ee:	e7e4      	b.n	140ba <ip_interface_connect+0x132>
   140f0:	2473      	movs	r4, #115	; 0x73
   140f2:	e79b      	b.n	1402c <ip_interface_connect+0xa4>
   140f4:	6803      	ldr	r3, [r0, #0]
   140f6:	b29b      	uxth	r3, r3
   140f8:	2b05      	cmp	r3, #5
   140fa:	bf14      	ite	ne
   140fc:	2409      	movne	r4, #9
   140fe:	2438      	moveq	r4, #56	; 0x38
   14100:	e794      	b.n	1402c <ip_interface_connect+0xa4>
   14102:	240c      	movs	r4, #12
   14104:	e792      	b.n	1402c <ip_interface_connect+0xa4>
   14106:	2409      	movs	r4, #9
   14108:	e790      	b.n	1402c <ip_interface_connect+0xa4>
   1410a:	bf00      	nop

0001410c <ip_interface_bind>:
   1410c:	f04f 33ff 	mov.w	r3, #4294967295
   14110:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14114:	b083      	sub	sp, #12
   14116:	9300      	str	r3, [sp, #0]
   14118:	b3b1      	cbz	r1, 14188 <ip_interface_bind+0x7c>
   1411a:	4616      	mov	r6, r2
   1411c:	b3a2      	cbz	r2, 14188 <ip_interface_bind+0x7c>
   1411e:	4607      	mov	r7, r0
   14120:	4688      	mov	r8, r1
   14122:	f005 f8e3 	bl	192ec <interface_socket_from_handle_get>
   14126:	4605      	mov	r5, r0
   14128:	2800      	cmp	r0, #0
   1412a:	d04a      	beq.n	141c2 <ip_interface_bind+0xb6>
   1412c:	6803      	ldr	r3, [r0, #0]
   1412e:	b29b      	uxth	r3, r3
   14130:	2b02      	cmp	r3, #2
   14132:	d146      	bne.n	141c2 <ip_interface_bind+0xb6>
   14134:	2100      	movs	r1, #0
   14136:	a802      	add	r0, sp, #8
   14138:	f840 1d04 	str.w	r1, [r0, #-4]!
   1413c:	f8d5 9018 	ldr.w	r9, [r5, #24]
   14140:	f7ff faa6 	bl	13690 <rpc_ip_client_request_alloc>
   14144:	bb50      	cbnz	r0, 1419c <ip_interface_bind+0x90>
   14146:	f247 0305 	movw	r3, #28677	; 0x7005
   1414a:	2208      	movs	r2, #8
   1414c:	9c01      	ldr	r4, [sp, #4]
   1414e:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   14152:	60e3      	str	r3, [r4, #12]
   14154:	f8c4 9010 	str.w	r9, [r4, #16]
   14158:	7260      	strb	r0, [r4, #9]
   1415a:	72a0      	strb	r0, [r4, #10]
   1415c:	72e0      	strb	r0, [r4, #11]
   1415e:	7222      	strb	r2, [r4, #8]
   14160:	68a3      	ldr	r3, [r4, #8]
   14162:	3304      	adds	r3, #4
   14164:	60a3      	str	r3, [r4, #8]
   14166:	68eb      	ldr	r3, [r5, #12]
   14168:	f8d8 2004 	ldr.w	r2, [r8, #4]
   1416c:	4293      	cmp	r3, r2
   1416e:	d11a      	bne.n	141a6 <ip_interface_bind+0x9a>
   14170:	f898 2000 	ldrb.w	r2, [r8]
   14174:	4296      	cmp	r6, r2
   14176:	d107      	bne.n	14188 <ip_interface_bind+0x7c>
   14178:	2b02      	cmp	r3, #2
   1417a:	f104 0018 	add.w	r0, r4, #24
   1417e:	d014      	beq.n	141aa <ip_interface_bind+0x9e>
   14180:	2b0a      	cmp	r3, #10
   14182:	d101      	bne.n	14188 <ip_interface_bind+0x7c>
   14184:	2e24      	cmp	r6, #36	; 0x24
   14186:	d01e      	beq.n	141c6 <ip_interface_bind+0xba>
   14188:	2416      	movs	r4, #22
   1418a:	4620      	mov	r0, r4
   1418c:	f7fb ff4e 	bl	1002c <bsd_os_errno_set>
   14190:	f04f 34ff 	mov.w	r4, #4294967295
   14194:	4620      	mov	r0, r4
   14196:	b003      	add	sp, #12
   14198:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1419c:	9c01      	ldr	r4, [sp, #4]
   1419e:	2c00      	cmp	r4, #0
   141a0:	d1de      	bne.n	14160 <ip_interface_bind+0x54>
   141a2:	240c      	movs	r4, #12
   141a4:	e7f1      	b.n	1418a <ip_interface_bind+0x7e>
   141a6:	242f      	movs	r4, #47	; 0x2f
   141a8:	e7ef      	b.n	1418a <ip_interface_bind+0x7e>
   141aa:	2e10      	cmp	r6, #16
   141ac:	d1ec      	bne.n	14188 <ip_interface_bind+0x7c>
   141ae:	2204      	movs	r2, #4
   141b0:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   141b4:	f108 010c 	add.w	r1, r8, #12
   141b8:	82e2      	strh	r2, [r4, #22]
   141ba:	82a3      	strh	r3, [r4, #20]
   141bc:	f007 ff12 	bl	1bfe4 <memcpy>
   141c0:	e00a      	b.n	141d8 <ip_interface_bind+0xcc>
   141c2:	2409      	movs	r4, #9
   141c4:	e7e1      	b.n	1418a <ip_interface_bind+0x7e>
   141c6:	2210      	movs	r2, #16
   141c8:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   141cc:	eb08 0102 	add.w	r1, r8, r2
   141d0:	82e2      	strh	r2, [r4, #22]
   141d2:	82a3      	strh	r3, [r4, #20]
   141d4:	f007 ff06 	bl	1bfe4 <memcpy>
   141d8:	68a3      	ldr	r3, [r4, #8]
   141da:	8ae2      	ldrh	r2, [r4, #22]
   141dc:	f247 0105 	movw	r1, #28677	; 0x7005
   141e0:	4413      	add	r3, r2
   141e2:	60a3      	str	r3, [r4, #8]
   141e4:	682b      	ldr	r3, [r5, #0]
   141e6:	4620      	mov	r0, r4
   141e8:	0c1b      	lsrs	r3, r3, #16
   141ea:	041b      	lsls	r3, r3, #16
   141ec:	f043 0303 	orr.w	r3, r3, #3
   141f0:	602b      	str	r3, [r5, #0]
   141f2:	682e      	ldr	r6, [r5, #0]
   141f4:	f7ff fa60 	bl	136b8 <rpc_ip_client_request_send>
   141f8:	4680      	mov	r8, r0
   141fa:	b978      	cbnz	r0, 1421c <ip_interface_bind+0x110>
   141fc:	466b      	mov	r3, sp
   141fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
   14202:	2104      	movs	r1, #4
   14204:	4638      	mov	r0, r7
   14206:	f004 fff1 	bl	191ec <interface_socket_wait>
   1420a:	4604      	mov	r4, r0
   1420c:	b1a0      	cbz	r0, 14238 <ip_interface_bind+0x12c>
   1420e:	682b      	ldr	r3, [r5, #0]
   14210:	0c1b      	lsrs	r3, r3, #16
   14212:	041b      	lsls	r3, r3, #16
   14214:	f043 0302 	orr.w	r3, r3, #2
   14218:	602b      	str	r3, [r5, #0]
   1421a:	e7b6      	b.n	1418a <ip_interface_bind+0x7e>
   1421c:	6820      	ldr	r0, [r4, #0]
   1421e:	b108      	cbz	r0, 14224 <ip_interface_bind+0x118>
   14220:	f7ff fa68 	bl	136f4 <rpc_ip_client_data_free>
   14224:	0c36      	lsrs	r6, r6, #16
   14226:	0436      	lsls	r6, r6, #16
   14228:	4620      	mov	r0, r4
   1422a:	f046 0602 	orr.w	r6, r6, #2
   1422e:	f7ff fa59 	bl	136e4 <rpc_ip_client_message_free>
   14232:	2423      	movs	r4, #35	; 0x23
   14234:	602e      	str	r6, [r5, #0]
   14236:	e7a8      	b.n	1418a <ip_interface_bind+0x7e>
   14238:	4638      	mov	r0, r7
   1423a:	f005 f857 	bl	192ec <interface_socket_from_handle_get>
   1423e:	2800      	cmp	r0, #0
   14240:	d0a8      	beq.n	14194 <ip_interface_bind+0x88>
   14242:	6844      	ldr	r4, [r0, #4]
   14244:	2c00      	cmp	r4, #0
   14246:	d0a5      	beq.n	14194 <ip_interface_bind+0x88>
   14248:	f8c0 8004 	str.w	r8, [r0, #4]
   1424c:	e7df      	b.n	1420e <ip_interface_bind+0x102>
   1424e:	bf00      	nop

00014250 <ip_interface_listen>:
   14250:	f04f 33ff 	mov.w	r3, #4294967295
   14254:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14258:	b082      	sub	sp, #8
   1425a:	4606      	mov	r6, r0
   1425c:	9300      	str	r3, [sp, #0]
   1425e:	f005 f845 	bl	192ec <interface_socket_from_handle_get>
   14262:	2800      	cmp	r0, #0
   14264:	d066      	beq.n	14334 <ip_interface_listen+0xe4>
   14266:	6803      	ldr	r3, [r0, #0]
   14268:	4605      	mov	r5, r0
   1426a:	b29b      	uxth	r3, r3
   1426c:	2b04      	cmp	r3, #4
   1426e:	d161      	bne.n	14334 <ip_interface_listen+0xe4>
   14270:	2100      	movs	r1, #0
   14272:	4a32      	ldr	r2, [pc, #200]	; (1433c <ip_interface_listen+0xec>)
   14274:	4630      	mov	r0, r6
   14276:	f004 ff81 	bl	1917c <interface_socket_packet_handler_update>
   1427a:	4601      	mov	r1, r0
   1427c:	2800      	cmp	r0, #0
   1427e:	d15b      	bne.n	14338 <ip_interface_listen+0xe8>
   14280:	a802      	add	r0, sp, #8
   14282:	f840 1d04 	str.w	r1, [r0, #-4]!
   14286:	69af      	ldr	r7, [r5, #24]
   14288:	f7ff fa02 	bl	13690 <rpc_ip_client_request_alloc>
   1428c:	bba0      	cbnz	r0, 142f8 <ip_interface_listen+0xa8>
   1428e:	f247 0308 	movw	r3, #28680	; 0x7008
   14292:	2208      	movs	r2, #8
   14294:	9c01      	ldr	r4, [sp, #4]
   14296:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   1429a:	60e3      	str	r3, [r4, #12]
   1429c:	6127      	str	r7, [r4, #16]
   1429e:	7260      	strb	r0, [r4, #9]
   142a0:	72a0      	strb	r0, [r4, #10]
   142a2:	72e0      	strb	r0, [r4, #11]
   142a4:	7222      	strb	r2, [r4, #8]
   142a6:	68a3      	ldr	r3, [r4, #8]
   142a8:	f247 0108 	movw	r1, #28680	; 0x7008
   142ac:	3304      	adds	r3, #4
   142ae:	60a3      	str	r3, [r4, #8]
   142b0:	682b      	ldr	r3, [r5, #0]
   142b2:	4620      	mov	r0, r4
   142b4:	0c1b      	lsrs	r3, r3, #16
   142b6:	041b      	lsls	r3, r3, #16
   142b8:	f043 0306 	orr.w	r3, r3, #6
   142bc:	602b      	str	r3, [r5, #0]
   142be:	682f      	ldr	r7, [r5, #0]
   142c0:	f7ff f9fa 	bl	136b8 <rpc_ip_client_request_send>
   142c4:	4680      	mov	r8, r0
   142c6:	b9e0      	cbnz	r0, 14302 <ip_interface_listen+0xb2>
   142c8:	466b      	mov	r3, sp
   142ca:	f64f 72ff 	movw	r2, #65535	; 0xffff
   142ce:	2107      	movs	r1, #7
   142d0:	4630      	mov	r0, r6
   142d2:	f004 ff8b 	bl	191ec <interface_socket_wait>
   142d6:	4604      	mov	r4, r0
   142d8:	b308      	cbz	r0, 1431e <ip_interface_listen+0xce>
   142da:	682b      	ldr	r3, [r5, #0]
   142dc:	0c1b      	lsrs	r3, r3, #16
   142de:	041b      	lsls	r3, r3, #16
   142e0:	f043 0304 	orr.w	r3, r3, #4
   142e4:	602b      	str	r3, [r5, #0]
   142e6:	4620      	mov	r0, r4
   142e8:	f7fb fea0 	bl	1002c <bsd_os_errno_set>
   142ec:	f04f 34ff 	mov.w	r4, #4294967295
   142f0:	4620      	mov	r0, r4
   142f2:	b002      	add	sp, #8
   142f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   142f8:	9c01      	ldr	r4, [sp, #4]
   142fa:	2c00      	cmp	r4, #0
   142fc:	d1d3      	bne.n	142a6 <ip_interface_listen+0x56>
   142fe:	240c      	movs	r4, #12
   14300:	e7f1      	b.n	142e6 <ip_interface_listen+0x96>
   14302:	6820      	ldr	r0, [r4, #0]
   14304:	b108      	cbz	r0, 1430a <ip_interface_listen+0xba>
   14306:	f7ff f9f5 	bl	136f4 <rpc_ip_client_data_free>
   1430a:	0c3f      	lsrs	r7, r7, #16
   1430c:	043f      	lsls	r7, r7, #16
   1430e:	4620      	mov	r0, r4
   14310:	f047 0704 	orr.w	r7, r7, #4
   14314:	f7ff f9e6 	bl	136e4 <rpc_ip_client_message_free>
   14318:	2423      	movs	r4, #35	; 0x23
   1431a:	602f      	str	r7, [r5, #0]
   1431c:	e7e3      	b.n	142e6 <ip_interface_listen+0x96>
   1431e:	4630      	mov	r0, r6
   14320:	f004 ffe4 	bl	192ec <interface_socket_from_handle_get>
   14324:	2800      	cmp	r0, #0
   14326:	d0e3      	beq.n	142f0 <ip_interface_listen+0xa0>
   14328:	6844      	ldr	r4, [r0, #4]
   1432a:	2c00      	cmp	r4, #0
   1432c:	d0e0      	beq.n	142f0 <ip_interface_listen+0xa0>
   1432e:	f8c0 8004 	str.w	r8, [r0, #4]
   14332:	e7d2      	b.n	142da <ip_interface_listen+0x8a>
   14334:	2409      	movs	r4, #9
   14336:	e7d6      	b.n	142e6 <ip_interface_listen+0x96>
   14338:	2423      	movs	r4, #35	; 0x23
   1433a:	e7d4      	b.n	142e6 <ip_interface_listen+0x96>
   1433c:	00013705 	.word	0x00013705

00014340 <ip_interface_accept>:
   14340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14344:	f04f 33ff 	mov.w	r3, #4294967295
   14348:	2500      	movs	r5, #0
   1434a:	b087      	sub	sp, #28
   1434c:	460f      	mov	r7, r1
   1434e:	4690      	mov	r8, r2
   14350:	e9cd 5303 	strd	r5, r3, [sp, #12]
   14354:	4606      	mov	r6, r0
   14356:	f004 ffc9 	bl	192ec <interface_socket_from_handle_get>
   1435a:	4604      	mov	r4, r0
   1435c:	2800      	cmp	r0, #0
   1435e:	f000 8123 	beq.w	145a8 <ip_interface_accept+0x268>
   14362:	6803      	ldr	r3, [r0, #0]
   14364:	b29b      	uxth	r3, r3
   14366:	2b07      	cmp	r3, #7
   14368:	d10a      	bne.n	14380 <ip_interface_accept+0x40>
   1436a:	6803      	ldr	r3, [r0, #0]
   1436c:	6805      	ldr	r5, [r0, #0]
   1436e:	00db      	lsls	r3, r3, #3
   14370:	d416      	bmi.n	143a0 <ip_interface_accept+0x60>
   14372:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   14376:	d019      	beq.n	143ac <ip_interface_accept+0x6c>
   14378:	6805      	ldr	r5, [r0, #0]
   1437a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   1437e:	d124      	bne.n	143ca <ip_interface_accept+0x8a>
   14380:	f04f 0909 	mov.w	r9, #9
   14384:	9b03      	ldr	r3, [sp, #12]
   14386:	b113      	cbz	r3, 1438e <ip_interface_accept+0x4e>
   14388:	4628      	mov	r0, r5
   1438a:	f004 fee1 	bl	19150 <interface_socket_free>
   1438e:	4648      	mov	r0, r9
   14390:	f04f 39ff 	mov.w	r9, #4294967295
   14394:	f7fb fe4a 	bl	1002c <bsd_os_errno_set>
   14398:	4648      	mov	r0, r9
   1439a:	b007      	add	sp, #28
   1439c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   143a0:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   143a4:	d170      	bne.n	14488 <ip_interface_accept+0x148>
   143a6:	f04f 0923 	mov.w	r9, #35	; 0x23
   143aa:	e7eb      	b.n	14384 <ip_interface_accept+0x44>
   143ac:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   143b0:	ab04      	add	r3, sp, #16
   143b2:	4611      	mov	r1, r2
   143b4:	4630      	mov	r0, r6
   143b6:	f004 ff19 	bl	191ec <interface_socket_wait>
   143ba:	4681      	mov	r9, r0
   143bc:	2800      	cmp	r0, #0
   143be:	f000 8082 	beq.w	144c6 <ip_interface_accept+0x186>
   143c2:	6825      	ldr	r5, [r4, #0]
   143c4:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   143c8:	d0dc      	beq.n	14384 <ip_interface_accept+0x44>
   143ca:	f04f 30ff 	mov.w	r0, #4294967295
   143ce:	2300      	movs	r3, #0
   143d0:	e9cd 0300 	strd	r0, r3, [sp]
   143d4:	4a78      	ldr	r2, [pc, #480]	; (145b8 <ip_interface_accept+0x278>)
   143d6:	6921      	ldr	r1, [r4, #16]
   143d8:	a803      	add	r0, sp, #12
   143da:	f004 fe55 	bl	19088 <interface_socket_allocate>
   143de:	9b03      	ldr	r3, [sp, #12]
   143e0:	4605      	mov	r5, r0
   143e2:	2b00      	cmp	r3, #0
   143e4:	f000 80e4 	beq.w	145b0 <ip_interface_accept+0x270>
   143e8:	2100      	movs	r1, #0
   143ea:	6962      	ldr	r2, [r4, #20]
   143ec:	a806      	add	r0, sp, #24
   143ee:	615a      	str	r2, [r3, #20]
   143f0:	68e2      	ldr	r2, [r4, #12]
   143f2:	f840 1d04 	str.w	r1, [r0, #-4]!
   143f6:	60da      	str	r2, [r3, #12]
   143f8:	6922      	ldr	r2, [r4, #16]
   143fa:	611a      	str	r2, [r3, #16]
   143fc:	f8d4 9018 	ldr.w	r9, [r4, #24]
   14400:	f7ff f946 	bl	13690 <rpc_ip_client_request_alloc>
   14404:	2800      	cmp	r0, #0
   14406:	d146      	bne.n	14496 <ip_interface_accept+0x156>
   14408:	f247 030c 	movw	r3, #28684	; 0x700c
   1440c:	2108      	movs	r1, #8
   1440e:	f8dd b014 	ldr.w	fp, [sp, #20]
   14412:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   14416:	f8cb 300c 	str.w	r3, [fp, #12]
   1441a:	f8cb 9010 	str.w	r9, [fp, #16]
   1441e:	f88b 0009 	strb.w	r0, [fp, #9]
   14422:	f88b 000a 	strb.w	r0, [fp, #10]
   14426:	f88b 000b 	strb.w	r0, [fp, #11]
   1442a:	f88b 1008 	strb.w	r1, [fp, #8]
   1442e:	6823      	ldr	r3, [r4, #0]
   14430:	f247 010c 	movw	r1, #28684	; 0x700c
   14434:	0c1b      	lsrs	r3, r3, #16
   14436:	041b      	lsls	r3, r3, #16
   14438:	f043 0308 	orr.w	r3, r3, #8
   1443c:	6023      	str	r3, [r4, #0]
   1443e:	4658      	mov	r0, fp
   14440:	f8d4 9000 	ldr.w	r9, [r4]
   14444:	f7ff f938 	bl	136b8 <rpc_ip_client_request_send>
   14448:	4682      	mov	sl, r0
   1444a:	bb60      	cbnz	r0, 144a6 <ip_interface_accept+0x166>
   1444c:	6822      	ldr	r2, [r4, #0]
   1444e:	9900      	ldr	r1, [sp, #0]
   14450:	ab04      	add	r3, sp, #16
   14452:	400a      	ands	r2, r1
   14454:	6022      	str	r2, [r4, #0]
   14456:	2109      	movs	r1, #9
   14458:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1445c:	4630      	mov	r0, r6
   1445e:	f004 fec5 	bl	191ec <interface_socket_wait>
   14462:	4681      	mov	r9, r0
   14464:	2800      	cmp	r0, #0
   14466:	f000 808d 	beq.w	14584 <ip_interface_accept+0x244>
   1446a:	6823      	ldr	r3, [r4, #0]
   1446c:	9a01      	ldr	r2, [sp, #4]
   1446e:	431a      	orrs	r2, r3
   14470:	6022      	str	r2, [r4, #0]
   14472:	6823      	ldr	r3, [r4, #0]
   14474:	0c1b      	lsrs	r3, r3, #16
   14476:	041b      	lsls	r3, r3, #16
   14478:	f043 0307 	orr.w	r3, r3, #7
   1447c:	6023      	str	r3, [r4, #0]
   1447e:	6823      	ldr	r3, [r4, #0]
   14480:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   14484:	6023      	str	r3, [r4, #0]
   14486:	e77d      	b.n	14384 <ip_interface_accept+0x44>
   14488:	f06f 5280 	mvn.w	r2, #268435456	; 0x10000000
   1448c:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   14490:	e9cd 2300 	strd	r2, r3, [sp]
   14494:	e79e      	b.n	143d4 <ip_interface_accept+0x94>
   14496:	f8dd b014 	ldr.w	fp, [sp, #20]
   1449a:	f04f 090c 	mov.w	r9, #12
   1449e:	f1bb 0f00 	cmp.w	fp, #0
   144a2:	d1c4      	bne.n	1442e <ip_interface_accept+0xee>
   144a4:	e76e      	b.n	14384 <ip_interface_accept+0x44>
   144a6:	f8db 0000 	ldr.w	r0, [fp]
   144aa:	b108      	cbz	r0, 144b0 <ip_interface_accept+0x170>
   144ac:	f7ff f922 	bl	136f4 <rpc_ip_client_data_free>
   144b0:	ea4f 4919 	mov.w	r9, r9, lsr #16
   144b4:	4658      	mov	r0, fp
   144b6:	ea4f 4909 	mov.w	r9, r9, lsl #16
   144ba:	f7ff f913 	bl	136e4 <rpc_ip_client_message_free>
   144be:	f049 0307 	orr.w	r3, r9, #7
   144c2:	6023      	str	r3, [r4, #0]
   144c4:	e76f      	b.n	143a6 <ip_interface_accept+0x66>
   144c6:	4630      	mov	r0, r6
   144c8:	f004 ff10 	bl	192ec <interface_socket_from_handle_get>
   144cc:	b130      	cbz	r0, 144dc <ip_interface_accept+0x19c>
   144ce:	f8d0 9004 	ldr.w	r9, [r0, #4]
   144d2:	f1b9 0f00 	cmp.w	r9, #0
   144d6:	d001      	beq.n	144dc <ip_interface_accept+0x19c>
   144d8:	6045      	str	r5, [r0, #4]
   144da:	e772      	b.n	143c2 <ip_interface_accept+0x82>
   144dc:	6823      	ldr	r3, [r4, #0]
   144de:	03d9      	lsls	r1, r3, #15
   144e0:	f53f af73 	bmi.w	143ca <ip_interface_accept+0x8a>
   144e4:	4d35      	ldr	r5, [pc, #212]	; (145bc <ip_interface_accept+0x27c>)
   144e6:	9903      	ldr	r1, [sp, #12]
   144e8:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   144ec:	699b      	ldr	r3, [r3, #24]
   144ee:	618b      	str	r3, [r1, #24]
   144f0:	b147      	cbz	r7, 14504 <ip_interface_accept+0x1c4>
   144f2:	68cb      	ldr	r3, [r1, #12]
   144f4:	2b0a      	cmp	r3, #10
   144f6:	d028      	beq.n	1454a <ip_interface_accept+0x20a>
   144f8:	2b02      	cmp	r3, #2
   144fa:	d103      	bne.n	14504 <ip_interface_accept+0x1c4>
   144fc:	f8d8 2000 	ldr.w	r2, [r8]
   14500:	2a10      	cmp	r2, #16
   14502:	d036      	beq.n	14572 <ip_interface_accept+0x232>
   14504:	680a      	ldr	r2, [r1, #0]
   14506:	482e      	ldr	r0, [pc, #184]	; (145c0 <ip_interface_accept+0x280>)
   14508:	4002      	ands	r2, r0
   1450a:	f042 0205 	orr.w	r2, r2, #5
   1450e:	600a      	str	r2, [r1, #0]
   14510:	9a03      	ldr	r2, [sp, #12]
   14512:	6811      	ldr	r1, [r2, #0]
   14514:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
   14518:	6011      	str	r1, [r2, #0]
   1451a:	6811      	ldr	r1, [r2, #0]
   1451c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14520:	6011      	str	r1, [r2, #0]
   14522:	6823      	ldr	r3, [r4, #0]
   14524:	4003      	ands	r3, r0
   14526:	f043 0307 	orr.w	r3, r3, #7
   1452a:	6023      	str	r3, [r4, #0]
   1452c:	6823      	ldr	r3, [r4, #0]
   1452e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   14532:	6023      	str	r3, [r4, #0]
   14534:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
   14538:	f7ff f8d4 	bl	136e4 <rpc_ip_client_message_free>
   1453c:	2300      	movs	r3, #0
   1453e:	4648      	mov	r0, r9
   14540:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
   14544:	b007      	add	sp, #28
   14546:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1454a:	f8d8 2000 	ldr.w	r2, [r8]
   1454e:	2a24      	cmp	r2, #36	; 0x24
   14550:	d1d8      	bne.n	14504 <ip_interface_accept+0x1c4>
   14552:	703a      	strb	r2, [r7, #0]
   14554:	2210      	movs	r2, #16
   14556:	607b      	str	r3, [r7, #4]
   14558:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   1455c:	f107 0010 	add.w	r0, r7, #16
   14560:	8b9b      	ldrh	r3, [r3, #28]
   14562:	813b      	strh	r3, [r7, #8]
   14564:	f855 1026 	ldr.w	r1, [r5, r6, lsl #2]
   14568:	3120      	adds	r1, #32
   1456a:	f007 fd3b 	bl	1bfe4 <memcpy>
   1456e:	9903      	ldr	r1, [sp, #12]
   14570:	e7c8      	b.n	14504 <ip_interface_accept+0x1c4>
   14572:	703a      	strb	r2, [r7, #0]
   14574:	607b      	str	r3, [r7, #4]
   14576:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   1457a:	f107 000c 	add.w	r0, r7, #12
   1457e:	8b9b      	ldrh	r3, [r3, #28]
   14580:	2204      	movs	r2, #4
   14582:	e7ee      	b.n	14562 <ip_interface_accept+0x222>
   14584:	4630      	mov	r0, r6
   14586:	f004 feb1 	bl	192ec <interface_socket_from_handle_get>
   1458a:	b138      	cbz	r0, 1459c <ip_interface_accept+0x25c>
   1458c:	f8d0 9004 	ldr.w	r9, [r0, #4]
   14590:	f1b9 0f00 	cmp.w	r9, #0
   14594:	d002      	beq.n	1459c <ip_interface_accept+0x25c>
   14596:	f8c0 a004 	str.w	sl, [r0, #4]
   1459a:	e766      	b.n	1446a <ip_interface_accept+0x12a>
   1459c:	6823      	ldr	r3, [r4, #0]
   1459e:	9a01      	ldr	r2, [sp, #4]
   145a0:	46a9      	mov	r9, r5
   145a2:	4313      	orrs	r3, r2
   145a4:	6023      	str	r3, [r4, #0]
   145a6:	e79d      	b.n	144e4 <ip_interface_accept+0x1a4>
   145a8:	4605      	mov	r5, r0
   145aa:	f04f 0909 	mov.w	r9, #9
   145ae:	e6e9      	b.n	14384 <ip_interface_accept+0x44>
   145b0:	f04f 090c 	mov.w	r9, #12
   145b4:	e6eb      	b.n	1438e <ip_interface_accept+0x4e>
   145b6:	bf00      	nop
   145b8:	00013705 	.word	0x00013705
   145bc:	20020778 	.word	0x20020778
   145c0:	ffff0000 	.word	0xffff0000

000145c4 <ip_interface_setopt>:
   145c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   145c8:	2901      	cmp	r1, #1
   145ca:	b086      	sub	sp, #24
   145cc:	f040 809d 	bne.w	1470a <ip_interface_setopt+0x146>
   145d0:	460e      	mov	r6, r1
   145d2:	4690      	mov	r8, r2
   145d4:	461d      	mov	r5, r3
   145d6:	4607      	mov	r7, r0
   145d8:	f004 fe88 	bl	192ec <interface_socket_from_handle_get>
   145dc:	4604      	mov	r4, r0
   145de:	2800      	cmp	r0, #0
   145e0:	f000 80a6 	beq.w	14730 <ip_interface_setopt+0x16c>
   145e4:	f1b8 0f19 	cmp.w	r8, #25
   145e8:	d16f      	bne.n	146ca <ip_interface_setopt+0x106>
   145ea:	2d00      	cmp	r5, #0
   145ec:	f000 8093 	beq.w	14716 <ip_interface_setopt+0x152>
   145f0:	4628      	mov	r0, r5
   145f2:	f007 fcc5 	bl	1bf80 <strlen>
   145f6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   145f8:	4298      	cmp	r0, r3
   145fa:	f040 808c 	bne.w	14716 <ip_interface_setopt+0x152>
   145fe:	6823      	ldr	r3, [r4, #0]
   14600:	b29b      	uxth	r3, r3
   14602:	2b02      	cmp	r3, #2
   14604:	d174      	bne.n	146f0 <ip_interface_setopt+0x12c>
   14606:	4629      	mov	r1, r5
   14608:	68e0      	ldr	r0, [r4, #12]
   1460a:	f002 fbd9 	bl	16dc0 <pdn_interface_pdn_id_get>
   1460e:	9003      	str	r0, [sp, #12]
   14610:	3001      	adds	r0, #1
   14612:	bf08      	it	eq
   14614:	2516      	moveq	r5, #22
   14616:	d04f      	beq.n	146b8 <ip_interface_setopt+0xf4>
   14618:	f04f 33ff 	mov.w	r3, #4294967295
   1461c:	9304      	str	r3, [sp, #16]
   1461e:	6823      	ldr	r3, [r4, #0]
   14620:	025b      	lsls	r3, r3, #9
   14622:	d448      	bmi.n	146b6 <ip_interface_setopt+0xf2>
   14624:	6823      	ldr	r3, [r4, #0]
   14626:	f413 0300 	ands.w	r3, r3, #8388608	; 0x800000
   1462a:	d144      	bne.n	146b6 <ip_interface_setopt+0xf2>
   1462c:	6826      	ldr	r6, [r4, #0]
   1462e:	6822      	ldr	r2, [r4, #0]
   14630:	a806      	add	r0, sp, #24
   14632:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   14636:	6022      	str	r2, [r4, #0]
   14638:	2104      	movs	r1, #4
   1463a:	f840 3d04 	str.w	r3, [r0, #-4]!
   1463e:	f8d4 8018 	ldr.w	r8, [r4, #24]
   14642:	f7ff f825 	bl	13690 <rpc_ip_client_request_alloc>
   14646:	2800      	cmp	r0, #0
   14648:	d14c      	bne.n	146e4 <ip_interface_setopt+0x120>
   1464a:	f247 0203 	movw	r2, #28675	; 0x7003
   1464e:	2300      	movs	r3, #0
   14650:	2108      	movs	r1, #8
   14652:	9d05      	ldr	r5, [sp, #20]
   14654:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   14658:	60ea      	str	r2, [r5, #12]
   1465a:	f8c5 8010 	str.w	r8, [r5, #16]
   1465e:	7229      	strb	r1, [r5, #8]
   14660:	726b      	strb	r3, [r5, #9]
   14662:	72ab      	strb	r3, [r5, #10]
   14664:	72eb      	strb	r3, [r5, #11]
   14666:	f04f 0c08 	mov.w	ip, #8
   1466a:	2300      	movs	r3, #0
   1466c:	2010      	movs	r0, #16
   1466e:	2130      	movs	r1, #48	; 0x30
   14670:	68aa      	ldr	r2, [r5, #8]
   14672:	756b      	strb	r3, [r5, #21]
   14674:	4462      	add	r2, ip
   14676:	60aa      	str	r2, [r5, #8]
   14678:	75ab      	strb	r3, [r5, #22]
   1467a:	75eb      	strb	r3, [r5, #23]
   1467c:	76ab      	strb	r3, [r5, #26]
   1467e:	76eb      	strb	r3, [r5, #27]
   14680:	f885 c014 	strb.w	ip, [r5, #20]
   14684:	7628      	strb	r0, [r5, #24]
   14686:	7669      	strb	r1, [r5, #25]
   14688:	2204      	movs	r2, #4
   1468a:	a903      	add	r1, sp, #12
   1468c:	6828      	ldr	r0, [r5, #0]
   1468e:	f007 fca9 	bl	1bfe4 <memcpy>
   14692:	f247 0103 	movw	r1, #28675	; 0x7003
   14696:	4628      	mov	r0, r5
   14698:	f7ff f80e 	bl	136b8 <rpc_ip_client_request_send>
   1469c:	4680      	mov	r8, r0
   1469e:	bb48      	cbnz	r0, 146f4 <ip_interface_setopt+0x130>
   146a0:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   146a4:	ab04      	add	r3, sp, #16
   146a6:	4611      	mov	r1, r2
   146a8:	4638      	mov	r0, r7
   146aa:	f004 fd9f 	bl	191ec <interface_socket_wait>
   146ae:	4605      	mov	r5, r0
   146b0:	b398      	cbz	r0, 1471a <ip_interface_setopt+0x156>
   146b2:	6026      	str	r6, [r4, #0]
   146b4:	e000      	b.n	146b8 <ip_interface_setopt+0xf4>
   146b6:	2523      	movs	r5, #35	; 0x23
   146b8:	4628      	mov	r0, r5
   146ba:	f7fb fcb7 	bl	1002c <bsd_os_errno_set>
   146be:	f04f 35ff 	mov.w	r5, #4294967295
   146c2:	4628      	mov	r0, r5
   146c4:	b006      	add	sp, #24
   146c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   146ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   146cc:	4642      	mov	r2, r8
   146ce:	9300      	str	r3, [sp, #0]
   146d0:	4631      	mov	r1, r6
   146d2:	462b      	mov	r3, r5
   146d4:	4638      	mov	r0, r7
   146d6:	f004 fe31 	bl	1933c <interface_socket_setopt>
   146da:	4605      	mov	r5, r0
   146dc:	4628      	mov	r0, r5
   146de:	b006      	add	sp, #24
   146e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   146e4:	9d05      	ldr	r5, [sp, #20]
   146e6:	2d00      	cmp	r5, #0
   146e8:	d1bd      	bne.n	14666 <ip_interface_setopt+0xa2>
   146ea:	6026      	str	r6, [r4, #0]
   146ec:	250c      	movs	r5, #12
   146ee:	e7e3      	b.n	146b8 <ip_interface_setopt+0xf4>
   146f0:	2509      	movs	r5, #9
   146f2:	e7e1      	b.n	146b8 <ip_interface_setopt+0xf4>
   146f4:	6828      	ldr	r0, [r5, #0]
   146f6:	b108      	cbz	r0, 146fc <ip_interface_setopt+0x138>
   146f8:	f7fe fffc 	bl	136f4 <rpc_ip_client_data_free>
   146fc:	4628      	mov	r0, r5
   146fe:	f7fe fff1 	bl	136e4 <rpc_ip_client_message_free>
   14702:	2523      	movs	r5, #35	; 0x23
   14704:	6026      	str	r6, [r4, #0]
   14706:	6026      	str	r6, [r4, #0]
   14708:	e7d6      	b.n	146b8 <ip_interface_setopt+0xf4>
   1470a:	202a      	movs	r0, #42	; 0x2a
   1470c:	f7fb fc8e 	bl	1002c <bsd_os_errno_set>
   14710:	f04f 35ff 	mov.w	r5, #4294967295
   14714:	e7d5      	b.n	146c2 <ip_interface_setopt+0xfe>
   14716:	250e      	movs	r5, #14
   14718:	e7ce      	b.n	146b8 <ip_interface_setopt+0xf4>
   1471a:	4638      	mov	r0, r7
   1471c:	f004 fde6 	bl	192ec <interface_socket_from_handle_get>
   14720:	b120      	cbz	r0, 1472c <ip_interface_setopt+0x168>
   14722:	6845      	ldr	r5, [r0, #4]
   14724:	b115      	cbz	r5, 1472c <ip_interface_setopt+0x168>
   14726:	f8c0 8004 	str.w	r8, [r0, #4]
   1472a:	e7c2      	b.n	146b2 <ip_interface_setopt+0xee>
   1472c:	6026      	str	r6, [r4, #0]
   1472e:	e7c8      	b.n	146c2 <ip_interface_setopt+0xfe>
   14730:	2009      	movs	r0, #9
   14732:	f7fb fc7b 	bl	1002c <bsd_os_errno_set>
   14736:	f04f 35ff 	mov.w	r5, #4294967295
   1473a:	e7c2      	b.n	146c2 <ip_interface_setopt+0xfe>

0001473c <ip_interface_getopt>:
   1473c:	f004 be44 	b.w	193c8 <interface_socket_getopt>

00014740 <ip_interface_getaddrinfo>:
   14740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14744:	f04f 0c00 	mov.w	ip, #0
   14748:	2401      	movs	r4, #1
   1474a:	4e72      	ldr	r6, [pc, #456]	; (14914 <ip_interface_getaddrinfo+0x1d4>)
   1474c:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 14920 <ip_interface_getaddrinfo+0x1e0>
   14750:	f8df 91d0 	ldr.w	r9, [pc, #464]	; 14924 <ip_interface_getaddrinfo+0x1e4>
   14754:	b085      	sub	sp, #20
   14756:	4607      	mov	r7, r0
   14758:	4615      	mov	r5, r2
   1475a:	9301      	str	r3, [sp, #4]
   1475c:	f8a6 c000 	strh.w	ip, [r6]
   14760:	f8ca 4000 	str.w	r4, [sl]
   14764:	f8c9 4000 	str.w	r4, [r9]
   14768:	b171      	cbz	r1, 14788 <ip_interface_getaddrinfo+0x48>
   1476a:	4608      	mov	r0, r1
   1476c:	220a      	movs	r2, #10
   1476e:	4661      	mov	r1, ip
   14770:	f007 fae9 	bl	1bd46 <strtol>
   14774:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   14778:	1e42      	subs	r2, r0, #1
   1477a:	429a      	cmp	r2, r3
   1477c:	f200 8083 	bhi.w	14886 <ip_interface_getaddrinfo+0x146>
   14780:	0203      	lsls	r3, r0, #8
   14782:	ea43 2020 	orr.w	r0, r3, r0, asr #8
   14786:	8030      	strh	r0, [r6, #0]
   14788:	f8df 819c 	ldr.w	r8, [pc, #412]	; 14928 <ip_interface_getaddrinfo+0x1e8>
   1478c:	f8d8 3000 	ldr.w	r3, [r8]
   14790:	2b00      	cmp	r3, #0
   14792:	d174      	bne.n	1487e <ip_interface_getaddrinfo+0x13e>
   14794:	4a60      	ldr	r2, [pc, #384]	; (14918 <ip_interface_getaddrinfo+0x1d8>)
   14796:	6013      	str	r3, [r2, #0]
   14798:	4a60      	ldr	r2, [pc, #384]	; (1491c <ip_interface_getaddrinfo+0x1dc>)
   1479a:	6013      	str	r3, [r2, #0]
   1479c:	2f00      	cmp	r7, #0
   1479e:	d062      	beq.n	14866 <ip_interface_getaddrinfo+0x126>
   147a0:	4638      	mov	r0, r7
   147a2:	f007 fbed 	bl	1bf80 <strlen>
   147a6:	4683      	mov	fp, r0
   147a8:	b125      	cbz	r5, 147b4 <ip_interface_getaddrinfo+0x74>
   147aa:	69ea      	ldr	r2, [r5, #28]
   147ac:	b112      	cbz	r2, 147b4 <ip_interface_getaddrinfo+0x74>
   147ae:	6851      	ldr	r1, [r2, #4]
   147b0:	2966      	cmp	r1, #102	; 0x66
   147b2:	d06c      	beq.n	1488e <ip_interface_getaddrinfo+0x14e>
   147b4:	f04f 32ff 	mov.w	r2, #4294967295
   147b8:	2100      	movs	r1, #0
   147ba:	ae04      	add	r6, sp, #16
   147bc:	f846 1d04 	str.w	r1, [r6, #-4]!
   147c0:	4630      	mov	r0, r6
   147c2:	4659      	mov	r1, fp
   147c4:	9200      	str	r2, [sp, #0]
   147c6:	f7fe ff63 	bl	13690 <rpc_ip_client_request_alloc>
   147ca:	9a00      	ldr	r2, [sp, #0]
   147cc:	2800      	cmp	r0, #0
   147ce:	d14c      	bne.n	1486a <ip_interface_getaddrinfo+0x12a>
   147d0:	f247 010d 	movw	r1, #28685	; 0x700d
   147d4:	f04f 0c08 	mov.w	ip, #8
   147d8:	9c03      	ldr	r4, [sp, #12]
   147da:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   147de:	60e1      	str	r1, [r4, #12]
   147e0:	6122      	str	r2, [r4, #16]
   147e2:	7260      	strb	r0, [r4, #9]
   147e4:	72a0      	strb	r0, [r4, #10]
   147e6:	72e0      	strb	r0, [r4, #11]
   147e8:	f884 c008 	strb.w	ip, [r4, #8]
   147ec:	2d00      	cmp	r5, #0
   147ee:	d076      	beq.n	148de <ip_interface_getaddrinfo+0x19e>
   147f0:	686a      	ldr	r2, [r5, #4]
   147f2:	f022 0108 	bic.w	r1, r2, #8
   147f6:	2902      	cmp	r1, #2
   147f8:	d05c      	beq.n	148b4 <ip_interface_getaddrinfo+0x174>
   147fa:	2a05      	cmp	r2, #5
   147fc:	d178      	bne.n	148f0 <ip_interface_getaddrinfo+0x1b0>
   147fe:	68a9      	ldr	r1, [r5, #8]
   14800:	2902      	cmp	r1, #2
   14802:	f8c9 1000 	str.w	r1, [r9]
   14806:	d061      	beq.n	148cc <ip_interface_getaddrinfo+0x18c>
   14808:	61a2      	str	r2, [r4, #24]
   1480a:	68ea      	ldr	r2, [r5, #12]
   1480c:	6222      	str	r2, [r4, #32]
   1480e:	68aa      	ldr	r2, [r5, #8]
   14810:	61e2      	str	r2, [r4, #28]
   14812:	682a      	ldr	r2, [r5, #0]
   14814:	6162      	str	r2, [r4, #20]
   14816:	68a2      	ldr	r2, [r4, #8]
   14818:	3210      	adds	r2, #16
   1481a:	60a2      	str	r2, [r4, #8]
   1481c:	b12f      	cbz	r7, 1482a <ip_interface_getaddrinfo+0xea>
   1481e:	6820      	ldr	r0, [r4, #0]
   14820:	b118      	cbz	r0, 1482a <ip_interface_getaddrinfo+0xea>
   14822:	465a      	mov	r2, fp
   14824:	4639      	mov	r1, r7
   14826:	f007 fbdd 	bl	1bfe4 <memcpy>
   1482a:	2301      	movs	r3, #1
   1482c:	f247 010d 	movw	r1, #28685	; 0x700d
   14830:	4620      	mov	r0, r4
   14832:	f8c8 3000 	str.w	r3, [r8]
   14836:	f7fe ff3f 	bl	136b8 <rpc_ip_client_request_send>
   1483a:	2800      	cmp	r0, #0
   1483c:	d156      	bne.n	148ec <ip_interface_getaddrinfo+0x1ac>
   1483e:	f04f 33ff 	mov.w	r3, #4294967295
   14842:	9303      	str	r3, [sp, #12]
   14844:	4631      	mov	r1, r6
   14846:	4620      	mov	r0, r4
   14848:	f7fb fb3a 	bl	fec0 <bsd_os_timedwait>
   1484c:	f8d8 3000 	ldr.w	r3, [r8]
   14850:	2b01      	cmp	r3, #1
   14852:	d0f7      	beq.n	14844 <ip_interface_getaddrinfo+0x104>
   14854:	4b31      	ldr	r3, [pc, #196]	; (1491c <ip_interface_getaddrinfo+0x1dc>)
   14856:	6818      	ldr	r0, [r3, #0]
   14858:	2800      	cmp	r0, #0
   1485a:	d13b      	bne.n	148d4 <ip_interface_getaddrinfo+0x194>
   1485c:	4b2e      	ldr	r3, [pc, #184]	; (14918 <ip_interface_getaddrinfo+0x1d8>)
   1485e:	9a01      	ldr	r2, [sp, #4]
   14860:	681b      	ldr	r3, [r3, #0]
   14862:	6013      	str	r3, [r2, #0]
   14864:	e00c      	b.n	14880 <ip_interface_getaddrinfo+0x140>
   14866:	46bb      	mov	fp, r7
   14868:	e79e      	b.n	147a8 <ip_interface_getaddrinfo+0x68>
   1486a:	9c03      	ldr	r4, [sp, #12]
   1486c:	2c00      	cmp	r4, #0
   1486e:	d1bd      	bne.n	147ec <ip_interface_getaddrinfo+0xac>
   14870:	200c      	movs	r0, #12
   14872:	2300      	movs	r3, #0
   14874:	f8c8 3000 	str.w	r3, [r8]
   14878:	b005      	add	sp, #20
   1487a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1487e:	2073      	movs	r0, #115	; 0x73
   14880:	b005      	add	sp, #20
   14882:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14886:	2016      	movs	r0, #22
   14888:	b005      	add	sp, #20
   1488a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1488e:	6891      	ldr	r1, [r2, #8]
   14890:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   14894:	d18e      	bne.n	147b4 <ip_interface_getaddrinfo+0x74>
   14896:	f240 2102 	movw	r1, #514	; 0x202
   1489a:	68d0      	ldr	r0, [r2, #12]
   1489c:	4288      	cmp	r0, r1
   1489e:	d189      	bne.n	147b4 <ip_interface_getaddrinfo+0x74>
   148a0:	6991      	ldr	r1, [r2, #24]
   148a2:	2900      	cmp	r1, #0
   148a4:	d086      	beq.n	147b4 <ip_interface_getaddrinfo+0x74>
   148a6:	6868      	ldr	r0, [r5, #4]
   148a8:	f002 fa8a 	bl	16dc0 <pdn_interface_pdn_id_get>
   148ac:	1c43      	adds	r3, r0, #1
   148ae:	d081      	beq.n	147b4 <ip_interface_getaddrinfo+0x74>
   148b0:	4602      	mov	r2, r0
   148b2:	e781      	b.n	147b8 <ip_interface_getaddrinfo+0x78>
   148b4:	68a9      	ldr	r1, [r5, #8]
   148b6:	2902      	cmp	r1, #2
   148b8:	f8c9 1000 	str.w	r1, [r9]
   148bc:	d006      	beq.n	148cc <ip_interface_getaddrinfo+0x18c>
   148be:	2a05      	cmp	r2, #5
   148c0:	d0a2      	beq.n	14808 <ip_interface_getaddrinfo+0xc8>
   148c2:	2a0a      	cmp	r2, #10
   148c4:	bf14      	ite	ne
   148c6:	2201      	movne	r2, #1
   148c8:	2202      	moveq	r2, #2
   148ca:	e79d      	b.n	14808 <ip_interface_getaddrinfo+0xc8>
   148cc:	2102      	movs	r1, #2
   148ce:	f8ca 1000 	str.w	r1, [sl]
   148d2:	e7f4      	b.n	148be <ip_interface_getaddrinfo+0x17e>
   148d4:	4b11      	ldr	r3, [pc, #68]	; (1491c <ip_interface_getaddrinfo+0x1dc>)
   148d6:	6818      	ldr	r0, [r3, #0]
   148d8:	2800      	cmp	r0, #0
   148da:	d0d1      	beq.n	14880 <ip_interface_getaddrinfo+0x140>
   148dc:	e7c9      	b.n	14872 <ip_interface_getaddrinfo+0x132>
   148de:	4629      	mov	r1, r5
   148e0:	2210      	movs	r2, #16
   148e2:	f104 0014 	add.w	r0, r4, #20
   148e6:	f007 fba8 	bl	1c03a <memset>
   148ea:	e794      	b.n	14816 <ip_interface_getaddrinfo+0xd6>
   148ec:	2023      	movs	r0, #35	; 0x23
   148ee:	e7c0      	b.n	14872 <ip_interface_getaddrinfo+0x132>
   148f0:	202f      	movs	r0, #47	; 0x2f
   148f2:	f7fb fb9b 	bl	1002c <bsd_os_errno_set>
   148f6:	68a2      	ldr	r2, [r4, #8]
   148f8:	3210      	adds	r2, #16
   148fa:	60a2      	str	r2, [r4, #8]
   148fc:	b917      	cbnz	r7, 14904 <ip_interface_getaddrinfo+0x1c4>
   148fe:	f04f 30ff 	mov.w	r0, #4294967295
   14902:	e7b6      	b.n	14872 <ip_interface_getaddrinfo+0x132>
   14904:	6820      	ldr	r0, [r4, #0]
   14906:	2800      	cmp	r0, #0
   14908:	d0f9      	beq.n	148fe <ip_interface_getaddrinfo+0x1be>
   1490a:	465a      	mov	r2, fp
   1490c:	4639      	mov	r1, r7
   1490e:	f007 fb69 	bl	1bfe4 <memcpy>
   14912:	e7f4      	b.n	148fe <ip_interface_getaddrinfo+0x1be>
   14914:	20022098 	.word	0x20022098
   14918:	20020774 	.word	0x20020774
   1491c:	2002076c 	.word	0x2002076c
   14920:	20020764 	.word	0x20020764
   14924:	20020768 	.word	0x20020768
   14928:	20020770 	.word	0x20020770

0001492c <ip_interface_freeaddrinfo>:
   1492c:	b538      	push	{r3, r4, r5, lr}
   1492e:	4d0b      	ldr	r5, [pc, #44]	; (1495c <ip_interface_freeaddrinfo+0x30>)
   14930:	682b      	ldr	r3, [r5, #0]
   14932:	2b02      	cmp	r3, #2
   14934:	d000      	beq.n	14938 <ip_interface_freeaddrinfo+0xc>
   14936:	bd38      	pop	{r3, r4, r5, pc}
   14938:	b150      	cbz	r0, 14950 <ip_interface_freeaddrinfo+0x24>
   1493a:	4604      	mov	r4, r0
   1493c:	6940      	ldr	r0, [r0, #20]
   1493e:	f004 f87b 	bl	18a38 <nrf_free>
   14942:	69a0      	ldr	r0, [r4, #24]
   14944:	b108      	cbz	r0, 1494a <ip_interface_freeaddrinfo+0x1e>
   14946:	f004 f877 	bl	18a38 <nrf_free>
   1494a:	4620      	mov	r0, r4
   1494c:	f004 f874 	bl	18a38 <nrf_free>
   14950:	2300      	movs	r3, #0
   14952:	4a03      	ldr	r2, [pc, #12]	; (14960 <ip_interface_freeaddrinfo+0x34>)
   14954:	602b      	str	r3, [r5, #0]
   14956:	6013      	str	r3, [r2, #0]
   14958:	bd38      	pop	{r3, r4, r5, pc}
   1495a:	bf00      	nop
   1495c:	20020770 	.word	0x20020770
   14960:	2002076c 	.word	0x2002076c

00014964 <rpc_ip_event_handler>:
   14964:	f248 030d 	movw	r3, #32781	; 0x800d
   14968:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1496c:	4299      	cmp	r1, r3
   1496e:	b089      	sub	sp, #36	; 0x24
   14970:	4604      	mov	r4, r0
   14972:	d062      	beq.n	14a3a <rpc_ip_event_handler+0xd6>
   14974:	f248 030f 	movw	r3, #32783	; 0x800f
   14978:	4299      	cmp	r1, r3
   1497a:	460d      	mov	r5, r1
   1497c:	d04b      	beq.n	14a16 <rpc_ip_event_handler+0xb2>
   1497e:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   14982:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   14986:	68c0      	ldr	r0, [r0, #12]
   14988:	d07b      	beq.n	14a82 <rpc_ip_event_handler+0x11e>
   1498a:	0c07      	lsrs	r7, r0, #16
   1498c:	4638      	mov	r0, r7
   1498e:	f004 fcad 	bl	192ec <interface_socket_from_handle_get>
   14992:	4606      	mov	r6, r0
   14994:	2800      	cmp	r0, #0
   14996:	d05f      	beq.n	14a58 <rpc_ip_event_handler+0xf4>
   14998:	4601      	mov	r1, r0
   1499a:	462b      	mov	r3, r5
   1499c:	4622      	mov	r2, r4
   1499e:	4638      	mov	r0, r7
   149a0:	f7fe fde4 	bl	1356c <tls_rpc_ip_event_handler>
   149a4:	2800      	cmp	r0, #0
   149a6:	d053      	beq.n	14a50 <rpc_ip_event_handler+0xec>
   149a8:	f248 0307 	movw	r3, #32775	; 0x8007
   149ac:	429d      	cmp	r5, r3
   149ae:	d97d      	bls.n	14aac <rpc_ip_event_handler+0x148>
   149b0:	f248 030c 	movw	r3, #32780	; 0x800c
   149b4:	429d      	cmp	r5, r3
   149b6:	d068      	beq.n	14a8a <rpc_ip_event_handler+0x126>
   149b8:	f240 8137 	bls.w	14c2a <rpc_ip_event_handler+0x2c6>
   149bc:	f249 0302 	movw	r3, #36866	; 0x9002
   149c0:	429d      	cmp	r5, r3
   149c2:	f000 819f 	beq.w	14d04 <rpc_ip_event_handler+0x3a0>
   149c6:	f249 0303 	movw	r3, #36867	; 0x9003
   149ca:	429d      	cmp	r5, r3
   149cc:	f000 81b2 	beq.w	14d34 <rpc_ip_event_handler+0x3d0>
   149d0:	f249 0301 	movw	r3, #36865	; 0x9001
   149d4:	429d      	cmp	r5, r3
   149d6:	d13f      	bne.n	14a58 <rpc_ip_event_handler+0xf4>
   149d8:	6835      	ldr	r5, [r6, #0]
   149da:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   149de:	f000 81d3 	beq.w	14d88 <rpc_ip_event_handler+0x424>
   149e2:	68a3      	ldr	r3, [r4, #8]
   149e4:	2b04      	cmp	r3, #4
   149e6:	f200 8207 	bhi.w	14df8 <rpc_ip_event_handler+0x494>
   149ea:	2500      	movs	r5, #0
   149ec:	462f      	mov	r7, r5
   149ee:	6821      	ldr	r1, [r4, #0]
   149f0:	6862      	ldr	r2, [r4, #4]
   149f2:	e9cd 7506 	strd	r7, r5, [sp, #24]
   149f6:	e9cd 1204 	strd	r1, r2, [sp, #16]
   149fa:	69f0      	ldr	r0, [r6, #28]
   149fc:	a904      	add	r1, sp, #16
   149fe:	6803      	ldr	r3, [r0, #0]
   14a00:	685b      	ldr	r3, [r3, #4]
   14a02:	4798      	blx	r3
   14a04:	3001      	adds	r0, #1
   14a06:	f000 81de 	beq.w	14dc6 <rpc_ip_event_handler+0x462>
   14a0a:	6833      	ldr	r3, [r6, #0]
   14a0c:	2000      	movs	r0, #0
   14a0e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   14a12:	6033      	str	r3, [r6, #0]
   14a14:	e00e      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14a16:	6943      	ldr	r3, [r0, #20]
   14a18:	2001      	movs	r0, #1
   14a1a:	2b10      	cmp	r3, #16
   14a1c:	49bc      	ldr	r1, [pc, #752]	; (14d10 <rpc_ip_event_handler+0x3ac>)
   14a1e:	bf88      	it	hi
   14a20:	222d      	movhi	r2, #45	; 0x2d
   14a22:	7008      	strb	r0, [r1, #0]
   14a24:	f04f 0000 	mov.w	r0, #0
   14a28:	bf9c      	itt	ls
   14a2a:	4aba      	ldrls	r2, [pc, #744]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14a2c:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
   14a30:	4bb9      	ldr	r3, [pc, #740]	; (14d18 <rpc_ip_event_handler+0x3b4>)
   14a32:	601a      	str	r2, [r3, #0]
   14a34:	b009      	add	sp, #36	; 0x24
   14a36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14a3a:	f8df a2f0 	ldr.w	sl, [pc, #752]	; 14d2c <rpc_ip_event_handler+0x3c8>
   14a3e:	6807      	ldr	r7, [r0, #0]
   14a40:	f8da 2000 	ldr.w	r2, [sl]
   14a44:	2a01      	cmp	r2, #1
   14a46:	d00b      	beq.n	14a60 <rpc_ip_event_handler+0xfc>
   14a48:	b117      	cbz	r7, 14a50 <rpc_ip_event_handler+0xec>
   14a4a:	4638      	mov	r0, r7
   14a4c:	f7fe fe52 	bl	136f4 <rpc_ip_client_data_free>
   14a50:	2000      	movs	r0, #0
   14a52:	b009      	add	sp, #36	; 0x24
   14a54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14a58:	6820      	ldr	r0, [r4, #0]
   14a5a:	2800      	cmp	r0, #0
   14a5c:	d1f6      	bne.n	14a4c <rpc_ip_event_handler+0xe8>
   14a5e:	e7f7      	b.n	14a50 <rpc_ip_event_handler+0xec>
   14a60:	6942      	ldr	r2, [r0, #20]
   14a62:	2a00      	cmp	r2, #0
   14a64:	d046      	beq.n	14af4 <rpc_ip_event_handler+0x190>
   14a66:	2a10      	cmp	r2, #16
   14a68:	bf8e      	itee	hi
   14a6a:	222d      	movhi	r2, #45	; 0x2d
   14a6c:	49a9      	ldrls	r1, [pc, #676]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14a6e:	f851 2022 	ldrls.w	r2, [r1, r2, lsl #2]
   14a72:	49aa      	ldr	r1, [pc, #680]	; (14d1c <rpc_ip_event_handler+0x3b8>)
   14a74:	600a      	str	r2, [r1, #0]
   14a76:	2202      	movs	r2, #2
   14a78:	f8ca 2000 	str.w	r2, [sl]
   14a7c:	2f00      	cmp	r7, #0
   14a7e:	d1e4      	bne.n	14a4a <rpc_ip_event_handler+0xe6>
   14a80:	e7e6      	b.n	14a50 <rpc_ip_event_handler+0xec>
   14a82:	f004 fbe1 	bl	19248 <interface_from_internal_id_search>
   14a86:	4607      	mov	r7, r0
   14a88:	e780      	b.n	1498c <rpc_ip_event_handler+0x28>
   14a8a:	6833      	ldr	r3, [r6, #0]
   14a8c:	b29b      	uxth	r3, r3
   14a8e:	2b08      	cmp	r3, #8
   14a90:	d1de      	bne.n	14a50 <rpc_ip_event_handler+0xec>
   14a92:	6963      	ldr	r3, [r4, #20]
   14a94:	2b00      	cmp	r3, #0
   14a96:	f000 8198 	beq.w	14dca <rpc_ip_event_handler+0x466>
   14a9a:	2b10      	cmp	r3, #16
   14a9c:	f200 8169 	bhi.w	14d72 <rpc_ip_event_handler+0x40e>
   14aa0:	4a9c      	ldr	r2, [pc, #624]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14aa2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14aa6:	6073      	str	r3, [r6, #4]
   14aa8:	2000      	movs	r0, #0
   14aaa:	e7c3      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14aac:	f248 0306 	movw	r3, #32774	; 0x8006
   14ab0:	429d      	cmp	r5, r3
   14ab2:	f080 80fc 	bcs.w	14cae <rpc_ip_event_handler+0x34a>
   14ab6:	f248 0302 	movw	r3, #32770	; 0x8002
   14aba:	429d      	cmp	r5, r3
   14abc:	f000 80df 	beq.w	14c7e <rpc_ip_event_handler+0x31a>
   14ac0:	f240 80cc 	bls.w	14c5c <rpc_ip_event_handler+0x2f8>
   14ac4:	f248 0303 	movw	r3, #32771	; 0x8003
   14ac8:	429d      	cmp	r5, r3
   14aca:	f000 810f 	beq.w	14cec <rpc_ip_event_handler+0x388>
   14ace:	f248 0305 	movw	r3, #32773	; 0x8005
   14ad2:	429d      	cmp	r5, r3
   14ad4:	d1c0      	bne.n	14a58 <rpc_ip_event_handler+0xf4>
   14ad6:	6833      	ldr	r3, [r6, #0]
   14ad8:	b29b      	uxth	r3, r3
   14ada:	2b03      	cmp	r3, #3
   14adc:	d1b8      	bne.n	14a50 <rpc_ip_event_handler+0xec>
   14ade:	6963      	ldr	r3, [r4, #20]
   14ae0:	2b00      	cmp	r3, #0
   14ae2:	d1da      	bne.n	14a9a <rpc_ip_event_handler+0x136>
   14ae4:	6833      	ldr	r3, [r6, #0]
   14ae6:	2000      	movs	r0, #0
   14ae8:	0c1b      	lsrs	r3, r3, #16
   14aea:	041b      	lsls	r3, r3, #16
   14aec:	f043 0304 	orr.w	r3, r3, #4
   14af0:	6033      	str	r3, [r6, #0]
   14af2:	e79f      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14af4:	6985      	ldr	r5, [r0, #24]
   14af6:	016b      	lsls	r3, r5, #5
   14af8:	4618      	mov	r0, r3
   14afa:	9303      	str	r3, [sp, #12]
   14afc:	f003 ff92 	bl	18a24 <nrf_malloc>
   14b00:	9002      	str	r0, [sp, #8]
   14b02:	2800      	cmp	r0, #0
   14b04:	f000 808a 	beq.w	14c1c <rpc_ip_event_handler+0x2b8>
   14b08:	00ee      	lsls	r6, r5, #3
   14b0a:	1970      	adds	r0, r6, r5
   14b0c:	0080      	lsls	r0, r0, #2
   14b0e:	f003 ff89 	bl	18a24 <nrf_malloc>
   14b12:	2800      	cmp	r0, #0
   14b14:	f000 8084 	beq.w	14c20 <rpc_ip_event_handler+0x2bc>
   14b18:	2d00      	cmp	r5, #0
   14b1a:	f000 8084 	beq.w	14c26 <rpc_ip_event_handler+0x2c2>
   14b1e:	2204      	movs	r2, #4
   14b20:	3610      	adds	r6, #16
   14b22:	1983      	adds	r3, r0, r6
   14b24:	9301      	str	r3, [sp, #4]
   14b26:	9b02      	ldr	r3, [sp, #8]
   14b28:	f8df b204 	ldr.w	fp, [pc, #516]	; 14d30 <rpc_ip_event_handler+0x3cc>
   14b2c:	f100 0810 	add.w	r8, r0, #16
   14b30:	f103 0520 	add.w	r5, r3, #32
   14b34:	58bb      	ldr	r3, [r7, r2]
   14b36:	18b9      	adds	r1, r7, r2
   14b38:	f845 3c20 	str.w	r3, [r5, #-32]
   14b3c:	684b      	ldr	r3, [r1, #4]
   14b3e:	f8db 0000 	ldr.w	r0, [fp]
   14b42:	2b02      	cmp	r3, #2
   14b44:	bf14      	ite	ne
   14b46:	2602      	movne	r6, #2
   14b48:	260a      	moveq	r6, #10
   14b4a:	4b75      	ldr	r3, [pc, #468]	; (14d20 <rpc_ip_event_handler+0x3bc>)
   14b4c:	e945 6007 	strd	r6, r0, [r5, #-28]
   14b50:	681b      	ldr	r3, [r3, #0]
   14b52:	f102 0614 	add.w	r6, r2, #20
   14b56:	f845 3c14 	str.w	r3, [r5, #-20]
   14b5a:	8a08      	ldrh	r0, [r1, #16]
   14b5c:	f1a8 0310 	sub.w	r3, r8, #16
   14b60:	f845 0c10 	str.w	r0, [r5, #-16]
   14b64:	f8b1 9012 	ldrh.w	r9, [r1, #18]
   14b68:	f845 3c0c 	str.w	r3, [r5, #-12]
   14b6c:	4b6d      	ldr	r3, [pc, #436]	; (14d24 <rpc_ip_event_handler+0x3c0>)
   14b6e:	2804      	cmp	r0, #4
   14b70:	eb07 0106 	add.w	r1, r7, r6
   14b74:	881b      	ldrh	r3, [r3, #0]
   14b76:	d042      	beq.n	14bfe <rpc_ip_event_handler+0x29a>
   14b78:	220a      	movs	r2, #10
   14b7a:	f848 2c0c 	str.w	r2, [r8, #-12]
   14b7e:	f04f 0224 	mov.w	r2, #36	; 0x24
   14b82:	f828 3c08 	strh.w	r3, [r8, #-8]
   14b86:	f808 2c10 	strb.w	r2, [r8, #-16]
   14b8a:	f855 2c10 	ldr.w	r2, [r5, #-16]
   14b8e:	4640      	mov	r0, r8
   14b90:	f007 fa28 	bl	1bfe4 <memcpy>
   14b94:	f855 3c10 	ldr.w	r3, [r5, #-16]
   14b98:	f109 0001 	add.w	r0, r9, #1
   14b9c:	441e      	add	r6, r3
   14b9e:	f003 ff41 	bl	18a24 <nrf_malloc>
   14ba2:	19b9      	adds	r1, r7, r6
   14ba4:	eb09 0206 	add.w	r2, r9, r6
   14ba8:	f845 0c08 	str.w	r0, [r5, #-8]
   14bac:	b1e8      	cbz	r0, 14bea <rpc_ip_event_handler+0x286>
   14bae:	464a      	mov	r2, r9
   14bb0:	f007 fa18 	bl	1bfe4 <memcpy>
   14bb4:	2100      	movs	r1, #0
   14bb6:	f855 3c08 	ldr.w	r3, [r5, #-8]
   14bba:	f108 0808 	add.w	r8, r8, #8
   14bbe:	f803 1009 	strb.w	r1, [r3, r9]
   14bc2:	9b01      	ldr	r3, [sp, #4]
   14bc4:	f845 5c04 	str.w	r5, [r5, #-4]
   14bc8:	4598      	cmp	r8, r3
   14bca:	eb09 0206 	add.w	r2, r9, r6
   14bce:	f105 0520 	add.w	r5, r5, #32
   14bd2:	d1af      	bne.n	14b34 <rpc_ip_event_handler+0x1d0>
   14bd4:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
   14bd8:	2100      	movs	r1, #0
   14bda:	4403      	add	r3, r0
   14bdc:	f843 1c04 	str.w	r1, [r3, #-4]
   14be0:	4603      	mov	r3, r0
   14be2:	4a51      	ldr	r2, [pc, #324]	; (14d28 <rpc_ip_event_handler+0x3c4>)
   14be4:	6827      	ldr	r7, [r4, #0]
   14be6:	6013      	str	r3, [r2, #0]
   14be8:	e745      	b.n	14a76 <rpc_ip_event_handler+0x112>
   14bea:	9b01      	ldr	r3, [sp, #4]
   14bec:	f108 0808 	add.w	r8, r8, #8
   14bf0:	4543      	cmp	r3, r8
   14bf2:	f845 5c04 	str.w	r5, [r5, #-4]
   14bf6:	f105 0520 	add.w	r5, r5, #32
   14bfa:	d19b      	bne.n	14b34 <rpc_ip_event_handler+0x1d0>
   14bfc:	e7ea      	b.n	14bd4 <rpc_ip_event_handler+0x270>
   14bfe:	2210      	movs	r2, #16
   14c00:	2002      	movs	r0, #2
   14c02:	f828 3c08 	strh.w	r3, [r8, #-8]
   14c06:	f848 0c0c 	str.w	r0, [r8, #-12]
   14c0a:	f808 2c10 	strb.w	r2, [r8, #-16]
   14c0e:	f855 2c10 	ldr.w	r2, [r5, #-16]
   14c12:	f1a8 0004 	sub.w	r0, r8, #4
   14c16:	f007 f9e5 	bl	1bfe4 <memcpy>
   14c1a:	e7bb      	b.n	14b94 <rpc_ip_event_handler+0x230>
   14c1c:	f003 ff0c 	bl	18a38 <nrf_free>
   14c20:	210c      	movs	r1, #12
   14c22:	4a3e      	ldr	r2, [pc, #248]	; (14d1c <rpc_ip_event_handler+0x3b8>)
   14c24:	6011      	str	r1, [r2, #0]
   14c26:	9b02      	ldr	r3, [sp, #8]
   14c28:	e7db      	b.n	14be2 <rpc_ip_event_handler+0x27e>
   14c2a:	f248 0308 	movw	r3, #32776	; 0x8008
   14c2e:	429d      	cmp	r5, r3
   14c30:	d04d      	beq.n	14cce <rpc_ip_event_handler+0x36a>
   14c32:	f248 0309 	movw	r3, #32777	; 0x8009
   14c36:	429d      	cmp	r5, r3
   14c38:	f47f af0e 	bne.w	14a58 <rpc_ip_event_handler+0xf4>
   14c3c:	6833      	ldr	r3, [r6, #0]
   14c3e:	b29b      	uxth	r3, r3
   14c40:	2b0d      	cmp	r3, #13
   14c42:	f47f af05 	bne.w	14a50 <rpc_ip_event_handler+0xec>
   14c46:	6960      	ldr	r0, [r4, #20]
   14c48:	2800      	cmp	r0, #0
   14c4a:	f000 80c9 	beq.w	14de0 <rpc_ip_event_handler+0x47c>
   14c4e:	2810      	cmp	r0, #16
   14c50:	f200 808f 	bhi.w	14d72 <rpc_ip_event_handler+0x40e>
   14c54:	4b2f      	ldr	r3, [pc, #188]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14c56:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   14c5a:	e724      	b.n	14aa6 <rpc_ip_event_handler+0x142>
   14c5c:	f248 0301 	movw	r3, #32769	; 0x8001
   14c60:	429d      	cmp	r5, r3
   14c62:	f47f aef9 	bne.w	14a58 <rpc_ip_event_handler+0xf4>
   14c66:	6833      	ldr	r3, [r6, #0]
   14c68:	2b01      	cmp	r3, #1
   14c6a:	f47f aef1 	bne.w	14a50 <rpc_ip_event_handler+0xec>
   14c6e:	6960      	ldr	r0, [r4, #20]
   14c70:	2800      	cmp	r0, #0
   14c72:	d1ec      	bne.n	14c4e <rpc_ip_event_handler+0x2ea>
   14c74:	2302      	movs	r3, #2
   14c76:	6033      	str	r3, [r6, #0]
   14c78:	69a3      	ldr	r3, [r4, #24]
   14c7a:	61b3      	str	r3, [r6, #24]
   14c7c:	e6da      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14c7e:	6833      	ldr	r3, [r6, #0]
   14c80:	0099      	lsls	r1, r3, #2
   14c82:	f57f aee5 	bpl.w	14a50 <rpc_ip_event_handler+0xec>
   14c86:	6833      	ldr	r3, [r6, #0]
   14c88:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   14c8c:	6033      	str	r3, [r6, #0]
   14c8e:	6960      	ldr	r0, [r4, #20]
   14c90:	2800      	cmp	r0, #0
   14c92:	d07e      	beq.n	14d92 <rpc_ip_event_handler+0x42e>
   14c94:	2810      	cmp	r0, #16
   14c96:	f200 8094 	bhi.w	14dc2 <rpc_ip_event_handler+0x45e>
   14c9a:	4b1e      	ldr	r3, [pc, #120]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14c9c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   14ca0:	6073      	str	r3, [r6, #4]
   14ca2:	6833      	ldr	r3, [r6, #0]
   14ca4:	2000      	movs	r0, #0
   14ca6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   14caa:	6033      	str	r3, [r6, #0]
   14cac:	e6c2      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14cae:	6833      	ldr	r3, [r6, #0]
   14cb0:	029a      	lsls	r2, r3, #10
   14cb2:	f57f aecd 	bpl.w	14a50 <rpc_ip_event_handler+0xec>
   14cb6:	6963      	ldr	r3, [r4, #20]
   14cb8:	2b00      	cmp	r3, #0
   14cba:	d079      	beq.n	14db0 <rpc_ip_event_handler+0x44c>
   14cbc:	2b6b      	cmp	r3, #107	; 0x6b
   14cbe:	f000 8096 	beq.w	14dee <rpc_ip_event_handler+0x48a>
   14cc2:	2b10      	cmp	r3, #16
   14cc4:	d87d      	bhi.n	14dc2 <rpc_ip_event_handler+0x45e>
   14cc6:	4a13      	ldr	r2, [pc, #76]	; (14d14 <rpc_ip_event_handler+0x3b0>)
   14cc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ccc:	e7e8      	b.n	14ca0 <rpc_ip_event_handler+0x33c>
   14cce:	6833      	ldr	r3, [r6, #0]
   14cd0:	b29b      	uxth	r3, r3
   14cd2:	2b06      	cmp	r3, #6
   14cd4:	f47f aebc 	bne.w	14a50 <rpc_ip_event_handler+0xec>
   14cd8:	6960      	ldr	r0, [r4, #20]
   14cda:	2800      	cmp	r0, #0
   14cdc:	d1b7      	bne.n	14c4e <rpc_ip_event_handler+0x2ea>
   14cde:	6833      	ldr	r3, [r6, #0]
   14ce0:	0c1b      	lsrs	r3, r3, #16
   14ce2:	041b      	lsls	r3, r3, #16
   14ce4:	f043 0307 	orr.w	r3, r3, #7
   14ce8:	6033      	str	r3, [r6, #0]
   14cea:	e6a3      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14cec:	6833      	ldr	r3, [r6, #0]
   14cee:	025b      	lsls	r3, r3, #9
   14cf0:	f57f aeae 	bpl.w	14a50 <rpc_ip_event_handler+0xec>
   14cf4:	6960      	ldr	r0, [r4, #20]
   14cf6:	2800      	cmp	r0, #0
   14cf8:	d1a9      	bne.n	14c4e <rpc_ip_event_handler+0x2ea>
   14cfa:	6833      	ldr	r3, [r6, #0]
   14cfc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   14d00:	6033      	str	r3, [r6, #0]
   14d02:	e697      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14d04:	6833      	ldr	r3, [r6, #0]
   14d06:	b29b      	uxth	r3, r3
   14d08:	2b07      	cmp	r3, #7
   14d0a:	f47f aea1 	bne.w	14a50 <rpc_ip_event_handler+0xec>
   14d0e:	e67c      	b.n	14a0a <rpc_ip_event_handler+0xa6>
   14d10:	2002366d 	.word	0x2002366d
   14d14:	0001de00 	.word	0x0001de00
   14d18:	2002079c 	.word	0x2002079c
   14d1c:	2002076c 	.word	0x2002076c
   14d20:	20020764 	.word	0x20020764
   14d24:	20022098 	.word	0x20022098
   14d28:	20020774 	.word	0x20020774
   14d2c:	20020770 	.word	0x20020770
   14d30:	20020768 	.word	0x20020768
   14d34:	6833      	ldr	r3, [r6, #0]
   14d36:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   14d3a:	6033      	str	r3, [r6, #0]
   14d3c:	6833      	ldr	r3, [r6, #0]
   14d3e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   14d42:	6033      	str	r3, [r6, #0]
   14d44:	6833      	ldr	r3, [r6, #0]
   14d46:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   14d4a:	6033      	str	r3, [r6, #0]
   14d4c:	6833      	ldr	r3, [r6, #0]
   14d4e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   14d52:	6033      	str	r3, [r6, #0]
   14d54:	6923      	ldr	r3, [r4, #16]
   14d56:	2b6c      	cmp	r3, #108	; 0x6c
   14d58:	d00d      	beq.n	14d76 <rpc_ip_event_handler+0x412>
   14d5a:	2b10      	cmp	r3, #16
   14d5c:	bf8c      	ite	hi
   14d5e:	232d      	movhi	r3, #45	; 0x2d
   14d60:	4a41      	ldrls	r2, [pc, #260]	; (14e68 <rpc_ip_event_handler+0x504>)
   14d62:	f04f 0000 	mov.w	r0, #0
   14d66:	bf98      	it	ls
   14d68:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   14d6c:	6073      	str	r3, [r6, #4]
   14d6e:	60b3      	str	r3, [r6, #8]
   14d70:	e660      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14d72:	232d      	movs	r3, #45	; 0x2d
   14d74:	e697      	b.n	14aa6 <rpc_ip_event_handler+0x142>
   14d76:	2239      	movs	r2, #57	; 0x39
   14d78:	6833      	ldr	r3, [r6, #0]
   14d7a:	2000      	movs	r0, #0
   14d7c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14d80:	6033      	str	r3, [r6, #0]
   14d82:	6072      	str	r2, [r6, #4]
   14d84:	60b2      	str	r2, [r6, #8]
   14d86:	e655      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14d88:	6820      	ldr	r0, [r4, #0]
   14d8a:	f7fe fcb3 	bl	136f4 <rpc_ip_client_data_free>
   14d8e:	4628      	mov	r0, r5
   14d90:	e650      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14d92:	6833      	ldr	r3, [r6, #0]
   14d94:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   14d98:	6033      	str	r3, [r6, #0]
   14d9a:	6833      	ldr	r3, [r6, #0]
   14d9c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   14da0:	6033      	str	r3, [r6, #0]
   14da2:	6833      	ldr	r3, [r6, #0]
   14da4:	0c1b      	lsrs	r3, r3, #16
   14da6:	041b      	lsls	r3, r3, #16
   14da8:	f043 0305 	orr.w	r3, r3, #5
   14dac:	6033      	str	r3, [r6, #0]
   14dae:	e641      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14db0:	6833      	ldr	r3, [r6, #0]
   14db2:	4a2e      	ldr	r2, [pc, #184]	; (14e6c <rpc_ip_event_handler+0x508>)
   14db4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   14db8:	6033      	str	r3, [r6, #0]
   14dba:	2001      	movs	r0, #1
   14dbc:	f842 4027 	str.w	r4, [r2, r7, lsl #2]
   14dc0:	e638      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14dc2:	232d      	movs	r3, #45	; 0x2d
   14dc4:	e76c      	b.n	14ca0 <rpc_ip_event_handler+0x33c>
   14dc6:	2002      	movs	r0, #2
   14dc8:	e634      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14dca:	4b28      	ldr	r3, [pc, #160]	; (14e6c <rpc_ip_event_handler+0x508>)
   14dcc:	2001      	movs	r0, #1
   14dce:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
   14dd2:	6833      	ldr	r3, [r6, #0]
   14dd4:	0c1b      	lsrs	r3, r3, #16
   14dd6:	041b      	lsls	r3, r3, #16
   14dd8:	f043 0309 	orr.w	r3, r3, #9
   14ddc:	6033      	str	r3, [r6, #0]
   14dde:	e629      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14de0:	6833      	ldr	r3, [r6, #0]
   14de2:	0c1b      	lsrs	r3, r3, #16
   14de4:	041b      	lsls	r3, r3, #16
   14de6:	f043 030e 	orr.w	r3, r3, #14
   14dea:	6033      	str	r3, [r6, #0]
   14dec:	e622      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14dee:	6933      	ldr	r3, [r6, #16]
   14df0:	2b01      	cmp	r3, #1
   14df2:	d005      	beq.n	14e00 <rpc_ip_event_handler+0x49c>
   14df4:	230c      	movs	r3, #12
   14df6:	e753      	b.n	14ca0 <rpc_ip_event_handler+0x33c>
   14df8:	8a65      	ldrh	r5, [r4, #18]
   14dfa:	b94d      	cbnz	r5, 14e10 <rpc_ip_event_handler+0x4ac>
   14dfc:	462f      	mov	r7, r5
   14dfe:	e5f6      	b.n	149ee <rpc_ip_event_handler+0x8a>
   14e00:	220c      	movs	r2, #12
   14e02:	6833      	ldr	r3, [r6, #0]
   14e04:	2000      	movs	r0, #0
   14e06:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   14e0a:	6033      	str	r3, [r6, #0]
   14e0c:	6072      	str	r2, [r6, #4]
   14e0e:	e611      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14e10:	2024      	movs	r0, #36	; 0x24
   14e12:	f003 fe07 	bl	18a24 <nrf_malloc>
   14e16:	4607      	mov	r7, r0
   14e18:	2800      	cmp	r0, #0
   14e1a:	d0d4      	beq.n	14dc6 <rpc_ip_event_handler+0x462>
   14e1c:	8a62      	ldrh	r2, [r4, #18]
   14e1e:	2a10      	cmp	r2, #16
   14e20:	d015      	beq.n	14e4e <rpc_ip_event_handler+0x4ea>
   14e22:	2a04      	cmp	r2, #4
   14e24:	d007      	beq.n	14e36 <rpc_ip_event_handler+0x4d2>
   14e26:	6820      	ldr	r0, [r4, #0]
   14e28:	f7fe fc64 	bl	136f4 <rpc_ip_client_data_free>
   14e2c:	4638      	mov	r0, r7
   14e2e:	f003 fe03 	bl	18a38 <nrf_free>
   14e32:	2000      	movs	r0, #0
   14e34:	e5fe      	b.n	14a34 <rpc_ip_event_handler+0xd0>
   14e36:	2302      	movs	r3, #2
   14e38:	2510      	movs	r5, #16
   14e3a:	6043      	str	r3, [r0, #4]
   14e3c:	7005      	strb	r5, [r0, #0]
   14e3e:	8a23      	ldrh	r3, [r4, #16]
   14e40:	f104 0114 	add.w	r1, r4, #20
   14e44:	8103      	strh	r3, [r0, #8]
   14e46:	300c      	adds	r0, #12
   14e48:	f007 f8cc 	bl	1bfe4 <memcpy>
   14e4c:	e5cf      	b.n	149ee <rpc_ip_event_handler+0x8a>
   14e4e:	230a      	movs	r3, #10
   14e50:	2524      	movs	r5, #36	; 0x24
   14e52:	6043      	str	r3, [r0, #4]
   14e54:	7005      	strb	r5, [r0, #0]
   14e56:	8a23      	ldrh	r3, [r4, #16]
   14e58:	f104 0114 	add.w	r1, r4, #20
   14e5c:	8103      	strh	r3, [r0, #8]
   14e5e:	3010      	adds	r0, #16
   14e60:	f007 f8c0 	bl	1bfe4 <memcpy>
   14e64:	e5c3      	b.n	149ee <rpc_ip_event_handler+0x8a>
   14e66:	bf00      	nop
   14e68:	0001de00 	.word	0x0001de00
   14e6c:	20020778 	.word	0x20020778

00014e70 <rpc_handle_ctrl_message>:
   14e70:	2902      	cmp	r1, #2
   14e72:	b510      	push	{r4, lr}
   14e74:	4604      	mov	r4, r0
   14e76:	d00c      	beq.n	14e92 <rpc_handle_ctrl_message+0x22>
   14e78:	2904      	cmp	r1, #4
   14e7a:	d008      	beq.n	14e8e <rpc_handle_ctrl_message+0x1e>
   14e7c:	2901      	cmp	r1, #1
   14e7e:	d006      	beq.n	14e8e <rpc_handle_ctrl_message+0x1e>
   14e80:	6880      	ldr	r0, [r0, #8]
   14e82:	b108      	cbz	r0, 14e88 <rpc_handle_ctrl_message+0x18>
   14e84:	f7fc ff76 	bl	11d74 <rpc_transport_data_free>
   14e88:	4620      	mov	r0, r4
   14e8a:	f7fc ff71 	bl	11d70 <rpc_transport_rpc_free>
   14e8e:	2000      	movs	r0, #0
   14e90:	bd10      	pop	{r4, pc}
   14e92:	6880      	ldr	r0, [r0, #8]
   14e94:	2800      	cmp	r0, #0
   14e96:	d0fa      	beq.n	14e8e <rpc_handle_ctrl_message+0x1e>
   14e98:	f7fc ff6c 	bl	11d74 <rpc_transport_data_free>
   14e9c:	2000      	movs	r0, #0
   14e9e:	bd10      	pop	{r4, pc}

00014ea0 <rpc_handle_data_message>:
   14ea0:	4b23      	ldr	r3, [pc, #140]	; (14f30 <rpc_handle_data_message+0x90>)
   14ea2:	6802      	ldr	r2, [r0, #0]
   14ea4:	8819      	ldrh	r1, [r3, #0]
   14ea6:	b292      	uxth	r2, r2
   14ea8:	4291      	cmp	r1, r2
   14eaa:	d027      	beq.n	14efc <rpc_handle_data_message+0x5c>
   14eac:	8a19      	ldrh	r1, [r3, #16]
   14eae:	4291      	cmp	r1, r2
   14eb0:	d02a      	beq.n	14f08 <rpc_handle_data_message+0x68>
   14eb2:	8c19      	ldrh	r1, [r3, #32]
   14eb4:	4291      	cmp	r1, r2
   14eb6:	d02b      	beq.n	14f10 <rpc_handle_data_message+0x70>
   14eb8:	8e19      	ldrh	r1, [r3, #48]	; 0x30
   14eba:	4291      	cmp	r1, r2
   14ebc:	d02a      	beq.n	14f14 <rpc_handle_data_message+0x74>
   14ebe:	f8b3 1040 	ldrh.w	r1, [r3, #64]	; 0x40
   14ec2:	4291      	cmp	r1, r2
   14ec4:	d028      	beq.n	14f18 <rpc_handle_data_message+0x78>
   14ec6:	f8b3 1050 	ldrh.w	r1, [r3, #80]	; 0x50
   14eca:	4291      	cmp	r1, r2
   14ecc:	d026      	beq.n	14f1c <rpc_handle_data_message+0x7c>
   14ece:	f8b3 1060 	ldrh.w	r1, [r3, #96]	; 0x60
   14ed2:	4291      	cmp	r1, r2
   14ed4:	d026      	beq.n	14f24 <rpc_handle_data_message+0x84>
   14ed6:	f8b3 1070 	ldrh.w	r1, [r3, #112]	; 0x70
   14eda:	4291      	cmp	r1, r2
   14edc:	d024      	beq.n	14f28 <rpc_handle_data_message+0x88>
   14ede:	f8b3 1080 	ldrh.w	r1, [r3, #128]	; 0x80
   14ee2:	4291      	cmp	r1, r2
   14ee4:	d01c      	beq.n	14f20 <rpc_handle_data_message+0x80>
   14ee6:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
   14eea:	4291      	cmp	r1, r2
   14eec:	d01e      	beq.n	14f2c <rpc_handle_data_message+0x8c>
   14eee:	6880      	ldr	r0, [r0, #8]
   14ef0:	b160      	cbz	r0, 14f0c <rpc_handle_data_message+0x6c>
   14ef2:	b510      	push	{r4, lr}
   14ef4:	f7fc ff3e 	bl	11d74 <rpc_transport_data_free>
   14ef8:	2000      	movs	r0, #0
   14efa:	bd10      	pop	{r4, pc}
   14efc:	2200      	movs	r2, #0
   14efe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   14f02:	685a      	ldr	r2, [r3, #4]
   14f04:	68d9      	ldr	r1, [r3, #12]
   14f06:	4710      	bx	r2
   14f08:	2201      	movs	r2, #1
   14f0a:	e7f8      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f0c:	2000      	movs	r0, #0
   14f0e:	4770      	bx	lr
   14f10:	2202      	movs	r2, #2
   14f12:	e7f4      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f14:	2203      	movs	r2, #3
   14f16:	e7f2      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f18:	2204      	movs	r2, #4
   14f1a:	e7f0      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f1c:	2205      	movs	r2, #5
   14f1e:	e7ee      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f20:	2208      	movs	r2, #8
   14f22:	e7ec      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f24:	2206      	movs	r2, #6
   14f26:	e7ea      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f28:	2207      	movs	r2, #7
   14f2a:	e7e8      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f2c:	2209      	movs	r2, #9
   14f2e:	e7e6      	b.n	14efe <rpc_handle_data_message+0x5e>
   14f30:	200207a0 	.word	0x200207a0

00014f34 <rpc_framework_init>:
   14f34:	b508      	push	{r3, lr}
   14f36:	22a0      	movs	r2, #160	; 0xa0
   14f38:	2100      	movs	r1, #0
   14f3a:	4802      	ldr	r0, [pc, #8]	; (14f44 <rpc_framework_init+0x10>)
   14f3c:	f007 f87d 	bl	1c03a <memset>
   14f40:	2000      	movs	r0, #0
   14f42:	bd08      	pop	{r3, pc}
   14f44:	200207a0 	.word	0x200207a0

00014f48 <rpc_client_register>:
   14f48:	8803      	ldrh	r3, [r0, #0]
   14f4a:	2b00      	cmp	r3, #0
   14f4c:	d045      	beq.n	14fda <rpc_client_register+0x92>
   14f4e:	6842      	ldr	r2, [r0, #4]
   14f50:	4601      	mov	r1, r0
   14f52:	2a00      	cmp	r2, #0
   14f54:	d050      	beq.n	14ff8 <rpc_client_register+0xb0>
   14f56:	4a30      	ldr	r2, [pc, #192]	; (15018 <rpc_client_register+0xd0>)
   14f58:	8810      	ldrh	r0, [r2, #0]
   14f5a:	4283      	cmp	r3, r0
   14f5c:	d03d      	beq.n	14fda <rpc_client_register+0x92>
   14f5e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   14f62:	8a14      	ldrh	r4, [r2, #16]
   14f64:	42a3      	cmp	r3, r4
   14f66:	d035      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f68:	8c15      	ldrh	r5, [r2, #32]
   14f6a:	42ab      	cmp	r3, r5
   14f6c:	d032      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f6e:	8e16      	ldrh	r6, [r2, #48]	; 0x30
   14f70:	42b3      	cmp	r3, r6
   14f72:	d02f      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f74:	f8b2 7040 	ldrh.w	r7, [r2, #64]	; 0x40
   14f78:	42bb      	cmp	r3, r7
   14f7a:	d02b      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f7c:	f8b2 c050 	ldrh.w	ip, [r2, #80]	; 0x50
   14f80:	4563      	cmp	r3, ip
   14f82:	d027      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f84:	f8b2 e060 	ldrh.w	lr, [r2, #96]	; 0x60
   14f88:	4573      	cmp	r3, lr
   14f8a:	d023      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f8c:	f8b2 8070 	ldrh.w	r8, [r2, #112]	; 0x70
   14f90:	4543      	cmp	r3, r8
   14f92:	d01f      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f94:	f8b2 9080 	ldrh.w	r9, [r2, #128]	; 0x80
   14f98:	454b      	cmp	r3, r9
   14f9a:	d01b      	beq.n	14fd4 <rpc_client_register+0x8c>
   14f9c:	f8b2 a090 	ldrh.w	sl, [r2, #144]	; 0x90
   14fa0:	4553      	cmp	r3, sl
   14fa2:	d017      	beq.n	14fd4 <rpc_client_register+0x8c>
   14fa4:	b1e0      	cbz	r0, 14fe0 <rpc_client_register+0x98>
   14fa6:	b35c      	cbz	r4, 15000 <rpc_client_register+0xb8>
   14fa8:	b365      	cbz	r5, 15004 <rpc_client_register+0xbc>
   14faa:	b36e      	cbz	r6, 15008 <rpc_client_register+0xc0>
   14fac:	b377      	cbz	r7, 1500c <rpc_client_register+0xc4>
   14fae:	f1bc 0f00 	cmp.w	ip, #0
   14fb2:	d02d      	beq.n	15010 <rpc_client_register+0xc8>
   14fb4:	f1be 0f00 	cmp.w	lr, #0
   14fb8:	d020      	beq.n	14ffc <rpc_client_register+0xb4>
   14fba:	f1b8 0f00 	cmp.w	r8, #0
   14fbe:	d029      	beq.n	15014 <rpc_client_register+0xcc>
   14fc0:	f1b9 0f00 	cmp.w	r9, #0
   14fc4:	d00b      	beq.n	14fde <rpc_client_register+0x96>
   14fc6:	2009      	movs	r0, #9
   14fc8:	f1ba 0f00 	cmp.w	sl, #0
   14fcc:	d008      	beq.n	14fe0 <rpc_client_register+0x98>
   14fce:	2004      	movs	r0, #4
   14fd0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14fd4:	2007      	movs	r0, #7
   14fd6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14fda:	2007      	movs	r0, #7
   14fdc:	4770      	bx	lr
   14fde:	2008      	movs	r0, #8
   14fe0:	0100      	lsls	r0, r0, #4
   14fe2:	5213      	strh	r3, [r2, r0]
   14fe4:	684b      	ldr	r3, [r1, #4]
   14fe6:	4402      	add	r2, r0
   14fe8:	6053      	str	r3, [r2, #4]
   14fea:	688b      	ldr	r3, [r1, #8]
   14fec:	2000      	movs	r0, #0
   14fee:	6093      	str	r3, [r2, #8]
   14ff0:	68cb      	ldr	r3, [r1, #12]
   14ff2:	60d3      	str	r3, [r2, #12]
   14ff4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   14ff8:	200e      	movs	r0, #14
   14ffa:	4770      	bx	lr
   14ffc:	2006      	movs	r0, #6
   14ffe:	e7ef      	b.n	14fe0 <rpc_client_register+0x98>
   15000:	2001      	movs	r0, #1
   15002:	e7ed      	b.n	14fe0 <rpc_client_register+0x98>
   15004:	2002      	movs	r0, #2
   15006:	e7eb      	b.n	14fe0 <rpc_client_register+0x98>
   15008:	2003      	movs	r0, #3
   1500a:	e7e9      	b.n	14fe0 <rpc_client_register+0x98>
   1500c:	2004      	movs	r0, #4
   1500e:	e7e7      	b.n	14fe0 <rpc_client_register+0x98>
   15010:	2005      	movs	r0, #5
   15012:	e7e5      	b.n	14fe0 <rpc_client_register+0x98>
   15014:	2007      	movs	r0, #7
   15016:	e7e3      	b.n	14fe0 <rpc_client_register+0x98>
   15018:	200207a0 	.word	0x200207a0

0001501c <rpc_message_send>:
   1501c:	b150      	cbz	r0, 15034 <rpc_message_send+0x18>
   1501e:	b159      	cbz	r1, 15038 <rpc_message_send+0x1c>
   15020:	684b      	ldr	r3, [r1, #4]
   15022:	8008      	strh	r0, [r1, #0]
   15024:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   15028:	f043 0302 	orr.w	r3, r3, #2
   1502c:	604b      	str	r3, [r1, #4]
   1502e:	4608      	mov	r0, r1
   15030:	f7fc be98 	b.w	11d64 <rpc_transport_send>
   15034:	2007      	movs	r0, #7
   15036:	4770      	bx	lr
   15038:	200e      	movs	r0, #14
   1503a:	4770      	bx	lr

0001503c <rpc_message_alloc>:
   1503c:	b342      	cbz	r2, 15090 <rpc_message_alloc+0x54>
   1503e:	b328      	cbz	r0, 1508c <rpc_message_alloc+0x50>
   15040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15042:	2300      	movs	r3, #0
   15044:	4616      	mov	r6, r2
   15046:	460c      	mov	r4, r1
   15048:	4605      	mov	r5, r0
   1504a:	6013      	str	r3, [r2, #0]
   1504c:	b171      	cbz	r1, 1506c <rpc_message_alloc+0x30>
   1504e:	4608      	mov	r0, r1
   15050:	f7fc fe8c 	bl	11d6c <rpc_transport_data_alloc>
   15054:	4607      	mov	r7, r0
   15056:	b1b8      	cbz	r0, 15088 <rpc_message_alloc+0x4c>
   15058:	f7fc fe86 	bl	11d68 <rpc_transport_rpc_alloc>
   1505c:	4603      	mov	r3, r0
   1505e:	b180      	cbz	r0, 15082 <rpc_message_alloc+0x46>
   15060:	2000      	movs	r0, #0
   15062:	60dc      	str	r4, [r3, #12]
   15064:	609f      	str	r7, [r3, #8]
   15066:	801d      	strh	r5, [r3, #0]
   15068:	6033      	str	r3, [r6, #0]
   1506a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1506c:	f7fc fe7c 	bl	11d68 <rpc_transport_rpc_alloc>
   15070:	4603      	mov	r3, r0
   15072:	b148      	cbz	r0, 15088 <rpc_message_alloc+0x4c>
   15074:	4627      	mov	r7, r4
   15076:	60dc      	str	r4, [r3, #12]
   15078:	609f      	str	r7, [r3, #8]
   1507a:	801d      	strh	r5, [r3, #0]
   1507c:	2000      	movs	r0, #0
   1507e:	6033      	str	r3, [r6, #0]
   15080:	e7f3      	b.n	1506a <rpc_message_alloc+0x2e>
   15082:	4638      	mov	r0, r7
   15084:	f7fc fe76 	bl	11d74 <rpc_transport_data_free>
   15088:	2004      	movs	r0, #4
   1508a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1508c:	2007      	movs	r0, #7
   1508e:	4770      	bx	lr
   15090:	200e      	movs	r0, #14
   15092:	4770      	bx	lr

00015094 <rpc_message_free>:
   15094:	b130      	cbz	r0, 150a4 <rpc_message_free+0x10>
   15096:	b139      	cbz	r1, 150a8 <rpc_message_free+0x14>
   15098:	b508      	push	{r3, lr}
   1509a:	4608      	mov	r0, r1
   1509c:	f7fc fe68 	bl	11d70 <rpc_transport_rpc_free>
   150a0:	2000      	movs	r0, #0
   150a2:	bd08      	pop	{r3, pc}
   150a4:	2007      	movs	r0, #7
   150a6:	4770      	bx	lr
   150a8:	200e      	movs	r0, #14
   150aa:	4770      	bx	lr

000150ac <rpc_message_data_free>:
   150ac:	b130      	cbz	r0, 150bc <rpc_message_data_free+0x10>
   150ae:	b139      	cbz	r1, 150c0 <rpc_message_data_free+0x14>
   150b0:	b508      	push	{r3, lr}
   150b2:	4608      	mov	r0, r1
   150b4:	f7fc fe5e 	bl	11d74 <rpc_transport_data_free>
   150b8:	2000      	movs	r0, #0
   150ba:	bd08      	pop	{r3, pc}
   150bc:	2007      	movs	r0, #7
   150be:	4770      	bx	lr
   150c0:	200e      	movs	r0, #14
   150c2:	4770      	bx	lr

000150c4 <packet_free_cb>:
   150c4:	b510      	push	{r4, lr}
   150c6:	4604      	mov	r4, r0
   150c8:	b118      	cbz	r0, 150d2 <packet_free_cb+0xe>
   150ca:	6800      	ldr	r0, [r0, #0]
   150cc:	b108      	cbz	r0, 150d2 <packet_free_cb+0xe>
   150ce:	f002 fec5 	bl	17e5c <rpc_gnss_client_data_free>
   150d2:	68a0      	ldr	r0, [r4, #8]
   150d4:	b118      	cbz	r0, 150de <packet_free_cb+0x1a>
   150d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   150da:	f003 bcad 	b.w	18a38 <nrf_free>
   150de:	bd10      	pop	{r4, pc}

000150e0 <rpc_gnss_event_handler>:
   150e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   150e2:	4b64      	ldr	r3, [pc, #400]	; (15274 <rpc_gnss_event_handler+0x194>)
   150e4:	4606      	mov	r6, r0
   150e6:	6800      	ldr	r0, [r0, #0]
   150e8:	881b      	ldrh	r3, [r3, #0]
   150ea:	6802      	ldr	r2, [r0, #0]
   150ec:	b085      	sub	sp, #20
   150ee:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   150f2:	460d      	mov	r5, r1
   150f4:	d037      	beq.n	15166 <rpc_gnss_event_handler+0x86>
   150f6:	f505 433f 	add.w	r3, r5, #48896	; 0xbf00
   150fa:	33ff      	adds	r3, #255	; 0xff
   150fc:	b29b      	uxth	r3, r3
   150fe:	2b02      	cmp	r3, #2
   15100:	d811      	bhi.n	15126 <rpc_gnss_event_handler+0x46>
   15102:	4c5d      	ldr	r4, [pc, #372]	; (15278 <rpc_gnss_event_handler+0x198>)
   15104:	6823      	ldr	r3, [r4, #0]
   15106:	075a      	lsls	r2, r3, #29
   15108:	d410      	bmi.n	1512c <rpc_gnss_event_handler+0x4c>
   1510a:	6823      	ldr	r3, [r4, #0]
   1510c:	079b      	lsls	r3, r3, #30
   1510e:	d503      	bpl.n	15118 <rpc_gnss_event_handler+0x38>
   15110:	f244 0303 	movw	r3, #16387	; 0x4003
   15114:	429d      	cmp	r5, r3
   15116:	d009      	beq.n	1512c <rpc_gnss_event_handler+0x4c>
   15118:	6830      	ldr	r0, [r6, #0]
   1511a:	b120      	cbz	r0, 15126 <rpc_gnss_event_handler+0x46>
   1511c:	f002 fe9e 	bl	17e5c <rpc_gnss_client_data_free>
   15120:	2200      	movs	r2, #0
   15122:	4b56      	ldr	r3, [pc, #344]	; (1527c <rpc_gnss_event_handler+0x19c>)
   15124:	601a      	str	r2, [r3, #0]
   15126:	2000      	movs	r0, #0
   15128:	b005      	add	sp, #20
   1512a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1512c:	2002      	movs	r0, #2
   1512e:	f003 fc79 	bl	18a24 <nrf_malloc>
   15132:	4607      	mov	r7, r0
   15134:	2800      	cmp	r0, #0
   15136:	f000 8094 	beq.w	15262 <rpc_gnss_event_handler+0x182>
   1513a:	2302      	movs	r3, #2
   1513c:	8005      	strh	r5, [r0, #0]
   1513e:	6831      	ldr	r1, [r6, #0]
   15140:	6872      	ldr	r2, [r6, #4]
   15142:	484f      	ldr	r0, [pc, #316]	; (15280 <rpc_gnss_event_handler+0x1a0>)
   15144:	e88d 0086 	stmia.w	sp, {r1, r2, r7}
   15148:	6800      	ldr	r0, [r0, #0]
   1514a:	9303      	str	r3, [sp, #12]
   1514c:	6803      	ldr	r3, [r0, #0]
   1514e:	4669      	mov	r1, sp
   15150:	685b      	ldr	r3, [r3, #4]
   15152:	4798      	blx	r3
   15154:	3001      	adds	r0, #1
   15156:	d071      	beq.n	1523c <rpc_gnss_event_handler+0x15c>
   15158:	2000      	movs	r0, #0
   1515a:	6823      	ldr	r3, [r4, #0]
   1515c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   15160:	6023      	str	r3, [r4, #0]
   15162:	b005      	add	sp, #20
   15164:	bdf0      	pop	{r4, r5, r6, r7, pc}
   15166:	4c44      	ldr	r4, [pc, #272]	; (15278 <rpc_gnss_event_handler+0x198>)
   15168:	4f44      	ldr	r7, [pc, #272]	; (1527c <rpc_gnss_event_handler+0x19c>)
   1516a:	6823      	ldr	r3, [r4, #0]
   1516c:	6038      	str	r0, [r7, #0]
   1516e:	01d9      	lsls	r1, r3, #7
   15170:	d523      	bpl.n	151ba <rpc_gnss_event_handler+0xda>
   15172:	f242 1302 	movw	r3, #8450	; 0x2102
   15176:	429d      	cmp	r5, r3
   15178:	d11f      	bne.n	151ba <rpc_gnss_event_handler+0xda>
   1517a:	6843      	ldr	r3, [r0, #4]
   1517c:	b91b      	cbnz	r3, 15186 <rpc_gnss_event_handler+0xa6>
   1517e:	6823      	ldr	r3, [r4, #0]
   15180:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   15184:	6023      	str	r3, [r4, #0]
   15186:	6823      	ldr	r3, [r4, #0]
   15188:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   1518c:	6023      	str	r3, [r4, #0]
   1518e:	6823      	ldr	r3, [r4, #0]
   15190:	025a      	lsls	r2, r3, #9
   15192:	d430      	bmi.n	151f6 <rpc_gnss_event_handler+0x116>
   15194:	f242 0305 	movw	r3, #8197	; 0x2005
   15198:	429d      	cmp	r5, r3
   1519a:	d12c      	bne.n	151f6 <rpc_gnss_event_handler+0x116>
   1519c:	6823      	ldr	r3, [r4, #0]
   1519e:	0299      	lsls	r1, r3, #10
   151a0:	d529      	bpl.n	151f6 <rpc_gnss_event_handler+0x116>
   151a2:	6843      	ldr	r3, [r0, #4]
   151a4:	2b00      	cmp	r3, #0
   151a6:	d157      	bne.n	15258 <rpc_gnss_event_handler+0x178>
   151a8:	6823      	ldr	r3, [r4, #0]
   151aa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   151ae:	6023      	str	r3, [r4, #0]
   151b0:	6823      	ldr	r3, [r4, #0]
   151b2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   151b6:	6023      	str	r3, [r4, #0]
   151b8:	e01d      	b.n	151f6 <rpc_gnss_event_handler+0x116>
   151ba:	6823      	ldr	r3, [r4, #0]
   151bc:	025b      	lsls	r3, r3, #9
   151be:	d50e      	bpl.n	151de <rpc_gnss_event_handler+0xfe>
   151c0:	f242 1303 	movw	r3, #8451	; 0x2103
   151c4:	429d      	cmp	r5, r3
   151c6:	d10a      	bne.n	151de <rpc_gnss_event_handler+0xfe>
   151c8:	6843      	ldr	r3, [r0, #4]
   151ca:	b91b      	cbnz	r3, 151d4 <rpc_gnss_event_handler+0xf4>
   151cc:	6823      	ldr	r3, [r4, #0]
   151ce:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   151d2:	6023      	str	r3, [r4, #0]
   151d4:	6823      	ldr	r3, [r4, #0]
   151d6:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   151da:	6023      	str	r3, [r4, #0]
   151dc:	e00b      	b.n	151f6 <rpc_gnss_event_handler+0x116>
   151de:	f242 0301 	movw	r3, #8193	; 0x2001
   151e2:	429d      	cmp	r5, r3
   151e4:	d10c      	bne.n	15200 <rpc_gnss_event_handler+0x120>
   151e6:	6843      	ldr	r3, [r0, #4]
   151e8:	b92b      	cbnz	r3, 151f6 <rpc_gnss_event_handler+0x116>
   151ea:	6823      	ldr	r3, [r4, #0]
   151ec:	0c1b      	lsrs	r3, r3, #16
   151ee:	041b      	lsls	r3, r3, #16
   151f0:	f043 0302 	orr.w	r3, r3, #2
   151f4:	6023      	str	r3, [r4, #0]
   151f6:	f002 fe31 	bl	17e5c <rpc_gnss_client_data_free>
   151fa:	2300      	movs	r3, #0
   151fc:	603b      	str	r3, [r7, #0]
   151fe:	e77a      	b.n	150f6 <rpc_gnss_event_handler+0x16>
   15200:	f242 0304 	movw	r3, #8196	; 0x2004
   15204:	429d      	cmp	r5, r3
   15206:	d1c5      	bne.n	15194 <rpc_gnss_event_handler+0xb4>
   15208:	6843      	ldr	r3, [r0, #4]
   1520a:	b993      	cbnz	r3, 15232 <rpc_gnss_event_handler+0x152>
   1520c:	6823      	ldr	r3, [r4, #0]
   1520e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   15212:	6023      	str	r3, [r4, #0]
   15214:	6823      	ldr	r3, [r4, #0]
   15216:	b29b      	uxth	r3, r3
   15218:	2b03      	cmp	r3, #3
   1521a:	6823      	ldr	r3, [r4, #0]
   1521c:	d016      	beq.n	1524c <rpc_gnss_event_handler+0x16c>
   1521e:	b29b      	uxth	r3, r3
   15220:	2b04      	cmp	r3, #4
   15222:	d1d7      	bne.n	151d4 <rpc_gnss_event_handler+0xf4>
   15224:	6823      	ldr	r3, [r4, #0]
   15226:	0c1b      	lsrs	r3, r3, #16
   15228:	041b      	lsls	r3, r3, #16
   1522a:	f043 0302 	orr.w	r3, r3, #2
   1522e:	6023      	str	r3, [r4, #0]
   15230:	e7d0      	b.n	151d4 <rpc_gnss_event_handler+0xf4>
   15232:	6823      	ldr	r3, [r4, #0]
   15234:	b29b      	uxth	r3, r3
   15236:	2b03      	cmp	r3, #3
   15238:	d1cc      	bne.n	151d4 <rpc_gnss_event_handler+0xf4>
   1523a:	e7f3      	b.n	15224 <rpc_gnss_event_handler+0x144>
   1523c:	4638      	mov	r0, r7
   1523e:	f003 fbfb 	bl	18a38 <nrf_free>
   15242:	6830      	ldr	r0, [r6, #0]
   15244:	2800      	cmp	r0, #0
   15246:	f47f af69 	bne.w	1511c <rpc_gnss_event_handler+0x3c>
   1524a:	e76c      	b.n	15126 <rpc_gnss_event_handler+0x46>
   1524c:	0c1b      	lsrs	r3, r3, #16
   1524e:	041b      	lsls	r3, r3, #16
   15250:	f043 0304 	orr.w	r3, r3, #4
   15254:	6023      	str	r3, [r4, #0]
   15256:	e7bd      	b.n	151d4 <rpc_gnss_event_handler+0xf4>
   15258:	6823      	ldr	r3, [r4, #0]
   1525a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   1525e:	6023      	str	r3, [r4, #0]
   15260:	e7c9      	b.n	151f6 <rpc_gnss_event_handler+0x116>
   15262:	6830      	ldr	r0, [r6, #0]
   15264:	2800      	cmp	r0, #0
   15266:	f43f af5e 	beq.w	15126 <rpc_gnss_event_handler+0x46>
   1526a:	f002 fdf7 	bl	17e5c <rpc_gnss_client_data_free>
   1526e:	4b03      	ldr	r3, [pc, #12]	; (1527c <rpc_gnss_event_handler+0x19c>)
   15270:	601f      	str	r7, [r3, #0]
   15272:	e758      	b.n	15126 <rpc_gnss_event_handler+0x46>
   15274:	2002209a 	.word	0x2002209a
   15278:	20020840 	.word	0x20020840
   1527c:	20020844 	.word	0x20020844
   15280:	20020848 	.word	0x20020848

00015284 <gnss_interface_write>:
   15284:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15288:	4a74      	ldr	r2, [pc, #464]	; (1545c <gnss_interface_write+0x1d8>)
   1528a:	b09f      	sub	sp, #124	; 0x7c
   1528c:	4290      	cmp	r0, r2
   1528e:	9d26      	ldr	r5, [sp, #152]	; 0x98
   15290:	f040 80d7 	bne.w	15442 <gnss_interface_write+0x1be>
   15294:	2900      	cmp	r1, #0
   15296:	f000 80c6 	beq.w	15426 <gnss_interface_write+0x1a2>
   1529a:	2d00      	cmp	r5, #0
   1529c:	f000 80c3 	beq.w	15426 <gnss_interface_write+0x1a2>
   152a0:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   152a2:	2a02      	cmp	r2, #2
   152a4:	f040 80bf 	bne.w	15426 <gnss_interface_write+0x1a2>
   152a8:	4c6d      	ldr	r4, [pc, #436]	; (15460 <gnss_interface_write+0x1dc>)
   152aa:	6822      	ldr	r2, [r4, #0]
   152ac:	b292      	uxth	r2, r2
   152ae:	2a02      	cmp	r2, #2
   152b0:	d004      	beq.n	152bc <gnss_interface_write+0x38>
   152b2:	6822      	ldr	r2, [r4, #0]
   152b4:	b292      	uxth	r2, r2
   152b6:	2a04      	cmp	r2, #4
   152b8:	f040 80bd 	bne.w	15436 <gnss_interface_write+0x1b2>
   152bc:	2b00      	cmp	r3, #0
   152be:	f040 80c6 	bne.w	1544e <gnss_interface_write+0x1ca>
   152c2:	6822      	ldr	r2, [r4, #0]
   152c4:	0390      	lsls	r0, r2, #14
   152c6:	d512      	bpl.n	152ee <gnss_interface_write+0x6a>
   152c8:	6822      	ldr	r2, [r4, #0]
   152ca:	882b      	ldrh	r3, [r5, #0]
   152cc:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
   152d0:	6022      	str	r2, [r4, #0]
   152d2:	6822      	ldr	r2, [r4, #0]
   152d4:	3b01      	subs	r3, #1
   152d6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   152da:	6022      	str	r2, [r4, #0]
   152dc:	2b07      	cmp	r3, #7
   152de:	f200 80a2 	bhi.w	15426 <gnss_interface_write+0x1a2>
   152e2:	e8df f003 	tbb	[pc, r3]
   152e6:	7d82      	.short	0x7d82
   152e8:	646e7378 	.word	0x646e7378
   152ec:	0869      	.short	0x0869
   152ee:	2000      	movs	r0, #0
   152f0:	b01f      	add	sp, #124	; 0x7c
   152f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   152f6:	4608      	mov	r0, r1
   152f8:	a902      	add	r1, sp, #8
   152fa:	f002 fd63 	bl	17dc4 <rpc_gnss_serialize_integrity>
   152fe:	2172      	movs	r1, #114	; 0x72
   15300:	4668      	mov	r0, sp
   15302:	f002 fd79 	bl	17df8 <rpc_gnss_client_request_alloc>
   15306:	4605      	mov	r5, r0
   15308:	9800      	ldr	r0, [sp, #0]
   1530a:	2d00      	cmp	r5, #0
   1530c:	d172      	bne.n	153f4 <gnss_interface_write+0x170>
   1530e:	2800      	cmp	r0, #0
   15310:	d077      	beq.n	15402 <gnss_interface_write+0x17e>
   15312:	f241 0605 	movw	r6, #4101	; 0x1005
   15316:	f04f 0c49 	mov.w	ip, #73	; 0x49
   1531a:	2272      	movs	r2, #114	; 0x72
   1531c:	f04f 0e76 	mov.w	lr, #118	; 0x76
   15320:	f04f 0943 	mov.w	r9, #67	; 0x43
   15324:	f04f 0854 	mov.w	r8, #84	; 0x54
   15328:	4f4e      	ldr	r7, [pc, #312]	; (15464 <gnss_interface_write+0x1e0>)
   1532a:	a91e      	add	r1, sp, #120	; 0x78
   1532c:	883b      	ldrh	r3, [r7, #0]
   1532e:	f880 c00f 	strb.w	ip, [r0, #15]
   15332:	3301      	adds	r3, #1
   15334:	b29b      	uxth	r3, r3
   15336:	ea46 4c03 	orr.w	ip, r6, r3, lsl #16
   1533a:	f841 cd74 	str.w	ip, [r1, #-116]!
   1533e:	7145      	strb	r5, [r0, #5]
   15340:	7185      	strb	r5, [r0, #6]
   15342:	71c5      	strb	r5, [r0, #7]
   15344:	7205      	strb	r5, [r0, #8]
   15346:	7245      	strb	r5, [r0, #9]
   15348:	7285      	strb	r5, [r0, #10]
   1534a:	72c5      	strb	r5, [r0, #11]
   1534c:	7102      	strb	r2, [r0, #4]
   1534e:	f880 900c 	strb.w	r9, [r0, #12]
   15352:	f880 800d 	strb.w	r8, [r0, #13]
   15356:	f880 e00e 	strb.w	lr, [r0, #14]
   1535a:	6800      	ldr	r0, [r0, #0]
   1535c:	803b      	strh	r3, [r7, #0]
   1535e:	f006 fe41 	bl	1bfe4 <memcpy>
   15362:	4b41      	ldr	r3, [pc, #260]	; (15468 <gnss_interface_write+0x1e4>)
   15364:	4631      	mov	r1, r6
   15366:	9800      	ldr	r0, [sp, #0]
   15368:	601d      	str	r5, [r3, #0]
   1536a:	f002 fd59 	bl	17e20 <rpc_gnss_client_request_send>
   1536e:	2800      	cmp	r0, #0
   15370:	d14e      	bne.n	15410 <gnss_interface_write+0x18c>
   15372:	6823      	ldr	r3, [r4, #0]
   15374:	0299      	lsls	r1, r3, #10
   15376:	d50b      	bpl.n	15390 <gnss_interface_write+0x10c>
   15378:	4e3c      	ldr	r6, [pc, #240]	; (1546c <gnss_interface_write+0x1e8>)
   1537a:	4d38      	ldr	r5, [pc, #224]	; (1545c <gnss_interface_write+0x1d8>)
   1537c:	e000      	b.n	15380 <gnss_interface_write+0xfc>
   1537e:	b978      	cbnz	r0, 153a0 <gnss_interface_write+0x11c>
   15380:	4631      	mov	r1, r6
   15382:	4628      	mov	r0, r5
   15384:	f7fa fd9c 	bl	fec0 <bsd_os_timedwait>
   15388:	6823      	ldr	r3, [r4, #0]
   1538a:	029a      	lsls	r2, r3, #10
   1538c:	d4f7      	bmi.n	1537e <gnss_interface_write+0xfa>
   1538e:	b938      	cbnz	r0, 153a0 <gnss_interface_write+0x11c>
   15390:	6823      	ldr	r3, [r4, #0]
   15392:	039b      	lsls	r3, r3, #14
   15394:	d4ab      	bmi.n	152ee <gnss_interface_write+0x6a>
   15396:	2005      	movs	r0, #5
   15398:	6823      	ldr	r3, [r4, #0]
   1539a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1539e:	6023      	str	r3, [r4, #0]
   153a0:	f7fa fe44 	bl	1002c <bsd_os_errno_set>
   153a4:	f04f 30ff 	mov.w	r0, #4294967295
   153a8:	b01f      	add	sp, #124	; 0x7c
   153aa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   153ae:	4608      	mov	r0, r1
   153b0:	a902      	add	r1, sp, #8
   153b2:	f002 fcbf 	bl	17d34 <rpc_gnss_serialize_time_and_sv_tow>
   153b6:	e7a2      	b.n	152fe <gnss_interface_write+0x7a>
   153b8:	4608      	mov	r0, r1
   153ba:	a902      	add	r1, sp, #8
   153bc:	f002 fce2 	bl	17d84 <rpc_gnss_serialize_location>
   153c0:	e79d      	b.n	152fe <gnss_interface_write+0x7a>
   153c2:	4608      	mov	r0, r1
   153c4:	a902      	add	r1, sp, #8
   153c6:	f002 fc9b 	bl	17d00 <rpc_gnss_serialize_nequick>
   153ca:	e798      	b.n	152fe <gnss_interface_write+0x7a>
   153cc:	4608      	mov	r0, r1
   153ce:	a902      	add	r1, sp, #8
   153d0:	f002 fc72 	bl	17cb8 <rpc_gnss_serialize_klob>
   153d4:	e793      	b.n	152fe <gnss_interface_write+0x7a>
   153d6:	4608      	mov	r0, r1
   153d8:	a902      	add	r1, sp, #8
   153da:	f002 fc3b 	bl	17c54 <rpc_gnss_serialize_alm>
   153de:	e78e      	b.n	152fe <gnss_interface_write+0x7a>
   153e0:	4608      	mov	r0, r1
   153e2:	a902      	add	r1, sp, #8
   153e4:	f002 fbe4 	bl	17bb0 <rpc_gnss_serialize_ephe>
   153e8:	e789      	b.n	152fe <gnss_interface_write+0x7a>
   153ea:	4608      	mov	r0, r1
   153ec:	a902      	add	r1, sp, #8
   153ee:	f002 fbbd 	bl	17b6c <rpc_gnss_serialize_utc>
   153f2:	e784      	b.n	152fe <gnss_interface_write+0x7a>
   153f4:	b128      	cbz	r0, 15402 <gnss_interface_write+0x17e>
   153f6:	6803      	ldr	r3, [r0, #0]
   153f8:	b11b      	cbz	r3, 15402 <gnss_interface_write+0x17e>
   153fa:	4618      	mov	r0, r3
   153fc:	f002 fd2e 	bl	17e5c <rpc_gnss_client_data_free>
   15400:	9800      	ldr	r0, [sp, #0]
   15402:	f002 fd23 	bl	17e4c <rpc_gnss_client_message_free>
   15406:	2023      	movs	r0, #35	; 0x23
   15408:	f7fa fe10 	bl	1002c <bsd_os_errno_set>
   1540c:	f04f 30ff 	mov.w	r0, #4294967295
   15410:	6823      	ldr	r3, [r4, #0]
   15412:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   15416:	6023      	str	r3, [r4, #0]
   15418:	6823      	ldr	r3, [r4, #0]
   1541a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1541e:	6023      	str	r3, [r4, #0]
   15420:	b01f      	add	sp, #124	; 0x7c
   15422:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15426:	2016      	movs	r0, #22
   15428:	f7fa fe00 	bl	1002c <bsd_os_errno_set>
   1542c:	f04f 30ff 	mov.w	r0, #4294967295
   15430:	b01f      	add	sp, #124	; 0x7c
   15432:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15436:	2039      	movs	r0, #57	; 0x39
   15438:	f7fa fdf8 	bl	1002c <bsd_os_errno_set>
   1543c:	f04f 30ff 	mov.w	r0, #4294967295
   15440:	e756      	b.n	152f0 <gnss_interface_write+0x6c>
   15442:	2009      	movs	r0, #9
   15444:	f7fa fdf2 	bl	1002c <bsd_os_errno_set>
   15448:	f04f 30ff 	mov.w	r0, #4294967295
   1544c:	e750      	b.n	152f0 <gnss_interface_write+0x6c>
   1544e:	202d      	movs	r0, #45	; 0x2d
   15450:	f7fa fdec 	bl	1002c <bsd_os_errno_set>
   15454:	f04f 30ff 	mov.w	r0, #4294967295
   15458:	e74a      	b.n	152f0 <gnss_interface_write+0x6c>
   1545a:	bf00      	nop
   1545c:	49765443 	.word	0x49765443
   15460:	20020840 	.word	0x20020840
   15464:	2002209a 	.word	0x2002209a
   15468:	20020844 	.word	0x20020844
   1546c:	200200ec 	.word	0x200200ec

00015470 <gnss_interface_read>:
   15470:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15474:	4c50      	ldr	r4, [pc, #320]	; (155b8 <gnss_interface_read+0x148>)
   15476:	b0b7      	sub	sp, #220	; 0xdc
   15478:	42a0      	cmp	r0, r4
   1547a:	f040 81fe 	bne.w	1587a <gnss_interface_read+0x40a>
   1547e:	4688      	mov	r8, r1
   15480:	2900      	cmp	r1, #0
   15482:	f000 81f4 	beq.w	1586e <gnss_interface_read+0x3fe>
   15486:	2ad7      	cmp	r2, #215	; 0xd7
   15488:	f240 81f1 	bls.w	1586e <gnss_interface_read+0x3fe>
   1548c:	4d4b      	ldr	r5, [pc, #300]	; (155bc <gnss_interface_read+0x14c>)
   1548e:	4699      	mov	r9, r3
   15490:	682b      	ldr	r3, [r5, #0]
   15492:	b29b      	uxth	r3, r3
   15494:	2b04      	cmp	r3, #4
   15496:	d004      	beq.n	154a2 <gnss_interface_read+0x32>
   15498:	682b      	ldr	r3, [r5, #0]
   1549a:	b29b      	uxth	r3, r3
   1549c:	2b02      	cmp	r3, #2
   1549e:	f040 81e0 	bne.w	15862 <gnss_interface_read+0x3f2>
   154a2:	f1b9 0f00 	cmp.w	r9, #0
   154a6:	d158      	bne.n	1555a <gnss_interface_read+0xea>
   154a8:	2102      	movs	r1, #2
   154aa:	20b6      	movs	r0, #182	; 0xb6
   154ac:	2400      	movs	r4, #0
   154ae:	682b      	ldr	r3, [r5, #0]
   154b0:	f10d 020e 	add.w	r2, sp, #14
   154b4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   154b8:	602b      	str	r3, [r5, #0]
   154ba:	f8df a108 	ldr.w	sl, [pc, #264]	; 155c4 <gnss_interface_read+0x154>
   154be:	ab08      	add	r3, sp, #32
   154c0:	4f3f      	ldr	r7, [pc, #252]	; (155c0 <gnss_interface_read+0x150>)
   154c2:	4e3d      	ldr	r6, [pc, #244]	; (155b8 <gnss_interface_read+0x148>)
   154c4:	9005      	str	r0, [sp, #20]
   154c6:	9107      	str	r1, [sp, #28]
   154c8:	9304      	str	r3, [sp, #16]
   154ca:	9206      	str	r2, [sp, #24]
   154cc:	ea09 0b01 	and.w	fp, r9, r1
   154d0:	f8da 0000 	ldr.w	r0, [sl]
   154d4:	464a      	mov	r2, r9
   154d6:	6803      	ldr	r3, [r0, #0]
   154d8:	a904      	add	r1, sp, #16
   154da:	689b      	ldr	r3, [r3, #8]
   154dc:	4798      	blx	r3
   154de:	2800      	cmp	r0, #0
   154e0:	da11      	bge.n	15506 <gnss_interface_read+0x96>
   154e2:	f1bb 0f00 	cmp.w	fp, #0
   154e6:	d141      	bne.n	1556c <gnss_interface_read+0xfc>
   154e8:	682b      	ldr	r3, [r5, #0]
   154ea:	03d8      	lsls	r0, r3, #15
   154ec:	d4f0      	bmi.n	154d0 <gnss_interface_read+0x60>
   154ee:	b10c      	cbz	r4, 154f4 <gnss_interface_read+0x84>
   154f0:	e7ee      	b.n	154d0 <gnss_interface_read+0x60>
   154f2:	b930      	cbnz	r0, 15502 <gnss_interface_read+0x92>
   154f4:	4639      	mov	r1, r7
   154f6:	4630      	mov	r0, r6
   154f8:	f7fa fce2 	bl	fec0 <bsd_os_timedwait>
   154fc:	682b      	ldr	r3, [r5, #0]
   154fe:	03d9      	lsls	r1, r3, #15
   15500:	d5f7      	bpl.n	154f2 <gnss_interface_read+0x82>
   15502:	4604      	mov	r4, r0
   15504:	e7e4      	b.n	154d0 <gnss_interface_read+0x60>
   15506:	f244 0202 	movw	r2, #16386	; 0x4002
   1550a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   1550e:	4293      	cmp	r3, r2
   15510:	d042      	beq.n	15598 <gnss_interface_read+0x128>
   15512:	f244 0201 	movw	r2, #16385	; 0x4001
   15516:	4293      	cmp	r3, r2
   15518:	d056      	beq.n	155c8 <gnss_interface_read+0x158>
   1551a:	f244 0203 	movw	r2, #16387	; 0x4003
   1551e:	4293      	cmp	r3, r2
   15520:	f040 81a5 	bne.w	1586e <gnss_interface_read+0x3fe>
   15524:	2203      	movs	r2, #3
   15526:	2414      	movs	r4, #20
   15528:	9b08      	ldr	r3, [sp, #32]
   1552a:	f888 2000 	strb.w	r2, [r8]
   1552e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15530:	f8c8 3008 	str.w	r3, [r8, #8]
   15534:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   15538:	e9c8 2303 	strd	r2, r3, [r8, #12]
   1553c:	f8da 0000 	ldr.w	r0, [sl]
   15540:	6803      	ldr	r3, [r0, #0]
   15542:	68db      	ldr	r3, [r3, #12]
   15544:	4798      	blx	r3
   15546:	2800      	cmp	r0, #0
   15548:	dd03      	ble.n	15552 <gnss_interface_read+0xe2>
   1554a:	682b      	ldr	r3, [r5, #0]
   1554c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   15550:	602b      	str	r3, [r5, #0]
   15552:	4620      	mov	r0, r4
   15554:	b037      	add	sp, #220	; 0xdc
   15556:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1555a:	f019 0f2a 	tst.w	r9, #42	; 0x2a
   1555e:	d1a3      	bne.n	154a8 <gnss_interface_read+0x38>
   15560:	202d      	movs	r0, #45	; 0x2d
   15562:	f7fa fd63 	bl	1002c <bsd_os_errno_set>
   15566:	f04f 34ff 	mov.w	r4, #4294967295
   1556a:	e7f2      	b.n	15552 <gnss_interface_read+0xe2>
   1556c:	1c42      	adds	r2, r0, #1
   1556e:	4603      	mov	r3, r0
   15570:	d1c9      	bne.n	15506 <gnss_interface_read+0x96>
   15572:	b93c      	cbnz	r4, 15584 <gnss_interface_read+0x114>
   15574:	461c      	mov	r4, r3
   15576:	2023      	movs	r0, #35	; 0x23
   15578:	f7fa fd58 	bl	1002c <bsd_os_errno_set>
   1557c:	4620      	mov	r0, r4
   1557e:	b037      	add	sp, #220	; 0xdc
   15580:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15584:	9001      	str	r0, [sp, #4]
   15586:	4620      	mov	r0, r4
   15588:	f7fa fd50 	bl	1002c <bsd_os_errno_set>
   1558c:	9b01      	ldr	r3, [sp, #4]
   1558e:	461c      	mov	r4, r3
   15590:	4620      	mov	r0, r4
   15592:	b037      	add	sp, #220	; 0xdc
   15594:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15598:	a808      	add	r0, sp, #32
   1559a:	f006 fcf1 	bl	1bf80 <strlen>
   1559e:	2302      	movs	r3, #2
   155a0:	1c44      	adds	r4, r0, #1
   155a2:	b2a4      	uxth	r4, r4
   155a4:	f808 3b08 	strb.w	r3, [r8], #8
   155a8:	4622      	mov	r2, r4
   155aa:	a908      	add	r1, sp, #32
   155ac:	4640      	mov	r0, r8
   155ae:	f006 fd19 	bl	1bfe4 <memcpy>
   155b2:	3408      	adds	r4, #8
   155b4:	e7c2      	b.n	1553c <gnss_interface_read+0xcc>
   155b6:	bf00      	nop
   155b8:	49765443 	.word	0x49765443
   155bc:	20020840 	.word	0x20020840
   155c0:	200200ec 	.word	0x200200ec
   155c4:	20020848 	.word	0x20020848
   155c8:	2401      	movs	r4, #1
   155ca:	a809      	add	r0, sp, #36	; 0x24
   155cc:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   155ce:	e9c8 0102 	strd	r0, r1, [r8, #8]
   155d2:	e9c8 2304 	strd	r2, r3, [r8, #16]
   155d6:	990d      	ldr	r1, [sp, #52]	; 0x34
   155d8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   155da:	f888 4000 	strb.w	r4, [r8]
   155de:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   155e0:	f8c8 1018 	str.w	r1, [r8, #24]
   155e4:	9910      	ldr	r1, [sp, #64]	; 0x40
   155e6:	f8c8 201c 	str.w	r2, [r8, #28]
   155ea:	f8c8 3020 	str.w	r3, [r8, #32]
   155ee:	f89d 205d 	ldrb.w	r2, [sp, #93]	; 0x5d
   155f2:	f8dd 304d 	ldr.w	r3, [sp, #77]	; 0x4d
   155f6:	f8c8 1024 	str.w	r1, [r8, #36]	; 0x24
   155fa:	f8dd 1051 	ldr.w	r1, [sp, #81]	; 0x51
   155fe:	f888 2044 	strb.w	r2, [r8, #68]	; 0x44
   15602:	f8dd 2055 	ldr.w	r2, [sp, #85]	; 0x55
   15606:	f8c8 3034 	str.w	r3, [r8, #52]	; 0x34
   1560a:	f8dd 3059 	ldr.w	r3, [sp, #89]	; 0x59
   1560e:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
   15612:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
   15616:	f8c8 203c 	str.w	r2, [r8, #60]	; 0x3c
   1561a:	f8c8 3040 	str.w	r3, [r8, #64]	; 0x40
   1561e:	f8dd 2046 	ldr.w	r2, [sp, #70]	; 0x46
   15622:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   15626:	f8a8 1028 	strh.w	r1, [r8, #40]	; 0x28
   1562a:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
   1562e:	f8c8 202a 	str.w	r2, [r8, #42]	; 0x2a
   15632:	f89d 004b 	ldrb.w	r0, [sp, #75]	; 0x4b
   15636:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   1563a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1563c:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
   15640:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   15644:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   15648:	f3c3 210f 	ubfx	r1, r3, #8, #16
   1564c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   1564e:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   15652:	f8a8 0030 	strh.w	r0, [r8, #48]	; 0x30
   15656:	f8a8 104a 	strh.w	r1, [r8, #74]	; 0x4a
   1565a:	f8bd 105e 	ldrh.w	r1, [sp, #94]	; 0x5e
   1565e:	f3c3 230f 	ubfx	r3, r3, #8, #16
   15662:	f8a8 2056 	strh.w	r2, [r8, #86]	; 0x56
   15666:	f89d 2060 	ldrb.w	r2, [sp, #96]	; 0x60
   1566a:	f8a8 3062 	strh.w	r3, [r8, #98]	; 0x62
   1566e:	f8dd 3063 	ldr.w	r3, [sp, #99]	; 0x63
   15672:	f8a8 1046 	strh.w	r1, [r8, #70]	; 0x46
   15676:	f888 2048 	strb.w	r2, [r8, #72]	; 0x48
   1567a:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
   1567e:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
   15682:	f8c8 304c 	str.w	r3, [r8, #76]	; 0x4c
   15686:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   1568a:	f888 1050 	strb.w	r1, [r8, #80]	; 0x50
   1568e:	f8a8 2052 	strh.w	r2, [r8, #82]	; 0x52
   15692:	f888 3054 	strb.w	r3, [r8, #84]	; 0x54
   15696:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   1569a:	f8dd 106d 	ldr.w	r1, [sp, #109]	; 0x6d
   1569e:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   156a2:	f8c8 1058 	str.w	r1, [r8, #88]	; 0x58
   156a6:	f888 205c 	strb.w	r2, [r8, #92]	; 0x5c
   156aa:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
   156ae:	f8dd 2077 	ldr.w	r2, [sp, #119]	; 0x77
   156b2:	f8a8 305e 	strh.w	r3, [r8, #94]	; 0x5e
   156b6:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
   156ba:	f888 1060 	strb.w	r1, [r8, #96]	; 0x60
   156be:	f8c8 2064 	str.w	r2, [r8, #100]	; 0x64
   156c2:	f888 3068 	strb.w	r3, [r8, #104]	; 0x68
   156c6:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   156ca:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
   156ce:	9a22      	ldr	r2, [sp, #136]	; 0x88
   156d0:	f89d 0094 	ldrb.w	r0, [sp, #148]	; 0x94
   156d4:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   156d8:	f89d 3093 	ldrb.w	r3, [sp, #147]	; 0x93
   156dc:	f3c2 220f 	ubfx	r2, r2, #8, #16
   156e0:	f8a8 106e 	strh.w	r1, [r8, #110]	; 0x6e
   156e4:	f8bd 107c 	ldrh.w	r1, [sp, #124]	; 0x7c
   156e8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   156ec:	f8a8 207a 	strh.w	r2, [r8, #122]	; 0x7a
   156f0:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
   156f4:	f8a8 3086 	strh.w	r3, [r8, #134]	; 0x86
   156f8:	f8dd 3081 	ldr.w	r3, [sp, #129]	; 0x81
   156fc:	f8a8 106a 	strh.w	r1, [r8, #106]	; 0x6a
   15700:	f888 206c 	strb.w	r2, [r8, #108]	; 0x6c
   15704:	f8bd 2086 	ldrh.w	r2, [sp, #134]	; 0x86
   15708:	f89d 1085 	ldrb.w	r1, [sp, #133]	; 0x85
   1570c:	f8c8 3070 	str.w	r3, [r8, #112]	; 0x70
   15710:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   15714:	f888 1074 	strb.w	r1, [r8, #116]	; 0x74
   15718:	f8a8 2076 	strh.w	r2, [r8, #118]	; 0x76
   1571c:	f888 3078 	strb.w	r3, [r8, #120]	; 0x78
   15720:	f8bd 3090 	ldrh.w	r3, [sp, #144]	; 0x90
   15724:	f8dd 108b 	ldr.w	r1, [sp, #139]	; 0x8b
   15728:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
   1572c:	f8c8 107c 	str.w	r1, [r8, #124]	; 0x7c
   15730:	f888 2080 	strb.w	r2, [r8, #128]	; 0x80
   15734:	f89d 1092 	ldrb.w	r1, [sp, #146]	; 0x92
   15738:	f8dd 2095 	ldr.w	r2, [sp, #149]	; 0x95
   1573c:	f8a8 3082 	strh.w	r3, [r8, #130]	; 0x82
   15740:	f89d 3099 	ldrb.w	r3, [sp, #153]	; 0x99
   15744:	f888 1084 	strb.w	r1, [r8, #132]	; 0x84
   15748:	f8c8 2088 	str.w	r2, [r8, #136]	; 0x88
   1574c:	f888 308c 	strb.w	r3, [r8, #140]	; 0x8c
   15750:	f8bd 009a 	ldrh.w	r0, [sp, #154]	; 0x9a
   15754:	9b27      	ldr	r3, [sp, #156]	; 0x9c
   15756:	f89d 40a8 	ldrb.w	r4, [sp, #168]	; 0xa8
   1575a:	f89d 20a7 	ldrb.w	r2, [sp, #167]	; 0xa7
   1575e:	f3c3 210f 	ubfx	r1, r3, #8, #16
   15762:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   15764:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   15768:	f8a8 1092 	strh.w	r1, [r8, #146]	; 0x92
   1576c:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
   15770:	f8a8 209e 	strh.w	r2, [r8, #158]	; 0x9e
   15774:	f3c3 230f 	ubfx	r3, r3, #8, #16
   15778:	f8dd 209f 	ldr.w	r2, [sp, #159]	; 0x9f
   1577c:	f8a8 008e 	strh.w	r0, [r8, #142]	; 0x8e
   15780:	f8a8 30aa 	strh.w	r3, [r8, #170]	; 0xaa
   15784:	f888 1090 	strb.w	r1, [r8, #144]	; 0x90
   15788:	f89d 30a3 	ldrb.w	r3, [sp, #163]	; 0xa3
   1578c:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
   15790:	f8c8 2094 	str.w	r2, [r8, #148]	; 0x94
   15794:	f89d 20a6 	ldrb.w	r2, [sp, #166]	; 0xa6
   15798:	f888 3098 	strb.w	r3, [r8, #152]	; 0x98
   1579c:	f8dd 30a9 	ldr.w	r3, [sp, #169]	; 0xa9
   157a0:	f8a8 109a 	strh.w	r1, [r8, #154]	; 0x9a
   157a4:	f888 209c 	strb.w	r2, [r8, #156]	; 0x9c
   157a8:	f8bd 20ae 	ldrh.w	r2, [sp, #174]	; 0xae
   157ac:	f89d 10ad 	ldrb.w	r1, [sp, #173]	; 0xad
   157b0:	f8c8 30a0 	str.w	r3, [r8, #160]	; 0xa0
   157b4:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   157b8:	f888 10a4 	strb.w	r1, [r8, #164]	; 0xa4
   157bc:	f8a8 20a6 	strh.w	r2, [r8, #166]	; 0xa6
   157c0:	f888 30a8 	strb.w	r3, [r8, #168]	; 0xa8
   157c4:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
   157c8:	f8dd 10b3 	ldr.w	r1, [sp, #179]	; 0xb3
   157cc:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   157d0:	f8c8 10ac 	str.w	r1, [r8, #172]	; 0xac
   157d4:	f888 20b0 	strb.w	r2, [r8, #176]	; 0xb0
   157d8:	f8a8 30b2 	strh.w	r3, [r8, #178]	; 0xb2
   157dc:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
   157e0:	f89d 10bb 	ldrb.w	r1, [sp, #187]	; 0xbb
   157e4:	f89d 00d0 	ldrb.w	r0, [sp, #208]	; 0xd0
   157e8:	9a31      	ldr	r2, [sp, #196]	; 0xc4
   157ea:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   157ee:	f89d 30cf 	ldrb.w	r3, [sp, #207]	; 0xcf
   157f2:	f89d 40ba 	ldrb.w	r4, [sp, #186]	; 0xba
   157f6:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   157fa:	f3c2 220f 	ubfx	r2, r2, #8, #16
   157fe:	f8a8 10b6 	strh.w	r1, [r8, #182]	; 0xb6
   15802:	f8a8 30ce 	strh.w	r3, [r8, #206]	; 0xce
   15806:	f888 40b4 	strb.w	r4, [r8, #180]	; 0xb4
   1580a:	f8a8 20c2 	strh.w	r2, [r8, #194]	; 0xc2
   1580e:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
   15812:	f89d 10c1 	ldrb.w	r1, [sp, #193]	; 0xc1
   15816:	f89d 30c4 	ldrb.w	r3, [sp, #196]	; 0xc4
   1581a:	f8dd 00bd 	ldr.w	r0, [sp, #189]	; 0xbd
   1581e:	f888 10bc 	strb.w	r1, [r8, #188]	; 0xbc
   15822:	f8a8 20be 	strh.w	r2, [r8, #190]	; 0xbe
   15826:	f8c8 00b8 	str.w	r0, [r8, #184]	; 0xb8
   1582a:	f888 30c0 	strb.w	r3, [r8, #192]	; 0xc0
   1582e:	f8bd 30cc 	ldrh.w	r3, [sp, #204]	; 0xcc
   15832:	f8dd 10c7 	ldr.w	r1, [sp, #199]	; 0xc7
   15836:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   1583a:	f8c8 10c4 	str.w	r1, [r8, #196]	; 0xc4
   1583e:	f888 20c8 	strb.w	r2, [r8, #200]	; 0xc8
   15842:	f89d 10ce 	ldrb.w	r1, [sp, #206]	; 0xce
   15846:	f8dd 20d1 	ldr.w	r2, [sp, #209]	; 0xd1
   1584a:	f8a8 30ca 	strh.w	r3, [r8, #202]	; 0xca
   1584e:	f89d 30d5 	ldrb.w	r3, [sp, #213]	; 0xd5
   15852:	f888 10cc 	strb.w	r1, [r8, #204]	; 0xcc
   15856:	f8c8 20d0 	str.w	r2, [r8, #208]	; 0xd0
   1585a:	f888 30d4 	strb.w	r3, [r8, #212]	; 0xd4
   1585e:	24d8      	movs	r4, #216	; 0xd8
   15860:	e66c      	b.n	1553c <gnss_interface_read+0xcc>
   15862:	2039      	movs	r0, #57	; 0x39
   15864:	f7fa fbe2 	bl	1002c <bsd_os_errno_set>
   15868:	f04f 34ff 	mov.w	r4, #4294967295
   1586c:	e671      	b.n	15552 <gnss_interface_read+0xe2>
   1586e:	2016      	movs	r0, #22
   15870:	f7fa fbdc 	bl	1002c <bsd_os_errno_set>
   15874:	f04f 34ff 	mov.w	r4, #4294967295
   15878:	e66b      	b.n	15552 <gnss_interface_read+0xe2>
   1587a:	2009      	movs	r0, #9
   1587c:	f7fa fbd6 	bl	1002c <bsd_os_errno_set>
   15880:	f04f 34ff 	mov.w	r4, #4294967295
   15884:	e665      	b.n	15552 <gnss_interface_read+0xe2>
   15886:	bf00      	nop

00015888 <gnss_interface_setopt>:
   15888:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1588c:	4db3      	ldr	r5, [pc, #716]	; (15b5c <gnss_interface_setopt+0x2d4>)
   1588e:	b086      	sub	sp, #24
   15890:	682c      	ldr	r4, [r5, #0]
   15892:	b2a4      	uxth	r4, r4
   15894:	2c02      	cmp	r4, #2
   15896:	d00d      	beq.n	158b4 <gnss_interface_setopt+0x2c>
   15898:	2a08      	cmp	r2, #8
   1589a:	d00b      	beq.n	158b4 <gnss_interface_setopt+0x2c>
   1589c:	f1a2 040a 	sub.w	r4, r2, #10
   158a0:	2c01      	cmp	r4, #1
   158a2:	d907      	bls.n	158b4 <gnss_interface_setopt+0x2c>
   158a4:	200e      	movs	r0, #14
   158a6:	f7fa fbc1 	bl	1002c <bsd_os_errno_set>
   158aa:	f04f 30ff 	mov.w	r0, #4294967295
   158ae:	b006      	add	sp, #24
   158b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   158b4:	682c      	ldr	r4, [r5, #0]
   158b6:	0264      	lsls	r4, r4, #9
   158b8:	f100 8149 	bmi.w	15b4e <gnss_interface_setopt+0x2c6>
   158bc:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   158c0:	f040 8139 	bne.w	15b36 <gnss_interface_setopt+0x2ae>
   158c4:	49a6      	ldr	r1, [pc, #664]	; (15b60 <gnss_interface_setopt+0x2d8>)
   158c6:	4288      	cmp	r0, r1
   158c8:	f040 813b 	bne.w	15b42 <gnss_interface_setopt+0x2ba>
   158cc:	f1a2 010a 	sub.w	r1, r2, #10
   158d0:	2901      	cmp	r1, #1
   158d2:	d902      	bls.n	158da <gnss_interface_setopt+0x52>
   158d4:	2b00      	cmp	r3, #0
   158d6:	f000 8112 	beq.w	15afe <gnss_interface_setopt+0x276>
   158da:	3a01      	subs	r2, #1
   158dc:	2a0a      	cmp	r2, #10
   158de:	f200 810e 	bhi.w	15afe <gnss_interface_setopt+0x276>
   158e2:	e8df f012 	tbh	[pc, r2, lsl #1]
   158e6:	007f      	.short	0x007f
   158e8:	0098008c 	.word	0x0098008c
   158ec:	00ae00a2 	.word	0x00ae00a2
   158f0:	00c500b9 	.word	0x00c500b9
   158f4:	00f300dd 	.word	0x00f300dd
   158f8:	000b00ff 	.word	0x000b00ff
   158fc:	682b      	ldr	r3, [r5, #0]
   158fe:	b29b      	uxth	r3, r3
   15900:	2b04      	cmp	r3, #4
   15902:	d1cf      	bne.n	158a4 <gnss_interface_setopt+0x1c>
   15904:	2203      	movs	r2, #3
   15906:	f241 0604 	movw	r6, #4100	; 0x1004
   1590a:	2300      	movs	r3, #0
   1590c:	4637      	mov	r7, r6
   1590e:	f88d 2008 	strb.w	r2, [sp, #8]
   15912:	f88d 3009 	strb.w	r3, [sp, #9]
   15916:	f88d 300a 	strb.w	r3, [sp, #10]
   1591a:	f88d 300b 	strb.w	r3, [sp, #11]
   1591e:	f88d 300c 	strb.w	r3, [sp, #12]
   15922:	682b      	ldr	r3, [r5, #0]
   15924:	2112      	movs	r1, #18
   15926:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   1592a:	4668      	mov	r0, sp
   1592c:	602b      	str	r3, [r5, #0]
   1592e:	f002 fa63 	bl	17df8 <rpc_gnss_client_request_alloc>
   15932:	4604      	mov	r4, r0
   15934:	9800      	ldr	r0, [sp, #0]
   15936:	2c00      	cmp	r4, #0
   15938:	f040 80e7 	bne.w	15b0a <gnss_interface_setopt+0x282>
   1593c:	2800      	cmp	r0, #0
   1593e:	f000 80eb 	beq.w	15b18 <gnss_interface_setopt+0x290>
   15942:	2212      	movs	r2, #18
   15944:	f04f 0876 	mov.w	r8, #118	; 0x76
   15948:	f04f 0e49 	mov.w	lr, #73	; 0x49
   1594c:	f04f 0a43 	mov.w	sl, #67	; 0x43
   15950:	f04f 0954 	mov.w	r9, #84	; 0x54
   15954:	f8df c210 	ldr.w	ip, [pc, #528]	; 15b68 <gnss_interface_setopt+0x2e0>
   15958:	a906      	add	r1, sp, #24
   1595a:	f8bc 3000 	ldrh.w	r3, [ip]
   1595e:	f880 800e 	strb.w	r8, [r0, #14]
   15962:	3301      	adds	r3, #1
   15964:	b29b      	uxth	r3, r3
   15966:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
   1596a:	f841 6d14 	str.w	r6, [r1, #-20]!
   1596e:	7144      	strb	r4, [r0, #5]
   15970:	7184      	strb	r4, [r0, #6]
   15972:	71c4      	strb	r4, [r0, #7]
   15974:	7204      	strb	r4, [r0, #8]
   15976:	7244      	strb	r4, [r0, #9]
   15978:	7284      	strb	r4, [r0, #10]
   1597a:	72c4      	strb	r4, [r0, #11]
   1597c:	7102      	strb	r2, [r0, #4]
   1597e:	f880 a00c 	strb.w	sl, [r0, #12]
   15982:	f880 900d 	strb.w	r9, [r0, #13]
   15986:	f880 e00f 	strb.w	lr, [r0, #15]
   1598a:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 15b6c <gnss_interface_setopt+0x2e4>
   1598e:	6800      	ldr	r0, [r0, #0]
   15990:	f8ac 3000 	strh.w	r3, [ip]
   15994:	f006 fb26 	bl	1bfe4 <memcpy>
   15998:	4639      	mov	r1, r7
   1599a:	9800      	ldr	r0, [sp, #0]
   1599c:	f8c8 4000 	str.w	r4, [r8]
   159a0:	f002 fa3e 	bl	17e20 <rpc_gnss_client_request_send>
   159a4:	2800      	cmp	r0, #0
   159a6:	f040 80bc 	bne.w	15b22 <gnss_interface_setopt+0x29a>
   159aa:	4f6e      	ldr	r7, [pc, #440]	; (15b64 <gnss_interface_setopt+0x2dc>)
   159ac:	4e6c      	ldr	r6, [pc, #432]	; (15b60 <gnss_interface_setopt+0x2d8>)
   159ae:	4639      	mov	r1, r7
   159b0:	4630      	mov	r0, r6
   159b2:	f7fa fa85 	bl	fec0 <bsd_os_timedwait>
   159b6:	682c      	ldr	r4, [r5, #0]
   159b8:	f414 0480 	ands.w	r4, r4, #4194304	; 0x400000
   159bc:	d1f7      	bne.n	159ae <gnss_interface_setopt+0x126>
   159be:	f8d8 0000 	ldr.w	r0, [r8]
   159c2:	b118      	cbz	r0, 159cc <gnss_interface_setopt+0x144>
   159c4:	f002 fa4a 	bl	17e5c <rpc_gnss_client_data_free>
   159c8:	f8c8 4000 	str.w	r4, [r8]
   159cc:	682b      	ldr	r3, [r5, #0]
   159ce:	021b      	lsls	r3, r3, #8
   159d0:	f140 808f 	bpl.w	15af2 <gnss_interface_setopt+0x26a>
   159d4:	2000      	movs	r0, #0
   159d6:	682b      	ldr	r3, [r5, #0]
   159d8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   159dc:	602b      	str	r3, [r5, #0]
   159de:	b006      	add	sp, #24
   159e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   159e4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   159e6:	2a02      	cmp	r2, #2
   159e8:	f040 8089 	bne.w	15afe <gnss_interface_setopt+0x276>
   159ec:	2208      	movs	r2, #8
   159ee:	f241 1603 	movw	r6, #4355	; 0x1103
   159f2:	881b      	ldrh	r3, [r3, #0]
   159f4:	9202      	str	r2, [sp, #8]
   159f6:	f8ad 300f 	strh.w	r3, [sp, #15]
   159fa:	4637      	mov	r7, r6
   159fc:	e791      	b.n	15922 <gnss_interface_setopt+0x9a>
   159fe:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a00:	2a02      	cmp	r2, #2
   15a02:	d17c      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a04:	2210      	movs	r2, #16
   15a06:	f241 1603 	movw	r6, #4355	; 0x1103
   15a0a:	881b      	ldrh	r3, [r3, #0]
   15a0c:	9202      	str	r2, [sp, #8]
   15a0e:	f8ad 3011 	strh.w	r3, [sp, #17]
   15a12:	4637      	mov	r7, r6
   15a14:	e785      	b.n	15922 <gnss_interface_setopt+0x9a>
   15a16:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a18:	2a01      	cmp	r2, #1
   15a1a:	d170      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a1c:	781b      	ldrb	r3, [r3, #0]
   15a1e:	2b01      	cmp	r3, #1
   15a20:	d16d      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a22:	f241 1603 	movw	r6, #4355	; 0x1103
   15a26:	4637      	mov	r7, r6
   15a28:	e77b      	b.n	15922 <gnss_interface_setopt+0x9a>
   15a2a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a2c:	2a02      	cmp	r2, #2
   15a2e:	d166      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a30:	2220      	movs	r2, #32
   15a32:	f241 1603 	movw	r6, #4355	; 0x1103
   15a36:	881b      	ldrh	r3, [r3, #0]
   15a38:	9202      	str	r2, [sp, #8]
   15a3a:	f8ad 3013 	strh.w	r3, [sp, #19]
   15a3e:	4637      	mov	r7, r6
   15a40:	e76f      	b.n	15922 <gnss_interface_setopt+0x9a>
   15a42:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a44:	2a01      	cmp	r2, #1
   15a46:	d15a      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a48:	f241 1603 	movw	r6, #4355	; 0x1103
   15a4c:	781b      	ldrb	r3, [r3, #0]
   15a4e:	9202      	str	r2, [sp, #8]
   15a50:	f88d 300c 	strb.w	r3, [sp, #12]
   15a54:	4637      	mov	r7, r6
   15a56:	e764      	b.n	15922 <gnss_interface_setopt+0x9a>
   15a58:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a5a:	2a01      	cmp	r2, #1
   15a5c:	d14f      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a5e:	2202      	movs	r2, #2
   15a60:	f241 1603 	movw	r6, #4355	; 0x1103
   15a64:	781b      	ldrb	r3, [r3, #0]
   15a66:	9202      	str	r2, [sp, #8]
   15a68:	f88d 300d 	strb.w	r3, [sp, #13]
   15a6c:	4637      	mov	r7, r6
   15a6e:	e758      	b.n	15922 <gnss_interface_setopt+0x9a>
   15a70:	682a      	ldr	r2, [r5, #0]
   15a72:	b292      	uxth	r2, r2
   15a74:	2a02      	cmp	r2, #2
   15a76:	f47f af15 	bne.w	158a4 <gnss_interface_setopt+0x1c>
   15a7a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15a7c:	2a04      	cmp	r2, #4
   15a7e:	d13e      	bne.n	15afe <gnss_interface_setopt+0x276>
   15a80:	2101      	movs	r1, #1
   15a82:	f241 0604 	movw	r6, #4100	; 0x1004
   15a86:	682a      	ldr	r2, [r5, #0]
   15a88:	6818      	ldr	r0, [r3, #0]
   15a8a:	0c13      	lsrs	r3, r2, #16
   15a8c:	041b      	lsls	r3, r3, #16
   15a8e:	f043 0303 	orr.w	r3, r3, #3
   15a92:	f8cd 0009 	str.w	r0, [sp, #9]
   15a96:	602b      	str	r3, [r5, #0]
   15a98:	f88d 1008 	strb.w	r1, [sp, #8]
   15a9c:	4637      	mov	r7, r6
   15a9e:	e740      	b.n	15922 <gnss_interface_setopt+0x9a>
   15aa0:	682a      	ldr	r2, [r5, #0]
   15aa2:	b292      	uxth	r2, r2
   15aa4:	2a04      	cmp	r2, #4
   15aa6:	d004      	beq.n	15ab2 <gnss_interface_setopt+0x22a>
   15aa8:	682a      	ldr	r2, [r5, #0]
   15aaa:	b292      	uxth	r2, r2
   15aac:	2a02      	cmp	r2, #2
   15aae:	f47f aef9 	bne.w	158a4 <gnss_interface_setopt+0x1c>
   15ab2:	2200      	movs	r2, #0
   15ab4:	f88d 2008 	strb.w	r2, [sp, #8]
   15ab8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15aba:	2a04      	cmp	r2, #4
   15abc:	d11f      	bne.n	15afe <gnss_interface_setopt+0x276>
   15abe:	f241 0604 	movw	r6, #4100	; 0x1004
   15ac2:	681b      	ldr	r3, [r3, #0]
   15ac4:	4637      	mov	r7, r6
   15ac6:	f8cd 3009 	str.w	r3, [sp, #9]
   15aca:	e72a      	b.n	15922 <gnss_interface_setopt+0x9a>
   15acc:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   15ace:	2a01      	cmp	r2, #1
   15ad0:	d115      	bne.n	15afe <gnss_interface_setopt+0x276>
   15ad2:	2240      	movs	r2, #64	; 0x40
   15ad4:	f241 1603 	movw	r6, #4355	; 0x1103
   15ad8:	781b      	ldrb	r3, [r3, #0]
   15ada:	9202      	str	r2, [sp, #8]
   15adc:	f88d 3015 	strb.w	r3, [sp, #21]
   15ae0:	4637      	mov	r7, r6
   15ae2:	e71e      	b.n	15922 <gnss_interface_setopt+0x9a>
   15ae4:	682b      	ldr	r3, [r5, #0]
   15ae6:	b29b      	uxth	r3, r3
   15ae8:	2b04      	cmp	r3, #4
   15aea:	f47f aedb 	bne.w	158a4 <gnss_interface_setopt+0x1c>
   15aee:	2202      	movs	r2, #2
   15af0:	e709      	b.n	15906 <gnss_interface_setopt+0x7e>
   15af2:	200e      	movs	r0, #14
   15af4:	f7fa fa9a 	bl	1002c <bsd_os_errno_set>
   15af8:	f04f 30ff 	mov.w	r0, #4294967295
   15afc:	e76b      	b.n	159d6 <gnss_interface_setopt+0x14e>
   15afe:	2016      	movs	r0, #22
   15b00:	f7fa fa94 	bl	1002c <bsd_os_errno_set>
   15b04:	f04f 30ff 	mov.w	r0, #4294967295
   15b08:	e6d1      	b.n	158ae <gnss_interface_setopt+0x26>
   15b0a:	b128      	cbz	r0, 15b18 <gnss_interface_setopt+0x290>
   15b0c:	6803      	ldr	r3, [r0, #0]
   15b0e:	b11b      	cbz	r3, 15b18 <gnss_interface_setopt+0x290>
   15b10:	4618      	mov	r0, r3
   15b12:	f002 f9a3 	bl	17e5c <rpc_gnss_client_data_free>
   15b16:	9800      	ldr	r0, [sp, #0]
   15b18:	f002 f998 	bl	17e4c <rpc_gnss_client_message_free>
   15b1c:	2023      	movs	r0, #35	; 0x23
   15b1e:	f7fa fa85 	bl	1002c <bsd_os_errno_set>
   15b22:	682b      	ldr	r3, [r5, #0]
   15b24:	200e      	movs	r0, #14
   15b26:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   15b2a:	602b      	str	r3, [r5, #0]
   15b2c:	f7fa fa7e 	bl	1002c <bsd_os_errno_set>
   15b30:	f04f 30ff 	mov.w	r0, #4294967295
   15b34:	e6bb      	b.n	158ae <gnss_interface_setopt+0x26>
   15b36:	202a      	movs	r0, #42	; 0x2a
   15b38:	f7fa fa78 	bl	1002c <bsd_os_errno_set>
   15b3c:	f04f 30ff 	mov.w	r0, #4294967295
   15b40:	e6b5      	b.n	158ae <gnss_interface_setopt+0x26>
   15b42:	2009      	movs	r0, #9
   15b44:	f7fa fa72 	bl	1002c <bsd_os_errno_set>
   15b48:	f04f 30ff 	mov.w	r0, #4294967295
   15b4c:	e6af      	b.n	158ae <gnss_interface_setopt+0x26>
   15b4e:	2073      	movs	r0, #115	; 0x73
   15b50:	f7fa fa6c 	bl	1002c <bsd_os_errno_set>
   15b54:	f04f 30ff 	mov.w	r0, #4294967295
   15b58:	e6a9      	b.n	158ae <gnss_interface_setopt+0x26>
   15b5a:	bf00      	nop
   15b5c:	20020840 	.word	0x20020840
   15b60:	49765443 	.word	0x49765443
   15b64:	200200ec 	.word	0x200200ec
   15b68:	2002209a 	.word	0x2002209a
   15b6c:	20020844 	.word	0x20020844

00015b70 <gnss_interface_getopt>:
   15b70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15b74:	4c81      	ldr	r4, [pc, #516]	; (15d7c <gnss_interface_getopt+0x20c>)
   15b76:	b087      	sub	sp, #28
   15b78:	6825      	ldr	r5, [r4, #0]
   15b7a:	4698      	mov	r8, r3
   15b7c:	b2ad      	uxth	r5, r5
   15b7e:	2d02      	cmp	r5, #2
   15b80:	9b10      	ldr	r3, [sp, #64]	; 0x40
   15b82:	f040 80dd 	bne.w	15d40 <gnss_interface_getopt+0x1d0>
   15b86:	6825      	ldr	r5, [r4, #0]
   15b88:	03ee      	lsls	r6, r5, #15
   15b8a:	f100 80eb 	bmi.w	15d64 <gnss_interface_getopt+0x1f4>
   15b8e:	6825      	ldr	r5, [r4, #0]
   15b90:	01ed      	lsls	r5, r5, #7
   15b92:	f100 80ed 	bmi.w	15d70 <gnss_interface_getopt+0x200>
   15b96:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   15b9a:	f040 80d7 	bne.w	15d4c <gnss_interface_getopt+0x1dc>
   15b9e:	4978      	ldr	r1, [pc, #480]	; (15d80 <gnss_interface_getopt+0x210>)
   15ba0:	4288      	cmp	r0, r1
   15ba2:	f040 80d9 	bne.w	15d58 <gnss_interface_getopt+0x1e8>
   15ba6:	f1b8 0f00 	cmp.w	r8, #0
   15baa:	d00b      	beq.n	15bc4 <gnss_interface_getopt+0x54>
   15bac:	b153      	cbz	r3, 15bc4 <gnss_interface_getopt+0x54>
   15bae:	1e57      	subs	r7, r2, #1
   15bb0:	2f05      	cmp	r7, #5
   15bb2:	d807      	bhi.n	15bc4 <gnss_interface_getopt+0x54>
   15bb4:	e8df f007 	tbb	[pc, r7]
   15bb8:	0f030f0f 	.word	0x0f030f0f
   15bbc:	0303      	.short	0x0303
   15bbe:	681b      	ldr	r3, [r3, #0]
   15bc0:	2b01      	cmp	r3, #1
   15bc2:	d00b      	beq.n	15bdc <gnss_interface_getopt+0x6c>
   15bc4:	2016      	movs	r0, #22
   15bc6:	f7fa fa31 	bl	1002c <bsd_os_errno_set>
   15bca:	f04f 35ff 	mov.w	r5, #4294967295
   15bce:	4628      	mov	r0, r5
   15bd0:	b007      	add	sp, #28
   15bd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15bd6:	681b      	ldr	r3, [r3, #0]
   15bd8:	2b02      	cmp	r3, #2
   15bda:	d1f3      	bne.n	15bc4 <gnss_interface_getopt+0x54>
   15bdc:	6823      	ldr	r3, [r4, #0]
   15bde:	2212      	movs	r2, #18
   15be0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   15be4:	2100      	movs	r1, #0
   15be6:	a801      	add	r0, sp, #4
   15be8:	6023      	str	r3, [r4, #0]
   15bea:	f006 fa26 	bl	1c03a <memset>
   15bee:	2112      	movs	r1, #18
   15bf0:	4668      	mov	r0, sp
   15bf2:	f002 f901 	bl	17df8 <rpc_gnss_client_request_alloc>
   15bf6:	4605      	mov	r5, r0
   15bf8:	9800      	ldr	r0, [sp, #0]
   15bfa:	2d00      	cmp	r5, #0
   15bfc:	f040 808a 	bne.w	15d14 <gnss_interface_getopt+0x1a4>
   15c00:	2800      	cmp	r0, #0
   15c02:	f000 808e 	beq.w	15d22 <gnss_interface_getopt+0x1b2>
   15c06:	f241 1602 	movw	r6, #4354	; 0x1102
   15c0a:	f04f 0e49 	mov.w	lr, #73	; 0x49
   15c0e:	2212      	movs	r2, #18
   15c10:	f04f 0976 	mov.w	r9, #118	; 0x76
   15c14:	f04f 0b43 	mov.w	fp, #67	; 0x43
   15c18:	f04f 0a54 	mov.w	sl, #84	; 0x54
   15c1c:	f8df c168 	ldr.w	ip, [pc, #360]	; 15d88 <gnss_interface_getopt+0x218>
   15c20:	f880 e00f 	strb.w	lr, [r0, #15]
   15c24:	f8bc 3000 	ldrh.w	r3, [ip]
   15c28:	f880 900e 	strb.w	r9, [r0, #14]
   15c2c:	3301      	adds	r3, #1
   15c2e:	b29b      	uxth	r3, r3
   15c30:	ea46 4e03 	orr.w	lr, r6, r3, lsl #16
   15c34:	f8cd e004 	str.w	lr, [sp, #4]
   15c38:	7145      	strb	r5, [r0, #5]
   15c3a:	7185      	strb	r5, [r0, #6]
   15c3c:	71c5      	strb	r5, [r0, #7]
   15c3e:	7205      	strb	r5, [r0, #8]
   15c40:	7245      	strb	r5, [r0, #9]
   15c42:	7285      	strb	r5, [r0, #10]
   15c44:	72c5      	strb	r5, [r0, #11]
   15c46:	a901      	add	r1, sp, #4
   15c48:	7102      	strb	r2, [r0, #4]
   15c4a:	f880 b00c 	strb.w	fp, [r0, #12]
   15c4e:	f880 a00d 	strb.w	sl, [r0, #13]
   15c52:	f8df 9138 	ldr.w	r9, [pc, #312]	; 15d8c <gnss_interface_getopt+0x21c>
   15c56:	6800      	ldr	r0, [r0, #0]
   15c58:	f8ac 3000 	strh.w	r3, [ip]
   15c5c:	f006 f9c2 	bl	1bfe4 <memcpy>
   15c60:	4631      	mov	r1, r6
   15c62:	9800      	ldr	r0, [sp, #0]
   15c64:	f8c9 5000 	str.w	r5, [r9]
   15c68:	f002 f8da 	bl	17e20 <rpc_gnss_client_request_send>
   15c6c:	2800      	cmp	r0, #0
   15c6e:	d15d      	bne.n	15d2c <gnss_interface_getopt+0x1bc>
   15c70:	4e44      	ldr	r6, [pc, #272]	; (15d84 <gnss_interface_getopt+0x214>)
   15c72:	4d43      	ldr	r5, [pc, #268]	; (15d80 <gnss_interface_getopt+0x210>)
   15c74:	4631      	mov	r1, r6
   15c76:	4628      	mov	r0, r5
   15c78:	f7fa f922 	bl	fec0 <bsd_os_timedwait>
   15c7c:	6823      	ldr	r3, [r4, #0]
   15c7e:	01db      	lsls	r3, r3, #7
   15c80:	d4f8      	bmi.n	15c74 <gnss_interface_getopt+0x104>
   15c82:	f8d9 0000 	ldr.w	r0, [r9]
   15c86:	b1d8      	cbz	r0, 15cc0 <gnss_interface_getopt+0x150>
   15c88:	6825      	ldr	r5, [r4, #0]
   15c8a:	f015 7500 	ands.w	r5, r5, #33554432	; 0x2000000
   15c8e:	d00f      	beq.n	15cb0 <gnss_interface_getopt+0x140>
   15c90:	2f05      	cmp	r7, #5
   15c92:	d837      	bhi.n	15d04 <gnss_interface_getopt+0x194>
   15c94:	e8df f007 	tbb	[pc, r7]
   15c98:	2b26201a 	.word	0x2b26201a
   15c9c:	0331      	.short	0x0331
   15c9e:	2500      	movs	r5, #0
   15ca0:	7b43      	ldrb	r3, [r0, #13]
   15ca2:	f888 3000 	strb.w	r3, [r8]
   15ca6:	f002 f8d9 	bl	17e5c <rpc_gnss_client_data_free>
   15caa:	2300      	movs	r3, #0
   15cac:	f8c9 3000 	str.w	r3, [r9]
   15cb0:	6823      	ldr	r3, [r4, #0]
   15cb2:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   15cb6:	6023      	str	r3, [r4, #0]
   15cb8:	4628      	mov	r0, r5
   15cba:	b007      	add	sp, #28
   15cbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15cc0:	6823      	ldr	r3, [r4, #0]
   15cc2:	4605      	mov	r5, r0
   15cc4:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   15cc8:	6023      	str	r3, [r4, #0]
   15cca:	e7f5      	b.n	15cb8 <gnss_interface_getopt+0x148>
   15ccc:	f8b0 300f 	ldrh.w	r3, [r0, #15]
   15cd0:	2500      	movs	r5, #0
   15cd2:	f8a8 3000 	strh.w	r3, [r8]
   15cd6:	e7e6      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15cd8:	f8b0 3011 	ldrh.w	r3, [r0, #17]
   15cdc:	2500      	movs	r5, #0
   15cde:	f8a8 3000 	strh.w	r3, [r8]
   15ce2:	e7e0      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15ce4:	7b83      	ldrb	r3, [r0, #14]
   15ce6:	2500      	movs	r5, #0
   15ce8:	f888 3000 	strb.w	r3, [r8]
   15cec:	e7db      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15cee:	f8b0 3013 	ldrh.w	r3, [r0, #19]
   15cf2:	2500      	movs	r5, #0
   15cf4:	f8a8 3000 	strh.w	r3, [r8]
   15cf8:	e7d5      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15cfa:	7b03      	ldrb	r3, [r0, #12]
   15cfc:	2500      	movs	r5, #0
   15cfe:	f888 3000 	strb.w	r3, [r8]
   15d02:	e7d0      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15d04:	2016      	movs	r0, #22
   15d06:	f7fa f991 	bl	1002c <bsd_os_errno_set>
   15d0a:	f04f 35ff 	mov.w	r5, #4294967295
   15d0e:	f8d9 0000 	ldr.w	r0, [r9]
   15d12:	e7c8      	b.n	15ca6 <gnss_interface_getopt+0x136>
   15d14:	b128      	cbz	r0, 15d22 <gnss_interface_getopt+0x1b2>
   15d16:	6803      	ldr	r3, [r0, #0]
   15d18:	b11b      	cbz	r3, 15d22 <gnss_interface_getopt+0x1b2>
   15d1a:	4618      	mov	r0, r3
   15d1c:	f002 f89e 	bl	17e5c <rpc_gnss_client_data_free>
   15d20:	9800      	ldr	r0, [sp, #0]
   15d22:	f002 f893 	bl	17e4c <rpc_gnss_client_message_free>
   15d26:	2023      	movs	r0, #35	; 0x23
   15d28:	f7fa f980 	bl	1002c <bsd_os_errno_set>
   15d2c:	6823      	ldr	r3, [r4, #0]
   15d2e:	200e      	movs	r0, #14
   15d30:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   15d34:	6023      	str	r3, [r4, #0]
   15d36:	f04f 35ff 	mov.w	r5, #4294967295
   15d3a:	f7fa f977 	bl	1002c <bsd_os_errno_set>
   15d3e:	e746      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d40:	200e      	movs	r0, #14
   15d42:	f7fa f973 	bl	1002c <bsd_os_errno_set>
   15d46:	f04f 35ff 	mov.w	r5, #4294967295
   15d4a:	e740      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d4c:	202a      	movs	r0, #42	; 0x2a
   15d4e:	f7fa f96d 	bl	1002c <bsd_os_errno_set>
   15d52:	f04f 35ff 	mov.w	r5, #4294967295
   15d56:	e73a      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d58:	2009      	movs	r0, #9
   15d5a:	f7fa f967 	bl	1002c <bsd_os_errno_set>
   15d5e:	f04f 35ff 	mov.w	r5, #4294967295
   15d62:	e734      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d64:	2005      	movs	r0, #5
   15d66:	f7fa f961 	bl	1002c <bsd_os_errno_set>
   15d6a:	f04f 35ff 	mov.w	r5, #4294967295
   15d6e:	e72e      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d70:	2073      	movs	r0, #115	; 0x73
   15d72:	f7fa f95b 	bl	1002c <bsd_os_errno_set>
   15d76:	f04f 35ff 	mov.w	r5, #4294967295
   15d7a:	e728      	b.n	15bce <gnss_interface_getopt+0x5e>
   15d7c:	20020840 	.word	0x20020840
   15d80:	49765443 	.word	0x49765443
   15d84:	200200ec 	.word	0x200200ec
   15d88:	2002209a 	.word	0x2002209a
   15d8c:	20020844 	.word	0x20020844

00015d90 <gnss_interface_init>:
   15d90:	2100      	movs	r1, #0
   15d92:	b538      	push	{r3, r4, r5, lr}
   15d94:	4c09      	ldr	r4, [pc, #36]	; (15dbc <gnss_interface_init+0x2c>)
   15d96:	4d0a      	ldr	r5, [pc, #40]	; (15dc0 <gnss_interface_init+0x30>)
   15d98:	6822      	ldr	r2, [r4, #0]
   15d9a:	480a      	ldr	r0, [pc, #40]	; (15dc4 <gnss_interface_init+0x34>)
   15d9c:	4b0a      	ldr	r3, [pc, #40]	; (15dc8 <gnss_interface_init+0x38>)
   15d9e:	402a      	ands	r2, r5
   15da0:	6022      	str	r2, [r4, #0]
   15da2:	8001      	strh	r1, [r0, #0]
   15da4:	6019      	str	r1, [r3, #0]
   15da6:	f002 f821 	bl	17dec <rpc_gnss_client_init>
   15daa:	b928      	cbnz	r0, 15db8 <gnss_interface_init+0x28>
   15dac:	6823      	ldr	r3, [r4, #0]
   15dae:	402b      	ands	r3, r5
   15db0:	f043 0301 	orr.w	r3, r3, #1
   15db4:	6023      	str	r3, [r4, #0]
   15db6:	bd38      	pop	{r3, r4, r5, pc}
   15db8:	2003      	movs	r0, #3
   15dba:	bd38      	pop	{r3, r4, r5, pc}
   15dbc:	20020840 	.word	0x20020840
   15dc0:	ffff0000 	.word	0xffff0000
   15dc4:	2002209a 	.word	0x2002209a
   15dc8:	20020844 	.word	0x20020844

00015dcc <gnss_interface_open>:
   15dcc:	2902      	cmp	r1, #2
   15dce:	b510      	push	{r4, lr}
   15dd0:	d121      	bne.n	15e16 <gnss_interface_open+0x4a>
   15dd2:	4c17      	ldr	r4, [pc, #92]	; (15e30 <gnss_interface_open+0x64>)
   15dd4:	6823      	ldr	r3, [r4, #0]
   15dd6:	b29b      	uxth	r3, r3
   15dd8:	2b01      	cmp	r3, #1
   15dda:	d116      	bne.n	15e0a <gnss_interface_open+0x3e>
   15ddc:	6823      	ldr	r3, [r4, #0]
   15dde:	4608      	mov	r0, r1
   15de0:	0c1b      	lsrs	r3, r3, #16
   15de2:	041b      	lsls	r3, r3, #16
   15de4:	f043 0302 	orr.w	r3, r3, #2
   15de8:	2200      	movs	r2, #0
   15dea:	4912      	ldr	r1, [pc, #72]	; (15e34 <gnss_interface_open+0x68>)
   15dec:	6023      	str	r3, [r4, #0]
   15dee:	f002 f91f 	bl	18030 <packet_handler_create>
   15df2:	4a11      	ldr	r2, [pc, #68]	; (15e38 <gnss_interface_open+0x6c>)
   15df4:	6010      	str	r0, [r2, #0]
   15df6:	b1a0      	cbz	r0, 15e22 <gnss_interface_open+0x56>
   15df8:	6823      	ldr	r3, [r4, #0]
   15dfa:	6802      	ldr	r2, [r0, #0]
   15dfc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   15e00:	6812      	ldr	r2, [r2, #0]
   15e02:	6023      	str	r3, [r4, #0]
   15e04:	4790      	blx	r2
   15e06:	480d      	ldr	r0, [pc, #52]	; (15e3c <gnss_interface_open+0x70>)
   15e08:	bd10      	pop	{r4, pc}
   15e0a:	2005      	movs	r0, #5
   15e0c:	f7fa f90e 	bl	1002c <bsd_os_errno_set>
   15e10:	f04f 30ff 	mov.w	r0, #4294967295
   15e14:	bd10      	pop	{r4, pc}
   15e16:	2029      	movs	r0, #41	; 0x29
   15e18:	f7fa f908 	bl	1002c <bsd_os_errno_set>
   15e1c:	f04f 30ff 	mov.w	r0, #4294967295
   15e20:	bd10      	pop	{r4, pc}
   15e22:	200e      	movs	r0, #14
   15e24:	f7fa f902 	bl	1002c <bsd_os_errno_set>
   15e28:	f04f 30ff 	mov.w	r0, #4294967295
   15e2c:	bd10      	pop	{r4, pc}
   15e2e:	bf00      	nop
   15e30:	20020840 	.word	0x20020840
   15e34:	000150c5 	.word	0x000150c5
   15e38:	20020848 	.word	0x20020848
   15e3c:	49765443 	.word	0x49765443

00015e40 <gnss_interface_close>:
   15e40:	b530      	push	{r4, r5, lr}
   15e42:	4b15      	ldr	r3, [pc, #84]	; (15e98 <gnss_interface_close+0x58>)
   15e44:	b085      	sub	sp, #20
   15e46:	4298      	cmp	r0, r3
   15e48:	d11f      	bne.n	15e8a <gnss_interface_close+0x4a>
   15e4a:	4c14      	ldr	r4, [pc, #80]	; (15e9c <gnss_interface_close+0x5c>)
   15e4c:	6822      	ldr	r2, [r4, #0]
   15e4e:	b292      	uxth	r2, r2
   15e50:	2a04      	cmp	r2, #4
   15e52:	d00f      	beq.n	15e74 <gnss_interface_close+0x34>
   15e54:	4d12      	ldr	r5, [pc, #72]	; (15ea0 <gnss_interface_close+0x60>)
   15e56:	6828      	ldr	r0, [r5, #0]
   15e58:	b118      	cbz	r0, 15e62 <gnss_interface_close+0x22>
   15e5a:	f002 f909 	bl	18070 <packet_handler_delete>
   15e5e:	2300      	movs	r3, #0
   15e60:	602b      	str	r3, [r5, #0]
   15e62:	2000      	movs	r0, #0
   15e64:	6823      	ldr	r3, [r4, #0]
   15e66:	0c1b      	lsrs	r3, r3, #16
   15e68:	041b      	lsls	r3, r3, #16
   15e6a:	f043 0301 	orr.w	r3, r3, #1
   15e6e:	6023      	str	r3, [r4, #0]
   15e70:	b005      	add	sp, #20
   15e72:	bd30      	pop	{r4, r5, pc}
   15e74:	2100      	movs	r1, #0
   15e76:	ab04      	add	r3, sp, #16
   15e78:	f843 1d04 	str.w	r1, [r3, #-4]!
   15e7c:	9200      	str	r2, [sp, #0]
   15e7e:	f44f 7101 	mov.w	r1, #516	; 0x204
   15e82:	2208      	movs	r2, #8
   15e84:	f001 fe32 	bl	17aec <nrf_setsockopt>
   15e88:	e7e4      	b.n	15e54 <gnss_interface_close+0x14>
   15e8a:	2009      	movs	r0, #9
   15e8c:	f7fa f8ce 	bl	1002c <bsd_os_errno_set>
   15e90:	f04f 30ff 	mov.w	r0, #4294967295
   15e94:	e7ec      	b.n	15e70 <gnss_interface_close+0x30>
   15e96:	bf00      	nop
   15e98:	49765443 	.word	0x49765443
   15e9c:	20020840 	.word	0x20020840
   15ea0:	20020848 	.word	0x20020848

00015ea4 <rpc_logobj_client_evt_handler>:
   15ea4:	b120      	cbz	r0, 15eb0 <rpc_logobj_client_evt_handler+0xc>
   15ea6:	f850 1b08 	ldr.w	r1, [r0], #8
   15eaa:	0c09      	lsrs	r1, r1, #16
   15eac:	f7fb bbaa 	b.w	11604 <logobj_event_handler>
   15eb0:	4770      	bx	lr
   15eb2:	bf00      	nop

00015eb4 <rpc_logobj_client_init>:
   15eb4:	4801      	ldr	r0, [pc, #4]	; (15ebc <rpc_logobj_client_init+0x8>)
   15eb6:	f7ff b847 	b.w	14f48 <rpc_client_register>
   15eba:	bf00      	nop
   15ebc:	0001de44 	.word	0x0001de44

00015ec0 <rpc_logobj_client_request_alloc>:
   15ec0:	2300      	movs	r3, #0
   15ec2:	b510      	push	{r4, lr}
   15ec4:	b082      	sub	sp, #8
   15ec6:	9301      	str	r3, [sp, #4]
   15ec8:	b961      	cbnz	r1, 15ee4 <rpc_logobj_client_request_alloc+0x24>
   15eca:	b170      	cbz	r0, 15eea <rpc_logobj_client_request_alloc+0x2a>
   15ecc:	4604      	mov	r4, r0
   15ece:	aa01      	add	r2, sp, #4
   15ed0:	2009      	movs	r0, #9
   15ed2:	f7ff f8b3 	bl	1503c <rpc_message_alloc>
   15ed6:	b918      	cbnz	r0, 15ee0 <rpc_logobj_client_request_alloc+0x20>
   15ed8:	9b01      	ldr	r3, [sp, #4]
   15eda:	b10b      	cbz	r3, 15ee0 <rpc_logobj_client_request_alloc+0x20>
   15edc:	3308      	adds	r3, #8
   15ede:	6023      	str	r3, [r4, #0]
   15ee0:	b002      	add	sp, #8
   15ee2:	bd10      	pop	{r4, pc}
   15ee4:	200f      	movs	r0, #15
   15ee6:	b002      	add	sp, #8
   15ee8:	bd10      	pop	{r4, pc}
   15eea:	200e      	movs	r0, #14
   15eec:	b002      	add	sp, #8
   15eee:	bd10      	pop	{r4, pc}

00015ef0 <rpc_logobj_client_request_send>:
   15ef0:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   15ef4:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   15ef8:	d10b      	bne.n	15f12 <rpc_logobj_client_request_send+0x22>
   15efa:	b160      	cbz	r0, 15f16 <rpc_logobj_client_request_send+0x26>
   15efc:	4603      	mov	r3, r0
   15efe:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   15f02:	2009      	movs	r0, #9
   15f04:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   15f08:	f843 1d08 	str.w	r1, [r3, #-8]!
   15f0c:	4619      	mov	r1, r3
   15f0e:	f7ff b885 	b.w	1501c <rpc_message_send>
   15f12:	200f      	movs	r0, #15
   15f14:	4770      	bx	lr
   15f16:	200e      	movs	r0, #14
   15f18:	4770      	bx	lr
   15f1a:	bf00      	nop

00015f1c <rpc_logobj_client_message_free>:
   15f1c:	b120      	cbz	r0, 15f28 <rpc_logobj_client_message_free+0xc>
   15f1e:	f1a0 0108 	sub.w	r1, r0, #8
   15f22:	2009      	movs	r0, #9
   15f24:	f7ff b8b6 	b.w	15094 <rpc_message_free>
   15f28:	200e      	movs	r0, #14
   15f2a:	4770      	bx	lr

00015f2c <rpc_logobj_client_data_free>:
   15f2c:	b118      	cbz	r0, 15f36 <rpc_logobj_client_data_free+0xa>
   15f2e:	4601      	mov	r1, r0
   15f30:	2009      	movs	r0, #9
   15f32:	f7ff b8bb 	b.w	150ac <rpc_message_data_free>
   15f36:	200e      	movs	r0, #14
   15f38:	4770      	bx	lr
   15f3a:	bf00      	nop

00015f3c <dfu_client_event_handler>:
   15f3c:	f850 1b08 	ldr.w	r1, [r0], #8
   15f40:	0c09      	lsrs	r1, r1, #16
   15f42:	f002 bd9b 	b.w	18a7c <rpc_dfu_event_handler>
   15f46:	bf00      	nop

00015f48 <rpc_dfu_client_init>:
   15f48:	4801      	ldr	r0, [pc, #4]	; (15f50 <rpc_dfu_client_init+0x8>)
   15f4a:	f7fe bffd 	b.w	14f48 <rpc_client_register>
   15f4e:	bf00      	nop
   15f50:	0001de54 	.word	0x0001de54

00015f54 <rpc_dfu_client_request_alloc>:
   15f54:	2300      	movs	r3, #0
   15f56:	b510      	push	{r4, lr}
   15f58:	b082      	sub	sp, #8
   15f5a:	9301      	str	r3, [sp, #4]
   15f5c:	b158      	cbz	r0, 15f76 <rpc_dfu_client_request_alloc+0x22>
   15f5e:	4604      	mov	r4, r0
   15f60:	aa01      	add	r2, sp, #4
   15f62:	2006      	movs	r0, #6
   15f64:	f7ff f86a 	bl	1503c <rpc_message_alloc>
   15f68:	b918      	cbnz	r0, 15f72 <rpc_dfu_client_request_alloc+0x1e>
   15f6a:	9b01      	ldr	r3, [sp, #4]
   15f6c:	b10b      	cbz	r3, 15f72 <rpc_dfu_client_request_alloc+0x1e>
   15f6e:	3308      	adds	r3, #8
   15f70:	6023      	str	r3, [r4, #0]
   15f72:	b002      	add	sp, #8
   15f74:	bd10      	pop	{r4, pc}
   15f76:	2007      	movs	r0, #7
   15f78:	b002      	add	sp, #8
   15f7a:	bd10      	pop	{r4, pc}

00015f7c <rpc_dfu_client_request_send>:
   15f7c:	f411 4f70 	tst.w	r1, #61440	; 0xf000
   15f80:	d10b      	bne.n	15f9a <rpc_dfu_client_request_send+0x1e>
   15f82:	b160      	cbz	r0, 15f9e <rpc_dfu_client_request_send+0x22>
   15f84:	4603      	mov	r3, r0
   15f86:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   15f8a:	2006      	movs	r0, #6
   15f8c:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   15f90:	f843 1d08 	str.w	r1, [r3, #-8]!
   15f94:	4619      	mov	r1, r3
   15f96:	f7ff b841 	b.w	1501c <rpc_message_send>
   15f9a:	200f      	movs	r0, #15
   15f9c:	4770      	bx	lr
   15f9e:	2007      	movs	r0, #7
   15fa0:	4770      	bx	lr
   15fa2:	bf00      	nop

00015fa4 <rpc_dfu_client_message_free>:
   15fa4:	b120      	cbz	r0, 15fb0 <rpc_dfu_client_message_free+0xc>
   15fa6:	f1a0 0108 	sub.w	r1, r0, #8
   15faa:	2006      	movs	r0, #6
   15fac:	f7ff b872 	b.w	15094 <rpc_message_free>
   15fb0:	2007      	movs	r0, #7
   15fb2:	4770      	bx	lr

00015fb4 <rpc_dfu_client_data_free>:
   15fb4:	b118      	cbz	r0, 15fbe <rpc_dfu_client_data_free+0xa>
   15fb6:	4601      	mov	r1, r0
   15fb8:	2006      	movs	r0, #6
   15fba:	f7ff b877 	b.w	150ac <rpc_message_data_free>
   15fbe:	2007      	movs	r0, #7
   15fc0:	4770      	bx	lr
   15fc2:	bf00      	nop

00015fc4 <packet_free_cb>:
   15fc4:	6800      	ldr	r0, [r0, #0]
   15fc6:	f003 babf 	b.w	19548 <rpc_at_client_data_free>
   15fca:	bf00      	nop

00015fcc <at_interface_write>:
   15fcc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15fd0:	b083      	sub	sp, #12
   15fd2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   15fd4:	2c00      	cmp	r4, #0
   15fd6:	d166      	bne.n	160a6 <at_interface_write+0xda>
   15fd8:	4688      	mov	r8, r1
   15fda:	4615      	mov	r5, r2
   15fdc:	461e      	mov	r6, r3
   15fde:	4607      	mov	r7, r0
   15fe0:	f003 f984 	bl	192ec <interface_socket_from_handle_get>
   15fe4:	4604      	mov	r4, r0
   15fe6:	2e00      	cmp	r6, #0
   15fe8:	d137      	bne.n	1605a <at_interface_write+0x8e>
   15fea:	2800      	cmp	r0, #0
   15fec:	d061      	beq.n	160b2 <at_interface_write+0xe6>
   15fee:	6803      	ldr	r3, [r0, #0]
   15ff0:	039b      	lsls	r3, r3, #14
   15ff2:	d55e      	bpl.n	160b2 <at_interface_write+0xe6>
   15ff4:	6803      	ldr	r3, [r0, #0]
   15ff6:	4629      	mov	r1, r5
   15ff8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   15ffc:	6003      	str	r3, [r0, #0]
   15ffe:	6803      	ldr	r3, [r0, #0]
   16000:	4668      	mov	r0, sp
   16002:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   16006:	6023      	str	r3, [r4, #0]
   16008:	f003 fa74 	bl	194f4 <rpc_at_client_request_alloc>
   1600c:	4606      	mov	r6, r0
   1600e:	4638      	mov	r0, r7
   16010:	f003 f96c 	bl	192ec <interface_socket_from_handle_get>
   16014:	4681      	mov	r9, r0
   16016:	2e00      	cmp	r6, #0
   16018:	d13f      	bne.n	1609a <at_interface_write+0xce>
   1601a:	2304      	movs	r3, #4
   1601c:	9800      	ldr	r0, [sp, #0]
   1601e:	7203      	strb	r3, [r0, #8]
   16020:	7246      	strb	r6, [r0, #9]
   16022:	7286      	strb	r6, [r0, #10]
   16024:	72c6      	strb	r6, [r0, #11]
   16026:	60c7      	str	r7, [r0, #12]
   16028:	b9fd      	cbnz	r5, 1606a <at_interface_write+0x9e>
   1602a:	2101      	movs	r1, #1
   1602c:	f003 fa76 	bl	1951c <rpc_at_client_request_send>
   16030:	bb50      	cbnz	r0, 16088 <at_interface_write+0xbc>
   16032:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
   16036:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   1603a:	2900      	cmp	r1, #0
   1603c:	bf08      	it	eq
   1603e:	f04f 31ff 	moveq.w	r1, #4294967295
   16042:	ab02      	add	r3, sp, #8
   16044:	f843 1d04 	str.w	r1, [r3, #-4]!
   16048:	4638      	mov	r0, r7
   1604a:	4611      	mov	r1, r2
   1604c:	f003 f8ce 	bl	191ec <interface_socket_wait>
   16050:	b9f0      	cbnz	r0, 16090 <at_interface_write+0xc4>
   16052:	4628      	mov	r0, r5
   16054:	b003      	add	sp, #12
   16056:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1605a:	b360      	cbz	r0, 160b6 <at_interface_write+0xea>
   1605c:	6803      	ldr	r3, [r0, #0]
   1605e:	202d      	movs	r0, #45	; 0x2d
   16060:	f7f9 ffe4 	bl	1002c <bsd_os_errno_set>
   16064:	f04f 30ff 	mov.w	r0, #4294967295
   16068:	e7f4      	b.n	16054 <at_interface_write+0x88>
   1606a:	4641      	mov	r1, r8
   1606c:	6800      	ldr	r0, [r0, #0]
   1606e:	462a      	mov	r2, r5
   16070:	f005 ffb8 	bl	1bfe4 <memcpy>
   16074:	2101      	movs	r1, #1
   16076:	9800      	ldr	r0, [sp, #0]
   16078:	f003 fa50 	bl	1951c <rpc_at_client_request_send>
   1607c:	2800      	cmp	r0, #0
   1607e:	d0d8      	beq.n	16032 <at_interface_write+0x66>
   16080:	9b00      	ldr	r3, [sp, #0]
   16082:	6818      	ldr	r0, [r3, #0]
   16084:	f003 fa60 	bl	19548 <rpc_at_client_data_free>
   16088:	9800      	ldr	r0, [sp, #0]
   1608a:	f003 fa55 	bl	19538 <rpc_at_client_message_free>
   1608e:	2023      	movs	r0, #35	; 0x23
   16090:	6823      	ldr	r3, [r4, #0]
   16092:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   16096:	6023      	str	r3, [r4, #0]
   16098:	e7e2      	b.n	16060 <at_interface_write+0x94>
   1609a:	6823      	ldr	r3, [r4, #0]
   1609c:	200c      	movs	r0, #12
   1609e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   160a2:	6023      	str	r3, [r4, #0]
   160a4:	e7dc      	b.n	16060 <at_interface_write+0x94>
   160a6:	2038      	movs	r0, #56	; 0x38
   160a8:	f7f9 ffc0 	bl	1002c <bsd_os_errno_set>
   160ac:	f04f 30ff 	mov.w	r0, #4294967295
   160b0:	e7d0      	b.n	16054 <at_interface_write+0x88>
   160b2:	2016      	movs	r0, #22
   160b4:	e7d4      	b.n	16060 <at_interface_write+0x94>
   160b6:	202d      	movs	r0, #45	; 0x2d
   160b8:	e7d2      	b.n	16060 <at_interface_write+0x94>
   160ba:	bf00      	nop

000160bc <at_interface_init>:
   160bc:	b508      	push	{r3, lr}
   160be:	f003 fa13 	bl	194e8 <rpc_at_client_init>
   160c2:	b910      	cbnz	r0, 160ca <at_interface_init+0xe>
   160c4:	2201      	movs	r2, #1
   160c6:	4b01      	ldr	r3, [pc, #4]	; (160cc <at_interface_init+0x10>)
   160c8:	701a      	strb	r2, [r3, #0]
   160ca:	bd08      	pop	{r3, pc}
   160cc:	2002366e 	.word	0x2002366e

000160d0 <at_interface_open>:
   160d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   160d4:	2600      	movs	r6, #0
   160d6:	4b2e      	ldr	r3, [pc, #184]	; (16190 <at_interface_open+0xc0>)
   160d8:	b084      	sub	sp, #16
   160da:	781b      	ldrb	r3, [r3, #0]
   160dc:	9601      	str	r6, [sp, #4]
   160de:	2b00      	cmp	r3, #0
   160e0:	d050      	beq.n	16184 <at_interface_open+0xb4>
   160e2:	2902      	cmp	r1, #2
   160e4:	460d      	mov	r5, r1
   160e6:	d147      	bne.n	16178 <at_interface_open+0xa8>
   160e8:	4680      	mov	r8, r0
   160ea:	4617      	mov	r7, r2
   160ec:	a801      	add	r0, sp, #4
   160ee:	4a29      	ldr	r2, [pc, #164]	; (16194 <at_interface_open+0xc4>)
   160f0:	f002 ffca 	bl	19088 <interface_socket_allocate>
   160f4:	9b01      	ldr	r3, [sp, #4]
   160f6:	4604      	mov	r4, r0
   160f8:	b35b      	cbz	r3, 16152 <at_interface_open+0x82>
   160fa:	615f      	str	r7, [r3, #20]
   160fc:	4631      	mov	r1, r6
   160fe:	e9c3 8503 	strd	r8, r5, [r3, #12]
   16102:	a802      	add	r0, sp, #8
   16104:	f003 f9f6 	bl	194f4 <rpc_at_client_request_alloc>
   16108:	4606      	mov	r6, r0
   1610a:	4620      	mov	r0, r4
   1610c:	f003 f8ee 	bl	192ec <interface_socket_from_handle_get>
   16110:	4607      	mov	r7, r0
   16112:	bb16      	cbnz	r6, 1615a <at_interface_open+0x8a>
   16114:	2304      	movs	r3, #4
   16116:	9802      	ldr	r0, [sp, #8]
   16118:	2105      	movs	r1, #5
   1611a:	7203      	strb	r3, [r0, #8]
   1611c:	7246      	strb	r6, [r0, #9]
   1611e:	7286      	strb	r6, [r0, #10]
   16120:	72c6      	strb	r6, [r0, #11]
   16122:	60c4      	str	r4, [r0, #12]
   16124:	f003 f9fa 	bl	1951c <rpc_at_client_request_send>
   16128:	bb08      	cbnz	r0, 1616e <at_interface_open+0x9e>
   1612a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1612c:	ab04      	add	r3, sp, #16
   1612e:	2a00      	cmp	r2, #0
   16130:	bf08      	it	eq
   16132:	f04f 32ff 	moveq.w	r2, #4294967295
   16136:	4629      	mov	r1, r5
   16138:	f843 2d04 	str.w	r2, [r3, #-4]!
   1613c:	4620      	mov	r0, r4
   1613e:	462a      	mov	r2, r5
   16140:	f003 f854 	bl	191ec <interface_socket_wait>
   16144:	4605      	mov	r5, r0
   16146:	b948      	cbnz	r0, 1615c <at_interface_open+0x8c>
   16148:	9a01      	ldr	r2, [sp, #4]
   1614a:	6813      	ldr	r3, [r2, #0]
   1614c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   16150:	6013      	str	r3, [r2, #0]
   16152:	4620      	mov	r0, r4
   16154:	b004      	add	sp, #16
   16156:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1615a:	250c      	movs	r5, #12
   1615c:	4620      	mov	r0, r4
   1615e:	f002 fff7 	bl	19150 <interface_socket_free>
   16162:	4628      	mov	r0, r5
   16164:	f7f9 ff62 	bl	1002c <bsd_os_errno_set>
   16168:	f04f 34ff 	mov.w	r4, #4294967295
   1616c:	e7f1      	b.n	16152 <at_interface_open+0x82>
   1616e:	9802      	ldr	r0, [sp, #8]
   16170:	f003 f9e2 	bl	19538 <rpc_at_client_message_free>
   16174:	2523      	movs	r5, #35	; 0x23
   16176:	e7f1      	b.n	1615c <at_interface_open+0x8c>
   16178:	2029      	movs	r0, #41	; 0x29
   1617a:	f7f9 ff57 	bl	1002c <bsd_os_errno_set>
   1617e:	f04f 34ff 	mov.w	r4, #4294967295
   16182:	e7e6      	b.n	16152 <at_interface_open+0x82>
   16184:	2005      	movs	r0, #5
   16186:	f7f9 ff51 	bl	1002c <bsd_os_errno_set>
   1618a:	f04f 34ff 	mov.w	r4, #4294967295
   1618e:	e7e0      	b.n	16152 <at_interface_open+0x82>
   16190:	2002366e 	.word	0x2002366e
   16194:	00015fc5 	.word	0x00015fc5

00016198 <at_interface_close>:
   16198:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1619c:	b082      	sub	sp, #8
   1619e:	4606      	mov	r6, r0
   161a0:	f003 f8a4 	bl	192ec <interface_socket_from_handle_get>
   161a4:	2800      	cmp	r0, #0
   161a6:	d044      	beq.n	16232 <at_interface_close+0x9a>
   161a8:	230d      	movs	r3, #13
   161aa:	6807      	ldr	r7, [r0, #0]
   161ac:	6003      	str	r3, [r0, #0]
   161ae:	6803      	ldr	r3, [r0, #0]
   161b0:	4604      	mov	r4, r0
   161b2:	039b      	lsls	r3, r3, #14
   161b4:	d42b      	bmi.n	1620e <at_interface_close+0x76>
   161b6:	2100      	movs	r1, #0
   161b8:	4668      	mov	r0, sp
   161ba:	f003 f99b 	bl	194f4 <rpc_at_client_request_alloc>
   161be:	4605      	mov	r5, r0
   161c0:	4630      	mov	r0, r6
   161c2:	f003 f893 	bl	192ec <interface_socket_from_handle_get>
   161c6:	4680      	mov	r8, r0
   161c8:	bb8d      	cbnz	r5, 1622e <at_interface_close+0x96>
   161ca:	2304      	movs	r3, #4
   161cc:	9800      	ldr	r0, [sp, #0]
   161ce:	2106      	movs	r1, #6
   161d0:	7203      	strb	r3, [r0, #8]
   161d2:	7245      	strb	r5, [r0, #9]
   161d4:	7285      	strb	r5, [r0, #10]
   161d6:	72c5      	strb	r5, [r0, #11]
   161d8:	60c6      	str	r6, [r0, #12]
   161da:	f003 f99f 	bl	1951c <rpc_at_client_request_send>
   161de:	b9d8      	cbnz	r0, 16218 <at_interface_close+0x80>
   161e0:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
   161e4:	220e      	movs	r2, #14
   161e6:	2900      	cmp	r1, #0
   161e8:	bf08      	it	eq
   161ea:	f04f 31ff 	moveq.w	r1, #4294967295
   161ee:	ab02      	add	r3, sp, #8
   161f0:	f843 1d04 	str.w	r1, [r3, #-4]!
   161f4:	4630      	mov	r0, r6
   161f6:	4611      	mov	r1, r2
   161f8:	f002 fff8 	bl	191ec <interface_socket_wait>
   161fc:	4605      	mov	r5, r0
   161fe:	b978      	cbnz	r0, 16220 <at_interface_close+0x88>
   16200:	4630      	mov	r0, r6
   16202:	f002 ffa5 	bl	19150 <interface_socket_free>
   16206:	4628      	mov	r0, r5
   16208:	b002      	add	sp, #8
   1620a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1620e:	6803      	ldr	r3, [r0, #0]
   16210:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   16214:	6003      	str	r3, [r0, #0]
   16216:	e7ce      	b.n	161b6 <at_interface_close+0x1e>
   16218:	9800      	ldr	r0, [sp, #0]
   1621a:	f003 f98d 	bl	19538 <rpc_at_client_message_free>
   1621e:	2523      	movs	r5, #35	; 0x23
   16220:	6027      	str	r7, [r4, #0]
   16222:	4628      	mov	r0, r5
   16224:	f7f9 ff02 	bl	1002c <bsd_os_errno_set>
   16228:	f04f 35ff 	mov.w	r5, #4294967295
   1622c:	e7eb      	b.n	16206 <at_interface_close+0x6e>
   1622e:	250c      	movs	r5, #12
   16230:	e7f6      	b.n	16220 <at_interface_close+0x88>
   16232:	2516      	movs	r5, #22
   16234:	e7f5      	b.n	16222 <at_interface_close+0x8a>
   16236:	bf00      	nop

00016238 <at_interface_read>:
   16238:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1623c:	b086      	sub	sp, #24
   1623e:	4688      	mov	r8, r1
   16240:	4615      	mov	r5, r2
   16242:	461e      	mov	r6, r3
   16244:	4607      	mov	r7, r0
   16246:	f003 f851 	bl	192ec <interface_socket_from_handle_get>
   1624a:	2800      	cmp	r0, #0
   1624c:	d045      	beq.n	162da <at_interface_read+0xa2>
   1624e:	2300      	movs	r3, #0
   16250:	4604      	mov	r4, r0
   16252:	e9cd 8502 	strd	r8, r5, [sp, #8]
   16256:	e9cd 3304 	strd	r3, r3, [sp, #16]
   1625a:	bb3e      	cbnz	r6, 162ac <at_interface_read+0x74>
   1625c:	f016 0502 	ands.w	r5, r6, #2
   16260:	d00f      	beq.n	16282 <at_interface_read+0x4a>
   16262:	e02a      	b.n	162ba <at_interface_read+0x82>
   16264:	b9dd      	cbnz	r5, 1629e <at_interface_read+0x66>
   16266:	6a25      	ldr	r5, [r4, #32]
   16268:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1626c:	2d00      	cmp	r5, #0
   1626e:	bf08      	it	eq
   16270:	f04f 35ff 	moveq.w	r5, #4294967295
   16274:	4611      	mov	r1, r2
   16276:	ab01      	add	r3, sp, #4
   16278:	4638      	mov	r0, r7
   1627a:	9501      	str	r5, [sp, #4]
   1627c:	f002 ffb6 	bl	191ec <interface_socket_wait>
   16280:	4605      	mov	r5, r0
   16282:	6823      	ldr	r3, [r4, #0]
   16284:	69e0      	ldr	r0, [r4, #28]
   16286:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   1628a:	6023      	str	r3, [r4, #0]
   1628c:	6803      	ldr	r3, [r0, #0]
   1628e:	4632      	mov	r2, r6
   16290:	689b      	ldr	r3, [r3, #8]
   16292:	a902      	add	r1, sp, #8
   16294:	4798      	blx	r3
   16296:	f1b0 0800 	subs.w	r8, r0, #0
   1629a:	dbe3      	blt.n	16264 <at_interface_read+0x2c>
   1629c:	b115      	cbz	r5, 162a4 <at_interface_read+0x6c>
   1629e:	4628      	mov	r0, r5
   162a0:	f7f9 fec4 	bl	1002c <bsd_os_errno_set>
   162a4:	4640      	mov	r0, r8
   162a6:	b006      	add	sp, #24
   162a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   162ac:	f016 0f2a 	tst.w	r6, #42	; 0x2a
   162b0:	d1d4      	bne.n	1625c <at_interface_read+0x24>
   162b2:	252d      	movs	r5, #45	; 0x2d
   162b4:	f04f 38ff 	mov.w	r8, #4294967295
   162b8:	e7f1      	b.n	1629e <at_interface_read+0x66>
   162ba:	6823      	ldr	r3, [r4, #0]
   162bc:	69e0      	ldr	r0, [r4, #28]
   162be:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   162c2:	6023      	str	r3, [r4, #0]
   162c4:	6803      	ldr	r3, [r0, #0]
   162c6:	4632      	mov	r2, r6
   162c8:	689b      	ldr	r3, [r3, #8]
   162ca:	a902      	add	r1, sp, #8
   162cc:	4798      	blx	r3
   162ce:	f1b0 3fff 	cmp.w	r0, #4294967295
   162d2:	4680      	mov	r8, r0
   162d4:	d1e6      	bne.n	162a4 <at_interface_read+0x6c>
   162d6:	2523      	movs	r5, #35	; 0x23
   162d8:	e7e1      	b.n	1629e <at_interface_read+0x66>
   162da:	2516      	movs	r5, #22
   162dc:	f04f 38ff 	mov.w	r8, #4294967295
   162e0:	e7dd      	b.n	1629e <at_interface_read+0x66>
   162e2:	bf00      	nop

000162e4 <at_interface_getopt>:
   162e4:	f003 b870 	b.w	193c8 <interface_socket_getopt>

000162e8 <at_interface_setopt>:
   162e8:	f003 b828 	b.w	1933c <interface_socket_setopt>

000162ec <rpc_at_event_handler>:
   162ec:	b570      	push	{r4, r5, r6, lr}
   162ee:	4606      	mov	r6, r0
   162f0:	b084      	sub	sp, #16
   162f2:	68c0      	ldr	r0, [r0, #12]
   162f4:	460d      	mov	r5, r1
   162f6:	f002 fff9 	bl	192ec <interface_socket_from_handle_get>
   162fa:	4604      	mov	r4, r0
   162fc:	b348      	cbz	r0, 16352 <rpc_at_event_handler+0x66>
   162fe:	6803      	ldr	r3, [r0, #0]
   16300:	b29b      	uxth	r3, r3
   16302:	2b01      	cmp	r3, #1
   16304:	d01f      	beq.n	16346 <rpc_at_event_handler+0x5a>
   16306:	6803      	ldr	r3, [r0, #0]
   16308:	b29b      	uxth	r3, r3
   1630a:	2b0d      	cmp	r3, #13
   1630c:	d029      	beq.n	16362 <rpc_at_event_handler+0x76>
   1630e:	6803      	ldr	r3, [r0, #0]
   16310:	b29b      	uxth	r3, r3
   16312:	2b02      	cmp	r3, #2
   16314:	d02d      	beq.n	16372 <rpc_at_event_handler+0x86>
   16316:	3d03      	subs	r5, #3
   16318:	2d01      	cmp	r5, #1
   1631a:	d817      	bhi.n	1634c <rpc_at_event_handler+0x60>
   1631c:	2500      	movs	r5, #0
   1631e:	6873      	ldr	r3, [r6, #4]
   16320:	6832      	ldr	r2, [r6, #0]
   16322:	e9cd 5502 	strd	r5, r5, [sp, #8]
   16326:	e9cd 2300 	strd	r2, r3, [sp]
   1632a:	69e0      	ldr	r0, [r4, #28]
   1632c:	4669      	mov	r1, sp
   1632e:	6803      	ldr	r3, [r0, #0]
   16330:	685b      	ldr	r3, [r3, #4]
   16332:	4798      	blx	r3
   16334:	3001      	adds	r0, #1
   16336:	d019      	beq.n	1636c <rpc_at_event_handler+0x80>
   16338:	4628      	mov	r0, r5
   1633a:	6823      	ldr	r3, [r4, #0]
   1633c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   16340:	6023      	str	r3, [r4, #0]
   16342:	b004      	add	sp, #16
   16344:	bd70      	pop	{r4, r5, r6, pc}
   16346:	2d02      	cmp	r5, #2
   16348:	d1e5      	bne.n	16316 <rpc_at_event_handler+0x2a>
   1634a:	6005      	str	r5, [r0, #0]
   1634c:	2000      	movs	r0, #0
   1634e:	b004      	add	sp, #16
   16350:	bd70      	pop	{r4, r5, r6, pc}
   16352:	6830      	ldr	r0, [r6, #0]
   16354:	2800      	cmp	r0, #0
   16356:	d0f9      	beq.n	1634c <rpc_at_event_handler+0x60>
   16358:	f003 f8f6 	bl	19548 <rpc_at_client_data_free>
   1635c:	4620      	mov	r0, r4
   1635e:	b004      	add	sp, #16
   16360:	bd70      	pop	{r4, r5, r6, pc}
   16362:	2d02      	cmp	r5, #2
   16364:	d1d7      	bne.n	16316 <rpc_at_event_handler+0x2a>
   16366:	230e      	movs	r3, #14
   16368:	6003      	str	r3, [r0, #0]
   1636a:	e7ef      	b.n	1634c <rpc_at_event_handler+0x60>
   1636c:	2002      	movs	r0, #2
   1636e:	b004      	add	sp, #16
   16370:	bd70      	pop	{r4, r5, r6, pc}
   16372:	6803      	ldr	r3, [r0, #0]
   16374:	029b      	lsls	r3, r3, #10
   16376:	d5ce      	bpl.n	16316 <rpc_at_event_handler+0x2a>
   16378:	2d02      	cmp	r5, #2
   1637a:	d1cc      	bne.n	16316 <rpc_at_event_handler+0x2a>
   1637c:	6803      	ldr	r3, [r0, #0]
   1637e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   16382:	6003      	str	r3, [r0, #0]
   16384:	6803      	ldr	r3, [r0, #0]
   16386:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   1638a:	6003      	str	r3, [r0, #0]
   1638c:	e7de      	b.n	1634c <rpc_at_event_handler+0x60>
   1638e:	bf00      	nop

00016390 <ok_rsp_parser>:
   16390:	2000      	movs	r0, #0
   16392:	4770      	bx	lr

00016394 <pdn_state_get_parser>:
   16394:	2200      	movs	r2, #0
   16396:	b570      	push	{r4, r5, r6, lr}
   16398:	780b      	ldrb	r3, [r1, #0]
   1639a:	b084      	sub	sp, #16
   1639c:	460e      	mov	r6, r1
   1639e:	e9cd 2200 	strd	r2, r2, [sp]
   163a2:	e9cd 2202 	strd	r2, r2, [sp, #8]
   163a6:	b323      	cbz	r3, 163f2 <pdn_state_get_parser+0x5e>
   163a8:	460c      	mov	r4, r1
   163aa:	2b20      	cmp	r3, #32
   163ac:	460d      	mov	r5, r1
   163ae:	d01b      	beq.n	163e8 <pdn_state_get_parser+0x54>
   163b0:	700b      	strb	r3, [r1, #0]
   163b2:	3201      	adds	r2, #1
   163b4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   163b8:	18b1      	adds	r1, r6, r2
   163ba:	460d      	mov	r5, r1
   163bc:	2b00      	cmp	r3, #0
   163be:	d1f4      	bne.n	163aa <pdn_state_get_parser+0x16>
   163c0:	2200      	movs	r2, #0
   163c2:	4b0d      	ldr	r3, [pc, #52]	; (163f8 <pdn_state_get_parser+0x64>)
   163c4:	702a      	strb	r2, [r5, #0]
   163c6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   163ca:	4a0c      	ldr	r2, [pc, #48]	; (163fc <pdn_state_get_parser+0x68>)
   163cc:	681b      	ldr	r3, [r3, #0]
   163ce:	2110      	movs	r1, #16
   163d0:	4668      	mov	r0, sp
   163d2:	f7f8 fe2d 	bl	f030 <snprintf>
   163d6:	4669      	mov	r1, sp
   163d8:	4630      	mov	r0, r6
   163da:	f005 fda3 	bl	1bf24 <strstr>
   163de:	3000      	adds	r0, #0
   163e0:	bf18      	it	ne
   163e2:	2001      	movne	r0, #1
   163e4:	b004      	add	sp, #16
   163e6:	bd70      	pop	{r4, r5, r6, pc}
   163e8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   163ec:	2b00      	cmp	r3, #0
   163ee:	d1dc      	bne.n	163aa <pdn_state_get_parser+0x16>
   163f0:	e7e6      	b.n	163c0 <pdn_state_get_parser+0x2c>
   163f2:	460d      	mov	r5, r1
   163f4:	e7e4      	b.n	163c0 <pdn_state_get_parser+0x2c>
   163f6:	bf00      	nop
   163f8:	20020950 	.word	0x20020950
   163fc:	0001df0c 	.word	0x0001df0c

00016400 <pdn_id_get_parser>:
   16400:	b570      	push	{r4, r5, r6, lr}
   16402:	780b      	ldrb	r3, [r1, #0]
   16404:	4606      	mov	r6, r0
   16406:	b313      	cbz	r3, 1644e <pdn_id_get_parser+0x4e>
   16408:	4608      	mov	r0, r1
   1640a:	2400      	movs	r4, #0
   1640c:	460a      	mov	r2, r1
   1640e:	2b20      	cmp	r3, #32
   16410:	4615      	mov	r5, r2
   16412:	d017      	beq.n	16444 <pdn_id_get_parser+0x44>
   16414:	7013      	strb	r3, [r2, #0]
   16416:	3401      	adds	r4, #1
   16418:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   1641c:	190a      	adds	r2, r1, r4
   1641e:	4615      	mov	r5, r2
   16420:	2b00      	cmp	r3, #0
   16422:	d1f4      	bne.n	1640e <pdn_id_get_parser+0xe>
   16424:	2300      	movs	r3, #0
   16426:	4608      	mov	r0, r1
   16428:	702b      	strb	r3, [r5, #0]
   1642a:	213a      	movs	r1, #58	; 0x3a
   1642c:	f005 fd9a 	bl	1bf64 <strchr>
   16430:	b130      	cbz	r0, 16440 <pdn_id_get_parser+0x40>
   16432:	3001      	adds	r0, #1
   16434:	f005 fc61 	bl	1bcfa <atoi>
   16438:	4b06      	ldr	r3, [pc, #24]	; (16454 <pdn_id_get_parser+0x54>)
   1643a:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   1643e:	6058      	str	r0, [r3, #4]
   16440:	2000      	movs	r0, #0
   16442:	bd70      	pop	{r4, r5, r6, pc}
   16444:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   16448:	2b00      	cmp	r3, #0
   1644a:	d1e0      	bne.n	1640e <pdn_id_get_parser+0xe>
   1644c:	e7ea      	b.n	16424 <pdn_id_get_parser+0x24>
   1644e:	460d      	mov	r5, r1
   16450:	e7e8      	b.n	16424 <pdn_id_get_parser+0x24>
   16452:	bf00      	nop
   16454:	20020950 	.word	0x20020950

00016458 <context_create_parser>:
   16458:	b570      	push	{r4, r5, r6, lr}
   1645a:	780b      	ldrb	r3, [r1, #0]
   1645c:	4606      	mov	r6, r0
   1645e:	b313      	cbz	r3, 164a6 <context_create_parser+0x4e>
   16460:	4608      	mov	r0, r1
   16462:	2400      	movs	r4, #0
   16464:	460a      	mov	r2, r1
   16466:	2b20      	cmp	r3, #32
   16468:	4615      	mov	r5, r2
   1646a:	d017      	beq.n	1649c <context_create_parser+0x44>
   1646c:	7013      	strb	r3, [r2, #0]
   1646e:	3401      	adds	r4, #1
   16470:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   16474:	190a      	adds	r2, r1, r4
   16476:	4615      	mov	r5, r2
   16478:	2b00      	cmp	r3, #0
   1647a:	d1f4      	bne.n	16466 <context_create_parser+0xe>
   1647c:	2300      	movs	r3, #0
   1647e:	4608      	mov	r0, r1
   16480:	702b      	strb	r3, [r5, #0]
   16482:	213a      	movs	r1, #58	; 0x3a
   16484:	f005 fd6e 	bl	1bf64 <strchr>
   16488:	b130      	cbz	r0, 16498 <context_create_parser+0x40>
   1648a:	4b08      	ldr	r3, [pc, #32]	; (164ac <context_create_parser+0x54>)
   1648c:	3001      	adds	r0, #1
   1648e:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   16492:	f005 fc32 	bl	1bcfa <atoi>
   16496:	6020      	str	r0, [r4, #0]
   16498:	2000      	movs	r0, #0
   1649a:	bd70      	pop	{r4, r5, r6, pc}
   1649c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   164a0:	2b00      	cmp	r3, #0
   164a2:	d1e0      	bne.n	16466 <context_create_parser+0xe>
   164a4:	e7ea      	b.n	1647c <context_create_parser+0x24>
   164a6:	460d      	mov	r5, r1
   164a8:	e7e8      	b.n	1647c <context_create_parser+0x24>
   164aa:	bf00      	nop
   164ac:	20020950 	.word	0x20020950

000164b0 <pdn_interface_init>:
   164b0:	f04f 33ff 	mov.w	r3, #4294967295
   164b4:	b510      	push	{r4, lr}
   164b6:	4c0b      	ldr	r4, [pc, #44]	; (164e4 <pdn_interface_init+0x34>)
   164b8:	2228      	movs	r2, #40	; 0x28
   164ba:	2100      	movs	r1, #0
   164bc:	480a      	ldr	r0, [pc, #40]	; (164e8 <pdn_interface_init+0x38>)
   164be:	6023      	str	r3, [r4, #0]
   164c0:	f005 fdbb 	bl	1c03a <memset>
   164c4:	f240 2201 	movw	r2, #513	; 0x201
   164c8:	2102      	movs	r1, #2
   164ca:	2066      	movs	r0, #102	; 0x66
   164cc:	f7ff fe00 	bl	160d0 <at_interface_open>
   164d0:	2800      	cmp	r0, #0
   164d2:	6020      	str	r0, [r4, #0]
   164d4:	db04      	blt.n	164e0 <pdn_interface_init+0x30>
   164d6:	2201      	movs	r2, #1
   164d8:	4b04      	ldr	r3, [pc, #16]	; (164ec <pdn_interface_init+0x3c>)
   164da:	2000      	movs	r0, #0
   164dc:	701a      	strb	r2, [r3, #0]
   164de:	bd10      	pop	{r4, pc}
   164e0:	2003      	movs	r0, #3
   164e2:	bd10      	pop	{r4, pc}
   164e4:	2002084c 	.word	0x2002084c
   164e8:	20020950 	.word	0x20020950
   164ec:	2002366f 	.word	0x2002366f

000164f0 <pdn_interface_open>:
   164f0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   164f4:	4b66      	ldr	r3, [pc, #408]	; (16690 <pdn_interface_open+0x1a0>)
   164f6:	b083      	sub	sp, #12
   164f8:	781b      	ldrb	r3, [r3, #0]
   164fa:	2b00      	cmp	r3, #0
   164fc:	f000 80c2 	beq.w	16684 <pdn_interface_open+0x194>
   16500:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   16504:	f040 80ad 	bne.w	16662 <pdn_interface_open+0x172>
   16508:	4c62      	ldr	r4, [pc, #392]	; (16694 <pdn_interface_open+0x1a4>)
   1650a:	6825      	ldr	r5, [r4, #0]
   1650c:	b34d      	cbz	r5, 16562 <pdn_interface_open+0x72>
   1650e:	6863      	ldr	r3, [r4, #4]
   16510:	2b00      	cmp	r3, #0
   16512:	f000 8098 	beq.w	16646 <pdn_interface_open+0x156>
   16516:	68a3      	ldr	r3, [r4, #8]
   16518:	2b00      	cmp	r3, #0
   1651a:	f000 8096 	beq.w	1664a <pdn_interface_open+0x15a>
   1651e:	68e3      	ldr	r3, [r4, #12]
   16520:	2b00      	cmp	r3, #0
   16522:	f000 8094 	beq.w	1664e <pdn_interface_open+0x15e>
   16526:	6923      	ldr	r3, [r4, #16]
   16528:	2b00      	cmp	r3, #0
   1652a:	f000 8092 	beq.w	16652 <pdn_interface_open+0x162>
   1652e:	6963      	ldr	r3, [r4, #20]
   16530:	2b00      	cmp	r3, #0
   16532:	f000 8090 	beq.w	16656 <pdn_interface_open+0x166>
   16536:	69a3      	ldr	r3, [r4, #24]
   16538:	2b00      	cmp	r3, #0
   1653a:	f000 808e 	beq.w	1665a <pdn_interface_open+0x16a>
   1653e:	69e3      	ldr	r3, [r4, #28]
   16540:	2b00      	cmp	r3, #0
   16542:	f000 808c 	beq.w	1665e <pdn_interface_open+0x16e>
   16546:	6a23      	ldr	r3, [r4, #32]
   16548:	b153      	cbz	r3, 16560 <pdn_interface_open+0x70>
   1654a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1654c:	2509      	movs	r5, #9
   1654e:	b143      	cbz	r3, 16562 <pdn_interface_open+0x72>
   16550:	200c      	movs	r0, #12
   16552:	f7f9 fd6b 	bl	1002c <bsd_os_errno_set>
   16556:	f04f 30ff 	mov.w	r0, #4294967295
   1655a:	b003      	add	sp, #12
   1655c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16560:	2508      	movs	r5, #8
   16562:	2074      	movs	r0, #116	; 0x74
   16564:	f002 fa5e 	bl	18a24 <nrf_malloc>
   16568:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
   1656c:	2800      	cmp	r0, #0
   1656e:	d0ef      	beq.n	16550 <pdn_interface_open+0x60>
   16570:	2274      	movs	r2, #116	; 0x74
   16572:	2100      	movs	r1, #0
   16574:	f005 fd61 	bl	1c03a <memset>
   16578:	2101      	movs	r1, #1
   1657a:	2003      	movs	r0, #3
   1657c:	f04f 37ff 	mov.w	r7, #4294967295
   16580:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   16584:	4a44      	ldr	r2, [pc, #272]	; (16698 <pdn_interface_open+0x1a8>)
   16586:	6099      	str	r1, [r3, #8]
   16588:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   1658c:	f44f 7180 	mov.w	r1, #256	; 0x100
   16590:	6718      	str	r0, [r3, #112]	; 0x70
   16592:	605f      	str	r7, [r3, #4]
   16594:	4841      	ldr	r0, [pc, #260]	; (1669c <pdn_interface_open+0x1ac>)
   16596:	f8df 8110 	ldr.w	r8, [pc, #272]	; 166a8 <pdn_interface_open+0x1b8>
   1659a:	f7f8 fd49 	bl	f030 <snprintf>
   1659e:	483f      	ldr	r0, [pc, #252]	; (1669c <pdn_interface_open+0x1ac>)
   165a0:	f8d8 9000 	ldr.w	r9, [r8]
   165a4:	2600      	movs	r6, #0
   165a6:	f005 fceb 	bl	1bf80 <strlen>
   165aa:	4633      	mov	r3, r6
   165ac:	4602      	mov	r2, r0
   165ae:	493b      	ldr	r1, [pc, #236]	; (1669c <pdn_interface_open+0x1ac>)
   165b0:	4648      	mov	r0, r9
   165b2:	9601      	str	r6, [sp, #4]
   165b4:	9600      	str	r6, [sp, #0]
   165b6:	f7ff fd09 	bl	15fcc <at_interface_write>
   165ba:	4681      	mov	r9, r0
   165bc:	4837      	ldr	r0, [pc, #220]	; (1669c <pdn_interface_open+0x1ac>)
   165be:	f005 fcdf 	bl	1bf80 <strlen>
   165c2:	4548      	cmp	r0, r9
   165c4:	d153      	bne.n	1666e <pdn_interface_open+0x17e>
   165c6:	4633      	mov	r3, r6
   165c8:	e9cd 6600 	strd	r6, r6, [sp]
   165cc:	f44f 7280 	mov.w	r2, #256	; 0x100
   165d0:	4932      	ldr	r1, [pc, #200]	; (1669c <pdn_interface_open+0x1ac>)
   165d2:	f8d8 0000 	ldr.w	r0, [r8]
   165d6:	f7ff fe2f 	bl	16238 <at_interface_read>
   165da:	4606      	mov	r6, r0
   165dc:	4830      	ldr	r0, [pc, #192]	; (166a0 <pdn_interface_open+0x1b0>)
   165de:	f005 fccf 	bl	1bf80 <strlen>
   165e2:	4286      	cmp	r6, r0
   165e4:	db15      	blt.n	16612 <pdn_interface_open+0x122>
   165e6:	4602      	mov	r2, r0
   165e8:	492c      	ldr	r1, [pc, #176]	; (1669c <pdn_interface_open+0x1ac>)
   165ea:	482d      	ldr	r0, [pc, #180]	; (166a0 <pdn_interface_open+0x1b0>)
   165ec:	f005 fcdb 	bl	1bfa6 <strncmp>
   165f0:	b978      	cbnz	r0, 16612 <pdn_interface_open+0x122>
   165f2:	492a      	ldr	r1, [pc, #168]	; (1669c <pdn_interface_open+0x1ac>)
   165f4:	4628      	mov	r0, r5
   165f6:	f7ff ff2f 	bl	16458 <context_create_parser>
   165fa:	b9b0      	cbnz	r0, 1662a <pdn_interface_open+0x13a>
   165fc:	2202      	movs	r2, #2
   165fe:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   16602:	f045 40f1 	orr.w	r0, r5, #2021654528	; 0x78800000
   16606:	f440 10d0 	orr.w	r0, r0, #1703936	; 0x1a0000
   1660a:	609a      	str	r2, [r3, #8]
   1660c:	b003      	add	sp, #12
   1660e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16612:	4824      	ldr	r0, [pc, #144]	; (166a4 <pdn_interface_open+0x1b4>)
   16614:	f005 fcb4 	bl	1bf80 <strlen>
   16618:	4920      	ldr	r1, [pc, #128]	; (1669c <pdn_interface_open+0x1ac>)
   1661a:	4602      	mov	r2, r0
   1661c:	4821      	ldr	r0, [pc, #132]	; (166a4 <pdn_interface_open+0x1b4>)
   1661e:	f005 fcc2 	bl	1bfa6 <strncmp>
   16622:	b960      	cbnz	r0, 1663e <pdn_interface_open+0x14e>
   16624:	2008      	movs	r0, #8
   16626:	f7f9 fd01 	bl	1002c <bsd_os_errno_set>
   1662a:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   1662e:	f002 fa03 	bl	18a38 <nrf_free>
   16632:	2300      	movs	r3, #0
   16634:	f04f 30ff 	mov.w	r0, #4294967295
   16638:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
   1663c:	e78d      	b.n	1655a <pdn_interface_open+0x6a>
   1663e:	2005      	movs	r0, #5
   16640:	f7f9 fcf4 	bl	1002c <bsd_os_errno_set>
   16644:	e7f1      	b.n	1662a <pdn_interface_open+0x13a>
   16646:	2501      	movs	r5, #1
   16648:	e78b      	b.n	16562 <pdn_interface_open+0x72>
   1664a:	2502      	movs	r5, #2
   1664c:	e789      	b.n	16562 <pdn_interface_open+0x72>
   1664e:	2503      	movs	r5, #3
   16650:	e787      	b.n	16562 <pdn_interface_open+0x72>
   16652:	2504      	movs	r5, #4
   16654:	e785      	b.n	16562 <pdn_interface_open+0x72>
   16656:	2505      	movs	r5, #5
   16658:	e783      	b.n	16562 <pdn_interface_open+0x72>
   1665a:	2506      	movs	r5, #6
   1665c:	e781      	b.n	16562 <pdn_interface_open+0x72>
   1665e:	2507      	movs	r5, #7
   16660:	e77f      	b.n	16562 <pdn_interface_open+0x72>
   16662:	2029      	movs	r0, #41	; 0x29
   16664:	f7f9 fce2 	bl	1002c <bsd_os_errno_set>
   16668:	f04f 30ff 	mov.w	r0, #4294967295
   1666c:	e775      	b.n	1655a <pdn_interface_open+0x6a>
   1666e:	2005      	movs	r0, #5
   16670:	f7f9 fcdc 	bl	1002c <bsd_os_errno_set>
   16674:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   16678:	f002 f9de 	bl	18a38 <nrf_free>
   1667c:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
   16680:	4638      	mov	r0, r7
   16682:	e76a      	b.n	1655a <pdn_interface_open+0x6a>
   16684:	2005      	movs	r0, #5
   16686:	f7f9 fcd1 	bl	1002c <bsd_os_errno_set>
   1668a:	f04f 30ff 	mov.w	r0, #4294967295
   1668e:	e764      	b.n	1655a <pdn_interface_open+0x6a>
   16690:	2002366f 	.word	0x2002366f
   16694:	20020950 	.word	0x20020950
   16698:	0001dee8 	.word	0x0001dee8
   1669c:	20020850 	.word	0x20020850
   166a0:	0001def8 	.word	0x0001def8
   166a4:	0001df04 	.word	0x0001df04
   166a8:	2002084c 	.word	0x2002084c

000166ac <pdn_interface_connect>:
   166ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   166b0:	b083      	sub	sp, #12
   166b2:	2900      	cmp	r1, #0
   166b4:	f000 813d 	beq.w	16932 <pdn_interface_connect+0x286>
   166b8:	2a64      	cmp	r2, #100	; 0x64
   166ba:	4691      	mov	r9, r2
   166bc:	f200 8139 	bhi.w	16932 <pdn_interface_connect+0x286>
   166c0:	4605      	mov	r5, r0
   166c2:	4608      	mov	r0, r1
   166c4:	4688      	mov	r8, r1
   166c6:	f005 fc5b 	bl	1bf80 <strlen>
   166ca:	2864      	cmp	r0, #100	; 0x64
   166cc:	f200 8131 	bhi.w	16932 <pdn_interface_connect+0x286>
   166d0:	0c2b      	lsrs	r3, r5, #16
   166d2:	4aa5      	ldr	r2, [pc, #660]	; (16968 <pdn_interface_connect+0x2bc>)
   166d4:	041b      	lsls	r3, r3, #16
   166d6:	4293      	cmp	r3, r2
   166d8:	f040 8122 	bne.w	16920 <pdn_interface_connect+0x274>
   166dc:	f025 45f1 	bic.w	r5, r5, #2021654528	; 0x78800000
   166e0:	f425 15d0 	bic.w	r5, r5, #1703936	; 0x1a0000
   166e4:	2d09      	cmp	r5, #9
   166e6:	f300 811b 	bgt.w	16920 <pdn_interface_connect+0x274>
   166ea:	4fa0      	ldr	r7, [pc, #640]	; (1696c <pdn_interface_connect+0x2c0>)
   166ec:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   166f0:	2b00      	cmp	r3, #0
   166f2:	f000 8115 	beq.w	16920 <pdn_interface_connect+0x274>
   166f6:	689a      	ldr	r2, [r3, #8]
   166f8:	2a00      	cmp	r2, #0
   166fa:	f000 8111 	beq.w	16920 <pdn_interface_connect+0x274>
   166fe:	689b      	ldr	r3, [r3, #8]
   16700:	2b02      	cmp	r3, #2
   16702:	f040 810d 	bne.w	16920 <pdn_interface_connect+0x274>
   16706:	4e9a      	ldr	r6, [pc, #616]	; (16970 <pdn_interface_connect+0x2c4>)
   16708:	4a9a      	ldr	r2, [pc, #616]	; (16974 <pdn_interface_connect+0x2c8>)
   1670a:	f44f 7180 	mov.w	r1, #256	; 0x100
   1670e:	4630      	mov	r0, r6
   16710:	f7f8 fc8e 	bl	f030 <snprintf>
   16714:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   16718:	4604      	mov	r4, r0
   1671a:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   1671e:	681b      	ldr	r3, [r3, #0]
   16720:	4a95      	ldr	r2, [pc, #596]	; (16978 <pdn_interface_connect+0x2cc>)
   16722:	1830      	adds	r0, r6, r0
   16724:	f7f8 fc84 	bl	f030 <snprintf>
   16728:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   1672c:	4404      	add	r4, r0
   1672e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   16730:	f003 0203 	and.w	r2, r3, #3
   16734:	2a03      	cmp	r2, #3
   16736:	f000 80ea 	beq.w	1690e <pdn_interface_connect+0x262>
   1673a:	079b      	lsls	r3, r3, #30
   1673c:	eb06 0004 	add.w	r0, r6, r4
   16740:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   16744:	bf4c      	ite	mi
   16746:	4b8d      	ldrmi	r3, [pc, #564]	; (1697c <pdn_interface_connect+0x2d0>)
   16748:	4b8d      	ldrpl	r3, [pc, #564]	; (16980 <pdn_interface_connect+0x2d4>)
   1674a:	4a8e      	ldr	r2, [pc, #568]	; (16984 <pdn_interface_connect+0x2d8>)
   1674c:	f7f8 fc70 	bl	f030 <snprintf>
   16750:	4404      	add	r4, r0
   16752:	4643      	mov	r3, r8
   16754:	4a8c      	ldr	r2, [pc, #560]	; (16988 <pdn_interface_connect+0x2dc>)
   16756:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   1675a:	1930      	adds	r0, r6, r4
   1675c:	f7f8 fc68 	bl	f030 <snprintf>
   16760:	4420      	add	r0, r4
   16762:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   16766:	f300 80f7 	bgt.w	16958 <pdn_interface_connect+0x2ac>
   1676a:	f8df a23c 	ldr.w	sl, [pc, #572]	; 169a8 <pdn_interface_connect+0x2fc>
   1676e:	4880      	ldr	r0, [pc, #512]	; (16970 <pdn_interface_connect+0x2c4>)
   16770:	f8da b000 	ldr.w	fp, [sl]
   16774:	2400      	movs	r4, #0
   16776:	f005 fc03 	bl	1bf80 <strlen>
   1677a:	4623      	mov	r3, r4
   1677c:	4602      	mov	r2, r0
   1677e:	497c      	ldr	r1, [pc, #496]	; (16970 <pdn_interface_connect+0x2c4>)
   16780:	4658      	mov	r0, fp
   16782:	9401      	str	r4, [sp, #4]
   16784:	9400      	str	r4, [sp, #0]
   16786:	f7ff fc21 	bl	15fcc <at_interface_write>
   1678a:	4683      	mov	fp, r0
   1678c:	4878      	ldr	r0, [pc, #480]	; (16970 <pdn_interface_connect+0x2c4>)
   1678e:	f005 fbf7 	bl	1bf80 <strlen>
   16792:	4558      	cmp	r0, fp
   16794:	d008      	beq.n	167a8 <pdn_interface_connect+0xfc>
   16796:	2005      	movs	r0, #5
   16798:	f7f9 fc48 	bl	1002c <bsd_os_errno_set>
   1679c:	f04f 34ff 	mov.w	r4, #4294967295
   167a0:	4620      	mov	r0, r4
   167a2:	b003      	add	sp, #12
   167a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   167a8:	4623      	mov	r3, r4
   167aa:	e9cd 4400 	strd	r4, r4, [sp]
   167ae:	f44f 7280 	mov.w	r2, #256	; 0x100
   167b2:	496f      	ldr	r1, [pc, #444]	; (16970 <pdn_interface_connect+0x2c4>)
   167b4:	f8da 0000 	ldr.w	r0, [sl]
   167b8:	f7ff fd3e 	bl	16238 <at_interface_read>
   167bc:	4604      	mov	r4, r0
   167be:	4873      	ldr	r0, [pc, #460]	; (1698c <pdn_interface_connect+0x2e0>)
   167c0:	f005 fbde 	bl	1bf80 <strlen>
   167c4:	4284      	cmp	r4, r0
   167c6:	f2c0 8091 	blt.w	168ec <pdn_interface_connect+0x240>
   167ca:	4602      	mov	r2, r0
   167cc:	4968      	ldr	r1, [pc, #416]	; (16970 <pdn_interface_connect+0x2c4>)
   167ce:	486f      	ldr	r0, [pc, #444]	; (1698c <pdn_interface_connect+0x2e0>)
   167d0:	f005 fbe9 	bl	1bfa6 <strncmp>
   167d4:	2800      	cmp	r0, #0
   167d6:	f040 8089 	bne.w	168ec <pdn_interface_connect+0x240>
   167da:	4965      	ldr	r1, [pc, #404]	; (16970 <pdn_interface_connect+0x2c4>)
   167dc:	4628      	mov	r0, r5
   167de:	f7ff fdd7 	bl	16390 <ok_rsp_parser>
   167e2:	4604      	mov	r4, r0
   167e4:	2800      	cmp	r0, #0
   167e6:	d1db      	bne.n	167a0 <pdn_interface_connect+0xf4>
   167e8:	4a69      	ldr	r2, [pc, #420]	; (16990 <pdn_interface_connect+0x2e4>)
   167ea:	f44f 7180 	mov.w	r1, #256	; 0x100
   167ee:	4860      	ldr	r0, [pc, #384]	; (16970 <pdn_interface_connect+0x2c4>)
   167f0:	f7f8 fc1e 	bl	f030 <snprintf>
   167f4:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   167f8:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   167fc:	681b      	ldr	r3, [r3, #0]
   167fe:	4a65      	ldr	r2, [pc, #404]	; (16994 <pdn_interface_connect+0x2e8>)
   16800:	4430      	add	r0, r6
   16802:	f7f8 fc15 	bl	f030 <snprintf>
   16806:	485a      	ldr	r0, [pc, #360]	; (16970 <pdn_interface_connect+0x2c4>)
   16808:	f8da b000 	ldr.w	fp, [sl]
   1680c:	f005 fbb8 	bl	1bf80 <strlen>
   16810:	4623      	mov	r3, r4
   16812:	4602      	mov	r2, r0
   16814:	4956      	ldr	r1, [pc, #344]	; (16970 <pdn_interface_connect+0x2c4>)
   16816:	4658      	mov	r0, fp
   16818:	9401      	str	r4, [sp, #4]
   1681a:	9400      	str	r4, [sp, #0]
   1681c:	f7ff fbd6 	bl	15fcc <at_interface_write>
   16820:	4683      	mov	fp, r0
   16822:	4853      	ldr	r0, [pc, #332]	; (16970 <pdn_interface_connect+0x2c4>)
   16824:	f005 fbac 	bl	1bf80 <strlen>
   16828:	4558      	cmp	r0, fp
   1682a:	d1b4      	bne.n	16796 <pdn_interface_connect+0xea>
   1682c:	4623      	mov	r3, r4
   1682e:	f44f 7280 	mov.w	r2, #256	; 0x100
   16832:	494f      	ldr	r1, [pc, #316]	; (16970 <pdn_interface_connect+0x2c4>)
   16834:	f8da 0000 	ldr.w	r0, [sl]
   16838:	e9cd 4400 	strd	r4, r4, [sp]
   1683c:	f7ff fcfc 	bl	16238 <at_interface_read>
   16840:	4683      	mov	fp, r0
   16842:	4852      	ldr	r0, [pc, #328]	; (1698c <pdn_interface_connect+0x2e0>)
   16844:	f005 fb9c 	bl	1bf80 <strlen>
   16848:	4583      	cmp	fp, r0
   1684a:	db4f      	blt.n	168ec <pdn_interface_connect+0x240>
   1684c:	4602      	mov	r2, r0
   1684e:	4948      	ldr	r1, [pc, #288]	; (16970 <pdn_interface_connect+0x2c4>)
   16850:	484e      	ldr	r0, [pc, #312]	; (1698c <pdn_interface_connect+0x2e0>)
   16852:	f005 fba8 	bl	1bfa6 <strncmp>
   16856:	2800      	cmp	r0, #0
   16858:	d148      	bne.n	168ec <pdn_interface_connect+0x240>
   1685a:	2103      	movs	r1, #3
   1685c:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   16860:	464a      	mov	r2, r9
   16862:	6099      	str	r1, [r3, #8]
   16864:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   16868:	4641      	mov	r1, r8
   1686a:	300c      	adds	r0, #12
   1686c:	f005 fbba 	bl	1bfe4 <memcpy>
   16870:	4a49      	ldr	r2, [pc, #292]	; (16998 <pdn_interface_connect+0x2ec>)
   16872:	f44f 7180 	mov.w	r1, #256	; 0x100
   16876:	483e      	ldr	r0, [pc, #248]	; (16970 <pdn_interface_connect+0x2c4>)
   16878:	f7f8 fbda 	bl	f030 <snprintf>
   1687c:	4601      	mov	r1, r0
   1687e:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   16882:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   16886:	681b      	ldr	r3, [r3, #0]
   16888:	4a42      	ldr	r2, [pc, #264]	; (16994 <pdn_interface_connect+0x2e8>)
   1688a:	1830      	adds	r0, r6, r0
   1688c:	f7f8 fbd0 	bl	f030 <snprintf>
   16890:	4837      	ldr	r0, [pc, #220]	; (16970 <pdn_interface_connect+0x2c4>)
   16892:	f8da 6000 	ldr.w	r6, [sl]
   16896:	f005 fb73 	bl	1bf80 <strlen>
   1689a:	4623      	mov	r3, r4
   1689c:	4602      	mov	r2, r0
   1689e:	4934      	ldr	r1, [pc, #208]	; (16970 <pdn_interface_connect+0x2c4>)
   168a0:	4630      	mov	r0, r6
   168a2:	9401      	str	r4, [sp, #4]
   168a4:	9400      	str	r4, [sp, #0]
   168a6:	f7ff fb91 	bl	15fcc <at_interface_write>
   168aa:	4606      	mov	r6, r0
   168ac:	4830      	ldr	r0, [pc, #192]	; (16970 <pdn_interface_connect+0x2c4>)
   168ae:	f005 fb67 	bl	1bf80 <strlen>
   168b2:	42b0      	cmp	r0, r6
   168b4:	d153      	bne.n	1695e <pdn_interface_connect+0x2b2>
   168b6:	4623      	mov	r3, r4
   168b8:	f44f 7280 	mov.w	r2, #256	; 0x100
   168bc:	492c      	ldr	r1, [pc, #176]	; (16970 <pdn_interface_connect+0x2c4>)
   168be:	f8da 0000 	ldr.w	r0, [sl]
   168c2:	e9cd 4400 	strd	r4, r4, [sp]
   168c6:	f7ff fcb7 	bl	16238 <at_interface_read>
   168ca:	4606      	mov	r6, r0
   168cc:	4833      	ldr	r0, [pc, #204]	; (1699c <pdn_interface_connect+0x2f0>)
   168ce:	f005 fb57 	bl	1bf80 <strlen>
   168d2:	4286      	cmp	r6, r0
   168d4:	db33      	blt.n	1693e <pdn_interface_connect+0x292>
   168d6:	4602      	mov	r2, r0
   168d8:	4925      	ldr	r1, [pc, #148]	; (16970 <pdn_interface_connect+0x2c4>)
   168da:	4830      	ldr	r0, [pc, #192]	; (1699c <pdn_interface_connect+0x2f0>)
   168dc:	f005 fb63 	bl	1bfa6 <strncmp>
   168e0:	bb68      	cbnz	r0, 1693e <pdn_interface_connect+0x292>
   168e2:	4628      	mov	r0, r5
   168e4:	4922      	ldr	r1, [pc, #136]	; (16970 <pdn_interface_connect+0x2c4>)
   168e6:	f7ff fd8b 	bl	16400 <pdn_id_get_parser>
   168ea:	e759      	b.n	167a0 <pdn_interface_connect+0xf4>
   168ec:	482c      	ldr	r0, [pc, #176]	; (169a0 <pdn_interface_connect+0x2f4>)
   168ee:	f005 fb47 	bl	1bf80 <strlen>
   168f2:	491f      	ldr	r1, [pc, #124]	; (16970 <pdn_interface_connect+0x2c4>)
   168f4:	4602      	mov	r2, r0
   168f6:	482a      	ldr	r0, [pc, #168]	; (169a0 <pdn_interface_connect+0x2f4>)
   168f8:	f005 fb55 	bl	1bfa6 <strncmp>
   168fc:	2800      	cmp	r0, #0
   168fe:	f47f af4a 	bne.w	16796 <pdn_interface_connect+0xea>
   16902:	2008      	movs	r0, #8
   16904:	f7f9 fb92 	bl	1002c <bsd_os_errno_set>
   16908:	f04f 34ff 	mov.w	r4, #4294967295
   1690c:	e748      	b.n	167a0 <pdn_interface_connect+0xf4>
   1690e:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   16912:	1930      	adds	r0, r6, r4
   16914:	4b23      	ldr	r3, [pc, #140]	; (169a4 <pdn_interface_connect+0x2f8>)
   16916:	4a1b      	ldr	r2, [pc, #108]	; (16984 <pdn_interface_connect+0x2d8>)
   16918:	f7f8 fb8a 	bl	f030 <snprintf>
   1691c:	4404      	add	r4, r0
   1691e:	e718      	b.n	16752 <pdn_interface_connect+0xa6>
   16920:	f04f 34ff 	mov.w	r4, #4294967295
   16924:	2009      	movs	r0, #9
   16926:	f7f9 fb81 	bl	1002c <bsd_os_errno_set>
   1692a:	4620      	mov	r0, r4
   1692c:	b003      	add	sp, #12
   1692e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   16932:	2016      	movs	r0, #22
   16934:	f7f9 fb7a 	bl	1002c <bsd_os_errno_set>
   16938:	f04f 34ff 	mov.w	r4, #4294967295
   1693c:	e730      	b.n	167a0 <pdn_interface_connect+0xf4>
   1693e:	4818      	ldr	r0, [pc, #96]	; (169a0 <pdn_interface_connect+0x2f4>)
   16940:	f005 fb1e 	bl	1bf80 <strlen>
   16944:	490a      	ldr	r1, [pc, #40]	; (16970 <pdn_interface_connect+0x2c4>)
   16946:	4602      	mov	r2, r0
   16948:	4815      	ldr	r0, [pc, #84]	; (169a0 <pdn_interface_connect+0x2f4>)
   1694a:	f005 fb2c 	bl	1bfa6 <strncmp>
   1694e:	b930      	cbnz	r0, 1695e <pdn_interface_connect+0x2b2>
   16950:	2008      	movs	r0, #8
   16952:	f7f9 fb6b 	bl	1002c <bsd_os_errno_set>
   16956:	e723      	b.n	167a0 <pdn_interface_connect+0xf4>
   16958:	f04f 34ff 	mov.w	r4, #4294967295
   1695c:	e720      	b.n	167a0 <pdn_interface_connect+0xf4>
   1695e:	2005      	movs	r0, #5
   16960:	f7f9 fb64 	bl	1002c <bsd_os_errno_set>
   16964:	e71c      	b.n	167a0 <pdn_interface_connect+0xf4>
   16966:	bf00      	nop
   16968:	789a0000 	.word	0x789a0000
   1696c:	20020950 	.word	0x20020950
   16970:	20020850 	.word	0x20020850
   16974:	0001de70 	.word	0x0001de70
   16978:	0001de7c 	.word	0x0001de7c
   1697c:	0001de90 	.word	0x0001de90
   16980:	0001de98 	.word	0x0001de98
   16984:	0001de88 	.word	0x0001de88
   16988:	0001decc 	.word	0x0001decc
   1698c:	0001de9c 	.word	0x0001de9c
   16990:	0001dea0 	.word	0x0001dea0
   16994:	0001deac 	.word	0x0001deac
   16998:	0001deb0 	.word	0x0001deb0
   1699c:	0001dec0 	.word	0x0001dec0
   169a0:	0001df04 	.word	0x0001df04
   169a4:	0001de80 	.word	0x0001de80
   169a8:	2002084c 	.word	0x2002084c

000169ac <pdn_interface_close>:
   169ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   169b0:	4a6b      	ldr	r2, [pc, #428]	; (16b60 <pdn_interface_close+0x1b4>)
   169b2:	0c03      	lsrs	r3, r0, #16
   169b4:	041b      	lsls	r3, r3, #16
   169b6:	4293      	cmp	r3, r2
   169b8:	b083      	sub	sp, #12
   169ba:	f040 80ac 	bne.w	16b16 <pdn_interface_close+0x16a>
   169be:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   169c2:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   169c6:	2c09      	cmp	r4, #9
   169c8:	f300 80a5 	bgt.w	16b16 <pdn_interface_close+0x16a>
   169cc:	4d65      	ldr	r5, [pc, #404]	; (16b64 <pdn_interface_close+0x1b8>)
   169ce:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   169d2:	2800      	cmp	r0, #0
   169d4:	f000 809f 	beq.w	16b16 <pdn_interface_close+0x16a>
   169d8:	6883      	ldr	r3, [r0, #8]
   169da:	2b00      	cmp	r3, #0
   169dc:	f000 809b 	beq.w	16b16 <pdn_interface_close+0x16a>
   169e0:	6883      	ldr	r3, [r0, #8]
   169e2:	2b03      	cmp	r3, #3
   169e4:	d00b      	beq.n	169fe <pdn_interface_close+0x52>
   169e6:	6883      	ldr	r3, [r0, #8]
   169e8:	2b02      	cmp	r3, #2
   169ea:	d055      	beq.n	16a98 <pdn_interface_close+0xec>
   169ec:	f002 f824 	bl	18a38 <nrf_free>
   169f0:	2300      	movs	r3, #0
   169f2:	4618      	mov	r0, r3
   169f4:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   169f8:	b003      	add	sp, #12
   169fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   169fe:	4e5a      	ldr	r6, [pc, #360]	; (16b68 <pdn_interface_close+0x1bc>)
   16a00:	4a5a      	ldr	r2, [pc, #360]	; (16b6c <pdn_interface_close+0x1c0>)
   16a02:	f44f 7180 	mov.w	r1, #256	; 0x100
   16a06:	4630      	mov	r0, r6
   16a08:	f7f8 fb12 	bl	f030 <snprintf>
   16a0c:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   16a10:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   16a14:	681b      	ldr	r3, [r3, #0]
   16a16:	4a56      	ldr	r2, [pc, #344]	; (16b70 <pdn_interface_close+0x1c4>)
   16a18:	4430      	add	r0, r6
   16a1a:	f8df 8164 	ldr.w	r8, [pc, #356]	; 16b80 <pdn_interface_close+0x1d4>
   16a1e:	f7f8 fb07 	bl	f030 <snprintf>
   16a22:	4630      	mov	r0, r6
   16a24:	f8d8 9000 	ldr.w	r9, [r8]
   16a28:	2700      	movs	r7, #0
   16a2a:	f005 faa9 	bl	1bf80 <strlen>
   16a2e:	4631      	mov	r1, r6
   16a30:	4602      	mov	r2, r0
   16a32:	463b      	mov	r3, r7
   16a34:	4648      	mov	r0, r9
   16a36:	9701      	str	r7, [sp, #4]
   16a38:	9700      	str	r7, [sp, #0]
   16a3a:	f7ff fac7 	bl	15fcc <at_interface_write>
   16a3e:	4681      	mov	r9, r0
   16a40:	4630      	mov	r0, r6
   16a42:	f005 fa9d 	bl	1bf80 <strlen>
   16a46:	4548      	cmp	r0, r9
   16a48:	f040 8082 	bne.w	16b50 <pdn_interface_close+0x1a4>
   16a4c:	463b      	mov	r3, r7
   16a4e:	e9cd 7700 	strd	r7, r7, [sp]
   16a52:	f44f 7280 	mov.w	r2, #256	; 0x100
   16a56:	4631      	mov	r1, r6
   16a58:	f8d8 0000 	ldr.w	r0, [r8]
   16a5c:	f7ff fbec 	bl	16238 <at_interface_read>
   16a60:	4607      	mov	r7, r0
   16a62:	4844      	ldr	r0, [pc, #272]	; (16b74 <pdn_interface_close+0x1c8>)
   16a64:	f005 fa8c 	bl	1bf80 <strlen>
   16a68:	4287      	cmp	r7, r0
   16a6a:	da5a      	bge.n	16b22 <pdn_interface_close+0x176>
   16a6c:	4842      	ldr	r0, [pc, #264]	; (16b78 <pdn_interface_close+0x1cc>)
   16a6e:	f005 fa87 	bl	1bf80 <strlen>
   16a72:	493d      	ldr	r1, [pc, #244]	; (16b68 <pdn_interface_close+0x1bc>)
   16a74:	4602      	mov	r2, r0
   16a76:	4840      	ldr	r0, [pc, #256]	; (16b78 <pdn_interface_close+0x1cc>)
   16a78:	f005 fa95 	bl	1bfa6 <strncmp>
   16a7c:	2800      	cmp	r0, #0
   16a7e:	d167      	bne.n	16b50 <pdn_interface_close+0x1a4>
   16a80:	2008      	movs	r0, #8
   16a82:	f7f9 fad3 	bl	1002c <bsd_os_errno_set>
   16a86:	2202      	movs	r2, #2
   16a88:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   16a8c:	609a      	str	r2, [r3, #8]
   16a8e:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   16a92:	6883      	ldr	r3, [r0, #8]
   16a94:	2b02      	cmp	r3, #2
   16a96:	d1a9      	bne.n	169ec <pdn_interface_close+0x40>
   16a98:	4e33      	ldr	r6, [pc, #204]	; (16b68 <pdn_interface_close+0x1bc>)
   16a9a:	4a38      	ldr	r2, [pc, #224]	; (16b7c <pdn_interface_close+0x1d0>)
   16a9c:	f44f 7180 	mov.w	r1, #256	; 0x100
   16aa0:	4630      	mov	r0, r6
   16aa2:	f7f8 fac5 	bl	f030 <snprintf>
   16aa6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   16aaa:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   16aae:	681b      	ldr	r3, [r3, #0]
   16ab0:	4a2f      	ldr	r2, [pc, #188]	; (16b70 <pdn_interface_close+0x1c4>)
   16ab2:	4430      	add	r0, r6
   16ab4:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 16b80 <pdn_interface_close+0x1d4>
   16ab8:	f7f8 faba 	bl	f030 <snprintf>
   16abc:	4630      	mov	r0, r6
   16abe:	f8d8 9000 	ldr.w	r9, [r8]
   16ac2:	2700      	movs	r7, #0
   16ac4:	f005 fa5c 	bl	1bf80 <strlen>
   16ac8:	4631      	mov	r1, r6
   16aca:	4602      	mov	r2, r0
   16acc:	463b      	mov	r3, r7
   16ace:	4648      	mov	r0, r9
   16ad0:	9701      	str	r7, [sp, #4]
   16ad2:	9700      	str	r7, [sp, #0]
   16ad4:	f7ff fa7a 	bl	15fcc <at_interface_write>
   16ad8:	4681      	mov	r9, r0
   16ada:	4630      	mov	r0, r6
   16adc:	f005 fa50 	bl	1bf80 <strlen>
   16ae0:	4548      	cmp	r0, r9
   16ae2:	d139      	bne.n	16b58 <pdn_interface_close+0x1ac>
   16ae4:	463b      	mov	r3, r7
   16ae6:	e9cd 7700 	strd	r7, r7, [sp]
   16aea:	f44f 7280 	mov.w	r2, #256	; 0x100
   16aee:	4631      	mov	r1, r6
   16af0:	f8d8 0000 	ldr.w	r0, [r8]
   16af4:	f7ff fba0 	bl	16238 <at_interface_read>
   16af8:	4607      	mov	r7, r0
   16afa:	481e      	ldr	r0, [pc, #120]	; (16b74 <pdn_interface_close+0x1c8>)
   16afc:	f005 fa40 	bl	1bf80 <strlen>
   16b00:	4287      	cmp	r7, r0
   16b02:	db16      	blt.n	16b32 <pdn_interface_close+0x186>
   16b04:	4602      	mov	r2, r0
   16b06:	4631      	mov	r1, r6
   16b08:	481a      	ldr	r0, [pc, #104]	; (16b74 <pdn_interface_close+0x1c8>)
   16b0a:	f005 fa4c 	bl	1bfa6 <strncmp>
   16b0e:	b980      	cbnz	r0, 16b32 <pdn_interface_close+0x186>
   16b10:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   16b14:	e76a      	b.n	169ec <pdn_interface_close+0x40>
   16b16:	2009      	movs	r0, #9
   16b18:	f7f9 fa88 	bl	1002c <bsd_os_errno_set>
   16b1c:	f04f 30ff 	mov.w	r0, #4294967295
   16b20:	e76a      	b.n	169f8 <pdn_interface_close+0x4c>
   16b22:	4602      	mov	r2, r0
   16b24:	4631      	mov	r1, r6
   16b26:	4813      	ldr	r0, [pc, #76]	; (16b74 <pdn_interface_close+0x1c8>)
   16b28:	f005 fa3d 	bl	1bfa6 <strncmp>
   16b2c:	2800      	cmp	r0, #0
   16b2e:	d0aa      	beq.n	16a86 <pdn_interface_close+0xda>
   16b30:	e79c      	b.n	16a6c <pdn_interface_close+0xc0>
   16b32:	4811      	ldr	r0, [pc, #68]	; (16b78 <pdn_interface_close+0x1cc>)
   16b34:	f005 fa24 	bl	1bf80 <strlen>
   16b38:	490b      	ldr	r1, [pc, #44]	; (16b68 <pdn_interface_close+0x1bc>)
   16b3a:	4602      	mov	r2, r0
   16b3c:	480e      	ldr	r0, [pc, #56]	; (16b78 <pdn_interface_close+0x1cc>)
   16b3e:	f005 fa32 	bl	1bfa6 <strncmp>
   16b42:	b948      	cbnz	r0, 16b58 <pdn_interface_close+0x1ac>
   16b44:	2008      	movs	r0, #8
   16b46:	f7f9 fa71 	bl	1002c <bsd_os_errno_set>
   16b4a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   16b4e:	e74d      	b.n	169ec <pdn_interface_close+0x40>
   16b50:	2005      	movs	r0, #5
   16b52:	f7f9 fa6b 	bl	1002c <bsd_os_errno_set>
   16b56:	e796      	b.n	16a86 <pdn_interface_close+0xda>
   16b58:	2005      	movs	r0, #5
   16b5a:	f7f9 fa67 	bl	1002c <bsd_os_errno_set>
   16b5e:	e7d7      	b.n	16b10 <pdn_interface_close+0x164>
   16b60:	789a0000 	.word	0x789a0000
   16b64:	20020950 	.word	0x20020950
   16b68:	20020850 	.word	0x20020850
   16b6c:	0001de64 	.word	0x0001de64
   16b70:	0001deac 	.word	0x0001deac
   16b74:	0001de9c 	.word	0x0001de9c
   16b78:	0001df04 	.word	0x0001df04
   16b7c:	0001de70 	.word	0x0001de70
   16b80:	2002084c 	.word	0x2002084c

00016b84 <pdn_interface_setopt>:
   16b84:	b538      	push	{r3, r4, r5, lr}
   16b86:	f240 2502 	movw	r5, #514	; 0x202
   16b8a:	42a9      	cmp	r1, r5
   16b8c:	9c04      	ldr	r4, [sp, #16]
   16b8e:	d140      	bne.n	16c12 <pdn_interface_setopt+0x8e>
   16b90:	2b00      	cmp	r3, #0
   16b92:	d03e      	beq.n	16c12 <pdn_interface_setopt+0x8e>
   16b94:	2c00      	cmp	r4, #0
   16b96:	d03c      	beq.n	16c12 <pdn_interface_setopt+0x8e>
   16b98:	0c01      	lsrs	r1, r0, #16
   16b9a:	4d22      	ldr	r5, [pc, #136]	; (16c24 <pdn_interface_setopt+0xa0>)
   16b9c:	0409      	lsls	r1, r1, #16
   16b9e:	42a9      	cmp	r1, r5
   16ba0:	d005      	beq.n	16bae <pdn_interface_setopt+0x2a>
   16ba2:	2009      	movs	r0, #9
   16ba4:	f7f9 fa42 	bl	1002c <bsd_os_errno_set>
   16ba8:	f04f 30ff 	mov.w	r0, #4294967295
   16bac:	bd38      	pop	{r3, r4, r5, pc}
   16bae:	f020 40f1 	bic.w	r0, r0, #2021654528	; 0x78800000
   16bb2:	f420 10d0 	bic.w	r0, r0, #1703936	; 0x1a0000
   16bb6:	2809      	cmp	r0, #9
   16bb8:	dcf3      	bgt.n	16ba2 <pdn_interface_setopt+0x1e>
   16bba:	491b      	ldr	r1, [pc, #108]	; (16c28 <pdn_interface_setopt+0xa4>)
   16bbc:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   16bc0:	2900      	cmp	r1, #0
   16bc2:	d0ee      	beq.n	16ba2 <pdn_interface_setopt+0x1e>
   16bc4:	6888      	ldr	r0, [r1, #8]
   16bc6:	2800      	cmp	r0, #0
   16bc8:	d0eb      	beq.n	16ba2 <pdn_interface_setopt+0x1e>
   16bca:	2a01      	cmp	r2, #1
   16bcc:	d128      	bne.n	16c20 <pdn_interface_setopt+0x9c>
   16bce:	688a      	ldr	r2, [r1, #8]
   16bd0:	b1ea      	cbz	r2, 16c0e <pdn_interface_setopt+0x8a>
   16bd2:	688a      	ldr	r2, [r1, #8]
   16bd4:	2a03      	cmp	r2, #3
   16bd6:	d01a      	beq.n	16c0e <pdn_interface_setopt+0x8a>
   16bd8:	688a      	ldr	r2, [r1, #8]
   16bda:	2a04      	cmp	r2, #4
   16bdc:	d017      	beq.n	16c0e <pdn_interface_setopt+0x8a>
   16bde:	08a2      	lsrs	r2, r4, #2
   16be0:	1e50      	subs	r0, r2, #1
   16be2:	2801      	cmp	r0, #1
   16be4:	d815      	bhi.n	16c12 <pdn_interface_setopt+0x8e>
   16be6:	07a0      	lsls	r0, r4, #30
   16be8:	d113      	bne.n	16c12 <pdn_interface_setopt+0x8e>
   16bea:	6818      	ldr	r0, [r3, #0]
   16bec:	2802      	cmp	r0, #2
   16bee:	d012      	beq.n	16c16 <pdn_interface_setopt+0x92>
   16bf0:	280a      	cmp	r0, #10
   16bf2:	d10e      	bne.n	16c12 <pdn_interface_setopt+0x8e>
   16bf4:	2002      	movs	r0, #2
   16bf6:	2a02      	cmp	r2, #2
   16bf8:	d106      	bne.n	16c08 <pdn_interface_setopt+0x84>
   16bfa:	685b      	ldr	r3, [r3, #4]
   16bfc:	2b02      	cmp	r3, #2
   16bfe:	d00c      	beq.n	16c1a <pdn_interface_setopt+0x96>
   16c00:	2b0a      	cmp	r3, #10
   16c02:	d106      	bne.n	16c12 <pdn_interface_setopt+0x8e>
   16c04:	f040 0002 	orr.w	r0, r0, #2
   16c08:	6708      	str	r0, [r1, #112]	; 0x70
   16c0a:	2000      	movs	r0, #0
   16c0c:	bd38      	pop	{r3, r4, r5, pc}
   16c0e:	200e      	movs	r0, #14
   16c10:	e7c8      	b.n	16ba4 <pdn_interface_setopt+0x20>
   16c12:	2016      	movs	r0, #22
   16c14:	e7c6      	b.n	16ba4 <pdn_interface_setopt+0x20>
   16c16:	2001      	movs	r0, #1
   16c18:	e7ed      	b.n	16bf6 <pdn_interface_setopt+0x72>
   16c1a:	f040 0001 	orr.w	r0, r0, #1
   16c1e:	e7f3      	b.n	16c08 <pdn_interface_setopt+0x84>
   16c20:	202d      	movs	r0, #45	; 0x2d
   16c22:	e7bf      	b.n	16ba4 <pdn_interface_setopt+0x20>
   16c24:	789a0000 	.word	0x789a0000
   16c28:	20020950 	.word	0x20020950

00016c2c <pdn_interface_getopt>:
   16c2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16c30:	f240 2402 	movw	r4, #514	; 0x202
   16c34:	b083      	sub	sp, #12
   16c36:	42a1      	cmp	r1, r4
   16c38:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   16c3a:	f040 809f 	bne.w	16d7c <pdn_interface_getopt+0x150>
   16c3e:	461e      	mov	r6, r3
   16c40:	2b00      	cmp	r3, #0
   16c42:	f000 809b 	beq.w	16d7c <pdn_interface_getopt+0x150>
   16c46:	2d00      	cmp	r5, #0
   16c48:	f000 8098 	beq.w	16d7c <pdn_interface_getopt+0x150>
   16c4c:	0c03      	lsrs	r3, r0, #16
   16c4e:	4955      	ldr	r1, [pc, #340]	; (16da4 <pdn_interface_getopt+0x178>)
   16c50:	041b      	lsls	r3, r3, #16
   16c52:	428b      	cmp	r3, r1
   16c54:	f040 8094 	bne.w	16d80 <pdn_interface_getopt+0x154>
   16c58:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   16c5c:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   16c60:	2c09      	cmp	r4, #9
   16c62:	f300 808d 	bgt.w	16d80 <pdn_interface_getopt+0x154>
   16c66:	4b50      	ldr	r3, [pc, #320]	; (16da8 <pdn_interface_getopt+0x17c>)
   16c68:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   16c6c:	2b00      	cmp	r3, #0
   16c6e:	f000 8087 	beq.w	16d80 <pdn_interface_getopt+0x154>
   16c72:	6899      	ldr	r1, [r3, #8]
   16c74:	2900      	cmp	r1, #0
   16c76:	f000 8083 	beq.w	16d80 <pdn_interface_getopt+0x154>
   16c7a:	2a02      	cmp	r2, #2
   16c7c:	d04c      	beq.n	16d18 <pdn_interface_getopt+0xec>
   16c7e:	2a03      	cmp	r2, #3
   16c80:	d009      	beq.n	16c96 <pdn_interface_getopt+0x6a>
   16c82:	2a01      	cmp	r2, #1
   16c84:	d052      	beq.n	16d2c <pdn_interface_getopt+0x100>
   16c86:	202d      	movs	r0, #45	; 0x2d
   16c88:	f7f9 f9d0 	bl	1002c <bsd_os_errno_set>
   16c8c:	f04f 30ff 	mov.w	r0, #4294967295
   16c90:	b003      	add	sp, #12
   16c92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16c96:	682b      	ldr	r3, [r5, #0]
   16c98:	2b00      	cmp	r3, #0
   16c9a:	d06f      	beq.n	16d7c <pdn_interface_getopt+0x150>
   16c9c:	4a43      	ldr	r2, [pc, #268]	; (16dac <pdn_interface_getopt+0x180>)
   16c9e:	f44f 7180 	mov.w	r1, #256	; 0x100
   16ca2:	4843      	ldr	r0, [pc, #268]	; (16db0 <pdn_interface_getopt+0x184>)
   16ca4:	f8df 8114 	ldr.w	r8, [pc, #276]	; 16dbc <pdn_interface_getopt+0x190>
   16ca8:	f7f8 f9c2 	bl	f030 <snprintf>
   16cac:	4840      	ldr	r0, [pc, #256]	; (16db0 <pdn_interface_getopt+0x184>)
   16cae:	f8d8 9000 	ldr.w	r9, [r8]
   16cb2:	2700      	movs	r7, #0
   16cb4:	f005 f964 	bl	1bf80 <strlen>
   16cb8:	463b      	mov	r3, r7
   16cba:	4602      	mov	r2, r0
   16cbc:	493c      	ldr	r1, [pc, #240]	; (16db0 <pdn_interface_getopt+0x184>)
   16cbe:	4648      	mov	r0, r9
   16cc0:	9701      	str	r7, [sp, #4]
   16cc2:	9700      	str	r7, [sp, #0]
   16cc4:	f7ff f982 	bl	15fcc <at_interface_write>
   16cc8:	4681      	mov	r9, r0
   16cca:	4839      	ldr	r0, [pc, #228]	; (16db0 <pdn_interface_getopt+0x184>)
   16ccc:	f005 f958 	bl	1bf80 <strlen>
   16cd0:	4548      	cmp	r0, r9
   16cd2:	d160      	bne.n	16d96 <pdn_interface_getopt+0x16a>
   16cd4:	463b      	mov	r3, r7
   16cd6:	e9cd 7700 	strd	r7, r7, [sp]
   16cda:	f44f 7280 	mov.w	r2, #256	; 0x100
   16cde:	4934      	ldr	r1, [pc, #208]	; (16db0 <pdn_interface_getopt+0x184>)
   16ce0:	f8d8 0000 	ldr.w	r0, [r8]
   16ce4:	f7ff faa8 	bl	16238 <at_interface_read>
   16ce8:	4607      	mov	r7, r0
   16cea:	4832      	ldr	r0, [pc, #200]	; (16db4 <pdn_interface_getopt+0x188>)
   16cec:	f005 f948 	bl	1bf80 <strlen>
   16cf0:	4287      	cmp	r7, r0
   16cf2:	db32      	blt.n	16d5a <pdn_interface_getopt+0x12e>
   16cf4:	4602      	mov	r2, r0
   16cf6:	492e      	ldr	r1, [pc, #184]	; (16db0 <pdn_interface_getopt+0x184>)
   16cf8:	482e      	ldr	r0, [pc, #184]	; (16db4 <pdn_interface_getopt+0x188>)
   16cfa:	f005 f954 	bl	1bfa6 <strncmp>
   16cfe:	4607      	mov	r7, r0
   16d00:	bb58      	cbnz	r0, 16d5a <pdn_interface_getopt+0x12e>
   16d02:	4620      	mov	r0, r4
   16d04:	492a      	ldr	r1, [pc, #168]	; (16db0 <pdn_interface_getopt+0x184>)
   16d06:	f7ff fb45 	bl	16394 <pdn_state_get_parser>
   16d0a:	2800      	cmp	r0, #0
   16d0c:	dbbc      	blt.n	16c88 <pdn_interface_getopt+0x5c>
   16d0e:	2301      	movs	r3, #1
   16d10:	7030      	strb	r0, [r6, #0]
   16d12:	4638      	mov	r0, r7
   16d14:	602b      	str	r3, [r5, #0]
   16d16:	e7bb      	b.n	16c90 <pdn_interface_getopt+0x64>
   16d18:	682a      	ldr	r2, [r5, #0]
   16d1a:	b37a      	cbz	r2, 16d7c <pdn_interface_getopt+0x150>
   16d1c:	2201      	movs	r2, #1
   16d1e:	2000      	movs	r0, #0
   16d20:	681b      	ldr	r3, [r3, #0]
   16d22:	7033      	strb	r3, [r6, #0]
   16d24:	602a      	str	r2, [r5, #0]
   16d26:	b003      	add	sp, #12
   16d28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16d2c:	689a      	ldr	r2, [r3, #8]
   16d2e:	b31a      	cbz	r2, 16d78 <pdn_interface_getopt+0x14c>
   16d30:	689a      	ldr	r2, [r3, #8]
   16d32:	2a04      	cmp	r2, #4
   16d34:	d020      	beq.n	16d78 <pdn_interface_getopt+0x14c>
   16d36:	682a      	ldr	r2, [r5, #0]
   16d38:	2a07      	cmp	r2, #7
   16d3a:	d91f      	bls.n	16d7c <pdn_interface_getopt+0x150>
   16d3c:	f012 0203 	ands.w	r2, r2, #3
   16d40:	d11c      	bne.n	16d7c <pdn_interface_getopt+0x150>
   16d42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   16d44:	0799      	lsls	r1, r3, #30
   16d46:	d421      	bmi.n	16d8c <pdn_interface_getopt+0x160>
   16d48:	2104      	movs	r1, #4
   16d4a:	07db      	lsls	r3, r3, #31
   16d4c:	d502      	bpl.n	16d54 <pdn_interface_getopt+0x128>
   16d4e:	2302      	movs	r3, #2
   16d50:	50b3      	str	r3, [r6, r2]
   16d52:	460a      	mov	r2, r1
   16d54:	602a      	str	r2, [r5, #0]
   16d56:	2000      	movs	r0, #0
   16d58:	e79a      	b.n	16c90 <pdn_interface_getopt+0x64>
   16d5a:	4817      	ldr	r0, [pc, #92]	; (16db8 <pdn_interface_getopt+0x18c>)
   16d5c:	f005 f910 	bl	1bf80 <strlen>
   16d60:	4913      	ldr	r1, [pc, #76]	; (16db0 <pdn_interface_getopt+0x184>)
   16d62:	4602      	mov	r2, r0
   16d64:	4814      	ldr	r0, [pc, #80]	; (16db8 <pdn_interface_getopt+0x18c>)
   16d66:	f005 f91e 	bl	1bfa6 <strncmp>
   16d6a:	b9a0      	cbnz	r0, 16d96 <pdn_interface_getopt+0x16a>
   16d6c:	2008      	movs	r0, #8
   16d6e:	f7f9 f95d 	bl	1002c <bsd_os_errno_set>
   16d72:	f04f 30ff 	mov.w	r0, #4294967295
   16d76:	e787      	b.n	16c88 <pdn_interface_getopt+0x5c>
   16d78:	200e      	movs	r0, #14
   16d7a:	e785      	b.n	16c88 <pdn_interface_getopt+0x5c>
   16d7c:	2016      	movs	r0, #22
   16d7e:	e783      	b.n	16c88 <pdn_interface_getopt+0x5c>
   16d80:	2009      	movs	r0, #9
   16d82:	f7f9 f953 	bl	1002c <bsd_os_errno_set>
   16d86:	f04f 30ff 	mov.w	r0, #4294967295
   16d8a:	e781      	b.n	16c90 <pdn_interface_getopt+0x64>
   16d8c:	220a      	movs	r2, #10
   16d8e:	2108      	movs	r1, #8
   16d90:	6032      	str	r2, [r6, #0]
   16d92:	2204      	movs	r2, #4
   16d94:	e7d9      	b.n	16d4a <pdn_interface_getopt+0x11e>
   16d96:	2005      	movs	r0, #5
   16d98:	f7f9 f948 	bl	1002c <bsd_os_errno_set>
   16d9c:	f04f 30ff 	mov.w	r0, #4294967295
   16da0:	e772      	b.n	16c88 <pdn_interface_getopt+0x5c>
   16da2:	bf00      	nop
   16da4:	789a0000 	.word	0x789a0000
   16da8:	20020950 	.word	0x20020950
   16dac:	0001ded4 	.word	0x0001ded4
   16db0:	20020850 	.word	0x20020850
   16db4:	0001dee0 	.word	0x0001dee0
   16db8:	0001df04 	.word	0x0001df04
   16dbc:	2002084c 	.word	0x2002084c

00016dc0 <pdn_interface_pdn_id_get>:
   16dc0:	2900      	cmp	r1, #0
   16dc2:	f000 83b9 	beq.w	17538 <pdn_interface_pdn_id_get+0x778>
   16dc6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16dca:	4ca3      	ldr	r4, [pc, #652]	; (17058 <pdn_interface_pdn_id_get+0x298>)
   16dcc:	2802      	cmp	r0, #2
   16dce:	b083      	sub	sp, #12
   16dd0:	460d      	mov	r5, r1
   16dd2:	6823      	ldr	r3, [r4, #0]
   16dd4:	f000 8094 	beq.w	16f00 <pdn_interface_pdn_id_get+0x140>
   16dd8:	280a      	cmp	r0, #10
   16dda:	d03f      	beq.n	16e5c <pdn_interface_pdn_id_get+0x9c>
   16ddc:	b11b      	cbz	r3, 16de6 <pdn_interface_pdn_id_get+0x26>
   16dde:	689b      	ldr	r3, [r3, #8]
   16de0:	2b03      	cmp	r3, #3
   16de2:	f000 8127 	beq.w	17034 <pdn_interface_pdn_id_get+0x274>
   16de6:	6863      	ldr	r3, [r4, #4]
   16de8:	b11b      	cbz	r3, 16df2 <pdn_interface_pdn_id_get+0x32>
   16dea:	689b      	ldr	r3, [r3, #8]
   16dec:	2b03      	cmp	r3, #3
   16dee:	f000 8110 	beq.w	17012 <pdn_interface_pdn_id_get+0x252>
   16df2:	68a3      	ldr	r3, [r4, #8]
   16df4:	b11b      	cbz	r3, 16dfe <pdn_interface_pdn_id_get+0x3e>
   16df6:	689b      	ldr	r3, [r3, #8]
   16df8:	2b03      	cmp	r3, #3
   16dfa:	f000 80f9 	beq.w	16ff0 <pdn_interface_pdn_id_get+0x230>
   16dfe:	68e3      	ldr	r3, [r4, #12]
   16e00:	b11b      	cbz	r3, 16e0a <pdn_interface_pdn_id_get+0x4a>
   16e02:	689b      	ldr	r3, [r3, #8]
   16e04:	2b03      	cmp	r3, #3
   16e06:	f000 80e2 	beq.w	16fce <pdn_interface_pdn_id_get+0x20e>
   16e0a:	6923      	ldr	r3, [r4, #16]
   16e0c:	b11b      	cbz	r3, 16e16 <pdn_interface_pdn_id_get+0x56>
   16e0e:	689b      	ldr	r3, [r3, #8]
   16e10:	2b03      	cmp	r3, #3
   16e12:	f000 8123 	beq.w	1705c <pdn_interface_pdn_id_get+0x29c>
   16e16:	6963      	ldr	r3, [r4, #20]
   16e18:	b11b      	cbz	r3, 16e22 <pdn_interface_pdn_id_get+0x62>
   16e1a:	689b      	ldr	r3, [r3, #8]
   16e1c:	2b03      	cmp	r3, #3
   16e1e:	f000 8161 	beq.w	170e4 <pdn_interface_pdn_id_get+0x324>
   16e22:	69a3      	ldr	r3, [r4, #24]
   16e24:	b11b      	cbz	r3, 16e2e <pdn_interface_pdn_id_get+0x6e>
   16e26:	689b      	ldr	r3, [r3, #8]
   16e28:	2b03      	cmp	r3, #3
   16e2a:	f000 814a 	beq.w	170c2 <pdn_interface_pdn_id_get+0x302>
   16e2e:	69e3      	ldr	r3, [r4, #28]
   16e30:	b11b      	cbz	r3, 16e3a <pdn_interface_pdn_id_get+0x7a>
   16e32:	689b      	ldr	r3, [r3, #8]
   16e34:	2b03      	cmp	r3, #3
   16e36:	f000 8133 	beq.w	170a0 <pdn_interface_pdn_id_get+0x2e0>
   16e3a:	6a23      	ldr	r3, [r4, #32]
   16e3c:	b11b      	cbz	r3, 16e46 <pdn_interface_pdn_id_get+0x86>
   16e3e:	689b      	ldr	r3, [r3, #8]
   16e40:	2b03      	cmp	r3, #3
   16e42:	f000 811c 	beq.w	1707e <pdn_interface_pdn_id_get+0x2be>
   16e46:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16e48:	b11b      	cbz	r3, 16e52 <pdn_interface_pdn_id_get+0x92>
   16e4a:	689b      	ldr	r3, [r3, #8]
   16e4c:	2b03      	cmp	r3, #3
   16e4e:	f000 80ad 	beq.w	16fac <pdn_interface_pdn_id_get+0x1ec>
   16e52:	f04f 30ff 	mov.w	r0, #4294967295
   16e56:	b003      	add	sp, #12
   16e58:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   16e5c:	b11b      	cbz	r3, 16e66 <pdn_interface_pdn_id_get+0xa6>
   16e5e:	689b      	ldr	r3, [r3, #8]
   16e60:	2b03      	cmp	r3, #3
   16e62:	f000 8335 	beq.w	174d0 <pdn_interface_pdn_id_get+0x710>
   16e66:	6863      	ldr	r3, [r4, #4]
   16e68:	b11b      	cbz	r3, 16e72 <pdn_interface_pdn_id_get+0xb2>
   16e6a:	689b      	ldr	r3, [r3, #8]
   16e6c:	2b03      	cmp	r3, #3
   16e6e:	f000 82fd 	beq.w	1746c <pdn_interface_pdn_id_get+0x6ac>
   16e72:	68a3      	ldr	r3, [r4, #8]
   16e74:	b11b      	cbz	r3, 16e7e <pdn_interface_pdn_id_get+0xbe>
   16e76:	689b      	ldr	r3, [r3, #8]
   16e78:	2b03      	cmp	r3, #3
   16e7a:	f000 82d5 	beq.w	17428 <pdn_interface_pdn_id_get+0x668>
   16e7e:	68e3      	ldr	r3, [r4, #12]
   16e80:	b11b      	cbz	r3, 16e8a <pdn_interface_pdn_id_get+0xca>
   16e82:	689e      	ldr	r6, [r3, #8]
   16e84:	2e03      	cmp	r6, #3
   16e86:	f000 81f0 	beq.w	1726a <pdn_interface_pdn_id_get+0x4aa>
   16e8a:	6923      	ldr	r3, [r4, #16]
   16e8c:	b11b      	cbz	r3, 16e96 <pdn_interface_pdn_id_get+0xd6>
   16e8e:	689b      	ldr	r3, [r3, #8]
   16e90:	2b03      	cmp	r3, #3
   16e92:	f000 8203 	beq.w	1729c <pdn_interface_pdn_id_get+0x4dc>
   16e96:	6963      	ldr	r3, [r4, #20]
   16e98:	b11b      	cbz	r3, 16ea2 <pdn_interface_pdn_id_get+0xe2>
   16e9a:	689b      	ldr	r3, [r3, #8]
   16e9c:	2b03      	cmp	r3, #3
   16e9e:	f000 8215 	beq.w	172cc <pdn_interface_pdn_id_get+0x50c>
   16ea2:	69a3      	ldr	r3, [r4, #24]
   16ea4:	b11b      	cbz	r3, 16eae <pdn_interface_pdn_id_get+0xee>
   16ea6:	689b      	ldr	r3, [r3, #8]
   16ea8:	2b03      	cmp	r3, #3
   16eaa:	f000 8227 	beq.w	172fc <pdn_interface_pdn_id_get+0x53c>
   16eae:	69e3      	ldr	r3, [r4, #28]
   16eb0:	b11b      	cbz	r3, 16eba <pdn_interface_pdn_id_get+0xfa>
   16eb2:	689b      	ldr	r3, [r3, #8]
   16eb4:	2b03      	cmp	r3, #3
   16eb6:	f000 8239 	beq.w	1732c <pdn_interface_pdn_id_get+0x56c>
   16eba:	6a23      	ldr	r3, [r4, #32]
   16ebc:	b11b      	cbz	r3, 16ec6 <pdn_interface_pdn_id_get+0x106>
   16ebe:	689b      	ldr	r3, [r3, #8]
   16ec0:	2b03      	cmp	r3, #3
   16ec2:	f000 824d 	beq.w	17360 <pdn_interface_pdn_id_get+0x5a0>
   16ec6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16ec8:	2b00      	cmp	r3, #0
   16eca:	d0c2      	beq.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16ecc:	689b      	ldr	r3, [r3, #8]
   16ece:	2b03      	cmp	r3, #3
   16ed0:	d1bf      	bne.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16ed2:	4628      	mov	r0, r5
   16ed4:	f005 f854 	bl	1bf80 <strlen>
   16ed8:	4606      	mov	r6, r0
   16eda:	6a60      	ldr	r0, [r4, #36]	; 0x24
   16edc:	300c      	adds	r0, #12
   16ede:	f005 f84f 	bl	1bf80 <strlen>
   16ee2:	42b0      	cmp	r0, r6
   16ee4:	d1b5      	bne.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16ee6:	6a61      	ldr	r1, [r4, #36]	; 0x24
   16ee8:	4628      	mov	r0, r5
   16eea:	310c      	adds	r1, #12
   16eec:	f005 f84f 	bl	1bf8e <strcmp>
   16ef0:	2800      	cmp	r0, #0
   16ef2:	d1ae      	bne.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16ef4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16ef6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   16ef8:	0792      	lsls	r2, r2, #30
   16efa:	d5aa      	bpl.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16efc:	2609      	movs	r6, #9
   16efe:	e11a      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   16f00:	b11b      	cbz	r3, 16f0a <pdn_interface_pdn_id_get+0x14a>
   16f02:	689b      	ldr	r3, [r3, #8]
   16f04:	2b03      	cmp	r3, #3
   16f06:	f000 82fd 	beq.w	17504 <pdn_interface_pdn_id_get+0x744>
   16f0a:	6863      	ldr	r3, [r4, #4]
   16f0c:	b11b      	cbz	r3, 16f16 <pdn_interface_pdn_id_get+0x156>
   16f0e:	689b      	ldr	r3, [r3, #8]
   16f10:	2b03      	cmp	r3, #3
   16f12:	f000 82c5 	beq.w	174a0 <pdn_interface_pdn_id_get+0x6e0>
   16f16:	68a3      	ldr	r3, [r4, #8]
   16f18:	b11b      	cbz	r3, 16f22 <pdn_interface_pdn_id_get+0x162>
   16f1a:	689b      	ldr	r3, [r3, #8]
   16f1c:	2b03      	cmp	r3, #3
   16f1e:	f000 8269 	beq.w	173f4 <pdn_interface_pdn_id_get+0x634>
   16f22:	68e3      	ldr	r3, [r4, #12]
   16f24:	b11b      	cbz	r3, 16f2e <pdn_interface_pdn_id_get+0x16e>
   16f26:	689e      	ldr	r6, [r3, #8]
   16f28:	2e03      	cmp	r6, #3
   16f2a:	f000 80ec 	beq.w	17106 <pdn_interface_pdn_id_get+0x346>
   16f2e:	6923      	ldr	r3, [r4, #16]
   16f30:	b11b      	cbz	r3, 16f3a <pdn_interface_pdn_id_get+0x17a>
   16f32:	689b      	ldr	r3, [r3, #8]
   16f34:	2b03      	cmp	r3, #3
   16f36:	f000 814a 	beq.w	171ce <pdn_interface_pdn_id_get+0x40e>
   16f3a:	6963      	ldr	r3, [r4, #20]
   16f3c:	b11b      	cbz	r3, 16f46 <pdn_interface_pdn_id_get+0x186>
   16f3e:	689b      	ldr	r3, [r3, #8]
   16f40:	2b03      	cmp	r3, #3
   16f42:	f000 815e 	beq.w	17202 <pdn_interface_pdn_id_get+0x442>
   16f46:	69a3      	ldr	r3, [r4, #24]
   16f48:	b11b      	cbz	r3, 16f52 <pdn_interface_pdn_id_get+0x192>
   16f4a:	689b      	ldr	r3, [r3, #8]
   16f4c:	2b03      	cmp	r3, #3
   16f4e:	f000 8172 	beq.w	17236 <pdn_interface_pdn_id_get+0x476>
   16f52:	69e3      	ldr	r3, [r4, #28]
   16f54:	b11b      	cbz	r3, 16f5e <pdn_interface_pdn_id_get+0x19e>
   16f56:	689b      	ldr	r3, [r3, #8]
   16f58:	2b03      	cmp	r3, #3
   16f5a:	f000 821b 	beq.w	17394 <pdn_interface_pdn_id_get+0x5d4>
   16f5e:	6a23      	ldr	r3, [r4, #32]
   16f60:	b11b      	cbz	r3, 16f6a <pdn_interface_pdn_id_get+0x1aa>
   16f62:	689b      	ldr	r3, [r3, #8]
   16f64:	2b03      	cmp	r3, #3
   16f66:	f000 822d 	beq.w	173c4 <pdn_interface_pdn_id_get+0x604>
   16f6a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16f6c:	2b00      	cmp	r3, #0
   16f6e:	f43f af70 	beq.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16f72:	689b      	ldr	r3, [r3, #8]
   16f74:	2b03      	cmp	r3, #3
   16f76:	f47f af6c 	bne.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16f7a:	4628      	mov	r0, r5
   16f7c:	f005 f800 	bl	1bf80 <strlen>
   16f80:	4606      	mov	r6, r0
   16f82:	6a60      	ldr	r0, [r4, #36]	; 0x24
   16f84:	300c      	adds	r0, #12
   16f86:	f004 fffb 	bl	1bf80 <strlen>
   16f8a:	4286      	cmp	r6, r0
   16f8c:	f47f af61 	bne.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16f90:	6a61      	ldr	r1, [r4, #36]	; 0x24
   16f92:	4628      	mov	r0, r5
   16f94:	310c      	adds	r1, #12
   16f96:	f004 fffa 	bl	1bf8e <strcmp>
   16f9a:	2800      	cmp	r0, #0
   16f9c:	f47f af59 	bne.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16fa0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   16fa2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   16fa4:	07d2      	lsls	r2, r2, #31
   16fa6:	f57f af54 	bpl.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16faa:	e7a7      	b.n	16efc <pdn_interface_pdn_id_get+0x13c>
   16fac:	4628      	mov	r0, r5
   16fae:	f004 ffe7 	bl	1bf80 <strlen>
   16fb2:	4606      	mov	r6, r0
   16fb4:	6a60      	ldr	r0, [r4, #36]	; 0x24
   16fb6:	300c      	adds	r0, #12
   16fb8:	f004 ffe2 	bl	1bf80 <strlen>
   16fbc:	42b0      	cmp	r0, r6
   16fbe:	f47f af48 	bne.w	16e52 <pdn_interface_pdn_id_get+0x92>
   16fc2:	6a61      	ldr	r1, [r4, #36]	; 0x24
   16fc4:	4628      	mov	r0, r5
   16fc6:	310c      	adds	r1, #12
   16fc8:	f004 ffe1 	bl	1bf8e <strcmp>
   16fcc:	e741      	b.n	16e52 <pdn_interface_pdn_id_get+0x92>
   16fce:	4628      	mov	r0, r5
   16fd0:	f004 ffd6 	bl	1bf80 <strlen>
   16fd4:	4606      	mov	r6, r0
   16fd6:	68e0      	ldr	r0, [r4, #12]
   16fd8:	300c      	adds	r0, #12
   16fda:	f004 ffd1 	bl	1bf80 <strlen>
   16fde:	4286      	cmp	r6, r0
   16fe0:	f47f af13 	bne.w	16e0a <pdn_interface_pdn_id_get+0x4a>
   16fe4:	68e1      	ldr	r1, [r4, #12]
   16fe6:	4628      	mov	r0, r5
   16fe8:	310c      	adds	r1, #12
   16fea:	f004 ffd0 	bl	1bf8e <strcmp>
   16fee:	e70c      	b.n	16e0a <pdn_interface_pdn_id_get+0x4a>
   16ff0:	4628      	mov	r0, r5
   16ff2:	f004 ffc5 	bl	1bf80 <strlen>
   16ff6:	4606      	mov	r6, r0
   16ff8:	68a0      	ldr	r0, [r4, #8]
   16ffa:	300c      	adds	r0, #12
   16ffc:	f004 ffc0 	bl	1bf80 <strlen>
   17000:	4286      	cmp	r6, r0
   17002:	f47f aefc 	bne.w	16dfe <pdn_interface_pdn_id_get+0x3e>
   17006:	68a1      	ldr	r1, [r4, #8]
   17008:	4628      	mov	r0, r5
   1700a:	310c      	adds	r1, #12
   1700c:	f004 ffbf 	bl	1bf8e <strcmp>
   17010:	e6f5      	b.n	16dfe <pdn_interface_pdn_id_get+0x3e>
   17012:	4628      	mov	r0, r5
   17014:	f004 ffb4 	bl	1bf80 <strlen>
   17018:	4606      	mov	r6, r0
   1701a:	6860      	ldr	r0, [r4, #4]
   1701c:	300c      	adds	r0, #12
   1701e:	f004 ffaf 	bl	1bf80 <strlen>
   17022:	4286      	cmp	r6, r0
   17024:	f47f aee5 	bne.w	16df2 <pdn_interface_pdn_id_get+0x32>
   17028:	6861      	ldr	r1, [r4, #4]
   1702a:	4628      	mov	r0, r5
   1702c:	310c      	adds	r1, #12
   1702e:	f004 ffae 	bl	1bf8e <strcmp>
   17032:	e6de      	b.n	16df2 <pdn_interface_pdn_id_get+0x32>
   17034:	4608      	mov	r0, r1
   17036:	f004 ffa3 	bl	1bf80 <strlen>
   1703a:	4606      	mov	r6, r0
   1703c:	6820      	ldr	r0, [r4, #0]
   1703e:	300c      	adds	r0, #12
   17040:	f004 ff9e 	bl	1bf80 <strlen>
   17044:	4286      	cmp	r6, r0
   17046:	f47f aece 	bne.w	16de6 <pdn_interface_pdn_id_get+0x26>
   1704a:	6821      	ldr	r1, [r4, #0]
   1704c:	4628      	mov	r0, r5
   1704e:	310c      	adds	r1, #12
   17050:	f004 ff9d 	bl	1bf8e <strcmp>
   17054:	e6c7      	b.n	16de6 <pdn_interface_pdn_id_get+0x26>
   17056:	bf00      	nop
   17058:	20020950 	.word	0x20020950
   1705c:	4628      	mov	r0, r5
   1705e:	f004 ff8f 	bl	1bf80 <strlen>
   17062:	4606      	mov	r6, r0
   17064:	6920      	ldr	r0, [r4, #16]
   17066:	300c      	adds	r0, #12
   17068:	f004 ff8a 	bl	1bf80 <strlen>
   1706c:	4286      	cmp	r6, r0
   1706e:	f47f aed2 	bne.w	16e16 <pdn_interface_pdn_id_get+0x56>
   17072:	6921      	ldr	r1, [r4, #16]
   17074:	4628      	mov	r0, r5
   17076:	310c      	adds	r1, #12
   17078:	f004 ff89 	bl	1bf8e <strcmp>
   1707c:	e6cb      	b.n	16e16 <pdn_interface_pdn_id_get+0x56>
   1707e:	4628      	mov	r0, r5
   17080:	f004 ff7e 	bl	1bf80 <strlen>
   17084:	4606      	mov	r6, r0
   17086:	6a20      	ldr	r0, [r4, #32]
   17088:	300c      	adds	r0, #12
   1708a:	f004 ff79 	bl	1bf80 <strlen>
   1708e:	4286      	cmp	r6, r0
   17090:	f47f aed9 	bne.w	16e46 <pdn_interface_pdn_id_get+0x86>
   17094:	6a21      	ldr	r1, [r4, #32]
   17096:	4628      	mov	r0, r5
   17098:	310c      	adds	r1, #12
   1709a:	f004 ff78 	bl	1bf8e <strcmp>
   1709e:	e6d2      	b.n	16e46 <pdn_interface_pdn_id_get+0x86>
   170a0:	4628      	mov	r0, r5
   170a2:	f004 ff6d 	bl	1bf80 <strlen>
   170a6:	4606      	mov	r6, r0
   170a8:	69e0      	ldr	r0, [r4, #28]
   170aa:	300c      	adds	r0, #12
   170ac:	f004 ff68 	bl	1bf80 <strlen>
   170b0:	4286      	cmp	r6, r0
   170b2:	f47f aec2 	bne.w	16e3a <pdn_interface_pdn_id_get+0x7a>
   170b6:	69e1      	ldr	r1, [r4, #28]
   170b8:	4628      	mov	r0, r5
   170ba:	310c      	adds	r1, #12
   170bc:	f004 ff67 	bl	1bf8e <strcmp>
   170c0:	e6bb      	b.n	16e3a <pdn_interface_pdn_id_get+0x7a>
   170c2:	4628      	mov	r0, r5
   170c4:	f004 ff5c 	bl	1bf80 <strlen>
   170c8:	4606      	mov	r6, r0
   170ca:	69a0      	ldr	r0, [r4, #24]
   170cc:	300c      	adds	r0, #12
   170ce:	f004 ff57 	bl	1bf80 <strlen>
   170d2:	4286      	cmp	r6, r0
   170d4:	f47f aeab 	bne.w	16e2e <pdn_interface_pdn_id_get+0x6e>
   170d8:	69a1      	ldr	r1, [r4, #24]
   170da:	4628      	mov	r0, r5
   170dc:	310c      	adds	r1, #12
   170de:	f004 ff56 	bl	1bf8e <strcmp>
   170e2:	e6a4      	b.n	16e2e <pdn_interface_pdn_id_get+0x6e>
   170e4:	4628      	mov	r0, r5
   170e6:	f004 ff4b 	bl	1bf80 <strlen>
   170ea:	4606      	mov	r6, r0
   170ec:	6960      	ldr	r0, [r4, #20]
   170ee:	300c      	adds	r0, #12
   170f0:	f004 ff46 	bl	1bf80 <strlen>
   170f4:	4286      	cmp	r6, r0
   170f6:	f47f ae94 	bne.w	16e22 <pdn_interface_pdn_id_get+0x62>
   170fa:	6961      	ldr	r1, [r4, #20]
   170fc:	4628      	mov	r0, r5
   170fe:	310c      	adds	r1, #12
   17100:	f004 ff45 	bl	1bf8e <strcmp>
   17104:	e68d      	b.n	16e22 <pdn_interface_pdn_id_get+0x62>
   17106:	4628      	mov	r0, r5
   17108:	f004 ff3a 	bl	1bf80 <strlen>
   1710c:	4607      	mov	r7, r0
   1710e:	68e0      	ldr	r0, [r4, #12]
   17110:	300c      	adds	r0, #12
   17112:	f004 ff35 	bl	1bf80 <strlen>
   17116:	4287      	cmp	r7, r0
   17118:	f47f af09 	bne.w	16f2e <pdn_interface_pdn_id_get+0x16e>
   1711c:	68e1      	ldr	r1, [r4, #12]
   1711e:	4628      	mov	r0, r5
   17120:	310c      	adds	r1, #12
   17122:	f004 ff34 	bl	1bf8e <strcmp>
   17126:	2800      	cmp	r0, #0
   17128:	f47f af01 	bne.w	16f2e <pdn_interface_pdn_id_get+0x16e>
   1712c:	68e3      	ldr	r3, [r4, #12]
   1712e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17130:	07d1      	lsls	r1, r2, #31
   17132:	f57f aefc 	bpl.w	16f2e <pdn_interface_pdn_id_get+0x16e>
   17136:	6858      	ldr	r0, [r3, #4]
   17138:	1c43      	adds	r3, r0, #1
   1713a:	f47f ae8c 	bne.w	16e56 <pdn_interface_pdn_id_get+0x96>
   1713e:	4dc6      	ldr	r5, [pc, #792]	; (17458 <pdn_interface_pdn_id_get+0x698>)
   17140:	4ac6      	ldr	r2, [pc, #792]	; (1745c <pdn_interface_pdn_id_get+0x69c>)
   17142:	f44f 7180 	mov.w	r1, #256	; 0x100
   17146:	4628      	mov	r0, r5
   17148:	f7f7 ff72 	bl	f030 <snprintf>
   1714c:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   17150:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   17154:	681b      	ldr	r3, [r3, #0]
   17156:	4ac2      	ldr	r2, [pc, #776]	; (17460 <pdn_interface_pdn_id_get+0x6a0>)
   17158:	4428      	add	r0, r5
   1715a:	f8df 830c 	ldr.w	r8, [pc, #780]	; 17468 <pdn_interface_pdn_id_get+0x6a8>
   1715e:	f7f7 ff67 	bl	f030 <snprintf>
   17162:	4628      	mov	r0, r5
   17164:	f8d8 9000 	ldr.w	r9, [r8]
   17168:	2700      	movs	r7, #0
   1716a:	f004 ff09 	bl	1bf80 <strlen>
   1716e:	4629      	mov	r1, r5
   17170:	4602      	mov	r2, r0
   17172:	463b      	mov	r3, r7
   17174:	4648      	mov	r0, r9
   17176:	9701      	str	r7, [sp, #4]
   17178:	9700      	str	r7, [sp, #0]
   1717a:	f7fe ff27 	bl	15fcc <at_interface_write>
   1717e:	4681      	mov	r9, r0
   17180:	4628      	mov	r0, r5
   17182:	f004 fefd 	bl	1bf80 <strlen>
   17186:	4548      	cmp	r0, r9
   17188:	f040 81e9 	bne.w	1755e <pdn_interface_pdn_id_get+0x79e>
   1718c:	463b      	mov	r3, r7
   1718e:	f44f 7280 	mov.w	r2, #256	; 0x100
   17192:	e9cd 7700 	strd	r7, r7, [sp]
   17196:	4629      	mov	r1, r5
   17198:	f8d8 0000 	ldr.w	r0, [r8]
   1719c:	f7ff f84c 	bl	16238 <at_interface_read>
   171a0:	4607      	mov	r7, r0
   171a2:	48b0      	ldr	r0, [pc, #704]	; (17464 <pdn_interface_pdn_id_get+0x6a4>)
   171a4:	f004 feec 	bl	1bf80 <strlen>
   171a8:	4287      	cmp	r7, r0
   171aa:	4602      	mov	r2, r0
   171ac:	f2c0 81c7 	blt.w	1753e <pdn_interface_pdn_id_get+0x77e>
   171b0:	4629      	mov	r1, r5
   171b2:	48ac      	ldr	r0, [pc, #688]	; (17464 <pdn_interface_pdn_id_get+0x6a4>)
   171b4:	f004 fef7 	bl	1bfa6 <strncmp>
   171b8:	2800      	cmp	r0, #0
   171ba:	f040 81c0 	bne.w	1753e <pdn_interface_pdn_id_get+0x77e>
   171be:	4629      	mov	r1, r5
   171c0:	4630      	mov	r0, r6
   171c2:	f7ff f91d 	bl	16400 <pdn_id_get_parser>
   171c6:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   171ca:	6858      	ldr	r0, [r3, #4]
   171cc:	e643      	b.n	16e56 <pdn_interface_pdn_id_get+0x96>
   171ce:	4628      	mov	r0, r5
   171d0:	f004 fed6 	bl	1bf80 <strlen>
   171d4:	4606      	mov	r6, r0
   171d6:	6920      	ldr	r0, [r4, #16]
   171d8:	300c      	adds	r0, #12
   171da:	f004 fed1 	bl	1bf80 <strlen>
   171de:	4286      	cmp	r6, r0
   171e0:	f47f aeab 	bne.w	16f3a <pdn_interface_pdn_id_get+0x17a>
   171e4:	6921      	ldr	r1, [r4, #16]
   171e6:	4628      	mov	r0, r5
   171e8:	310c      	adds	r1, #12
   171ea:	f004 fed0 	bl	1bf8e <strcmp>
   171ee:	2800      	cmp	r0, #0
   171f0:	f47f aea3 	bne.w	16f3a <pdn_interface_pdn_id_get+0x17a>
   171f4:	6923      	ldr	r3, [r4, #16]
   171f6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   171f8:	07d2      	lsls	r2, r2, #31
   171fa:	f57f ae9e 	bpl.w	16f3a <pdn_interface_pdn_id_get+0x17a>
   171fe:	2604      	movs	r6, #4
   17200:	e799      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   17202:	4628      	mov	r0, r5
   17204:	f004 febc 	bl	1bf80 <strlen>
   17208:	4606      	mov	r6, r0
   1720a:	6960      	ldr	r0, [r4, #20]
   1720c:	300c      	adds	r0, #12
   1720e:	f004 feb7 	bl	1bf80 <strlen>
   17212:	4286      	cmp	r6, r0
   17214:	f47f ae97 	bne.w	16f46 <pdn_interface_pdn_id_get+0x186>
   17218:	6961      	ldr	r1, [r4, #20]
   1721a:	4628      	mov	r0, r5
   1721c:	310c      	adds	r1, #12
   1721e:	f004 feb6 	bl	1bf8e <strcmp>
   17222:	2800      	cmp	r0, #0
   17224:	f47f ae8f 	bne.w	16f46 <pdn_interface_pdn_id_get+0x186>
   17228:	6963      	ldr	r3, [r4, #20]
   1722a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   1722c:	07d7      	lsls	r7, r2, #31
   1722e:	f57f ae8a 	bpl.w	16f46 <pdn_interface_pdn_id_get+0x186>
   17232:	2605      	movs	r6, #5
   17234:	e77f      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   17236:	4628      	mov	r0, r5
   17238:	f004 fea2 	bl	1bf80 <strlen>
   1723c:	4606      	mov	r6, r0
   1723e:	69a0      	ldr	r0, [r4, #24]
   17240:	300c      	adds	r0, #12
   17242:	f004 fe9d 	bl	1bf80 <strlen>
   17246:	4286      	cmp	r6, r0
   17248:	f47f ae83 	bne.w	16f52 <pdn_interface_pdn_id_get+0x192>
   1724c:	69a1      	ldr	r1, [r4, #24]
   1724e:	4628      	mov	r0, r5
   17250:	310c      	adds	r1, #12
   17252:	f004 fe9c 	bl	1bf8e <strcmp>
   17256:	2800      	cmp	r0, #0
   17258:	f47f ae7b 	bne.w	16f52 <pdn_interface_pdn_id_get+0x192>
   1725c:	69a3      	ldr	r3, [r4, #24]
   1725e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17260:	07d6      	lsls	r6, r2, #31
   17262:	f57f ae76 	bpl.w	16f52 <pdn_interface_pdn_id_get+0x192>
   17266:	2606      	movs	r6, #6
   17268:	e765      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   1726a:	4628      	mov	r0, r5
   1726c:	f004 fe88 	bl	1bf80 <strlen>
   17270:	4607      	mov	r7, r0
   17272:	68e0      	ldr	r0, [r4, #12]
   17274:	300c      	adds	r0, #12
   17276:	f004 fe83 	bl	1bf80 <strlen>
   1727a:	4287      	cmp	r7, r0
   1727c:	f47f ae05 	bne.w	16e8a <pdn_interface_pdn_id_get+0xca>
   17280:	68e1      	ldr	r1, [r4, #12]
   17282:	4628      	mov	r0, r5
   17284:	310c      	adds	r1, #12
   17286:	f004 fe82 	bl	1bf8e <strcmp>
   1728a:	2800      	cmp	r0, #0
   1728c:	f47f adfd 	bne.w	16e8a <pdn_interface_pdn_id_get+0xca>
   17290:	68e3      	ldr	r3, [r4, #12]
   17292:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17294:	0791      	lsls	r1, r2, #30
   17296:	f53f af4e 	bmi.w	17136 <pdn_interface_pdn_id_get+0x376>
   1729a:	e5f6      	b.n	16e8a <pdn_interface_pdn_id_get+0xca>
   1729c:	4628      	mov	r0, r5
   1729e:	f004 fe6f 	bl	1bf80 <strlen>
   172a2:	4606      	mov	r6, r0
   172a4:	6920      	ldr	r0, [r4, #16]
   172a6:	300c      	adds	r0, #12
   172a8:	f004 fe6a 	bl	1bf80 <strlen>
   172ac:	4286      	cmp	r6, r0
   172ae:	f47f adf2 	bne.w	16e96 <pdn_interface_pdn_id_get+0xd6>
   172b2:	6921      	ldr	r1, [r4, #16]
   172b4:	4628      	mov	r0, r5
   172b6:	310c      	adds	r1, #12
   172b8:	f004 fe69 	bl	1bf8e <strcmp>
   172bc:	2800      	cmp	r0, #0
   172be:	f47f adea 	bne.w	16e96 <pdn_interface_pdn_id_get+0xd6>
   172c2:	6923      	ldr	r3, [r4, #16]
   172c4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   172c6:	0792      	lsls	r2, r2, #30
   172c8:	d499      	bmi.n	171fe <pdn_interface_pdn_id_get+0x43e>
   172ca:	e5e4      	b.n	16e96 <pdn_interface_pdn_id_get+0xd6>
   172cc:	4628      	mov	r0, r5
   172ce:	f004 fe57 	bl	1bf80 <strlen>
   172d2:	4606      	mov	r6, r0
   172d4:	6960      	ldr	r0, [r4, #20]
   172d6:	300c      	adds	r0, #12
   172d8:	f004 fe52 	bl	1bf80 <strlen>
   172dc:	4286      	cmp	r6, r0
   172de:	f47f ade0 	bne.w	16ea2 <pdn_interface_pdn_id_get+0xe2>
   172e2:	6961      	ldr	r1, [r4, #20]
   172e4:	4628      	mov	r0, r5
   172e6:	310c      	adds	r1, #12
   172e8:	f004 fe51 	bl	1bf8e <strcmp>
   172ec:	2800      	cmp	r0, #0
   172ee:	f47f add8 	bne.w	16ea2 <pdn_interface_pdn_id_get+0xe2>
   172f2:	6963      	ldr	r3, [r4, #20]
   172f4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   172f6:	0797      	lsls	r7, r2, #30
   172f8:	d49b      	bmi.n	17232 <pdn_interface_pdn_id_get+0x472>
   172fa:	e5d2      	b.n	16ea2 <pdn_interface_pdn_id_get+0xe2>
   172fc:	4628      	mov	r0, r5
   172fe:	f004 fe3f 	bl	1bf80 <strlen>
   17302:	4606      	mov	r6, r0
   17304:	69a0      	ldr	r0, [r4, #24]
   17306:	300c      	adds	r0, #12
   17308:	f004 fe3a 	bl	1bf80 <strlen>
   1730c:	4286      	cmp	r6, r0
   1730e:	f47f adce 	bne.w	16eae <pdn_interface_pdn_id_get+0xee>
   17312:	69a1      	ldr	r1, [r4, #24]
   17314:	4628      	mov	r0, r5
   17316:	310c      	adds	r1, #12
   17318:	f004 fe39 	bl	1bf8e <strcmp>
   1731c:	2800      	cmp	r0, #0
   1731e:	f47f adc6 	bne.w	16eae <pdn_interface_pdn_id_get+0xee>
   17322:	69a3      	ldr	r3, [r4, #24]
   17324:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17326:	0796      	lsls	r6, r2, #30
   17328:	d49d      	bmi.n	17266 <pdn_interface_pdn_id_get+0x4a6>
   1732a:	e5c0      	b.n	16eae <pdn_interface_pdn_id_get+0xee>
   1732c:	4628      	mov	r0, r5
   1732e:	f004 fe27 	bl	1bf80 <strlen>
   17332:	4606      	mov	r6, r0
   17334:	69e0      	ldr	r0, [r4, #28]
   17336:	300c      	adds	r0, #12
   17338:	f004 fe22 	bl	1bf80 <strlen>
   1733c:	4286      	cmp	r6, r0
   1733e:	f47f adbc 	bne.w	16eba <pdn_interface_pdn_id_get+0xfa>
   17342:	69e1      	ldr	r1, [r4, #28]
   17344:	4628      	mov	r0, r5
   17346:	310c      	adds	r1, #12
   17348:	f004 fe21 	bl	1bf8e <strcmp>
   1734c:	2800      	cmp	r0, #0
   1734e:	f47f adb4 	bne.w	16eba <pdn_interface_pdn_id_get+0xfa>
   17352:	69e3      	ldr	r3, [r4, #28]
   17354:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17356:	0790      	lsls	r0, r2, #30
   17358:	f57f adaf 	bpl.w	16eba <pdn_interface_pdn_id_get+0xfa>
   1735c:	2607      	movs	r6, #7
   1735e:	e6ea      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   17360:	4628      	mov	r0, r5
   17362:	f004 fe0d 	bl	1bf80 <strlen>
   17366:	4606      	mov	r6, r0
   17368:	6a20      	ldr	r0, [r4, #32]
   1736a:	300c      	adds	r0, #12
   1736c:	f004 fe08 	bl	1bf80 <strlen>
   17370:	4286      	cmp	r6, r0
   17372:	f47f ada8 	bne.w	16ec6 <pdn_interface_pdn_id_get+0x106>
   17376:	6a21      	ldr	r1, [r4, #32]
   17378:	4628      	mov	r0, r5
   1737a:	310c      	adds	r1, #12
   1737c:	f004 fe07 	bl	1bf8e <strcmp>
   17380:	2800      	cmp	r0, #0
   17382:	f47f ada0 	bne.w	16ec6 <pdn_interface_pdn_id_get+0x106>
   17386:	6a23      	ldr	r3, [r4, #32]
   17388:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   1738a:	0791      	lsls	r1, r2, #30
   1738c:	f57f ad9b 	bpl.w	16ec6 <pdn_interface_pdn_id_get+0x106>
   17390:	2608      	movs	r6, #8
   17392:	e6d0      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   17394:	4628      	mov	r0, r5
   17396:	f004 fdf3 	bl	1bf80 <strlen>
   1739a:	4606      	mov	r6, r0
   1739c:	69e0      	ldr	r0, [r4, #28]
   1739e:	300c      	adds	r0, #12
   173a0:	f004 fdee 	bl	1bf80 <strlen>
   173a4:	4286      	cmp	r6, r0
   173a6:	f47f adda 	bne.w	16f5e <pdn_interface_pdn_id_get+0x19e>
   173aa:	69e1      	ldr	r1, [r4, #28]
   173ac:	4628      	mov	r0, r5
   173ae:	310c      	adds	r1, #12
   173b0:	f004 fded 	bl	1bf8e <strcmp>
   173b4:	2800      	cmp	r0, #0
   173b6:	f47f add2 	bne.w	16f5e <pdn_interface_pdn_id_get+0x19e>
   173ba:	69e3      	ldr	r3, [r4, #28]
   173bc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   173be:	07d0      	lsls	r0, r2, #31
   173c0:	d4cc      	bmi.n	1735c <pdn_interface_pdn_id_get+0x59c>
   173c2:	e5cc      	b.n	16f5e <pdn_interface_pdn_id_get+0x19e>
   173c4:	4628      	mov	r0, r5
   173c6:	f004 fddb 	bl	1bf80 <strlen>
   173ca:	4606      	mov	r6, r0
   173cc:	6a20      	ldr	r0, [r4, #32]
   173ce:	300c      	adds	r0, #12
   173d0:	f004 fdd6 	bl	1bf80 <strlen>
   173d4:	4286      	cmp	r6, r0
   173d6:	f47f adc8 	bne.w	16f6a <pdn_interface_pdn_id_get+0x1aa>
   173da:	6a21      	ldr	r1, [r4, #32]
   173dc:	4628      	mov	r0, r5
   173de:	310c      	adds	r1, #12
   173e0:	f004 fdd5 	bl	1bf8e <strcmp>
   173e4:	2800      	cmp	r0, #0
   173e6:	f47f adc0 	bne.w	16f6a <pdn_interface_pdn_id_get+0x1aa>
   173ea:	6a23      	ldr	r3, [r4, #32]
   173ec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   173ee:	07d1      	lsls	r1, r2, #31
   173f0:	d4ce      	bmi.n	17390 <pdn_interface_pdn_id_get+0x5d0>
   173f2:	e5ba      	b.n	16f6a <pdn_interface_pdn_id_get+0x1aa>
   173f4:	4628      	mov	r0, r5
   173f6:	f004 fdc3 	bl	1bf80 <strlen>
   173fa:	4606      	mov	r6, r0
   173fc:	68a0      	ldr	r0, [r4, #8]
   173fe:	300c      	adds	r0, #12
   17400:	f004 fdbe 	bl	1bf80 <strlen>
   17404:	4286      	cmp	r6, r0
   17406:	f47f ad8c 	bne.w	16f22 <pdn_interface_pdn_id_get+0x162>
   1740a:	68a1      	ldr	r1, [r4, #8]
   1740c:	4628      	mov	r0, r5
   1740e:	310c      	adds	r1, #12
   17410:	f004 fdbd 	bl	1bf8e <strcmp>
   17414:	2800      	cmp	r0, #0
   17416:	f47f ad84 	bne.w	16f22 <pdn_interface_pdn_id_get+0x162>
   1741a:	68a3      	ldr	r3, [r4, #8]
   1741c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   1741e:	07d0      	lsls	r0, r2, #31
   17420:	f57f ad7f 	bpl.w	16f22 <pdn_interface_pdn_id_get+0x162>
   17424:	2602      	movs	r6, #2
   17426:	e686      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   17428:	4628      	mov	r0, r5
   1742a:	f004 fda9 	bl	1bf80 <strlen>
   1742e:	4606      	mov	r6, r0
   17430:	68a0      	ldr	r0, [r4, #8]
   17432:	300c      	adds	r0, #12
   17434:	f004 fda4 	bl	1bf80 <strlen>
   17438:	4286      	cmp	r6, r0
   1743a:	f47f ad20 	bne.w	16e7e <pdn_interface_pdn_id_get+0xbe>
   1743e:	68a1      	ldr	r1, [r4, #8]
   17440:	4628      	mov	r0, r5
   17442:	310c      	adds	r1, #12
   17444:	f004 fda3 	bl	1bf8e <strcmp>
   17448:	2800      	cmp	r0, #0
   1744a:	f47f ad18 	bne.w	16e7e <pdn_interface_pdn_id_get+0xbe>
   1744e:	68a3      	ldr	r3, [r4, #8]
   17450:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17452:	0790      	lsls	r0, r2, #30
   17454:	d4e6      	bmi.n	17424 <pdn_interface_pdn_id_get+0x664>
   17456:	e512      	b.n	16e7e <pdn_interface_pdn_id_get+0xbe>
   17458:	20020850 	.word	0x20020850
   1745c:	0001deb0 	.word	0x0001deb0
   17460:	0001deac 	.word	0x0001deac
   17464:	0001dec0 	.word	0x0001dec0
   17468:	2002084c 	.word	0x2002084c
   1746c:	4628      	mov	r0, r5
   1746e:	f004 fd87 	bl	1bf80 <strlen>
   17472:	4606      	mov	r6, r0
   17474:	6860      	ldr	r0, [r4, #4]
   17476:	300c      	adds	r0, #12
   17478:	f004 fd82 	bl	1bf80 <strlen>
   1747c:	4286      	cmp	r6, r0
   1747e:	f47f acf8 	bne.w	16e72 <pdn_interface_pdn_id_get+0xb2>
   17482:	6861      	ldr	r1, [r4, #4]
   17484:	4628      	mov	r0, r5
   17486:	310c      	adds	r1, #12
   17488:	f004 fd81 	bl	1bf8e <strcmp>
   1748c:	2800      	cmp	r0, #0
   1748e:	f47f acf0 	bne.w	16e72 <pdn_interface_pdn_id_get+0xb2>
   17492:	6863      	ldr	r3, [r4, #4]
   17494:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17496:	0796      	lsls	r6, r2, #30
   17498:	f57f aceb 	bpl.w	16e72 <pdn_interface_pdn_id_get+0xb2>
   1749c:	2601      	movs	r6, #1
   1749e:	e64a      	b.n	17136 <pdn_interface_pdn_id_get+0x376>
   174a0:	4628      	mov	r0, r5
   174a2:	f004 fd6d 	bl	1bf80 <strlen>
   174a6:	4606      	mov	r6, r0
   174a8:	6860      	ldr	r0, [r4, #4]
   174aa:	300c      	adds	r0, #12
   174ac:	f004 fd68 	bl	1bf80 <strlen>
   174b0:	4286      	cmp	r6, r0
   174b2:	f47f ad30 	bne.w	16f16 <pdn_interface_pdn_id_get+0x156>
   174b6:	6861      	ldr	r1, [r4, #4]
   174b8:	4628      	mov	r0, r5
   174ba:	310c      	adds	r1, #12
   174bc:	f004 fd67 	bl	1bf8e <strcmp>
   174c0:	2800      	cmp	r0, #0
   174c2:	f47f ad28 	bne.w	16f16 <pdn_interface_pdn_id_get+0x156>
   174c6:	6863      	ldr	r3, [r4, #4]
   174c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   174ca:	07d6      	lsls	r6, r2, #31
   174cc:	d4e6      	bmi.n	1749c <pdn_interface_pdn_id_get+0x6dc>
   174ce:	e522      	b.n	16f16 <pdn_interface_pdn_id_get+0x156>
   174d0:	4608      	mov	r0, r1
   174d2:	f004 fd55 	bl	1bf80 <strlen>
   174d6:	4606      	mov	r6, r0
   174d8:	6820      	ldr	r0, [r4, #0]
   174da:	300c      	adds	r0, #12
   174dc:	f004 fd50 	bl	1bf80 <strlen>
   174e0:	4286      	cmp	r6, r0
   174e2:	f47f acc0 	bne.w	16e66 <pdn_interface_pdn_id_get+0xa6>
   174e6:	6821      	ldr	r1, [r4, #0]
   174e8:	4628      	mov	r0, r5
   174ea:	310c      	adds	r1, #12
   174ec:	f004 fd4f 	bl	1bf8e <strcmp>
   174f0:	4606      	mov	r6, r0
   174f2:	2800      	cmp	r0, #0
   174f4:	f47f acb7 	bne.w	16e66 <pdn_interface_pdn_id_get+0xa6>
   174f8:	6823      	ldr	r3, [r4, #0]
   174fa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   174fc:	0797      	lsls	r7, r2, #30
   174fe:	f53f ae1a 	bmi.w	17136 <pdn_interface_pdn_id_get+0x376>
   17502:	e4b0      	b.n	16e66 <pdn_interface_pdn_id_get+0xa6>
   17504:	4608      	mov	r0, r1
   17506:	f004 fd3b 	bl	1bf80 <strlen>
   1750a:	4606      	mov	r6, r0
   1750c:	6820      	ldr	r0, [r4, #0]
   1750e:	300c      	adds	r0, #12
   17510:	f004 fd36 	bl	1bf80 <strlen>
   17514:	4286      	cmp	r6, r0
   17516:	f47f acf8 	bne.w	16f0a <pdn_interface_pdn_id_get+0x14a>
   1751a:	6821      	ldr	r1, [r4, #0]
   1751c:	4628      	mov	r0, r5
   1751e:	310c      	adds	r1, #12
   17520:	f004 fd35 	bl	1bf8e <strcmp>
   17524:	4606      	mov	r6, r0
   17526:	2800      	cmp	r0, #0
   17528:	f47f acef 	bne.w	16f0a <pdn_interface_pdn_id_get+0x14a>
   1752c:	6823      	ldr	r3, [r4, #0]
   1752e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   17530:	07d7      	lsls	r7, r2, #31
   17532:	f53f ae00 	bmi.w	17136 <pdn_interface_pdn_id_get+0x376>
   17536:	e4e8      	b.n	16f0a <pdn_interface_pdn_id_get+0x14a>
   17538:	f04f 30ff 	mov.w	r0, #4294967295
   1753c:	4770      	bx	lr
   1753e:	480b      	ldr	r0, [pc, #44]	; (1756c <pdn_interface_pdn_id_get+0x7ac>)
   17540:	f004 fd1e 	bl	1bf80 <strlen>
   17544:	490a      	ldr	r1, [pc, #40]	; (17570 <pdn_interface_pdn_id_get+0x7b0>)
   17546:	4602      	mov	r2, r0
   17548:	4808      	ldr	r0, [pc, #32]	; (1756c <pdn_interface_pdn_id_get+0x7ac>)
   1754a:	f004 fd2c 	bl	1bfa6 <strncmp>
   1754e:	b930      	cbnz	r0, 1755e <pdn_interface_pdn_id_get+0x79e>
   17550:	2008      	movs	r0, #8
   17552:	f7f8 fd6b 	bl	1002c <bsd_os_errno_set>
   17556:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   1755a:	6858      	ldr	r0, [r3, #4]
   1755c:	e47b      	b.n	16e56 <pdn_interface_pdn_id_get+0x96>
   1755e:	2005      	movs	r0, #5
   17560:	f7f8 fd64 	bl	1002c <bsd_os_errno_set>
   17564:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   17568:	6858      	ldr	r0, [r3, #4]
   1756a:	e474      	b.n	16e56 <pdn_interface_pdn_id_get+0x96>
   1756c:	0001df04 	.word	0x0001df04
   17570:	20020850 	.word	0x20020850

00017574 <bsd_platform_error_handler>:
   17574:	b508      	push	{r3, lr}
   17576:	f7f5 fca9 	bl	cecc <bsd_recoverable_error_handler>
   1757a:	bd08      	pop	{r3, pc}

0001757c <bsd_init>:
   1757c:	b160      	cbz	r0, 17598 <bsd_init+0x1c>
   1757e:	b510      	push	{r4, lr}
   17580:	4c07      	ldr	r4, [pc, #28]	; (175a0 <bsd_init+0x24>)
   17582:	7823      	ldrb	r3, [r4, #0]
   17584:	b92b      	cbnz	r3, 17592 <bsd_init+0x16>
   17586:	f000 f81b 	bl	175c0 <bsd_platform_init>
   1758a:	b908      	cbnz	r0, 17590 <bsd_init+0x14>
   1758c:	2301      	movs	r3, #1
   1758e:	7023      	strb	r3, [r4, #0]
   17590:	bd10      	pop	{r4, pc}
   17592:	f04f 30ff 	mov.w	r0, #4294967295
   17596:	bd10      	pop	{r4, pc}
   17598:	f04f 30ff 	mov.w	r0, #4294967295
   1759c:	4770      	bx	lr
   1759e:	bf00      	nop
   175a0:	20023670 	.word	0x20023670

000175a4 <unimplemented_method>:
   175a4:	b40f      	push	{r0, r1, r2, r3}
   175a6:	b508      	push	{r3, lr}
   175a8:	202d      	movs	r0, #45	; 0x2d
   175aa:	f7f8 fd3f 	bl	1002c <bsd_os_errno_set>
   175ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   175b2:	f04f 30ff 	mov.w	r0, #4294967295
   175b6:	b004      	add	sp, #16
   175b8:	4770      	bx	lr
   175ba:	bf00      	nop

000175bc <rpc_transport_ipc_fault_handler>:
   175bc:	f7ff bfda 	b.w	17574 <bsd_platform_error_handler>

000175c0 <bsd_platform_init>:
   175c0:	b5f0      	push	{r4, r5, r6, r7, lr}
   175c2:	f04f 0c00 	mov.w	ip, #0
   175c6:	f247 0660 	movw	r6, #28768	; 0x7060
   175ca:	f24b 0260 	movw	r2, #45152	; 0xb060
   175ce:	6843      	ldr	r3, [r0, #4]
   175d0:	4d3a      	ldr	r5, [pc, #232]	; (176bc <bsd_platform_init+0xfc>)
   175d2:	4607      	mov	r7, r0
   175d4:	602b      	str	r3, [r5, #0]
   175d6:	7801      	ldrb	r1, [r0, #0]
   175d8:	2006      	movs	r0, #6
   175da:	4561      	cmp	r1, ip
   175dc:	bf08      	it	eq
   175de:	4632      	moveq	r2, r6
   175e0:	4413      	add	r3, r2
   175e2:	4c37      	ldr	r4, [pc, #220]	; (176c0 <bsd_platform_init+0x100>)
   175e4:	60ab      	str	r3, [r5, #8]
   175e6:	68b9      	ldr	r1, [r7, #8]
   175e8:	6063      	str	r3, [r4, #4]
   175ea:	4b36      	ldr	r3, [pc, #216]	; (176c4 <bsd_platform_init+0x104>)
   175ec:	b093      	sub	sp, #76	; 0x4c
   175ee:	606a      	str	r2, [r5, #4]
   175f0:	f8a4 c000 	strh.w	ip, [r4]
   175f4:	1a8a      	subs	r2, r1, r2
   175f6:	60ea      	str	r2, [r5, #12]
   175f8:	60a2      	str	r2, [r4, #8]
   175fa:	81a0      	strh	r0, [r4, #12]
   175fc:	6123      	str	r3, [r4, #16]
   175fe:	f001 f883 	bl	18708 <nrf_mem_init>
   17602:	2800      	cmp	r0, #0
   17604:	d156      	bne.n	176b4 <bsd_platform_init+0xf4>
   17606:	4621      	mov	r1, r4
   17608:	a801      	add	r0, sp, #4
   1760a:	f001 f8f1 	bl	187f0 <nrf_mem_register>
   1760e:	2800      	cmp	r0, #0
   17610:	d150      	bne.n	176b4 <bsd_platform_init+0xf4>
   17612:	f7f8 fe87 	bl	10324 <bsd_os_init>
   17616:	f7fd fc8d 	bl	14f34 <rpc_framework_init>
   1761a:	2800      	cmp	r0, #0
   1761c:	d14a      	bne.n	176b4 <bsd_platform_init+0xf4>
   1761e:	783a      	ldrb	r2, [r7, #0]
   17620:	682b      	ldr	r3, [r5, #0]
   17622:	bb32      	cbnz	r2, 17672 <bsd_platform_init+0xb2>
   17624:	4606      	mov	r6, r0
   17626:	2220      	movs	r2, #32
   17628:	2408      	movs	r4, #8
   1762a:	2500      	movs	r5, #0
   1762c:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
   17630:	f44f 4780 	mov.w	r7, #16384	; 0x4000
   17634:	f503 5141 	add.w	r1, r3, #12352	; 0x3040
   17638:	4411      	add	r1, r2
   1763a:	9302      	str	r3, [sp, #8]
   1763c:	e9cd 6008 	strd	r6, r0, [sp, #32]
   17640:	910c      	str	r1, [sp, #48]	; 0x30
   17642:	9203      	str	r2, [sp, #12]
   17644:	f103 0140 	add.w	r1, r3, #64	; 0x40
   17648:	9205      	str	r2, [sp, #20]
   1764a:	9207      	str	r2, [sp, #28]
   1764c:	eb0d 0004 	add.w	r0, sp, r4
   17650:	189a      	adds	r2, r3, r2
   17652:	3360      	adds	r3, #96	; 0x60
   17654:	e9cd 5510 	strd	r5, r5, [sp, #64]	; 0x40
   17658:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   1765c:	e9cd 740d 	strd	r7, r4, [sp, #52]	; 0x34
   17660:	940f      	str	r4, [sp, #60]	; 0x3c
   17662:	9104      	str	r1, [sp, #16]
   17664:	9206      	str	r2, [sp, #24]
   17666:	930a      	str	r3, [sp, #40]	; 0x28
   17668:	f7fa fe0c 	bl	12284 <rpc_transport_ipc_init>
   1766c:	b128      	cbz	r0, 1767a <bsd_platform_init+0xba>
   1766e:	b013      	add	sp, #76	; 0x4c
   17670:	bdf0      	pop	{r4, r5, r6, r7, pc}
   17672:	441e      	add	r6, r3
   17674:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   17678:	e7d5      	b.n	17626 <bsd_platform_init+0x66>
   1767a:	f001 fcf9 	bl	19070 <interface_init>
   1767e:	b9c8      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   17680:	f7fe fd1c 	bl	160bc <at_interface_init>
   17684:	b9b0      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   17686:	f7fc f89b 	bl	137c0 <ip_interface_init>
   1768a:	b998      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   1768c:	f7fb fbce 	bl	12e2c <tls_interface_init>
   17690:	b980      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   17692:	f001 fa09 	bl	18aa8 <mfu_interface_init>
   17696:	b968      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   17698:	f7fe ff0a 	bl	164b0 <pdn_interface_init>
   1769c:	b950      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   1769e:	f7fe fb77 	bl	15d90 <gnss_interface_init>
   176a2:	b938      	cbnz	r0, 176b4 <bsd_platform_init+0xf4>
   176a4:	f7fa f82c 	bl	11700 <logobj_interface_init>
   176a8:	1b40      	subs	r0, r0, r5
   176aa:	bf18      	it	ne
   176ac:	2001      	movne	r0, #1
   176ae:	4240      	negs	r0, r0
   176b0:	b013      	add	sp, #76	; 0x4c
   176b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   176b4:	f04f 30ff 	mov.w	r0, #4294967295
   176b8:	b013      	add	sp, #76	; 0x4c
   176ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
   176bc:	2002098c 	.word	0x2002098c
   176c0:	20020978 	.word	0x20020978
   176c4:	0001e058 	.word	0x0001e058

000176c8 <bsd_platform_af_method_table_get>:
   176c8:	2805      	cmp	r0, #5
   176ca:	d02a      	beq.n	17722 <bsd_platform_af_method_table_get+0x5a>
   176cc:	b508      	push	{r3, lr}
   176ce:	d914      	bls.n	176fa <bsd_platform_af_method_table_get+0x32>
   176d0:	280a      	cmp	r0, #10
   176d2:	d016      	beq.n	17702 <bsd_platform_af_method_table_get+0x3a>
   176d4:	2866      	cmp	r0, #102	; 0x66
   176d6:	d11f      	bne.n	17718 <bsd_platform_af_method_table_get+0x50>
   176d8:	f240 2302 	movw	r3, #514	; 0x202
   176dc:	429a      	cmp	r2, r3
   176de:	d035      	beq.n	1774c <bsd_platform_af_method_table_get+0x84>
   176e0:	f240 2305 	movw	r3, #517	; 0x205
   176e4:	429a      	cmp	r2, r3
   176e6:	d035      	beq.n	17754 <bsd_platform_af_method_table_get+0x8c>
   176e8:	f240 2301 	movw	r3, #513	; 0x201
   176ec:	429a      	cmp	r2, r3
   176ee:	d02f      	beq.n	17750 <bsd_platform_af_method_table_get+0x88>
   176f0:	202b      	movs	r0, #43	; 0x2b
   176f2:	f7f8 fc9b 	bl	1002c <bsd_os_errno_set>
   176f6:	2000      	movs	r0, #0
   176f8:	bd08      	pop	{r3, pc}
   176fa:	2801      	cmp	r0, #1
   176fc:	d016      	beq.n	1772c <bsd_platform_af_method_table_get+0x64>
   176fe:	2802      	cmp	r0, #2
   17700:	d10a      	bne.n	17718 <bsd_platform_af_method_table_get+0x50>
   17702:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   17706:	d21a      	bcs.n	1773e <bsd_platform_af_method_table_get+0x76>
   17708:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   1770c:	d21a      	bcs.n	17744 <bsd_platform_af_method_table_get+0x7c>
   1770e:	3a01      	subs	r2, #1
   17710:	2a01      	cmp	r2, #1
   17712:	d8ed      	bhi.n	176f0 <bsd_platform_af_method_table_get+0x28>
   17714:	4810      	ldr	r0, [pc, #64]	; (17758 <bsd_platform_af_method_table_get+0x90>)
   17716:	bd08      	pop	{r3, pc}
   17718:	2016      	movs	r0, #22
   1771a:	f7f8 fc87 	bl	1002c <bsd_os_errno_set>
   1771e:	2000      	movs	r0, #0
   17720:	bd08      	pop	{r3, pc}
   17722:	2903      	cmp	r1, #3
   17724:	480d      	ldr	r0, [pc, #52]	; (1775c <bsd_platform_af_method_table_get+0x94>)
   17726:	bf18      	it	ne
   17728:	2000      	movne	r0, #0
   1772a:	4770      	bx	lr
   1772c:	f240 2303 	movw	r3, #515	; 0x203
   17730:	429a      	cmp	r2, r3
   17732:	d009      	beq.n	17748 <bsd_platform_af_method_table_get+0x80>
   17734:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   17738:	d1da      	bne.n	176f0 <bsd_platform_af_method_table_get+0x28>
   1773a:	4809      	ldr	r0, [pc, #36]	; (17760 <bsd_platform_af_method_table_get+0x98>)
   1773c:	bd08      	pop	{r3, pc}
   1773e:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   17742:	d1d5      	bne.n	176f0 <bsd_platform_af_method_table_get+0x28>
   17744:	4807      	ldr	r0, [pc, #28]	; (17764 <bsd_platform_af_method_table_get+0x9c>)
   17746:	bd08      	pop	{r3, pc}
   17748:	4807      	ldr	r0, [pc, #28]	; (17768 <bsd_platform_af_method_table_get+0xa0>)
   1774a:	bd08      	pop	{r3, pc}
   1774c:	4807      	ldr	r0, [pc, #28]	; (1776c <bsd_platform_af_method_table_get+0xa4>)
   1774e:	bd08      	pop	{r3, pc}
   17750:	4807      	ldr	r0, [pc, #28]	; (17770 <bsd_platform_af_method_table_get+0xa8>)
   17752:	bd08      	pop	{r3, pc}
   17754:	4807      	ldr	r0, [pc, #28]	; (17774 <bsd_platform_af_method_table_get+0xac>)
   17756:	bd08      	pop	{r3, pc}
   17758:	0001df40 	.word	0x0001df40
   1775c:	0001e030 	.word	0x0001e030
   17760:	0001dfe0 	.word	0x0001dfe0
   17764:	0001df68 	.word	0x0001df68
   17768:	0001df90 	.word	0x0001df90
   1776c:	0001dfb8 	.word	0x0001dfb8
   17770:	0001df18 	.word	0x0001df18
   17774:	0001e008 	.word	0x0001e008

00017778 <bsd_platform_fd_method_table_get>:
   17778:	b538      	push	{r3, r4, r5, lr}
   1777a:	4605      	mov	r5, r0
   1777c:	f001 fdb6 	bl	192ec <interface_socket_from_handle_get>
   17780:	4604      	mov	r4, r0
   17782:	b960      	cbnz	r0, 1779e <bsd_platform_fd_method_table_get+0x26>
   17784:	4b2c      	ldr	r3, [pc, #176]	; (17838 <bsd_platform_fd_method_table_get+0xc0>)
   17786:	429d      	cmp	r5, r3
   17788:	d02f      	beq.n	177ea <bsd_platform_fd_method_table_get+0x72>
   1778a:	0c2b      	lsrs	r3, r5, #16
   1778c:	4a2b      	ldr	r2, [pc, #172]	; (1783c <bsd_platform_fd_method_table_get+0xc4>)
   1778e:	041b      	lsls	r3, r3, #16
   17790:	4293      	cmp	r3, r2
   17792:	d03d      	beq.n	17810 <bsd_platform_fd_method_table_get+0x98>
   17794:	4b2a      	ldr	r3, [pc, #168]	; (17840 <bsd_platform_fd_method_table_get+0xc8>)
   17796:	429d      	cmp	r5, r3
   17798:	d149      	bne.n	1782e <bsd_platform_fd_method_table_get+0xb6>
   1779a:	482a      	ldr	r0, [pc, #168]	; (17844 <bsd_platform_fd_method_table_get+0xcc>)
   1779c:	bd38      	pop	{r3, r4, r5, pc}
   1779e:	68c3      	ldr	r3, [r0, #12]
   177a0:	6942      	ldr	r2, [r0, #20]
   177a2:	2b05      	cmp	r3, #5
   177a4:	d036      	beq.n	17814 <bsd_platform_fd_method_table_get+0x9c>
   177a6:	d911      	bls.n	177cc <bsd_platform_fd_method_table_get+0x54>
   177a8:	2b0a      	cmp	r3, #10
   177aa:	d013      	beq.n	177d4 <bsd_platform_fd_method_table_get+0x5c>
   177ac:	2b66      	cmp	r3, #102	; 0x66
   177ae:	d11e      	bne.n	177ee <bsd_platform_fd_method_table_get+0x76>
   177b0:	f240 2302 	movw	r3, #514	; 0x202
   177b4:	429a      	cmp	r2, r3
   177b6:	d02b      	beq.n	17810 <bsd_platform_fd_method_table_get+0x98>
   177b8:	f240 2305 	movw	r3, #517	; 0x205
   177bc:	429a      	cmp	r2, r3
   177be:	d02f      	beq.n	17820 <bsd_platform_fd_method_table_get+0xa8>
   177c0:	f240 2301 	movw	r3, #513	; 0x201
   177c4:	429a      	cmp	r2, r3
   177c6:	d11e      	bne.n	17806 <bsd_platform_fd_method_table_get+0x8e>
   177c8:	481f      	ldr	r0, [pc, #124]	; (17848 <bsd_platform_fd_method_table_get+0xd0>)
   177ca:	bd38      	pop	{r3, r4, r5, pc}
   177cc:	2b01      	cmp	r3, #1
   177ce:	d013      	beq.n	177f8 <bsd_platform_fd_method_table_get+0x80>
   177d0:	2b02      	cmp	r3, #2
   177d2:	d10c      	bne.n	177ee <bsd_platform_fd_method_table_get+0x76>
   177d4:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   177d8:	d224      	bcs.n	17824 <bsd_platform_fd_method_table_get+0xac>
   177da:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   177de:	d224      	bcs.n	1782a <bsd_platform_fd_method_table_get+0xb2>
   177e0:	3a01      	subs	r2, #1
   177e2:	2a01      	cmp	r2, #1
   177e4:	d80f      	bhi.n	17806 <bsd_platform_fd_method_table_get+0x8e>
   177e6:	4819      	ldr	r0, [pc, #100]	; (1784c <bsd_platform_fd_method_table_get+0xd4>)
   177e8:	bd38      	pop	{r3, r4, r5, pc}
   177ea:	4819      	ldr	r0, [pc, #100]	; (17850 <bsd_platform_fd_method_table_get+0xd8>)
   177ec:	bd38      	pop	{r3, r4, r5, pc}
   177ee:	2016      	movs	r0, #22
   177f0:	f7f8 fc1c 	bl	1002c <bsd_os_errno_set>
   177f4:	2000      	movs	r0, #0
   177f6:	bd38      	pop	{r3, r4, r5, pc}
   177f8:	f240 2303 	movw	r3, #515	; 0x203
   177fc:	429a      	cmp	r2, r3
   177fe:	d0f4      	beq.n	177ea <bsd_platform_fd_method_table_get+0x72>
   17800:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   17804:	d0c9      	beq.n	1779a <bsd_platform_fd_method_table_get+0x22>
   17806:	202b      	movs	r0, #43	; 0x2b
   17808:	f7f8 fc10 	bl	1002c <bsd_os_errno_set>
   1780c:	2000      	movs	r0, #0
   1780e:	bd38      	pop	{r3, r4, r5, pc}
   17810:	4810      	ldr	r0, [pc, #64]	; (17854 <bsd_platform_fd_method_table_get+0xdc>)
   17812:	bd38      	pop	{r3, r4, r5, pc}
   17814:	6903      	ldr	r3, [r0, #16]
   17816:	4810      	ldr	r0, [pc, #64]	; (17858 <bsd_platform_fd_method_table_get+0xe0>)
   17818:	2b03      	cmp	r3, #3
   1781a:	bf18      	it	ne
   1781c:	2000      	movne	r0, #0
   1781e:	bd38      	pop	{r3, r4, r5, pc}
   17820:	480e      	ldr	r0, [pc, #56]	; (1785c <bsd_platform_fd_method_table_get+0xe4>)
   17822:	bd38      	pop	{r3, r4, r5, pc}
   17824:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   17828:	d1ed      	bne.n	17806 <bsd_platform_fd_method_table_get+0x8e>
   1782a:	480d      	ldr	r0, [pc, #52]	; (17860 <bsd_platform_fd_method_table_get+0xe8>)
   1782c:	bd38      	pop	{r3, r4, r5, pc}
   1782e:	2009      	movs	r0, #9
   17830:	f7f8 fbfc 	bl	1002c <bsd_os_errno_set>
   17834:	4620      	mov	r0, r4
   17836:	bd38      	pop	{r3, r4, r5, pc}
   17838:	49765432 	.word	0x49765432
   1783c:	789a0000 	.word	0x789a0000
   17840:	49765443 	.word	0x49765443
   17844:	0001dfe0 	.word	0x0001dfe0
   17848:	0001df18 	.word	0x0001df18
   1784c:	0001df40 	.word	0x0001df40
   17850:	0001df90 	.word	0x0001df90
   17854:	0001dfb8 	.word	0x0001dfb8
   17858:	0001e030 	.word	0x0001e030
   1785c:	0001e008 	.word	0x0001e008
   17860:	0001df68 	.word	0x0001df68

00017864 <bsd_platform_getaddrinfo>:
   17864:	f7fc bf6c 	b.w	14740 <ip_interface_getaddrinfo>

00017868 <bsd_platform_freeaddrinfo>:
   17868:	f7fd b860 	b.w	1492c <ip_interface_freeaddrinfo>

0001786c <bsd_platform_poll>:
   1786c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   17870:	ea42 72e2 	orr.w	r2, r2, r2, asr #31
   17874:	b083      	sub	sp, #12
   17876:	9200      	str	r2, [sp, #0]
   17878:	2800      	cmp	r0, #0
   1787a:	d048      	beq.n	1790e <bsd_platform_poll+0xa2>
   1787c:	1e4b      	subs	r3, r1, #1
   1787e:	2b08      	cmp	r3, #8
   17880:	d845      	bhi.n	1790e <bsd_platform_poll+0xa2>
   17882:	4680      	mov	r8, r0
   17884:	4605      	mov	r5, r0
   17886:	2400      	movs	r4, #0
   17888:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
   1788c:	88ab      	ldrh	r3, [r5, #4]
   1788e:	6828      	ldr	r0, [r5, #0]
   17890:	f003 0303 	and.w	r3, r3, #3
   17894:	a901      	add	r1, sp, #4
   17896:	f043 061c 	orr.w	r6, r3, #28
   1789a:	f001 fd35 	bl	19308 <interface_socket_event_get>
   1789e:	9b01      	ldr	r3, [sp, #4]
   178a0:	3508      	adds	r5, #8
   178a2:	4033      	ands	r3, r6
   178a4:	f825 3c02 	strh.w	r3, [r5, #-2]
   178a8:	b103      	cbz	r3, 178ac <bsd_platform_poll+0x40>
   178aa:	3401      	adds	r4, #1
   178ac:	42af      	cmp	r7, r5
   178ae:	d1ed      	bne.n	1788c <bsd_platform_poll+0x20>
   178b0:	bb9c      	cbnz	r4, 1791a <bsd_platform_poll+0xae>
   178b2:	4669      	mov	r1, sp
   178b4:	4640      	mov	r0, r8
   178b6:	f7f8 fb03 	bl	fec0 <bsd_os_timedwait>
   178ba:	4607      	mov	r7, r0
   178bc:	b108      	cbz	r0, 178c2 <bsd_platform_poll+0x56>
   178be:	283c      	cmp	r0, #60	; 0x3c
   178c0:	d11d      	bne.n	178fe <bsd_platform_poll+0x92>
   178c2:	46c1      	mov	r9, r8
   178c4:	2600      	movs	r6, #0
   178c6:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   178ca:	f8d9 0000 	ldr.w	r0, [r9]
   178ce:	f003 0303 	and.w	r3, r3, #3
   178d2:	a901      	add	r1, sp, #4
   178d4:	f043 041c 	orr.w	r4, r3, #28
   178d8:	f001 fd16 	bl	19308 <interface_socket_event_get>
   178dc:	9b01      	ldr	r3, [sp, #4]
   178de:	f109 0908 	add.w	r9, r9, #8
   178e2:	4023      	ands	r3, r4
   178e4:	f829 3c02 	strh.w	r3, [r9, #-2]
   178e8:	b103      	cbz	r3, 178ec <bsd_platform_poll+0x80>
   178ea:	3601      	adds	r6, #1
   178ec:	454d      	cmp	r5, r9
   178ee:	d1ea      	bne.n	178c6 <bsd_platform_poll+0x5a>
   178f0:	b90e      	cbnz	r6, 178f6 <bsd_platform_poll+0x8a>
   178f2:	2f00      	cmp	r7, #0
   178f4:	d0dd      	beq.n	178b2 <bsd_platform_poll+0x46>
   178f6:	4630      	mov	r0, r6
   178f8:	b003      	add	sp, #12
   178fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   178fe:	2023      	movs	r0, #35	; 0x23
   17900:	f7f8 fb94 	bl	1002c <bsd_os_errno_set>
   17904:	f04f 30ff 	mov.w	r0, #4294967295
   17908:	b003      	add	sp, #12
   1790a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1790e:	2016      	movs	r0, #22
   17910:	f7f8 fb8c 	bl	1002c <bsd_os_errno_set>
   17914:	f04f 30ff 	mov.w	r0, #4294967295
   17918:	e7ee      	b.n	178f8 <bsd_platform_poll+0x8c>
   1791a:	4620      	mov	r0, r4
   1791c:	e7ec      	b.n	178f8 <bsd_platform_poll+0x8c>
   1791e:	bf00      	nop

00017920 <bsd_platform_fcntl>:
   17920:	b508      	push	{r3, lr}
   17922:	4b06      	ldr	r3, [pc, #24]	; (1793c <bsd_platform_fcntl+0x1c>)
   17924:	4298      	cmp	r0, r3
   17926:	d003      	beq.n	17930 <bsd_platform_fcntl+0x10>
   17928:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   1792c:	f001 bd96 	b.w	1945c <interface_socket_fcntl>
   17930:	202d      	movs	r0, #45	; 0x2d
   17932:	f7f8 fb7b 	bl	1002c <bsd_os_errno_set>
   17936:	f04f 30ff 	mov.w	r0, #4294967295
   1793a:	bd08      	pop	{r3, pc}
   1793c:	49765432 	.word	0x49765432

00017940 <linked_list_init>:
   17940:	b128      	cbz	r0, 1794e <linked_list_init+0xe>
   17942:	2300      	movs	r3, #0
   17944:	6003      	str	r3, [r0, #0]
   17946:	e9c0 3301 	strd	r3, r3, [r0, #4]
   1794a:	4618      	mov	r0, r3
   1794c:	4770      	bx	lr
   1794e:	2007      	movs	r0, #7
   17950:	4770      	bx	lr
   17952:	bf00      	nop

00017954 <linked_list_push>:
   17954:	6802      	ldr	r2, [r0, #0]
   17956:	4603      	mov	r3, r0
   17958:	3201      	adds	r2, #1
   1795a:	d00e      	beq.n	1797a <linked_list_push+0x26>
   1795c:	2200      	movs	r2, #0
   1795e:	600a      	str	r2, [r1, #0]
   17960:	6802      	ldr	r2, [r0, #0]
   17962:	b13a      	cbz	r2, 17974 <linked_list_push+0x20>
   17964:	6882      	ldr	r2, [r0, #8]
   17966:	6011      	str	r1, [r2, #0]
   17968:	6081      	str	r1, [r0, #8]
   1796a:	681a      	ldr	r2, [r3, #0]
   1796c:	2000      	movs	r0, #0
   1796e:	3201      	adds	r2, #1
   17970:	601a      	str	r2, [r3, #0]
   17972:	4770      	bx	lr
   17974:	e9c0 1101 	strd	r1, r1, [r0, #4]
   17978:	e7f7      	b.n	1796a <linked_list_push+0x16>
   1797a:	2004      	movs	r0, #4
   1797c:	4770      	bx	lr
   1797e:	bf00      	nop

00017980 <linked_list_pop>:
   17980:	4603      	mov	r3, r0
   17982:	6800      	ldr	r0, [r0, #0]
   17984:	b128      	cbz	r0, 17992 <linked_list_pop+0x12>
   17986:	6858      	ldr	r0, [r3, #4]
   17988:	681a      	ldr	r2, [r3, #0]
   1798a:	6801      	ldr	r1, [r0, #0]
   1798c:	3a01      	subs	r2, #1
   1798e:	6059      	str	r1, [r3, #4]
   17990:	601a      	str	r2, [r3, #0]
   17992:	4770      	bx	lr

00017994 <linked_list_peek>:
   17994:	6803      	ldr	r3, [r0, #0]
   17996:	b10b      	cbz	r3, 1799c <linked_list_peek+0x8>
   17998:	6840      	ldr	r0, [r0, #4]
   1799a:	4770      	bx	lr
   1799c:	4618      	mov	r0, r3
   1799e:	4770      	bx	lr

000179a0 <linked_list_size_get>:
   179a0:	6800      	ldr	r0, [r0, #0]
   179a2:	4770      	bx	lr

000179a4 <linked_list_get_next>:
   179a4:	6800      	ldr	r0, [r0, #0]
   179a6:	4770      	bx	lr

000179a8 <nrf_socket>:
   179a8:	b570      	push	{r4, r5, r6, lr}
   179aa:	4604      	mov	r4, r0
   179ac:	460d      	mov	r5, r1
   179ae:	4616      	mov	r6, r2
   179b0:	f7ff fe8a 	bl	176c8 <bsd_platform_af_method_table_get>
   179b4:	b130      	cbz	r0, 179c4 <nrf_socket+0x1c>
   179b6:	6803      	ldr	r3, [r0, #0]
   179b8:	4632      	mov	r2, r6
   179ba:	4629      	mov	r1, r5
   179bc:	4620      	mov	r0, r4
   179be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   179c2:	4718      	bx	r3
   179c4:	f04f 30ff 	mov.w	r0, #4294967295
   179c8:	bd70      	pop	{r4, r5, r6, pc}
   179ca:	bf00      	nop

000179cc <nrf_close>:
   179cc:	b510      	push	{r4, lr}
   179ce:	4604      	mov	r4, r0
   179d0:	f7ff fed2 	bl	17778 <bsd_platform_fd_method_table_get>
   179d4:	b120      	cbz	r0, 179e0 <nrf_close+0x14>
   179d6:	6843      	ldr	r3, [r0, #4]
   179d8:	4620      	mov	r0, r4
   179da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   179de:	4718      	bx	r3
   179e0:	f04f 30ff 	mov.w	r0, #4294967295
   179e4:	bd10      	pop	{r4, pc}
   179e6:	bf00      	nop

000179e8 <nrf_sendto>:
   179e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   179ec:	460d      	mov	r5, r1
   179ee:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   179f2:	4616      	mov	r6, r2
   179f4:	461f      	mov	r7, r3
   179f6:	4604      	mov	r4, r0
   179f8:	f7ff febe 	bl	17778 <bsd_platform_fd_method_table_get>
   179fc:	b158      	cbz	r0, 17a16 <nrf_sendto+0x2e>
   179fe:	e9cd 8908 	strd	r8, r9, [sp, #32]
   17a02:	f8d0 e008 	ldr.w	lr, [r0, #8]
   17a06:	463b      	mov	r3, r7
   17a08:	4632      	mov	r2, r6
   17a0a:	4629      	mov	r1, r5
   17a0c:	4620      	mov	r0, r4
   17a0e:	46f4      	mov	ip, lr
   17a10:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17a14:	4760      	bx	ip
   17a16:	f04f 30ff 	mov.w	r0, #4294967295
   17a1a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   17a1e:	bf00      	nop

00017a20 <nrf_recvfrom>:
   17a20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17a24:	460d      	mov	r5, r1
   17a26:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   17a2a:	4616      	mov	r6, r2
   17a2c:	461f      	mov	r7, r3
   17a2e:	4604      	mov	r4, r0
   17a30:	f7ff fea2 	bl	17778 <bsd_platform_fd_method_table_get>
   17a34:	b158      	cbz	r0, 17a4e <nrf_recvfrom+0x2e>
   17a36:	e9cd 8908 	strd	r8, r9, [sp, #32]
   17a3a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   17a3e:	463b      	mov	r3, r7
   17a40:	4632      	mov	r2, r6
   17a42:	4629      	mov	r1, r5
   17a44:	4620      	mov	r0, r4
   17a46:	46f4      	mov	ip, lr
   17a48:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   17a4c:	4760      	bx	ip
   17a4e:	f04f 30ff 	mov.w	r0, #4294967295
   17a52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   17a56:	bf00      	nop

00017a58 <nrf_connect>:
   17a58:	b570      	push	{r4, r5, r6, lr}
   17a5a:	460d      	mov	r5, r1
   17a5c:	4616      	mov	r6, r2
   17a5e:	4604      	mov	r4, r0
   17a60:	f7ff fe8a 	bl	17778 <bsd_platform_fd_method_table_get>
   17a64:	b130      	cbz	r0, 17a74 <nrf_connect+0x1c>
   17a66:	6943      	ldr	r3, [r0, #20]
   17a68:	4632      	mov	r2, r6
   17a6a:	4629      	mov	r1, r5
   17a6c:	4620      	mov	r0, r4
   17a6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   17a72:	4718      	bx	r3
   17a74:	f04f 30ff 	mov.w	r0, #4294967295
   17a78:	bd70      	pop	{r4, r5, r6, pc}
   17a7a:	bf00      	nop

00017a7c <nrf_listen>:
   17a7c:	b570      	push	{r4, r5, r6, lr}
   17a7e:	460d      	mov	r5, r1
   17a80:	4604      	mov	r4, r0
   17a82:	f7ff fe79 	bl	17778 <bsd_platform_fd_method_table_get>
   17a86:	b128      	cbz	r0, 17a94 <nrf_listen+0x18>
   17a88:	6983      	ldr	r3, [r0, #24]
   17a8a:	4629      	mov	r1, r5
   17a8c:	4620      	mov	r0, r4
   17a8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   17a92:	4718      	bx	r3
   17a94:	f04f 30ff 	mov.w	r0, #4294967295
   17a98:	bd70      	pop	{r4, r5, r6, pc}
   17a9a:	bf00      	nop

00017a9c <nrf_accept>:
   17a9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17aa0:	460d      	mov	r5, r1
   17aa2:	4616      	mov	r6, r2
   17aa4:	4604      	mov	r4, r0
   17aa6:	f7ff fe67 	bl	17778 <bsd_platform_fd_method_table_get>
   17aaa:	b140      	cbz	r0, 17abe <nrf_accept+0x22>
   17aac:	69c7      	ldr	r7, [r0, #28]
   17aae:	4632      	mov	r2, r6
   17ab0:	4629      	mov	r1, r5
   17ab2:	4620      	mov	r0, r4
   17ab4:	46bc      	mov	ip, r7
   17ab6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   17aba:	2300      	movs	r3, #0
   17abc:	4760      	bx	ip
   17abe:	f04f 30ff 	mov.w	r0, #4294967295
   17ac2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17ac6:	bf00      	nop

00017ac8 <nrf_bind>:
   17ac8:	b570      	push	{r4, r5, r6, lr}
   17aca:	460d      	mov	r5, r1
   17acc:	4616      	mov	r6, r2
   17ace:	4604      	mov	r4, r0
   17ad0:	f7ff fe52 	bl	17778 <bsd_platform_fd_method_table_get>
   17ad4:	b130      	cbz	r0, 17ae4 <nrf_bind+0x1c>
   17ad6:	6903      	ldr	r3, [r0, #16]
   17ad8:	4632      	mov	r2, r6
   17ada:	4629      	mov	r1, r5
   17adc:	4620      	mov	r0, r4
   17ade:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   17ae2:	4718      	bx	r3
   17ae4:	f04f 30ff 	mov.w	r0, #4294967295
   17ae8:	bd70      	pop	{r4, r5, r6, pc}
   17aea:	bf00      	nop

00017aec <nrf_setsockopt>:
   17aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17af0:	f8dd 8018 	ldr.w	r8, [sp, #24]
   17af4:	460d      	mov	r5, r1
   17af6:	4616      	mov	r6, r2
   17af8:	461f      	mov	r7, r3
   17afa:	4604      	mov	r4, r0
   17afc:	f7ff fe3c 	bl	17778 <bsd_platform_fd_method_table_get>
   17b00:	b158      	cbz	r0, 17b1a <nrf_setsockopt+0x2e>
   17b02:	f8cd 8018 	str.w	r8, [sp, #24]
   17b06:	f8d0 e020 	ldr.w	lr, [r0, #32]
   17b0a:	463b      	mov	r3, r7
   17b0c:	4632      	mov	r2, r6
   17b0e:	4629      	mov	r1, r5
   17b10:	4620      	mov	r0, r4
   17b12:	46f4      	mov	ip, lr
   17b14:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   17b18:	4760      	bx	ip
   17b1a:	f04f 30ff 	mov.w	r0, #4294967295
   17b1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17b22:	bf00      	nop

00017b24 <nrf_getsockopt>:
   17b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17b28:	f8dd 8018 	ldr.w	r8, [sp, #24]
   17b2c:	460d      	mov	r5, r1
   17b2e:	4616      	mov	r6, r2
   17b30:	461f      	mov	r7, r3
   17b32:	4604      	mov	r4, r0
   17b34:	f7ff fe20 	bl	17778 <bsd_platform_fd_method_table_get>
   17b38:	b158      	cbz	r0, 17b52 <nrf_getsockopt+0x2e>
   17b3a:	f8cd 8018 	str.w	r8, [sp, #24]
   17b3e:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
   17b42:	463b      	mov	r3, r7
   17b44:	4632      	mov	r2, r6
   17b46:	4629      	mov	r1, r5
   17b48:	4620      	mov	r0, r4
   17b4a:	46f4      	mov	ip, lr
   17b4c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   17b50:	4760      	bx	ip
   17b52:	f04f 30ff 	mov.w	r0, #4294967295
   17b56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17b5a:	bf00      	nop

00017b5c <nrf_getaddrinfo>:
   17b5c:	f7ff be82 	b.w	17864 <bsd_platform_getaddrinfo>

00017b60 <nrf_freeaddrinfo>:
   17b60:	f7ff be82 	b.w	17868 <bsd_platform_freeaddrinfo>

00017b64 <nrf_poll>:
   17b64:	f7ff be82 	b.w	1786c <bsd_platform_poll>

00017b68 <nrf_fcntl>:
   17b68:	f7ff beda 	b.w	17920 <bsd_platform_fcntl>

00017b6c <rpc_gnss_serialize_utc>:
   17b6c:	4603      	mov	r3, r0
   17b6e:	b1d8      	cbz	r0, 17ba8 <rpc_gnss_serialize_utc+0x3c>
   17b70:	b1d1      	cbz	r1, 17ba8 <rpc_gnss_serialize_utc+0x3c>
   17b72:	2000      	movs	r0, #0
   17b74:	2201      	movs	r2, #1
   17b76:	7048      	strb	r0, [r1, #1]
   17b78:	700a      	strb	r2, [r1, #0]
   17b7a:	685a      	ldr	r2, [r3, #4]
   17b7c:	2010      	movs	r0, #16
   17b7e:	f8c1 2006 	str.w	r2, [r1, #6]
   17b82:	681a      	ldr	r2, [r3, #0]
   17b84:	f8c1 2002 	str.w	r2, [r1, #2]
   17b88:	f993 200a 	ldrsb.w	r2, [r3, #10]
   17b8c:	730a      	strb	r2, [r1, #12]
   17b8e:	f993 200d 	ldrsb.w	r2, [r3, #13]
   17b92:	73ca      	strb	r2, [r1, #15]
   17b94:	f993 200c 	ldrsb.w	r2, [r3, #12]
   17b98:	738a      	strb	r2, [r1, #14]
   17b9a:	7a1a      	ldrb	r2, [r3, #8]
   17b9c:	728a      	strb	r2, [r1, #10]
   17b9e:	7ada      	ldrb	r2, [r3, #11]
   17ba0:	734a      	strb	r2, [r1, #13]
   17ba2:	7a5b      	ldrb	r3, [r3, #9]
   17ba4:	72cb      	strb	r3, [r1, #11]
   17ba6:	4770      	bx	lr
   17ba8:	f04f 30ff 	mov.w	r0, #4294967295
   17bac:	4770      	bx	lr
   17bae:	bf00      	nop

00017bb0 <rpc_gnss_serialize_ephe>:
   17bb0:	4603      	mov	r3, r0
   17bb2:	2800      	cmp	r0, #0
   17bb4:	d04b      	beq.n	17c4e <rpc_gnss_serialize_ephe+0x9e>
   17bb6:	2900      	cmp	r1, #0
   17bb8:	d049      	beq.n	17c4e <rpc_gnss_serialize_ephe+0x9e>
   17bba:	2000      	movs	r0, #0
   17bbc:	2202      	movs	r2, #2
   17bbe:	7048      	strb	r0, [r1, #1]
   17bc0:	700a      	strb	r2, [r1, #0]
   17bc2:	68da      	ldr	r2, [r3, #12]
   17bc4:	2040      	movs	r0, #64	; 0x40
   17bc6:	f8c1 200b 	str.w	r2, [r1, #11]
   17bca:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   17bce:	f8a1 2009 	strh.w	r2, [r1, #9]
   17bd2:	f993 2006 	ldrsb.w	r2, [r3, #6]
   17bd6:	720a      	strb	r2, [r1, #8]
   17bd8:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
   17bdc:	878a      	strh	r2, [r1, #60]	; 0x3c
   17bde:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
   17be2:	86ca      	strh	r2, [r1, #54]	; 0x36
   17be4:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
   17be8:	874a      	strh	r2, [r1, #58]	; 0x3a
   17bea:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
   17bee:	868a      	strh	r2, [r1, #52]	; 0x34
   17bf0:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
   17bf4:	87ca      	strh	r2, [r1, #62]	; 0x3e
   17bf6:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
   17bfa:	870a      	strh	r2, [r1, #56]	; 0x38
   17bfc:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   17c00:	830a      	strh	r2, [r1, #24]
   17c02:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   17c04:	f8c1 2022 	str.w	r2, [r1, #34]	; 0x22
   17c08:	7c9a      	ldrb	r2, [r3, #18]
   17c0a:	744a      	strb	r2, [r1, #17]
   17c0c:	785a      	ldrb	r2, [r3, #1]
   17c0e:	70ca      	strb	r2, [r1, #3]
   17c10:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   17c12:	62ca      	str	r2, [r1, #44]	; 0x2c
   17c14:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
   17c18:	84ca      	strh	r2, [r1, #38]	; 0x26
   17c1a:	885a      	ldrh	r2, [r3, #2]
   17c1c:	808a      	strh	r2, [r1, #4]
   17c1e:	6a1a      	ldr	r2, [r3, #32]
   17c20:	f8c1 201a 	str.w	r2, [r1, #26]
   17c24:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   17c26:	630a      	str	r2, [r1, #48]	; 0x30
   17c28:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   17c2a:	f8c1 201e 	str.w	r2, [r1, #30]
   17c2e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   17c30:	628a      	str	r2, [r1, #40]	; 0x28
   17c32:	781a      	ldrb	r2, [r3, #0]
   17c34:	708a      	strb	r2, [r1, #2]
   17c36:	f993 2010 	ldrsb.w	r2, [r3, #16]
   17c3a:	73ca      	strb	r2, [r1, #15]
   17c3c:	889a      	ldrh	r2, [r3, #4]
   17c3e:	80ca      	strh	r2, [r1, #6]
   17c40:	8a9a      	ldrh	r2, [r3, #20]
   17c42:	824a      	strh	r2, [r1, #18]
   17c44:	7c5a      	ldrb	r2, [r3, #17]
   17c46:	740a      	strb	r2, [r1, #16]
   17c48:	699b      	ldr	r3, [r3, #24]
   17c4a:	614b      	str	r3, [r1, #20]
   17c4c:	4770      	bx	lr
   17c4e:	f04f 30ff 	mov.w	r0, #4294967295
   17c52:	4770      	bx	lr

00017c54 <rpc_gnss_serialize_alm>:
   17c54:	4603      	mov	r3, r0
   17c56:	b360      	cbz	r0, 17cb2 <rpc_gnss_serialize_alm+0x5e>
   17c58:	b359      	cbz	r1, 17cb2 <rpc_gnss_serialize_alm+0x5e>
   17c5a:	2000      	movs	r0, #0
   17c5c:	2203      	movs	r2, #3
   17c5e:	7048      	strb	r0, [r1, #1]
   17c60:	700a      	strb	r2, [r1, #0]
   17c62:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   17c66:	2021      	movs	r0, #33	; 0x21
   17c68:	f8a1 201d 	strh.w	r2, [r1, #29]
   17c6c:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
   17c70:	f8a1 201f 	strh.w	r2, [r1, #31]
   17c74:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   17c78:	810a      	strh	r2, [r1, #8]
   17c7a:	889a      	ldrh	r2, [r3, #4]
   17c7c:	80ca      	strh	r2, [r1, #6]
   17c7e:	78da      	ldrb	r2, [r3, #3]
   17c80:	714a      	strb	r2, [r1, #5]
   17c82:	699a      	ldr	r2, [r3, #24]
   17c84:	f8c1 2019 	str.w	r2, [r1, #25]
   17c88:	691a      	ldr	r2, [r3, #16]
   17c8a:	f8c1 2011 	str.w	r2, [r1, #17]
   17c8e:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   17c92:	814a      	strh	r2, [r1, #10]
   17c94:	68da      	ldr	r2, [r3, #12]
   17c96:	f8c1 200d 	str.w	r2, [r1, #13]
   17c9a:	7a9a      	ldrb	r2, [r3, #10]
   17c9c:	730a      	strb	r2, [r1, #12]
   17c9e:	781a      	ldrb	r2, [r3, #0]
   17ca0:	708a      	strb	r2, [r1, #2]
   17ca2:	789a      	ldrb	r2, [r3, #2]
   17ca4:	710a      	strb	r2, [r1, #4]
   17ca6:	695a      	ldr	r2, [r3, #20]
   17ca8:	f8c1 2015 	str.w	r2, [r1, #21]
   17cac:	785b      	ldrb	r3, [r3, #1]
   17cae:	70cb      	strb	r3, [r1, #3]
   17cb0:	4770      	bx	lr
   17cb2:	f04f 30ff 	mov.w	r0, #4294967295
   17cb6:	4770      	bx	lr

00017cb8 <rpc_gnss_serialize_klob>:
   17cb8:	4603      	mov	r3, r0
   17cba:	b1f0      	cbz	r0, 17cfa <rpc_gnss_serialize_klob+0x42>
   17cbc:	b1e9      	cbz	r1, 17cfa <rpc_gnss_serialize_klob+0x42>
   17cbe:	2000      	movs	r0, #0
   17cc0:	2204      	movs	r2, #4
   17cc2:	7048      	strb	r0, [r1, #1]
   17cc4:	700a      	strb	r2, [r1, #0]
   17cc6:	f993 2000 	ldrsb.w	r2, [r3]
   17cca:	200a      	movs	r0, #10
   17ccc:	708a      	strb	r2, [r1, #2]
   17cce:	f993 2001 	ldrsb.w	r2, [r3, #1]
   17cd2:	70ca      	strb	r2, [r1, #3]
   17cd4:	f993 2002 	ldrsb.w	r2, [r3, #2]
   17cd8:	710a      	strb	r2, [r1, #4]
   17cda:	f993 2003 	ldrsb.w	r2, [r3, #3]
   17cde:	714a      	strb	r2, [r1, #5]
   17ce0:	f993 2004 	ldrsb.w	r2, [r3, #4]
   17ce4:	718a      	strb	r2, [r1, #6]
   17ce6:	f993 2005 	ldrsb.w	r2, [r3, #5]
   17cea:	71ca      	strb	r2, [r1, #7]
   17cec:	f993 2006 	ldrsb.w	r2, [r3, #6]
   17cf0:	720a      	strb	r2, [r1, #8]
   17cf2:	f993 3007 	ldrsb.w	r3, [r3, #7]
   17cf6:	724b      	strb	r3, [r1, #9]
   17cf8:	4770      	bx	lr
   17cfa:	f04f 30ff 	mov.w	r0, #4294967295
   17cfe:	4770      	bx	lr

00017d00 <rpc_gnss_serialize_nequick>:
   17d00:	4603      	mov	r3, r0
   17d02:	b198      	cbz	r0, 17d2c <rpc_gnss_serialize_nequick+0x2c>
   17d04:	b191      	cbz	r1, 17d2c <rpc_gnss_serialize_nequick+0x2c>
   17d06:	2000      	movs	r0, #0
   17d08:	2205      	movs	r2, #5
   17d0a:	7048      	strb	r0, [r1, #1]
   17d0c:	700a      	strb	r2, [r1, #0]
   17d0e:	f9b3 2000 	ldrsh.w	r2, [r3]
   17d12:	200a      	movs	r0, #10
   17d14:	804a      	strh	r2, [r1, #2]
   17d16:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   17d1a:	808a      	strh	r2, [r1, #4]
   17d1c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   17d20:	80ca      	strh	r2, [r1, #6]
   17d22:	799a      	ldrb	r2, [r3, #6]
   17d24:	720a      	strb	r2, [r1, #8]
   17d26:	79db      	ldrb	r3, [r3, #7]
   17d28:	724b      	strb	r3, [r1, #9]
   17d2a:	4770      	bx	lr
   17d2c:	f04f 30ff 	mov.w	r0, #4294967295
   17d30:	4770      	bx	lr
   17d32:	bf00      	nop

00017d34 <rpc_gnss_serialize_time_and_sv_tow>:
   17d34:	b310      	cbz	r0, 17d7c <rpc_gnss_serialize_time_and_sv_tow+0x48>
   17d36:	b309      	cbz	r1, 17d7c <rpc_gnss_serialize_time_and_sv_tow+0x48>
   17d38:	b470      	push	{r4, r5, r6}
   17d3a:	2500      	movs	r5, #0
   17d3c:	2606      	movs	r6, #6
   17d3e:	460c      	mov	r4, r1
   17d40:	704d      	strb	r5, [r1, #1]
   17d42:	700e      	strb	r6, [r1, #0]
   17d44:	462b      	mov	r3, r5
   17d46:	8805      	ldrh	r5, [r0, #0]
   17d48:	4602      	mov	r2, r0
   17d4a:	804d      	strh	r5, [r1, #2]
   17d4c:	68c5      	ldr	r5, [r0, #12]
   17d4e:	f8c1 500a 	str.w	r5, [r1, #10]
   17d52:	8905      	ldrh	r5, [r0, #8]
   17d54:	810d      	strh	r5, [r1, #8]
   17d56:	6840      	ldr	r0, [r0, #4]
   17d58:	6048      	str	r0, [r1, #4]
   17d5a:	8a15      	ldrh	r5, [r2, #16]
   17d5c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   17d60:	4408      	add	r0, r1
   17d62:	81c5      	strh	r5, [r0, #14]
   17d64:	7c90      	ldrb	r0, [r2, #18]
   17d66:	3301      	adds	r3, #1
   17d68:	2b20      	cmp	r3, #32
   17d6a:	7420      	strb	r0, [r4, #16]
   17d6c:	f102 0204 	add.w	r2, r2, #4
   17d70:	f104 0403 	add.w	r4, r4, #3
   17d74:	d1f1      	bne.n	17d5a <rpc_gnss_serialize_time_and_sv_tow+0x26>
   17d76:	206e      	movs	r0, #110	; 0x6e
   17d78:	bc70      	pop	{r4, r5, r6}
   17d7a:	4770      	bx	lr
   17d7c:	f04f 30ff 	mov.w	r0, #4294967295
   17d80:	4770      	bx	lr
   17d82:	bf00      	nop

00017d84 <rpc_gnss_serialize_location>:
   17d84:	4603      	mov	r3, r0
   17d86:	b1c8      	cbz	r0, 17dbc <rpc_gnss_serialize_location+0x38>
   17d88:	b1c1      	cbz	r1, 17dbc <rpc_gnss_serialize_location+0x38>
   17d8a:	2000      	movs	r0, #0
   17d8c:	2207      	movs	r2, #7
   17d8e:	7048      	strb	r0, [r1, #1]
   17d90:	700a      	strb	r2, [r1, #0]
   17d92:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   17d96:	2011      	movs	r0, #17
   17d98:	814a      	strh	r2, [r1, #10]
   17d9a:	7b9a      	ldrb	r2, [r3, #14]
   17d9c:	740a      	strb	r2, [r1, #16]
   17d9e:	681a      	ldr	r2, [r3, #0]
   17da0:	f8c1 2002 	str.w	r2, [r1, #2]
   17da4:	685a      	ldr	r2, [r3, #4]
   17da6:	f8c1 2006 	str.w	r2, [r1, #6]
   17daa:	7b1a      	ldrb	r2, [r3, #12]
   17dac:	738a      	strb	r2, [r1, #14]
   17dae:	7b5a      	ldrb	r2, [r3, #13]
   17db0:	73ca      	strb	r2, [r1, #15]
   17db2:	7a9a      	ldrb	r2, [r3, #10]
   17db4:	730a      	strb	r2, [r1, #12]
   17db6:	7adb      	ldrb	r3, [r3, #11]
   17db8:	734b      	strb	r3, [r1, #13]
   17dba:	4770      	bx	lr
   17dbc:	f04f 30ff 	mov.w	r0, #4294967295
   17dc0:	4770      	bx	lr
   17dc2:	bf00      	nop

00017dc4 <rpc_gnss_serialize_integrity>:
   17dc4:	b148      	cbz	r0, 17dda <rpc_gnss_serialize_integrity+0x16>
   17dc6:	b141      	cbz	r1, 17dda <rpc_gnss_serialize_integrity+0x16>
   17dc8:	2200      	movs	r2, #0
   17dca:	2308      	movs	r3, #8
   17dcc:	704a      	strb	r2, [r1, #1]
   17dce:	700b      	strb	r3, [r1, #0]
   17dd0:	6803      	ldr	r3, [r0, #0]
   17dd2:	2006      	movs	r0, #6
   17dd4:	f8c1 3002 	str.w	r3, [r1, #2]
   17dd8:	4770      	bx	lr
   17dda:	f04f 30ff 	mov.w	r0, #4294967295
   17dde:	4770      	bx	lr

00017de0 <gnss_client_event_handler>:
   17de0:	f850 1b08 	ldr.w	r1, [r0], #8
   17de4:	0c09      	lsrs	r1, r1, #16
   17de6:	f7fd b97b 	b.w	150e0 <rpc_gnss_event_handler>
   17dea:	bf00      	nop

00017dec <rpc_gnss_client_init>:
   17dec:	4801      	ldr	r0, [pc, #4]	; (17df4 <rpc_gnss_client_init+0x8>)
   17dee:	f7fd b8ab 	b.w	14f48 <rpc_client_register>
   17df2:	bf00      	nop
   17df4:	0001e070 	.word	0x0001e070

00017df8 <rpc_gnss_client_request_alloc>:
   17df8:	2300      	movs	r3, #0
   17dfa:	b510      	push	{r4, lr}
   17dfc:	b082      	sub	sp, #8
   17dfe:	9301      	str	r3, [sp, #4]
   17e00:	b158      	cbz	r0, 17e1a <rpc_gnss_client_request_alloc+0x22>
   17e02:	4604      	mov	r4, r0
   17e04:	aa01      	add	r2, sp, #4
   17e06:	2007      	movs	r0, #7
   17e08:	f7fd f918 	bl	1503c <rpc_message_alloc>
   17e0c:	b918      	cbnz	r0, 17e16 <rpc_gnss_client_request_alloc+0x1e>
   17e0e:	9b01      	ldr	r3, [sp, #4]
   17e10:	b10b      	cbz	r3, 17e16 <rpc_gnss_client_request_alloc+0x1e>
   17e12:	3308      	adds	r3, #8
   17e14:	6023      	str	r3, [r4, #0]
   17e16:	b002      	add	sp, #8
   17e18:	bd10      	pop	{r4, pc}
   17e1a:	2007      	movs	r0, #7
   17e1c:	b002      	add	sp, #8
   17e1e:	bd10      	pop	{r4, pc}

00017e20 <rpc_gnss_client_request_send>:
   17e20:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   17e24:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   17e28:	d10b      	bne.n	17e42 <rpc_gnss_client_request_send+0x22>
   17e2a:	b160      	cbz	r0, 17e46 <rpc_gnss_client_request_send+0x26>
   17e2c:	4603      	mov	r3, r0
   17e2e:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   17e32:	2007      	movs	r0, #7
   17e34:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   17e38:	f843 1d08 	str.w	r1, [r3, #-8]!
   17e3c:	4619      	mov	r1, r3
   17e3e:	f7fd b8ed 	b.w	1501c <rpc_message_send>
   17e42:	200f      	movs	r0, #15
   17e44:	4770      	bx	lr
   17e46:	2007      	movs	r0, #7
   17e48:	4770      	bx	lr
   17e4a:	bf00      	nop

00017e4c <rpc_gnss_client_message_free>:
   17e4c:	b120      	cbz	r0, 17e58 <rpc_gnss_client_message_free+0xc>
   17e4e:	f1a0 0108 	sub.w	r1, r0, #8
   17e52:	2007      	movs	r0, #7
   17e54:	f7fd b91e 	b.w	15094 <rpc_message_free>
   17e58:	2007      	movs	r0, #7
   17e5a:	4770      	bx	lr

00017e5c <rpc_gnss_client_data_free>:
   17e5c:	b118      	cbz	r0, 17e66 <rpc_gnss_client_data_free+0xa>
   17e5e:	4601      	mov	r1, r0
   17e60:	2007      	movs	r0, #7
   17e62:	f7fd b923 	b.w	150ac <rpc_message_data_free>
   17e66:	2007      	movs	r0, #7
   17e68:	4770      	bx	lr
   17e6a:	bf00      	nop

00017e6c <datagram_handler_init>:
   17e6c:	b510      	push	{r4, lr}
   17e6e:	4604      	mov	r4, r0
   17e70:	200c      	movs	r0, #12
   17e72:	f000 fdd7 	bl	18a24 <nrf_malloc>
   17e76:	60e0      	str	r0, [r4, #12]
   17e78:	b118      	cbz	r0, 17e82 <datagram_handler_init+0x16>
   17e7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   17e7e:	f7ff bd5f 	b.w	17940 <linked_list_init>
   17e82:	2004      	movs	r0, #4
   17e84:	bd10      	pop	{r4, pc}
   17e86:	bf00      	nop

00017e88 <datagram_handler_put>:
   17e88:	b570      	push	{r4, r5, r6, lr}
   17e8a:	4606      	mov	r6, r0
   17e8c:	2014      	movs	r0, #20
   17e8e:	460d      	mov	r5, r1
   17e90:	f000 fdc8 	bl	18a24 <nrf_malloc>
   17e94:	b178      	cbz	r0, 17eb6 <datagram_handler_put+0x2e>
   17e96:	682b      	ldr	r3, [r5, #0]
   17e98:	4604      	mov	r4, r0
   17e9a:	6043      	str	r3, [r0, #4]
   17e9c:	686b      	ldr	r3, [r5, #4]
   17e9e:	4601      	mov	r1, r0
   17ea0:	6083      	str	r3, [r0, #8]
   17ea2:	68eb      	ldr	r3, [r5, #12]
   17ea4:	60c3      	str	r3, [r0, #12]
   17ea6:	68ab      	ldr	r3, [r5, #8]
   17ea8:	6103      	str	r3, [r0, #16]
   17eaa:	68f0      	ldr	r0, [r6, #12]
   17eac:	f7ff fd52 	bl	17954 <linked_list_push>
   17eb0:	b920      	cbnz	r0, 17ebc <datagram_handler_put+0x34>
   17eb2:	6868      	ldr	r0, [r5, #4]
   17eb4:	bd70      	pop	{r4, r5, r6, pc}
   17eb6:	f04f 30ff 	mov.w	r0, #4294967295
   17eba:	bd70      	pop	{r4, r5, r6, pc}
   17ebc:	4620      	mov	r0, r4
   17ebe:	f000 fdbb 	bl	18a38 <nrf_free>
   17ec2:	f04f 30ff 	mov.w	r0, #4294967295
   17ec6:	bd70      	pop	{r4, r5, r6, pc}

00017ec8 <datagram_handler_get>:
   17ec8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17ecc:	4607      	mov	r7, r0
   17ece:	b084      	sub	sp, #16
   17ed0:	68c0      	ldr	r0, [r0, #12]
   17ed2:	460c      	mov	r4, r1
   17ed4:	4616      	mov	r6, r2
   17ed6:	f7ff fd5d 	bl	17994 <linked_list_peek>
   17eda:	2800      	cmp	r0, #0
   17edc:	d03b      	beq.n	17f56 <datagram_handler_get+0x8e>
   17ede:	6882      	ldr	r2, [r0, #8]
   17ee0:	4605      	mov	r5, r0
   17ee2:	e9d4 0300 	ldrd	r0, r3, [r4]
   17ee6:	429a      	cmp	r2, r3
   17ee8:	bf28      	it	cs
   17eea:	461a      	movcs	r2, r3
   17eec:	6062      	str	r2, [r4, #4]
   17eee:	b110      	cbz	r0, 17ef6 <datagram_handler_get+0x2e>
   17ef0:	6869      	ldr	r1, [r5, #4]
   17ef2:	f004 f877 	bl	1bfe4 <memcpy>
   17ef6:	68a0      	ldr	r0, [r4, #8]
   17ef8:	b118      	cbz	r0, 17f02 <datagram_handler_get+0x3a>
   17efa:	692b      	ldr	r3, [r5, #16]
   17efc:	b10b      	cbz	r3, 17f02 <datagram_handler_get+0x3a>
   17efe:	68ea      	ldr	r2, [r5, #12]
   17f00:	bb02      	cbnz	r2, 17f44 <datagram_handler_get+0x7c>
   17f02:	2300      	movs	r3, #0
   17f04:	60e3      	str	r3, [r4, #12]
   17f06:	0732      	lsls	r2, r6, #28
   17f08:	d506      	bpl.n	17f18 <datagram_handler_get+0x50>
   17f0a:	06b3      	lsls	r3, r6, #26
   17f0c:	bf4c      	ite	mi
   17f0e:	68a8      	ldrmi	r0, [r5, #8]
   17f10:	6860      	ldrpl	r0, [r4, #4]
   17f12:	b004      	add	sp, #16
   17f14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   17f18:	68f8      	ldr	r0, [r7, #12]
   17f1a:	f7ff fd31 	bl	17980 <linked_list_pop>
   17f1e:	4680      	mov	r8, r0
   17f20:	2800      	cmp	r0, #0
   17f22:	d0f2      	beq.n	17f0a <datagram_handler_get+0x42>
   17f24:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   17f28:	6902      	ldr	r2, [r0, #16]
   17f2a:	9300      	str	r3, [sp, #0]
   17f2c:	68c3      	ldr	r3, [r0, #12]
   17f2e:	e9cd 1201 	strd	r1, r2, [sp, #4]
   17f32:	9303      	str	r3, [sp, #12]
   17f34:	4668      	mov	r0, sp
   17f36:	e9d7 3101 	ldrd	r3, r1, [r7, #4]
   17f3a:	4798      	blx	r3
   17f3c:	4640      	mov	r0, r8
   17f3e:	f000 fd7b 	bl	18a38 <nrf_free>
   17f42:	e7e2      	b.n	17f0a <datagram_handler_get+0x42>
   17f44:	68e3      	ldr	r3, [r4, #12]
   17f46:	429a      	cmp	r2, r3
   17f48:	bf28      	it	cs
   17f4a:	461a      	movcs	r2, r3
   17f4c:	60e2      	str	r2, [r4, #12]
   17f4e:	6929      	ldr	r1, [r5, #16]
   17f50:	f004 f848 	bl	1bfe4 <memcpy>
   17f54:	e7d7      	b.n	17f06 <datagram_handler_get+0x3e>
   17f56:	f04f 30ff 	mov.w	r0, #4294967295
   17f5a:	e7da      	b.n	17f12 <datagram_handler_get+0x4a>

00017f5c <datagram_handler_available>:
   17f5c:	b508      	push	{r3, lr}
   17f5e:	68c0      	ldr	r0, [r0, #12]
   17f60:	f7ff fd18 	bl	17994 <linked_list_peek>
   17f64:	b108      	cbz	r0, 17f6a <datagram_handler_available+0xe>
   17f66:	6880      	ldr	r0, [r0, #8]
   17f68:	bd08      	pop	{r3, pc}
   17f6a:	f04f 30ff 	mov.w	r0, #4294967295
   17f6e:	bd08      	pop	{r3, pc}

00017f70 <datagram_handler_flush>:
   17f70:	b530      	push	{r4, r5, lr}
   17f72:	4605      	mov	r5, r0
   17f74:	68c0      	ldr	r0, [r0, #12]
   17f76:	b085      	sub	sp, #20
   17f78:	b9a8      	cbnz	r0, 17fa6 <datagram_handler_flush+0x36>
   17f7a:	e01a      	b.n	17fb2 <datagram_handler_flush+0x42>
   17f7c:	68e8      	ldr	r0, [r5, #12]
   17f7e:	f7ff fcff 	bl	17980 <linked_list_pop>
   17f82:	4604      	mov	r4, r0
   17f84:	b170      	cbz	r0, 17fa4 <datagram_handler_flush+0x34>
   17f86:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   17f8a:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   17f8e:	e9cd 0100 	strd	r0, r1, [sp]
   17f92:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17f96:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   17f9a:	4668      	mov	r0, sp
   17f9c:	4798      	blx	r3
   17f9e:	4620      	mov	r0, r4
   17fa0:	f000 fd4a 	bl	18a38 <nrf_free>
   17fa4:	68e8      	ldr	r0, [r5, #12]
   17fa6:	f7ff fcfb 	bl	179a0 <linked_list_size_get>
   17faa:	2800      	cmp	r0, #0
   17fac:	d1e6      	bne.n	17f7c <datagram_handler_flush+0xc>
   17fae:	b005      	add	sp, #20
   17fb0:	bd30      	pop	{r4, r5, pc}
   17fb2:	2008      	movs	r0, #8
   17fb4:	b005      	add	sp, #20
   17fb6:	bd30      	pop	{r4, r5, pc}

00017fb8 <datagram_handler_free>:
   17fb8:	b530      	push	{r4, r5, lr}
   17fba:	4605      	mov	r5, r0
   17fbc:	68c0      	ldr	r0, [r0, #12]
   17fbe:	b085      	sub	sp, #20
   17fc0:	b9a0      	cbnz	r0, 17fec <datagram_handler_free+0x34>
   17fc2:	e01c      	b.n	17ffe <datagram_handler_free+0x46>
   17fc4:	f7ff fcdc 	bl	17980 <linked_list_pop>
   17fc8:	4604      	mov	r4, r0
   17fca:	b170      	cbz	r0, 17fea <datagram_handler_free+0x32>
   17fcc:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   17fd0:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   17fd4:	e9cd 0100 	strd	r0, r1, [sp]
   17fd8:	e9cd 2302 	strd	r2, r3, [sp, #8]
   17fdc:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   17fe0:	4668      	mov	r0, sp
   17fe2:	4798      	blx	r3
   17fe4:	4620      	mov	r0, r4
   17fe6:	f000 fd27 	bl	18a38 <nrf_free>
   17fea:	68e8      	ldr	r0, [r5, #12]
   17fec:	f7ff fcd8 	bl	179a0 <linked_list_size_get>
   17ff0:	4604      	mov	r4, r0
   17ff2:	68e8      	ldr	r0, [r5, #12]
   17ff4:	2c00      	cmp	r4, #0
   17ff6:	d1e5      	bne.n	17fc4 <datagram_handler_free+0xc>
   17ff8:	f000 fd1e 	bl	18a38 <nrf_free>
   17ffc:	60ec      	str	r4, [r5, #12]
   17ffe:	b005      	add	sp, #20
   18000:	bd30      	pop	{r4, r5, pc}
   18002:	bf00      	nop

00018004 <null_handler_init>:
   18004:	2000      	movs	r0, #0
   18006:	4770      	bx	lr

00018008 <null_handler_put>:
   18008:	b510      	push	{r4, lr}
   1800a:	460c      	mov	r4, r1
   1800c:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   18010:	4620      	mov	r0, r4
   18012:	4798      	blx	r3
   18014:	6860      	ldr	r0, [r4, #4]
   18016:	bd10      	pop	{r4, pc}

00018018 <null_handler_get>:
   18018:	f04f 30ff 	mov.w	r0, #4294967295
   1801c:	4770      	bx	lr
   1801e:	bf00      	nop

00018020 <null_handler_available>:
   18020:	f04f 30ff 	mov.w	r0, #4294967295
   18024:	4770      	bx	lr
   18026:	bf00      	nop

00018028 <null_handler_flush>:
   18028:	2000      	movs	r0, #0
   1802a:	4770      	bx	lr

0001802c <null_handler_free>:
   1802c:	4770      	bx	lr
   1802e:	bf00      	nop

00018030 <packet_handler_create>:
   18030:	2801      	cmp	r0, #1
   18032:	b538      	push	{r3, r4, r5, lr}
   18034:	460d      	mov	r5, r1
   18036:	4614      	mov	r4, r2
   18038:	d00d      	beq.n	18056 <packet_handler_create+0x26>
   1803a:	db11      	blt.n	18060 <packet_handler_create+0x30>
   1803c:	2803      	cmp	r0, #3
   1803e:	dc0f      	bgt.n	18060 <packet_handler_create+0x30>
   18040:	2010      	movs	r0, #16
   18042:	f000 fcef 	bl	18a24 <nrf_malloc>
   18046:	2218      	movs	r2, #24
   18048:	b120      	cbz	r0, 18054 <packet_handler_create+0x24>
   1804a:	4b08      	ldr	r3, [pc, #32]	; (1806c <packet_handler_create+0x3c>)
   1804c:	6045      	str	r5, [r0, #4]
   1804e:	4413      	add	r3, r2
   18050:	6084      	str	r4, [r0, #8]
   18052:	6003      	str	r3, [r0, #0]
   18054:	bd38      	pop	{r3, r4, r5, pc}
   18056:	2014      	movs	r0, #20
   18058:	f000 fce4 	bl	18a24 <nrf_malloc>
   1805c:	2230      	movs	r2, #48	; 0x30
   1805e:	e7f3      	b.n	18048 <packet_handler_create+0x18>
   18060:	200c      	movs	r0, #12
   18062:	f000 fcdf 	bl	18a24 <nrf_malloc>
   18066:	2200      	movs	r2, #0
   18068:	e7ee      	b.n	18048 <packet_handler_create+0x18>
   1806a:	bf00      	nop
   1806c:	0001e080 	.word	0x0001e080

00018070 <packet_handler_delete>:
   18070:	b510      	push	{r4, lr}
   18072:	4604      	mov	r4, r0
   18074:	6803      	ldr	r3, [r0, #0]
   18076:	691b      	ldr	r3, [r3, #16]
   18078:	4798      	blx	r3
   1807a:	6823      	ldr	r3, [r4, #0]
   1807c:	4620      	mov	r0, r4
   1807e:	695b      	ldr	r3, [r3, #20]
   18080:	4798      	blx	r3
   18082:	4620      	mov	r0, r4
   18084:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   18088:	f000 bcd6 	b.w	18a38 <nrf_free>

0001808c <stream_handler_init>:
   1808c:	b510      	push	{r4, lr}
   1808e:	4604      	mov	r4, r0
   18090:	200c      	movs	r0, #12
   18092:	f000 fcc7 	bl	18a24 <nrf_malloc>
   18096:	60e0      	str	r0, [r4, #12]
   18098:	b128      	cbz	r0, 180a6 <stream_handler_init+0x1a>
   1809a:	2300      	movs	r3, #0
   1809c:	6123      	str	r3, [r4, #16]
   1809e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   180a2:	f7ff bc4d 	b.w	17940 <linked_list_init>
   180a6:	2004      	movs	r0, #4
   180a8:	bd10      	pop	{r4, pc}
   180aa:	bf00      	nop

000180ac <stream_handler_put>:
   180ac:	b570      	push	{r4, r5, r6, lr}
   180ae:	4606      	mov	r6, r0
   180b0:	2014      	movs	r0, #20
   180b2:	460d      	mov	r5, r1
   180b4:	f000 fcb6 	bl	18a24 <nrf_malloc>
   180b8:	b178      	cbz	r0, 180da <stream_handler_put+0x2e>
   180ba:	682b      	ldr	r3, [r5, #0]
   180bc:	4604      	mov	r4, r0
   180be:	6043      	str	r3, [r0, #4]
   180c0:	686b      	ldr	r3, [r5, #4]
   180c2:	4601      	mov	r1, r0
   180c4:	6083      	str	r3, [r0, #8]
   180c6:	68eb      	ldr	r3, [r5, #12]
   180c8:	60c3      	str	r3, [r0, #12]
   180ca:	68ab      	ldr	r3, [r5, #8]
   180cc:	6103      	str	r3, [r0, #16]
   180ce:	68f0      	ldr	r0, [r6, #12]
   180d0:	f7ff fc40 	bl	17954 <linked_list_push>
   180d4:	b920      	cbnz	r0, 180e0 <stream_handler_put+0x34>
   180d6:	6868      	ldr	r0, [r5, #4]
   180d8:	bd70      	pop	{r4, r5, r6, pc}
   180da:	f04f 30ff 	mov.w	r0, #4294967295
   180de:	bd70      	pop	{r4, r5, r6, pc}
   180e0:	4620      	mov	r0, r4
   180e2:	f000 fca9 	bl	18a38 <nrf_free>
   180e6:	f04f 30ff 	mov.w	r0, #4294967295
   180ea:	bd70      	pop	{r4, r5, r6, pc}

000180ec <stream_handler_get>:
   180ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   180f0:	4682      	mov	sl, r0
   180f2:	b089      	sub	sp, #36	; 0x24
   180f4:	68c0      	ldr	r0, [r0, #12]
   180f6:	4689      	mov	r9, r1
   180f8:	4693      	mov	fp, r2
   180fa:	f7ff fc4b 	bl	17994 <linked_list_peek>
   180fe:	2800      	cmp	r0, #0
   18100:	d071      	beq.n	181e6 <stream_handler_get+0xfa>
   18102:	4605      	mov	r5, r0
   18104:	f8d9 0008 	ldr.w	r0, [r9, #8]
   18108:	b120      	cbz	r0, 18114 <stream_handler_get+0x28>
   1810a:	692b      	ldr	r3, [r5, #16]
   1810c:	b113      	cbz	r3, 18114 <stream_handler_get+0x28>
   1810e:	68ea      	ldr	r2, [r5, #12]
   18110:	2a00      	cmp	r2, #0
   18112:	d15d      	bne.n	181d0 <stream_handler_get+0xe4>
   18114:	2300      	movs	r3, #0
   18116:	f8c9 300c 	str.w	r3, [r9, #12]
   1811a:	f8d9 2000 	ldr.w	r2, [r9]
   1811e:	f8d9 8004 	ldr.w	r8, [r9, #4]
   18122:	f8da 1010 	ldr.w	r1, [sl, #16]
   18126:	9203      	str	r2, [sp, #12]
   18128:	f1b8 0f00 	cmp.w	r8, #0
   1812c:	d030      	beq.n	18190 <stream_handler_get+0xa4>
   1812e:	2400      	movs	r4, #0
   18130:	f00b 0320 	and.w	r3, fp, #32
   18134:	9301      	str	r3, [sp, #4]
   18136:	f00b 0b08 	and.w	fp, fp, #8
   1813a:	68ae      	ldr	r6, [r5, #8]
   1813c:	eba8 0304 	sub.w	r3, r8, r4
   18140:	1a76      	subs	r6, r6, r1
   18142:	429e      	cmp	r6, r3
   18144:	4637      	mov	r7, r6
   18146:	bf28      	it	cs
   18148:	461f      	movcs	r7, r3
   1814a:	b10a      	cbz	r2, 18150 <stream_handler_get+0x64>
   1814c:	9a01      	ldr	r2, [sp, #4]
   1814e:	b1aa      	cbz	r2, 1817c <stream_handler_get+0x90>
   18150:	f1bb 0f00 	cmp.w	fp, #0
   18154:	d106      	bne.n	18164 <stream_handler_get+0x78>
   18156:	429e      	cmp	r6, r3
   18158:	d921      	bls.n	1819e <stream_handler_get+0xb2>
   1815a:	f8da 3010 	ldr.w	r3, [sl, #16]
   1815e:	443b      	add	r3, r7
   18160:	f8ca 3010 	str.w	r3, [sl, #16]
   18164:	4628      	mov	r0, r5
   18166:	f7ff fc1d 	bl	179a4 <linked_list_get_next>
   1816a:	443c      	add	r4, r7
   1816c:	4605      	mov	r5, r0
   1816e:	b180      	cbz	r0, 18192 <stream_handler_get+0xa6>
   18170:	45a0      	cmp	r8, r4
   18172:	d90e      	bls.n	18192 <stream_handler_get+0xa6>
   18174:	f8d9 2000 	ldr.w	r2, [r9]
   18178:	2100      	movs	r1, #0
   1817a:	e7de      	b.n	1813a <stream_handler_get+0x4e>
   1817c:	6868      	ldr	r0, [r5, #4]
   1817e:	9302      	str	r3, [sp, #8]
   18180:	9b03      	ldr	r3, [sp, #12]
   18182:	4401      	add	r1, r0
   18184:	463a      	mov	r2, r7
   18186:	1918      	adds	r0, r3, r4
   18188:	f003 ff2c 	bl	1bfe4 <memcpy>
   1818c:	9b02      	ldr	r3, [sp, #8]
   1818e:	e7df      	b.n	18150 <stream_handler_get+0x64>
   18190:	4644      	mov	r4, r8
   18192:	4620      	mov	r0, r4
   18194:	f8c9 4004 	str.w	r4, [r9, #4]
   18198:	b009      	add	sp, #36	; 0x24
   1819a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1819e:	f8da 000c 	ldr.w	r0, [sl, #12]
   181a2:	f7ff fbed 	bl	17980 <linked_list_pop>
   181a6:	4606      	mov	r6, r0
   181a8:	b170      	cbz	r0, 181c8 <stream_handler_get+0xdc>
   181aa:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   181ae:	e9d0 0103 	ldrd	r0, r1, [r0, #12]
   181b2:	e9cd 2304 	strd	r2, r3, [sp, #16]
   181b6:	e9cd 1006 	strd	r1, r0, [sp, #24]
   181ba:	e9da 3101 	ldrd	r3, r1, [sl, #4]
   181be:	a804      	add	r0, sp, #16
   181c0:	4798      	blx	r3
   181c2:	4630      	mov	r0, r6
   181c4:	f000 fc38 	bl	18a38 <nrf_free>
   181c8:	2300      	movs	r3, #0
   181ca:	f8ca 3010 	str.w	r3, [sl, #16]
   181ce:	e7c9      	b.n	18164 <stream_handler_get+0x78>
   181d0:	f8d9 300c 	ldr.w	r3, [r9, #12]
   181d4:	429a      	cmp	r2, r3
   181d6:	bf28      	it	cs
   181d8:	461a      	movcs	r2, r3
   181da:	f8c9 200c 	str.w	r2, [r9, #12]
   181de:	6929      	ldr	r1, [r5, #16]
   181e0:	f003 ff00 	bl	1bfe4 <memcpy>
   181e4:	e799      	b.n	1811a <stream_handler_get+0x2e>
   181e6:	f04f 30ff 	mov.w	r0, #4294967295
   181ea:	e7d5      	b.n	18198 <stream_handler_get+0xac>

000181ec <stream_handler_available>:
   181ec:	b510      	push	{r4, lr}
   181ee:	4604      	mov	r4, r0
   181f0:	68c0      	ldr	r0, [r0, #12]
   181f2:	f7ff fbcf 	bl	17994 <linked_list_peek>
   181f6:	b150      	cbz	r0, 1820e <stream_handler_available+0x22>
   181f8:	6924      	ldr	r4, [r4, #16]
   181fa:	4264      	negs	r4, r4
   181fc:	6883      	ldr	r3, [r0, #8]
   181fe:	441c      	add	r4, r3
   18200:	f7ff fbd0 	bl	179a4 <linked_list_get_next>
   18204:	2800      	cmp	r0, #0
   18206:	d1f9      	bne.n	181fc <stream_handler_available+0x10>
   18208:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
   1820c:	bd10      	pop	{r4, pc}
   1820e:	f04f 30ff 	mov.w	r0, #4294967295
   18212:	bd10      	pop	{r4, pc}

00018214 <stream_handler_flush>:
   18214:	b530      	push	{r4, r5, lr}
   18216:	4605      	mov	r5, r0
   18218:	68c0      	ldr	r0, [r0, #12]
   1821a:	b085      	sub	sp, #20
   1821c:	b9a8      	cbnz	r0, 1824a <stream_handler_flush+0x36>
   1821e:	e01a      	b.n	18256 <stream_handler_flush+0x42>
   18220:	68e8      	ldr	r0, [r5, #12]
   18222:	f7ff fbad 	bl	17980 <linked_list_pop>
   18226:	4604      	mov	r4, r0
   18228:	b170      	cbz	r0, 18248 <stream_handler_flush+0x34>
   1822a:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   1822e:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   18232:	e9cd 0100 	strd	r0, r1, [sp]
   18236:	e9cd 2302 	strd	r2, r3, [sp, #8]
   1823a:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   1823e:	4668      	mov	r0, sp
   18240:	4798      	blx	r3
   18242:	4620      	mov	r0, r4
   18244:	f000 fbf8 	bl	18a38 <nrf_free>
   18248:	68e8      	ldr	r0, [r5, #12]
   1824a:	f7ff fba9 	bl	179a0 <linked_list_size_get>
   1824e:	2800      	cmp	r0, #0
   18250:	d1e6      	bne.n	18220 <stream_handler_flush+0xc>
   18252:	b005      	add	sp, #20
   18254:	bd30      	pop	{r4, r5, pc}
   18256:	2008      	movs	r0, #8
   18258:	b005      	add	sp, #20
   1825a:	bd30      	pop	{r4, r5, pc}

0001825c <stream_handler_free>:
   1825c:	b530      	push	{r4, r5, lr}
   1825e:	4605      	mov	r5, r0
   18260:	68c0      	ldr	r0, [r0, #12]
   18262:	b085      	sub	sp, #20
   18264:	b9a0      	cbnz	r0, 18290 <stream_handler_free+0x34>
   18266:	e01c      	b.n	182a2 <stream_handler_free+0x46>
   18268:	f7ff fb8a 	bl	17980 <linked_list_pop>
   1826c:	4604      	mov	r4, r0
   1826e:	b170      	cbz	r0, 1828e <stream_handler_free+0x32>
   18270:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   18274:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   18278:	e9cd 0100 	strd	r0, r1, [sp]
   1827c:	e9cd 2302 	strd	r2, r3, [sp, #8]
   18280:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   18284:	4668      	mov	r0, sp
   18286:	4798      	blx	r3
   18288:	4620      	mov	r0, r4
   1828a:	f000 fbd5 	bl	18a38 <nrf_free>
   1828e:	68e8      	ldr	r0, [r5, #12]
   18290:	f7ff fb86 	bl	179a0 <linked_list_size_get>
   18294:	4604      	mov	r4, r0
   18296:	68e8      	ldr	r0, [r5, #12]
   18298:	2c00      	cmp	r4, #0
   1829a:	d1e5      	bne.n	18268 <stream_handler_free+0xc>
   1829c:	f000 fbcc 	bl	18a38 <nrf_free>
   182a0:	60ec      	str	r4, [r5, #12]
   182a2:	b005      	add	sp, #20
   182a4:	bd30      	pop	{r4, r5, pc}
   182a6:	bf00      	nop

000182a8 <mem_free>:
   182a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   182ac:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 1837c <mem_free+0xd4>
   182b0:	b083      	sub	sp, #12
   182b2:	9000      	str	r0, [sp, #0]
   182b4:	f10c 0b3c 	add.w	fp, ip, #60	; 0x3c
   182b8:	f8dc 3008 	ldr.w	r3, [ip, #8]
   182bc:	b12b      	cbz	r3, 182ca <mem_free+0x22>
   182be:	f8dc 2000 	ldr.w	r2, [ip]
   182c2:	9c00      	ldr	r4, [sp, #0]
   182c4:	7810      	ldrb	r0, [r2, #0]
   182c6:	42a0      	cmp	r0, r4
   182c8:	d006      	beq.n	182d8 <mem_free+0x30>
   182ca:	f10c 0c0c 	add.w	ip, ip, #12
   182ce:	45e3      	cmp	fp, ip
   182d0:	d1f2      	bne.n	182b8 <mem_free+0x10>
   182d2:	b003      	add	sp, #12
   182d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   182d8:	f8dc a004 	ldr.w	sl, [ip, #4]
   182dc:	eb03 080a 	add.w	r8, r3, sl
   182e0:	45c2      	cmp	sl, r8
   182e2:	d2f2      	bcs.n	182ca <mem_free+0x22>
   182e4:	6853      	ldr	r3, [r2, #4]
   182e6:	f8cd c004 	str.w	ip, [sp, #4]
   182ea:	46d6      	mov	lr, sl
   182ec:	469c      	mov	ip, r3
   182ee:	f8d2 9010 	ldr.w	r9, [r2, #16]
   182f2:	8997      	ldrh	r7, [r2, #12]
   182f4:	ebae 000a 	sub.w	r0, lr, sl
   182f8:	b3df      	cbz	r7, 18372 <mem_free+0xca>
   182fa:	f8b9 2002 	ldrh.w	r2, [r9, #2]
   182fe:	4290      	cmp	r0, r2
   18300:	d31c      	bcc.n	1833c <mem_free+0x94>
   18302:	4665      	mov	r5, ip
   18304:	2400      	movs	r4, #0
   18306:	f109 0304 	add.w	r3, r9, #4
   1830a:	e003      	b.n	18314 <mem_free+0x6c>
   1830c:	885a      	ldrh	r2, [r3, #2]
   1830e:	3304      	adds	r3, #4
   18310:	4282      	cmp	r2, r0
   18312:	d815      	bhi.n	18340 <mem_free+0x98>
   18314:	f833 6c04 	ldrh.w	r6, [r3, #-4]
   18318:	3401      	adds	r4, #1
   1831a:	42a7      	cmp	r7, r4
   1831c:	fb02 5506 	mla	r5, r2, r6, r5
   18320:	eba0 0002 	sub.w	r0, r0, r2
   18324:	461e      	mov	r6, r3
   18326:	d1f1      	bne.n	1830c <mem_free+0x64>
   18328:	2000      	movs	r0, #0
   1832a:	4281      	cmp	r1, r0
   1832c:	d00d      	beq.n	1834a <mem_free+0xa2>
   1832e:	f10e 0e01 	add.w	lr, lr, #1
   18332:	45f0      	cmp	r8, lr
   18334:	d1de      	bne.n	182f4 <mem_free+0x4c>
   18336:	f8dd c004 	ldr.w	ip, [sp, #4]
   1833a:	e7c6      	b.n	182ca <mem_free+0x22>
   1833c:	4665      	mov	r5, ip
   1833e:	464e      	mov	r6, r9
   18340:	8833      	ldrh	r3, [r6, #0]
   18342:	fb00 5003 	mla	r0, r0, r3, r5
   18346:	4281      	cmp	r1, r0
   18348:	d1f1      	bne.n	1832e <mem_free+0x86>
   1834a:	f5be 7f00 	cmp.w	lr, #512	; 0x200
   1834e:	f8dd c004 	ldr.w	ip, [sp, #4]
   18352:	d0ba      	beq.n	182ca <mem_free+0x22>
   18354:	2301      	movs	r3, #1
   18356:	4a08      	ldr	r2, [pc, #32]	; (18378 <mem_free+0xd0>)
   18358:	ea4f 115e 	mov.w	r1, lr, lsr #5
   1835c:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   18360:	f00e 0e1f 	and.w	lr, lr, #31
   18364:	fa03 fe0e 	lsl.w	lr, r3, lr
   18368:	ea4e 0000 	orr.w	r0, lr, r0
   1836c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
   18370:	e7af      	b.n	182d2 <mem_free+0x2a>
   18372:	4638      	mov	r0, r7
   18374:	e7d9      	b.n	1832a <mem_free+0x82>
   18376:	bf00      	nop
   18378:	2002099c 	.word	0x2002099c
   1837c:	200209e0 	.word	0x200209e0

00018380 <mem_alloc.constprop.5>:
   18380:	2800      	cmp	r0, #0
   18382:	d050      	beq.n	18426 <mem_alloc.constprop.5+0xa6>
   18384:	4b6d      	ldr	r3, [pc, #436]	; (1853c <mem_alloc.constprop.5+0x1bc>)
   18386:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1838a:	4290      	cmp	r0, r2
   1838c:	d84b      	bhi.n	18426 <mem_alloc.constprop.5+0xa6>
   1838e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18392:	f8d3 b08c 	ldr.w	fp, [r3, #140]	; 0x8c
   18396:	b083      	sub	sp, #12
   18398:	f1bb 0f00 	cmp.w	fp, #0
   1839c:	d054      	beq.n	18448 <mem_alloc.constprop.5+0xc8>
   1839e:	f10b 32ff 	add.w	r2, fp, #4294967295
   183a2:	4691      	mov	r9, r2
   183a4:	2600      	movs	r6, #0
   183a6:	f04f 0812 	mov.w	r8, #18
   183aa:	4f65      	ldr	r7, [pc, #404]	; (18540 <mem_alloc.constprop.5+0x1c0>)
   183ac:	9201      	str	r2, [sp, #4]
   183ae:	f10b 0e11 	add.w	lr, fp, #17
   183b2:	eb06 0209 	add.w	r2, r6, r9
   183b6:	f853 4038 	ldr.w	r4, [r3, r8, lsl #3]
   183ba:	3201      	adds	r2, #1
   183bc:	0852      	lsrs	r2, r2, #1
   183be:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
   183c2:	f102 0112 	add.w	r1, r2, #18
   183c6:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
   183ca:	f857 a02c 	ldr.w	sl, [r7, ip, lsl #2]
   183ce:	f853 403e 	ldr.w	r4, [r3, lr, lsl #3]
   183d2:	eb03 0cc8 	add.w	ip, r3, r8, lsl #3
   183d6:	f8dc c004 	ldr.w	ip, [ip, #4]
   183da:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   183de:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   183e2:	f8da a010 	ldr.w	sl, [sl, #16]
   183e6:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
   183ea:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
   183ee:	f83a a02c 	ldrh.w	sl, [sl, ip, lsl #2]
   183f2:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   183f6:	eb03 0cce 	add.w	ip, r3, lr, lsl #3
   183fa:	6849      	ldr	r1, [r1, #4]
   183fc:	692d      	ldr	r5, [r5, #16]
   183fe:	6924      	ldr	r4, [r4, #16]
   18400:	f8dc c004 	ldr.w	ip, [ip, #4]
   18404:	4550      	cmp	r0, sl
   18406:	f835 5021 	ldrh.w	r5, [r5, r1, lsl #2]
   1840a:	f834 102c 	ldrh.w	r1, [r4, ip, lsl #2]
   1840e:	d915      	bls.n	1843c <mem_alloc.constprop.5+0xbc>
   18410:	4288      	cmp	r0, r1
   18412:	d211      	bcs.n	18438 <mem_alloc.constprop.5+0xb8>
   18414:	42a8      	cmp	r0, r5
   18416:	d908      	bls.n	1842a <mem_alloc.constprop.5+0xaa>
   18418:	1c56      	adds	r6, r2, #1
   1841a:	45b1      	cmp	r9, r6
   1841c:	f0c0 8087 	bcc.w	1852e <mem_alloc.constprop.5+0x1ae>
   18420:	f102 0813 	add.w	r8, r2, #19
   18424:	e7c5      	b.n	183b2 <mem_alloc.constprop.5+0x32>
   18426:	2000      	movs	r0, #0
   18428:	4770      	bx	lr
   1842a:	f102 39ff 	add.w	r9, r2, #4294967295
   1842e:	454e      	cmp	r6, r9
   18430:	d87d      	bhi.n	1852e <mem_alloc.constprop.5+0x1ae>
   18432:	f102 0e11 	add.w	lr, r2, #17
   18436:	e7bc      	b.n	183b2 <mem_alloc.constprop.5+0x32>
   18438:	f109 0601 	add.w	r6, r9, #1
   1843c:	45b3      	cmp	fp, r6
   1843e:	d007      	beq.n	18450 <mem_alloc.constprop.5+0xd0>
   18440:	2e10      	cmp	r6, #16
   18442:	d001      	beq.n	18448 <mem_alloc.constprop.5+0xc8>
   18444:	45b3      	cmp	fp, r6
   18446:	d808      	bhi.n	1845a <mem_alloc.constprop.5+0xda>
   18448:	2000      	movs	r0, #0
   1844a:	b003      	add	sp, #12
   1844c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18450:	9a01      	ldr	r2, [sp, #4]
   18452:	2a10      	cmp	r2, #16
   18454:	bf18      	it	ne
   18456:	4616      	movne	r6, r2
   18458:	d0f6      	beq.n	18448 <mem_alloc.constprop.5+0xc8>
   1845a:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 18544 <mem_alloc.constprop.5+0x1c4>
   1845e:	eb03 08c6 	add.w	r8, r3, r6, lsl #3
   18462:	e9d8 2424 	ldrd	r2, r4, [r8, #144]	; 0x90
   18466:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1846a:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   1846e:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   18472:	f8d2 e004 	ldr.w	lr, [r2, #4]
   18476:	691d      	ldr	r5, [r3, #16]
   18478:	2c00      	cmp	r4, #0
   1847a:	d056      	beq.n	1852a <mem_alloc.constprop.5+0x1aa>
   1847c:	462a      	mov	r2, r5
   1847e:	4670      	mov	r0, lr
   18480:	00a4      	lsls	r4, r4, #2
   18482:	eb05 0904 	add.w	r9, r5, r4
   18486:	8851      	ldrh	r1, [r2, #2]
   18488:	3204      	adds	r2, #4
   1848a:	4591      	cmp	r9, r2
   1848c:	4408      	add	r0, r1
   1848e:	d1fa      	bne.n	18486 <mem_alloc.constprop.5+0x106>
   18490:	1929      	adds	r1, r5, r4
   18492:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   18496:	4482      	add	sl, r0
   18498:	4582      	cmp	sl, r0
   1849a:	d918      	bls.n	184ce <mem_alloc.constprop.5+0x14e>
   1849c:	0941      	lsrs	r1, r0, #5
   1849e:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   184a2:	f000 041f 	and.w	r4, r0, #31
   184a6:	fa22 f904 	lsr.w	r9, r2, r4
   184aa:	f019 0f01 	tst.w	r9, #1
   184ae:	d007      	beq.n	184c0 <mem_alloc.constprop.5+0x140>
   184b0:	e013      	b.n	184da <mem_alloc.constprop.5+0x15a>
   184b2:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   184b6:	fa22 f904 	lsr.w	r9, r2, r4
   184ba:	f019 0f01 	tst.w	r9, #1
   184be:	d10c      	bne.n	184da <mem_alloc.constprop.5+0x15a>
   184c0:	3001      	adds	r0, #1
   184c2:	4582      	cmp	sl, r0
   184c4:	ea4f 1150 	mov.w	r1, r0, lsr #5
   184c8:	f000 041f 	and.w	r4, r0, #31
   184cc:	d1f1      	bne.n	184b2 <mem_alloc.constprop.5+0x132>
   184ce:	3601      	adds	r6, #1
   184d0:	455e      	cmp	r6, fp
   184d2:	f108 0808 	add.w	r8, r8, #8
   184d6:	d3c4      	bcc.n	18462 <mem_alloc.constprop.5+0xe2>
   184d8:	e7b6      	b.n	18448 <mem_alloc.constprop.5+0xc8>
   184da:	2601      	movs	r6, #1
   184dc:	fa06 f404 	lsl.w	r4, r6, r4
   184e0:	899e      	ldrh	r6, [r3, #12]
   184e2:	ea22 0204 	bic.w	r2, r2, r4
   184e6:	eba0 000e 	sub.w	r0, r0, lr
   184ea:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
   184ee:	685c      	ldr	r4, [r3, #4]
   184f0:	2e00      	cmp	r6, #0
   184f2:	d0a9      	beq.n	18448 <mem_alloc.constprop.5+0xc8>
   184f4:	886a      	ldrh	r2, [r5, #2]
   184f6:	4282      	cmp	r2, r0
   184f8:	d811      	bhi.n	1851e <mem_alloc.constprop.5+0x19e>
   184fa:	2100      	movs	r1, #0
   184fc:	1d2b      	adds	r3, r5, #4
   184fe:	e003      	b.n	18508 <mem_alloc.constprop.5+0x188>
   18500:	885a      	ldrh	r2, [r3, #2]
   18502:	3304      	adds	r3, #4
   18504:	4282      	cmp	r2, r0
   18506:	d80a      	bhi.n	1851e <mem_alloc.constprop.5+0x19e>
   18508:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   1850c:	3101      	adds	r1, #1
   1850e:	428e      	cmp	r6, r1
   18510:	fb02 4405 	mla	r4, r2, r5, r4
   18514:	eba0 0002 	sub.w	r0, r0, r2
   18518:	461d      	mov	r5, r3
   1851a:	d1f1      	bne.n	18500 <mem_alloc.constprop.5+0x180>
   1851c:	e794      	b.n	18448 <mem_alloc.constprop.5+0xc8>
   1851e:	882b      	ldrh	r3, [r5, #0]
   18520:	fb00 4003 	mla	r0, r0, r3, r4
   18524:	b003      	add	sp, #12
   18526:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1852a:	4670      	mov	r0, lr
   1852c:	e7b0      	b.n	18490 <mem_alloc.constprop.5+0x110>
   1852e:	f1bb 0f10 	cmp.w	fp, #16
   18532:	bf08      	it	eq
   18534:	260f      	moveq	r6, #15
   18536:	d090      	beq.n	1845a <mem_alloc.constprop.5+0xda>
   18538:	e786      	b.n	18448 <mem_alloc.constprop.5+0xc8>
   1853a:	bf00      	nop
   1853c:	20020a1c 	.word	0x20020a1c
   18540:	200209e0 	.word	0x200209e0
   18544:	2002099c 	.word	0x2002099c

00018548 <mem_alloc.constprop.4>:
   18548:	2800      	cmp	r0, #0
   1854a:	d04c      	beq.n	185e6 <mem_alloc.constprop.4+0x9e>
   1854c:	4b6b      	ldr	r3, [pc, #428]	; (186fc <mem_alloc.constprop.4+0x1b4>)
   1854e:	681a      	ldr	r2, [r3, #0]
   18550:	4290      	cmp	r0, r2
   18552:	d848      	bhi.n	185e6 <mem_alloc.constprop.4+0x9e>
   18554:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18558:	685f      	ldr	r7, [r3, #4]
   1855a:	b083      	sub	sp, #12
   1855c:	9700      	str	r7, [sp, #0]
   1855e:	2f00      	cmp	r7, #0
   18560:	d051      	beq.n	18606 <mem_alloc.constprop.4+0xbe>
   18562:	1e7a      	subs	r2, r7, #1
   18564:	4696      	mov	lr, r2
   18566:	2100      	movs	r1, #0
   18568:	f04f 0c01 	mov.w	ip, #1
   1856c:	4c64      	ldr	r4, [pc, #400]	; (18700 <mem_alloc.constprop.4+0x1b8>)
   1856e:	9201      	str	r2, [sp, #4]
   18570:	eb01 020e 	add.w	r2, r1, lr
   18574:	3201      	adds	r2, #1
   18576:	f853 503c 	ldr.w	r5, [r3, ip, lsl #3]
   1857a:	0852      	lsrs	r2, r2, #1
   1857c:	f102 0801 	add.w	r8, r2, #1
   18580:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   18584:	f853 9037 	ldr.w	r9, [r3, r7, lsl #3]
   18588:	f854 a025 	ldr.w	sl, [r4, r5, lsl #2]
   1858c:	f853 6038 	ldr.w	r6, [r3, r8, lsl #3]
   18590:	eb09 0549 	add.w	r5, r9, r9, lsl #1
   18594:	eb03 09cc 	add.w	r9, r3, ip, lsl #3
   18598:	f8d9 9004 	ldr.w	r9, [r9, #4]
   1859c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   185a0:	f8da a010 	ldr.w	sl, [sl, #16]
   185a4:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   185a8:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   185ac:	f83a a029 	ldrh.w	sl, [sl, r9, lsl #2]
   185b0:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
   185b4:	eb03 09c7 	add.w	r9, r3, r7, lsl #3
   185b8:	6936      	ldr	r6, [r6, #16]
   185ba:	f8db b004 	ldr.w	fp, [fp, #4]
   185be:	692d      	ldr	r5, [r5, #16]
   185c0:	f8d9 9004 	ldr.w	r9, [r9, #4]
   185c4:	4550      	cmp	r0, sl
   185c6:	f836 602b 	ldrh.w	r6, [r6, fp, lsl #2]
   185ca:	f835 5029 	ldrh.w	r5, [r5, r9, lsl #2]
   185ce:	d913      	bls.n	185f8 <mem_alloc.constprop.4+0xb0>
   185d0:	42a8      	cmp	r0, r5
   185d2:	d210      	bcs.n	185f6 <mem_alloc.constprop.4+0xae>
   185d4:	42b0      	cmp	r0, r6
   185d6:	d908      	bls.n	185ea <mem_alloc.constprop.4+0xa2>
   185d8:	45c6      	cmp	lr, r8
   185da:	4641      	mov	r1, r8
   185dc:	f0c0 8087 	bcc.w	186ee <mem_alloc.constprop.4+0x1a6>
   185e0:	f108 0c01 	add.w	ip, r8, #1
   185e4:	e7c4      	b.n	18570 <mem_alloc.constprop.4+0x28>
   185e6:	2000      	movs	r0, #0
   185e8:	4770      	bx	lr
   185ea:	f102 3eff 	add.w	lr, r2, #4294967295
   185ee:	4571      	cmp	r1, lr
   185f0:	d87d      	bhi.n	186ee <mem_alloc.constprop.4+0x1a6>
   185f2:	4617      	mov	r7, r2
   185f4:	e7bc      	b.n	18570 <mem_alloc.constprop.4+0x28>
   185f6:	4639      	mov	r1, r7
   185f8:	9a00      	ldr	r2, [sp, #0]
   185fa:	428a      	cmp	r2, r1
   185fc:	d007      	beq.n	1860e <mem_alloc.constprop.4+0xc6>
   185fe:	2910      	cmp	r1, #16
   18600:	d001      	beq.n	18606 <mem_alloc.constprop.4+0xbe>
   18602:	428a      	cmp	r2, r1
   18604:	d808      	bhi.n	18618 <mem_alloc.constprop.4+0xd0>
   18606:	2000      	movs	r0, #0
   18608:	b003      	add	sp, #12
   1860a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1860e:	9a01      	ldr	r2, [sp, #4]
   18610:	2a10      	cmp	r2, #16
   18612:	bf18      	it	ne
   18614:	4611      	movne	r1, r2
   18616:	d0f6      	beq.n	18606 <mem_alloc.constprop.4+0xbe>
   18618:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 18704 <mem_alloc.constprop.4+0x1bc>
   1861c:	f8dd 9000 	ldr.w	r9, [sp]
   18620:	eb03 08c1 	add.w	r8, r3, r1, lsl #3
   18624:	e9d8 2602 	ldrd	r2, r6, [r8, #8]
   18628:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   1862c:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
   18630:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   18634:	f8d2 e004 	ldr.w	lr, [r2, #4]
   18638:	691f      	ldr	r7, [r3, #16]
   1863a:	2e00      	cmp	r6, #0
   1863c:	d055      	beq.n	186ea <mem_alloc.constprop.4+0x1a2>
   1863e:	463a      	mov	r2, r7
   18640:	4670      	mov	r0, lr
   18642:	00b6      	lsls	r6, r6, #2
   18644:	eb07 0a06 	add.w	sl, r7, r6
   18648:	8855      	ldrh	r5, [r2, #2]
   1864a:	3204      	adds	r2, #4
   1864c:	4592      	cmp	sl, r2
   1864e:	4428      	add	r0, r5
   18650:	d1fa      	bne.n	18648 <mem_alloc.constprop.4+0x100>
   18652:	19bd      	adds	r5, r7, r6
   18654:	f8b5 b002 	ldrh.w	fp, [r5, #2]
   18658:	4483      	add	fp, r0
   1865a:	4583      	cmp	fp, r0
   1865c:	d918      	bls.n	18690 <mem_alloc.constprop.4+0x148>
   1865e:	0945      	lsrs	r5, r0, #5
   18660:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   18664:	f000 061f 	and.w	r6, r0, #31
   18668:	fa22 fa06 	lsr.w	sl, r2, r6
   1866c:	f01a 0f01 	tst.w	sl, #1
   18670:	d007      	beq.n	18682 <mem_alloc.constprop.4+0x13a>
   18672:	e013      	b.n	1869c <mem_alloc.constprop.4+0x154>
   18674:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   18678:	fa22 fa06 	lsr.w	sl, r2, r6
   1867c:	f01a 0f01 	tst.w	sl, #1
   18680:	d10c      	bne.n	1869c <mem_alloc.constprop.4+0x154>
   18682:	3001      	adds	r0, #1
   18684:	4583      	cmp	fp, r0
   18686:	ea4f 1550 	mov.w	r5, r0, lsr #5
   1868a:	f000 061f 	and.w	r6, r0, #31
   1868e:	d1f1      	bne.n	18674 <mem_alloc.constprop.4+0x12c>
   18690:	3101      	adds	r1, #1
   18692:	4549      	cmp	r1, r9
   18694:	f108 0808 	add.w	r8, r8, #8
   18698:	d3c4      	bcc.n	18624 <mem_alloc.constprop.4+0xdc>
   1869a:	e7b4      	b.n	18606 <mem_alloc.constprop.4+0xbe>
   1869c:	2101      	movs	r1, #1
   1869e:	40b1      	lsls	r1, r6
   186a0:	899e      	ldrh	r6, [r3, #12]
   186a2:	ea22 0201 	bic.w	r2, r2, r1
   186a6:	eba0 000e 	sub.w	r0, r0, lr
   186aa:	f84c 2025 	str.w	r2, [ip, r5, lsl #2]
   186ae:	685c      	ldr	r4, [r3, #4]
   186b0:	2e00      	cmp	r6, #0
   186b2:	d0a8      	beq.n	18606 <mem_alloc.constprop.4+0xbe>
   186b4:	887a      	ldrh	r2, [r7, #2]
   186b6:	4282      	cmp	r2, r0
   186b8:	d811      	bhi.n	186de <mem_alloc.constprop.4+0x196>
   186ba:	2100      	movs	r1, #0
   186bc:	1d3b      	adds	r3, r7, #4
   186be:	e003      	b.n	186c8 <mem_alloc.constprop.4+0x180>
   186c0:	885a      	ldrh	r2, [r3, #2]
   186c2:	3304      	adds	r3, #4
   186c4:	4282      	cmp	r2, r0
   186c6:	d80a      	bhi.n	186de <mem_alloc.constprop.4+0x196>
   186c8:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   186cc:	3101      	adds	r1, #1
   186ce:	428e      	cmp	r6, r1
   186d0:	eba0 0002 	sub.w	r0, r0, r2
   186d4:	fb02 4405 	mla	r4, r2, r5, r4
   186d8:	461f      	mov	r7, r3
   186da:	d1f1      	bne.n	186c0 <mem_alloc.constprop.4+0x178>
   186dc:	e793      	b.n	18606 <mem_alloc.constprop.4+0xbe>
   186de:	883b      	ldrh	r3, [r7, #0]
   186e0:	fb00 4003 	mla	r0, r0, r3, r4
   186e4:	b003      	add	sp, #12
   186e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   186ea:	4670      	mov	r0, lr
   186ec:	e7b1      	b.n	18652 <mem_alloc.constprop.4+0x10a>
   186ee:	9a00      	ldr	r2, [sp, #0]
   186f0:	2a10      	cmp	r2, #16
   186f2:	bf08      	it	eq
   186f4:	210f      	moveq	r1, #15
   186f6:	d08f      	beq.n	18618 <mem_alloc.constprop.4+0xd0>
   186f8:	e785      	b.n	18606 <mem_alloc.constprop.4+0xbe>
   186fa:	bf00      	nop
   186fc:	20020a1c 	.word	0x20020a1c
   18700:	200209e0 	.word	0x200209e0
   18704:	2002099c 	.word	0x2002099c

00018708 <nrf_mem_init>:
   18708:	b570      	push	{r4, r5, r6, lr}
   1870a:	2200      	movs	r2, #0
   1870c:	2501      	movs	r5, #1
   1870e:	4833      	ldr	r0, [pc, #204]	; (187dc <nrf_mem_init+0xd4>)
   18710:	0951      	lsrs	r1, r2, #5
   18712:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
   18716:	f002 031f 	and.w	r3, r2, #31
   1871a:	fa05 f303 	lsl.w	r3, r5, r3
   1871e:	3201      	adds	r2, #1
   18720:	4323      	orrs	r3, r4
   18722:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   18726:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   1872a:	d1f1      	bne.n	18710 <nrf_mem_init+0x8>
   1872c:	2400      	movs	r4, #0
   1872e:	4b2c      	ldr	r3, [pc, #176]	; (187e0 <nrf_mem_init+0xd8>)
   18730:	4621      	mov	r1, r4
   18732:	223c      	movs	r2, #60	; 0x3c
   18734:	482b      	ldr	r0, [pc, #172]	; (187e4 <nrf_mem_init+0xdc>)
   18736:	601c      	str	r4, [r3, #0]
   18738:	f003 fc7f 	bl	1c03a <memset>
   1873c:	2110      	movs	r1, #16
   1873e:	2205      	movs	r2, #5
   18740:	4b29      	ldr	r3, [pc, #164]	; (187e8 <nrf_mem_init+0xe0>)
   18742:	4e2a      	ldr	r6, [pc, #168]	; (187ec <nrf_mem_init+0xe4>)
   18744:	e9c3 4400 	strd	r4, r4, [r3]
   18748:	60d9      	str	r1, [r3, #12]
   1874a:	6159      	str	r1, [r3, #20]
   1874c:	61d9      	str	r1, [r3, #28]
   1874e:	6259      	str	r1, [r3, #36]	; 0x24
   18750:	62d9      	str	r1, [r3, #44]	; 0x2c
   18752:	6359      	str	r1, [r3, #52]	; 0x34
   18754:	63d9      	str	r1, [r3, #60]	; 0x3c
   18756:	6459      	str	r1, [r3, #68]	; 0x44
   18758:	64d9      	str	r1, [r3, #76]	; 0x4c
   1875a:	6559      	str	r1, [r3, #84]	; 0x54
   1875c:	65d9      	str	r1, [r3, #92]	; 0x5c
   1875e:	6659      	str	r1, [r3, #100]	; 0x64
   18760:	66d9      	str	r1, [r3, #108]	; 0x6c
   18762:	6759      	str	r1, [r3, #116]	; 0x74
   18764:	67d9      	str	r1, [r3, #124]	; 0x7c
   18766:	609a      	str	r2, [r3, #8]
   18768:	611a      	str	r2, [r3, #16]
   1876a:	619a      	str	r2, [r3, #24]
   1876c:	621a      	str	r2, [r3, #32]
   1876e:	629a      	str	r2, [r3, #40]	; 0x28
   18770:	631a      	str	r2, [r3, #48]	; 0x30
   18772:	639a      	str	r2, [r3, #56]	; 0x38
   18774:	641a      	str	r2, [r3, #64]	; 0x40
   18776:	649a      	str	r2, [r3, #72]	; 0x48
   18778:	651a      	str	r2, [r3, #80]	; 0x50
   1877a:	659a      	str	r2, [r3, #88]	; 0x58
   1877c:	661a      	str	r2, [r3, #96]	; 0x60
   1877e:	669a      	str	r2, [r3, #104]	; 0x68
   18780:	671a      	str	r2, [r3, #112]	; 0x70
   18782:	679a      	str	r2, [r3, #120]	; 0x78
   18784:	e9c3 2120 	strd	r2, r1, [r3, #128]	; 0x80
   18788:	e9c3 4422 	strd	r4, r4, [r3, #136]	; 0x88
   1878c:	e9c3 2124 	strd	r2, r1, [r3, #144]	; 0x90
   18790:	e9c3 2126 	strd	r2, r1, [r3, #152]	; 0x98
   18794:	e9c3 2128 	strd	r2, r1, [r3, #160]	; 0xa0
   18798:	e9c3 212a 	strd	r2, r1, [r3, #168]	; 0xa8
   1879c:	e9c3 212c 	strd	r2, r1, [r3, #176]	; 0xb0
   187a0:	e9c3 212e 	strd	r2, r1, [r3, #184]	; 0xb8
   187a4:	e9c3 2130 	strd	r2, r1, [r3, #192]	; 0xc0
   187a8:	e9c3 2132 	strd	r2, r1, [r3, #200]	; 0xc8
   187ac:	e9c3 2134 	strd	r2, r1, [r3, #208]	; 0xd0
   187b0:	e9c3 2136 	strd	r2, r1, [r3, #216]	; 0xd8
   187b4:	e9c3 2138 	strd	r2, r1, [r3, #224]	; 0xe0
   187b8:	e9c3 213a 	strd	r2, r1, [r3, #232]	; 0xe8
   187bc:	e9c3 213c 	strd	r2, r1, [r3, #240]	; 0xf0
   187c0:	e9c3 213e 	strd	r2, r1, [r3, #248]	; 0xf8
   187c4:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
   187c8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   187cc:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
   187d0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   187d4:	4620      	mov	r0, r4
   187d6:	7035      	strb	r5, [r6, #0]
   187d8:	bd70      	pop	{r4, r5, r6, pc}
   187da:	bf00      	nop
   187dc:	2002099c 	.word	0x2002099c
   187e0:	200209dc 	.word	0x200209dc
   187e4:	200209e0 	.word	0x200209e0
   187e8:	20020a1c 	.word	0x20020a1c
   187ec:	20023671 	.word	0x20023671

000187f0 <nrf_mem_register>:
   187f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   187f4:	4b87      	ldr	r3, [pc, #540]	; (18a14 <nrf_mem_register+0x224>)
   187f6:	b087      	sub	sp, #28
   187f8:	781b      	ldrb	r3, [r3, #0]
   187fa:	2b00      	cmp	r3, #0
   187fc:	f000 808c 	beq.w	18918 <nrf_mem_register+0x128>
   18800:	b328      	cbz	r0, 1884e <nrf_mem_register+0x5e>
   18802:	b321      	cbz	r1, 1884e <nrf_mem_register+0x5e>
   18804:	780b      	ldrb	r3, [r1, #0]
   18806:	f8df 8218 	ldr.w	r8, [pc, #536]	; 18a20 <nrf_mem_register+0x230>
   1880a:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   1880e:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   18812:	685b      	ldr	r3, [r3, #4]
   18814:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   18818:	4463      	add	r3, ip
   1881a:	2b10      	cmp	r3, #16
   1881c:	d811      	bhi.n	18842 <nrf_mem_register+0x52>
   1881e:	f04f 0a00 	mov.w	sl, #0
   18822:	4689      	mov	r9, r1
   18824:	4b7c      	ldr	r3, [pc, #496]	; (18a18 <nrf_mem_register+0x228>)
   18826:	4f7d      	ldr	r7, [pc, #500]	; (18a1c <nrf_mem_register+0x22c>)
   18828:	681b      	ldr	r3, [r3, #0]
   1882a:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
   1882e:	9300      	str	r3, [sp, #0]
   18830:	68b9      	ldr	r1, [r7, #8]
   18832:	b191      	cbz	r1, 1885a <nrf_mem_register+0x6a>
   18834:	f10a 0a01 	add.w	sl, sl, #1
   18838:	f1ba 0f05 	cmp.w	sl, #5
   1883c:	f107 070c 	add.w	r7, r7, #12
   18840:	d1f6      	bne.n	18830 <nrf_mem_register+0x40>
   18842:	f248 1b07 	movw	fp, #33031	; 0x8107
   18846:	4658      	mov	r0, fp
   18848:	b007      	add	sp, #28
   1884a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1884e:	f248 1b0e 	movw	fp, #33038	; 0x810e
   18852:	4658      	mov	r0, fp
   18854:	b007      	add	sp, #28
   18856:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1885a:	f1bc 0f00 	cmp.w	ip, #0
   1885e:	d061      	beq.n	18924 <nrf_mem_register+0x134>
   18860:	460d      	mov	r5, r1
   18862:	460c      	mov	r4, r1
   18864:	f8d9 3010 	ldr.w	r3, [r9, #16]
   18868:	eb0e 0b03 	add.w	fp, lr, r3
   1886c:	885a      	ldrh	r2, [r3, #2]
   1886e:	f833 6b04 	ldrh.w	r6, [r3], #4
   18872:	4415      	add	r5, r2
   18874:	459b      	cmp	fp, r3
   18876:	fb02 4406 	mla	r4, r2, r6, r4
   1887a:	d1f7      	bne.n	1886c <nrf_mem_register+0x7c>
   1887c:	f8d9 3008 	ldr.w	r3, [r9, #8]
   18880:	42a3      	cmp	r3, r4
   18882:	d3d7      	bcc.n	18834 <nrf_mem_register+0x44>
   18884:	9b00      	ldr	r3, [sp, #0]
   18886:	442b      	add	r3, r5
   18888:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1888c:	d2d2      	bcs.n	18834 <nrf_mem_register+0x44>
   1888e:	4c63      	ldr	r4, [pc, #396]	; (18a1c <nrf_mem_register+0x22c>)
   18890:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   18894:	0092      	lsls	r2, r2, #2
   18896:	f8c0 a000 	str.w	sl, [r0]
   1889a:	18a0      	adds	r0, r4, r2
   1889c:	f844 9002 	str.w	r9, [r4, r2]
   188a0:	9a00      	ldr	r2, [sp, #0]
   188a2:	468b      	mov	fp, r1
   188a4:	e9c0 2501 	strd	r2, r5, [r0, #4]
   188a8:	f899 2001 	ldrb.w	r2, [r9, #1]
   188ac:	485a      	ldr	r0, [pc, #360]	; (18a18 <nrf_mem_register+0x228>)
   188ae:	2a01      	cmp	r2, #1
   188b0:	6003      	str	r3, [r0, #0]
   188b2:	d0c8      	beq.n	18846 <nrf_mem_register+0x56>
   188b4:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   188b8:	2b00      	cmp	r3, #0
   188ba:	d0c4      	beq.n	18846 <nrf_mem_register+0x56>
   188bc:	2500      	movs	r5, #0
   188be:	f8cd 9004 	str.w	r9, [sp, #4]
   188c2:	f8cd a00c 	str.w	sl, [sp, #12]
   188c6:	f8cd b014 	str.w	fp, [sp, #20]
   188ca:	9b01      	ldr	r3, [sp, #4]
   188cc:	781f      	ldrb	r7, [r3, #0]
   188ce:	691a      	ldr	r2, [r3, #16]
   188d0:	013b      	lsls	r3, r7, #4
   188d2:	eb03 0907 	add.w	r9, r3, r7
   188d6:	9300      	str	r3, [sp, #0]
   188d8:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   188dc:	6859      	ldr	r1, [r3, #4]
   188de:	f832 4025 	ldrh.w	r4, [r2, r5, lsl #2]
   188e2:	9102      	str	r1, [sp, #8]
   188e4:	bb39      	cbnz	r1, 18936 <nrf_mem_register+0x146>
   188e6:	9a03      	ldr	r2, [sp, #12]
   188e8:	60dd      	str	r5, [r3, #12]
   188ea:	609a      	str	r2, [r3, #8]
   188ec:	9b00      	ldr	r3, [sp, #0]
   188ee:	443b      	add	r3, r7
   188f0:	461f      	mov	r7, r3
   188f2:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
   188f6:	684b      	ldr	r3, [r1, #4]
   188f8:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
   188fc:	3301      	adds	r3, #1
   188fe:	4294      	cmp	r4, r2
   18900:	604b      	str	r3, [r1, #4]
   18902:	d912      	bls.n	1892a <nrf_mem_register+0x13a>
   18904:	9b01      	ldr	r3, [sp, #4]
   18906:	f848 4037 	str.w	r4, [r8, r7, lsl #3]
   1890a:	899b      	ldrh	r3, [r3, #12]
   1890c:	3501      	adds	r5, #1
   1890e:	429d      	cmp	r5, r3
   18910:	d3db      	bcc.n	188ca <nrf_mem_register+0xda>
   18912:	f8dd b014 	ldr.w	fp, [sp, #20]
   18916:	e796      	b.n	18846 <nrf_mem_register+0x56>
   18918:	f248 1b08 	movw	fp, #33032	; 0x8108
   1891c:	4658      	mov	r0, fp
   1891e:	b007      	add	sp, #28
   18920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18924:	9b00      	ldr	r3, [sp, #0]
   18926:	4665      	mov	r5, ip
   18928:	e7ae      	b.n	18888 <nrf_mem_register+0x98>
   1892a:	9b01      	ldr	r3, [sp, #4]
   1892c:	3501      	adds	r5, #1
   1892e:	899b      	ldrh	r3, [r3, #12]
   18930:	42ab      	cmp	r3, r5
   18932:	d8ca      	bhi.n	188ca <nrf_mem_register+0xda>
   18934:	e7ed      	b.n	18912 <nrf_mem_register+0x122>
   18936:	2600      	movs	r6, #0
   18938:	f101 3aff 	add.w	sl, r1, #4294967295
   1893c:	9504      	str	r5, [sp, #16]
   1893e:	eb06 000a 	add.w	r0, r6, sl
   18942:	eb09 0206 	add.w	r2, r9, r6
   18946:	3201      	adds	r2, #1
   18948:	3001      	adds	r0, #1
   1894a:	f858 c032 	ldr.w	ip, [r8, r2, lsl #3]
   1894e:	0840      	lsrs	r0, r0, #1
   18950:	4d32      	ldr	r5, [pc, #200]	; (18a1c <nrf_mem_register+0x22c>)
   18952:	eb09 0100 	add.w	r1, r9, r0
   18956:	eb09 030a 	add.w	r3, r9, sl
   1895a:	3101      	adds	r1, #1
   1895c:	3301      	adds	r3, #1
   1895e:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   18962:	f858 e031 	ldr.w	lr, [r8, r1, lsl #3]
   18966:	f855 b02c 	ldr.w	fp, [r5, ip, lsl #2]
   1896a:	f858 c033 	ldr.w	ip, [r8, r3, lsl #3]
   1896e:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
   18972:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   18976:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   1897a:	f8db b010 	ldr.w	fp, [fp, #16]
   1897e:	6852      	ldr	r2, [r2, #4]
   18980:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
   18984:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
   18988:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
   1898c:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   18990:	f83b 2022 	ldrh.w	r2, [fp, r2, lsl #2]
   18994:	f8de e010 	ldr.w	lr, [lr, #16]
   18998:	6849      	ldr	r1, [r1, #4]
   1899a:	f8dc c010 	ldr.w	ip, [ip, #16]
   1899e:	685b      	ldr	r3, [r3, #4]
   189a0:	4294      	cmp	r4, r2
   189a2:	f83e 1021 	ldrh.w	r1, [lr, r1, lsl #2]
   189a6:	f83c 3023 	ldrh.w	r3, [ip, r3, lsl #2]
   189aa:	d92d      	bls.n	18a08 <nrf_mem_register+0x218>
   189ac:	429c      	cmp	r4, r3
   189ae:	d22d      	bcs.n	18a0c <nrf_mem_register+0x21c>
   189b0:	428c      	cmp	r4, r1
   189b2:	d924      	bls.n	189fe <nrf_mem_register+0x20e>
   189b4:	1c46      	adds	r6, r0, #1
   189b6:	45b2      	cmp	sl, r6
   189b8:	d2c1      	bcs.n	1893e <nrf_mem_register+0x14e>
   189ba:	2610      	movs	r6, #16
   189bc:	9d04      	ldr	r5, [sp, #16]
   189be:	9a02      	ldr	r2, [sp, #8]
   189c0:	42b2      	cmp	r2, r6
   189c2:	d911      	bls.n	189e8 <nrf_mem_register+0x1f8>
   189c4:	9b00      	ldr	r3, [sp, #0]
   189c6:	443b      	add	r3, r7
   189c8:	441a      	add	r2, r3
   189ca:	4433      	add	r3, r6
   189cc:	eb08 0ac2 	add.w	sl, r8, r2, lsl #3
   189d0:	eb08 09c3 	add.w	r9, r8, r3, lsl #3
   189d4:	2208      	movs	r2, #8
   189d6:	4651      	mov	r1, sl
   189d8:	eb0a 0002 	add.w	r0, sl, r2
   189dc:	f1aa 0a08 	sub.w	sl, sl, #8
   189e0:	f003 fb00 	bl	1bfe4 <memcpy>
   189e4:	45d1      	cmp	r9, sl
   189e6:	d1f5      	bne.n	189d4 <nrf_mem_register+0x1e4>
   189e8:	9b00      	ldr	r3, [sp, #0]
   189ea:	9903      	ldr	r1, [sp, #12]
   189ec:	443b      	add	r3, r7
   189ee:	4433      	add	r3, r6
   189f0:	3301      	adds	r3, #1
   189f2:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
   189f6:	f848 1033 	str.w	r1, [r8, r3, lsl #3]
   189fa:	6055      	str	r5, [r2, #4]
   189fc:	e776      	b.n	188ec <nrf_mem_register+0xfc>
   189fe:	f100 3aff 	add.w	sl, r0, #4294967295
   18a02:	4556      	cmp	r6, sl
   18a04:	d99b      	bls.n	1893e <nrf_mem_register+0x14e>
   18a06:	e7d8      	b.n	189ba <nrf_mem_register+0x1ca>
   18a08:	9d04      	ldr	r5, [sp, #16]
   18a0a:	e7d8      	b.n	189be <nrf_mem_register+0x1ce>
   18a0c:	9d04      	ldr	r5, [sp, #16]
   18a0e:	f10a 0601 	add.w	r6, sl, #1
   18a12:	e7d4      	b.n	189be <nrf_mem_register+0x1ce>
   18a14:	20023671 	.word	0x20023671
   18a18:	200209dc 	.word	0x200209dc
   18a1c:	200209e0 	.word	0x200209e0
   18a20:	20020a1c 	.word	0x20020a1c

00018a24 <nrf_malloc>:
   18a24:	4b03      	ldr	r3, [pc, #12]	; (18a34 <nrf_malloc+0x10>)
   18a26:	781b      	ldrb	r3, [r3, #0]
   18a28:	b10b      	cbz	r3, 18a2e <nrf_malloc+0xa>
   18a2a:	f7ff bd8d 	b.w	18548 <mem_alloc.constprop.4>
   18a2e:	4618      	mov	r0, r3
   18a30:	4770      	bx	lr
   18a32:	bf00      	nop
   18a34:	20023671 	.word	0x20023671

00018a38 <nrf_free>:
   18a38:	4b04      	ldr	r3, [pc, #16]	; (18a4c <nrf_free+0x14>)
   18a3a:	781b      	ldrb	r3, [r3, #0]
   18a3c:	b123      	cbz	r3, 18a48 <nrf_free+0x10>
   18a3e:	b118      	cbz	r0, 18a48 <nrf_free+0x10>
   18a40:	4601      	mov	r1, r0
   18a42:	2000      	movs	r0, #0
   18a44:	f7ff bc30 	b.w	182a8 <mem_free>
   18a48:	4770      	bx	lr
   18a4a:	bf00      	nop
   18a4c:	20023671 	.word	0x20023671

00018a50 <nrf_shared_malloc>:
   18a50:	4b03      	ldr	r3, [pc, #12]	; (18a60 <nrf_shared_malloc+0x10>)
   18a52:	781b      	ldrb	r3, [r3, #0]
   18a54:	b10b      	cbz	r3, 18a5a <nrf_shared_malloc+0xa>
   18a56:	f7ff bc93 	b.w	18380 <mem_alloc.constprop.5>
   18a5a:	4618      	mov	r0, r3
   18a5c:	4770      	bx	lr
   18a5e:	bf00      	nop
   18a60:	20023671 	.word	0x20023671

00018a64 <nrf_shared_free>:
   18a64:	4b04      	ldr	r3, [pc, #16]	; (18a78 <nrf_shared_free+0x14>)
   18a66:	781b      	ldrb	r3, [r3, #0]
   18a68:	b123      	cbz	r3, 18a74 <nrf_shared_free+0x10>
   18a6a:	b118      	cbz	r0, 18a74 <nrf_shared_free+0x10>
   18a6c:	4601      	mov	r1, r0
   18a6e:	2001      	movs	r0, #1
   18a70:	f7ff bc1a 	b.w	182a8 <mem_free>
   18a74:	4770      	bx	lr
   18a76:	bf00      	nop
   18a78:	20023671 	.word	0x20023671

00018a7c <rpc_dfu_event_handler>:
   18a7c:	b508      	push	{r3, lr}
   18a7e:	4a08      	ldr	r2, [pc, #32]	; (18aa0 <rpc_dfu_event_handler+0x24>)
   18a80:	68c1      	ldr	r1, [r0, #12]
   18a82:	8812      	ldrh	r2, [r2, #0]
   18a84:	4603      	mov	r3, r0
   18a86:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   18a8a:	d005      	beq.n	18a98 <rpc_dfu_event_handler+0x1c>
   18a8c:	6800      	ldr	r0, [r0, #0]
   18a8e:	b110      	cbz	r0, 18a96 <rpc_dfu_event_handler+0x1a>
   18a90:	f7fd fa90 	bl	15fb4 <rpc_dfu_client_data_free>
   18a94:	2000      	movs	r0, #0
   18a96:	bd08      	pop	{r3, pc}
   18a98:	4a02      	ldr	r2, [pc, #8]	; (18aa4 <rpc_dfu_event_handler+0x28>)
   18a9a:	2001      	movs	r0, #1
   18a9c:	6013      	str	r3, [r2, #0]
   18a9e:	bd08      	pop	{r3, pc}
   18aa0:	2002209c 	.word	0x2002209c
   18aa4:	20020b38 	.word	0x20020b38

00018aa8 <mfu_interface_init>:
   18aa8:	2300      	movs	r3, #0
   18aaa:	b510      	push	{r4, lr}
   18aac:	4808      	ldr	r0, [pc, #32]	; (18ad0 <mfu_interface_init+0x28>)
   18aae:	4909      	ldr	r1, [pc, #36]	; (18ad4 <mfu_interface_init+0x2c>)
   18ab0:	4a09      	ldr	r2, [pc, #36]	; (18ad8 <mfu_interface_init+0x30>)
   18ab2:	4c0a      	ldr	r4, [pc, #40]	; (18adc <mfu_interface_init+0x34>)
   18ab4:	8003      	strh	r3, [r0, #0]
   18ab6:	600b      	str	r3, [r1, #0]
   18ab8:	6013      	str	r3, [r2, #0]
   18aba:	6023      	str	r3, [r4, #0]
   18abc:	f7fd fa44 	bl	15f48 <rpc_dfu_client_init>
   18ac0:	b910      	cbnz	r0, 18ac8 <mfu_interface_init+0x20>
   18ac2:	2301      	movs	r3, #1
   18ac4:	6023      	str	r3, [r4, #0]
   18ac6:	bd10      	pop	{r4, pc}
   18ac8:	f04f 30ff 	mov.w	r0, #4294967295
   18acc:	bd10      	pop	{r4, pc}
   18ace:	bf00      	nop
   18ad0:	2002209c 	.word	0x2002209c
   18ad4:	20020b38 	.word	0x20020b38
   18ad8:	20020b34 	.word	0x20020b34
   18adc:	20020b2c 	.word	0x20020b2c

00018ae0 <mfu_interface_open>:
   18ae0:	b508      	push	{r3, lr}
   18ae2:	4b07      	ldr	r3, [pc, #28]	; (18b00 <mfu_interface_open+0x20>)
   18ae4:	681a      	ldr	r2, [r3, #0]
   18ae6:	2a01      	cmp	r2, #1
   18ae8:	d103      	bne.n	18af2 <mfu_interface_open+0x12>
   18aea:	2202      	movs	r2, #2
   18aec:	601a      	str	r2, [r3, #0]
   18aee:	4805      	ldr	r0, [pc, #20]	; (18b04 <mfu_interface_open+0x24>)
   18af0:	bd08      	pop	{r3, pc}
   18af2:	2001      	movs	r0, #1
   18af4:	f7f7 fa9a 	bl	1002c <bsd_os_errno_set>
   18af8:	f04f 30ff 	mov.w	r0, #4294967295
   18afc:	bd08      	pop	{r3, pc}
   18afe:	bf00      	nop
   18b00:	20020b2c 	.word	0x20020b2c
   18b04:	49765432 	.word	0x49765432

00018b08 <mfu_interface_close>:
   18b08:	b5f0      	push	{r4, r5, r6, r7, lr}
   18b0a:	4c32      	ldr	r4, [pc, #200]	; (18bd4 <mfu_interface_close+0xcc>)
   18b0c:	b083      	sub	sp, #12
   18b0e:	6823      	ldr	r3, [r4, #0]
   18b10:	1e9a      	subs	r2, r3, #2
   18b12:	2a01      	cmp	r2, #1
   18b14:	d857      	bhi.n	18bc6 <mfu_interface_close+0xbe>
   18b16:	2b03      	cmp	r3, #3
   18b18:	d004      	beq.n	18b24 <mfu_interface_close+0x1c>
   18b1a:	2301      	movs	r3, #1
   18b1c:	2000      	movs	r0, #0
   18b1e:	6023      	str	r3, [r4, #0]
   18b20:	b003      	add	sp, #12
   18b22:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18b24:	2100      	movs	r1, #0
   18b26:	4668      	mov	r0, sp
   18b28:	f7fd fa14 	bl	15f54 <rpc_dfu_client_request_alloc>
   18b2c:	4603      	mov	r3, r0
   18b2e:	2800      	cmp	r0, #0
   18b30:	d13d      	bne.n	18bae <mfu_interface_close+0xa6>
   18b32:	2104      	movs	r1, #4
   18b34:	4e28      	ldr	r6, [pc, #160]	; (18bd8 <mfu_interface_close+0xd0>)
   18b36:	9800      	ldr	r0, [sp, #0]
   18b38:	8832      	ldrh	r2, [r6, #0]
   18b3a:	7201      	strb	r1, [r0, #8]
   18b3c:	3201      	adds	r2, #1
   18b3e:	b292      	uxth	r2, r2
   18b40:	0411      	lsls	r1, r2, #16
   18b42:	f041 0106 	orr.w	r1, r1, #6
   18b46:	4d25      	ldr	r5, [pc, #148]	; (18bdc <mfu_interface_close+0xd4>)
   18b48:	60c1      	str	r1, [r0, #12]
   18b4a:	7103      	strb	r3, [r0, #4]
   18b4c:	7143      	strb	r3, [r0, #5]
   18b4e:	7183      	strb	r3, [r0, #6]
   18b50:	71c3      	strb	r3, [r0, #7]
   18b52:	7243      	strb	r3, [r0, #9]
   18b54:	7283      	strb	r3, [r0, #10]
   18b56:	72c3      	strb	r3, [r0, #11]
   18b58:	2106      	movs	r1, #6
   18b5a:	8032      	strh	r2, [r6, #0]
   18b5c:	602b      	str	r3, [r5, #0]
   18b5e:	f7fd fa0d 	bl	15f7c <rpc_dfu_client_request_send>
   18b62:	b9d8      	cbnz	r0, 18b9c <mfu_interface_close+0x94>
   18b64:	f04f 33ff 	mov.w	r3, #4294967295
   18b68:	ae02      	add	r6, sp, #8
   18b6a:	4627      	mov	r7, r4
   18b6c:	f846 3d04 	str.w	r3, [r6, #-4]!
   18b70:	e004      	b.n	18b7c <mfu_interface_close+0x74>
   18b72:	4631      	mov	r1, r6
   18b74:	4638      	mov	r0, r7
   18b76:	f7f7 f9a3 	bl	fec0 <bsd_os_timedwait>
   18b7a:	b9f0      	cbnz	r0, 18bba <mfu_interface_close+0xb2>
   18b7c:	6828      	ldr	r0, [r5, #0]
   18b7e:	2800      	cmp	r0, #0
   18b80:	d0f7      	beq.n	18b72 <mfu_interface_close+0x6a>
   18b82:	6905      	ldr	r5, [r0, #16]
   18b84:	f7fd fa0e 	bl	15fa4 <rpc_dfu_client_message_free>
   18b88:	2d00      	cmp	r5, #0
   18b8a:	d0c6      	beq.n	18b1a <mfu_interface_close+0x12>
   18b8c:	4b14      	ldr	r3, [pc, #80]	; (18be0 <mfu_interface_close+0xd8>)
   18b8e:	2008      	movs	r0, #8
   18b90:	601d      	str	r5, [r3, #0]
   18b92:	f7f7 fa4b 	bl	1002c <bsd_os_errno_set>
   18b96:	f04f 30ff 	mov.w	r0, #4294967295
   18b9a:	e7c1      	b.n	18b20 <mfu_interface_close+0x18>
   18b9c:	9800      	ldr	r0, [sp, #0]
   18b9e:	6803      	ldr	r3, [r0, #0]
   18ba0:	b11b      	cbz	r3, 18baa <mfu_interface_close+0xa2>
   18ba2:	4618      	mov	r0, r3
   18ba4:	f7fd fa06 	bl	15fb4 <rpc_dfu_client_data_free>
   18ba8:	9800      	ldr	r0, [sp, #0]
   18baa:	f7fd f9fb 	bl	15fa4 <rpc_dfu_client_message_free>
   18bae:	200c      	movs	r0, #12
   18bb0:	f7f7 fa3c 	bl	1002c <bsd_os_errno_set>
   18bb4:	f04f 30ff 	mov.w	r0, #4294967295
   18bb8:	e7b2      	b.n	18b20 <mfu_interface_close+0x18>
   18bba:	203c      	movs	r0, #60	; 0x3c
   18bbc:	f7f7 fa36 	bl	1002c <bsd_os_errno_set>
   18bc0:	f04f 30ff 	mov.w	r0, #4294967295
   18bc4:	e7ac      	b.n	18b20 <mfu_interface_close+0x18>
   18bc6:	2001      	movs	r0, #1
   18bc8:	f7f7 fa30 	bl	1002c <bsd_os_errno_set>
   18bcc:	f04f 30ff 	mov.w	r0, #4294967295
   18bd0:	e7a6      	b.n	18b20 <mfu_interface_close+0x18>
   18bd2:	bf00      	nop
   18bd4:	20020b2c 	.word	0x20020b2c
   18bd8:	2002209c 	.word	0x2002209c
   18bdc:	20020b38 	.word	0x20020b38
   18be0:	20020b30 	.word	0x20020b30

00018be4 <mfu_interface_sendto>:
   18be4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   18be8:	4e64      	ldr	r6, [pc, #400]	; (18d7c <mfu_interface_sendto+0x198>)
   18bea:	460f      	mov	r7, r1
   18bec:	6831      	ldr	r1, [r6, #0]
   18bee:	4615      	mov	r5, r2
   18bf0:	1e8a      	subs	r2, r1, #2
   18bf2:	2a01      	cmp	r2, #1
   18bf4:	b082      	sub	sp, #8
   18bf6:	f200 80b4 	bhi.w	18d62 <mfu_interface_sendto+0x17e>
   18bfa:	2f00      	cmp	r7, #0
   18bfc:	f000 80a5 	beq.w	18d4a <mfu_interface_sendto+0x166>
   18c00:	2d00      	cmp	r5, #0
   18c02:	f000 80a2 	beq.w	18d4a <mfu_interface_sendto+0x166>
   18c06:	2b00      	cmp	r3, #0
   18c08:	f040 80b1 	bne.w	18d6e <mfu_interface_sendto+0x18a>
   18c0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   18c0e:	2b00      	cmp	r3, #0
   18c10:	f040 80a1 	bne.w	18d56 <mfu_interface_sendto+0x172>
   18c14:	2902      	cmp	r1, #2
   18c16:	d04f      	beq.n	18cb8 <mfu_interface_sendto+0xd4>
   18c18:	46e8      	mov	r8, sp
   18c1a:	4640      	mov	r0, r8
   18c1c:	4629      	mov	r1, r5
   18c1e:	f7fd f999 	bl	15f54 <rpc_dfu_client_request_alloc>
   18c22:	4606      	mov	r6, r0
   18c24:	b140      	cbz	r0, 18c38 <mfu_interface_sendto+0x54>
   18c26:	200c      	movs	r0, #12
   18c28:	f7f7 fa00 	bl	1002c <bsd_os_errno_set>
   18c2c:	f04f 35ff 	mov.w	r5, #4294967295
   18c30:	4628      	mov	r0, r5
   18c32:	b002      	add	sp, #8
   18c34:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18c38:	9b00      	ldr	r3, [sp, #0]
   18c3a:	4639      	mov	r1, r7
   18c3c:	6818      	ldr	r0, [r3, #0]
   18c3e:	462a      	mov	r2, r5
   18c40:	f003 f9d0 	bl	1bfe4 <memcpy>
   18c44:	2104      	movs	r1, #4
   18c46:	4c4e      	ldr	r4, [pc, #312]	; (18d80 <mfu_interface_sendto+0x19c>)
   18c48:	9800      	ldr	r0, [sp, #0]
   18c4a:	8823      	ldrh	r3, [r4, #0]
   18c4c:	6045      	str	r5, [r0, #4]
   18c4e:	3301      	adds	r3, #1
   18c50:	b29b      	uxth	r3, r3
   18c52:	041a      	lsls	r2, r3, #16
   18c54:	8023      	strh	r3, [r4, #0]
   18c56:	430a      	orrs	r2, r1
   18c58:	4c4a      	ldr	r4, [pc, #296]	; (18d84 <mfu_interface_sendto+0x1a0>)
   18c5a:	60c2      	str	r2, [r0, #12]
   18c5c:	7246      	strb	r6, [r0, #9]
   18c5e:	7286      	strb	r6, [r0, #10]
   18c60:	72c6      	strb	r6, [r0, #11]
   18c62:	7201      	strb	r1, [r0, #8]
   18c64:	6026      	str	r6, [r4, #0]
   18c66:	f7fd f989 	bl	15f7c <rpc_dfu_client_request_send>
   18c6a:	2800      	cmp	r0, #0
   18c6c:	d163      	bne.n	18d36 <mfu_interface_sendto+0x152>
   18c6e:	f04f 33ff 	mov.w	r3, #4294967295
   18c72:	ae02      	add	r6, sp, #8
   18c74:	4f41      	ldr	r7, [pc, #260]	; (18d7c <mfu_interface_sendto+0x198>)
   18c76:	f846 3d04 	str.w	r3, [r6, #-4]!
   18c7a:	e004      	b.n	18c86 <mfu_interface_sendto+0xa2>
   18c7c:	4631      	mov	r1, r6
   18c7e:	4638      	mov	r0, r7
   18c80:	f7f7 f91e 	bl	fec0 <bsd_os_timedwait>
   18c84:	b978      	cbnz	r0, 18ca6 <mfu_interface_sendto+0xc2>
   18c86:	6820      	ldr	r0, [r4, #0]
   18c88:	2800      	cmp	r0, #0
   18c8a:	d0f7      	beq.n	18c7c <mfu_interface_sendto+0x98>
   18c8c:	6904      	ldr	r4, [r0, #16]
   18c8e:	f7fd f989 	bl	15fa4 <rpc_dfu_client_message_free>
   18c92:	2c00      	cmp	r4, #0
   18c94:	d0cc      	beq.n	18c30 <mfu_interface_sendto+0x4c>
   18c96:	4b3c      	ldr	r3, [pc, #240]	; (18d88 <mfu_interface_sendto+0x1a4>)
   18c98:	2008      	movs	r0, #8
   18c9a:	601c      	str	r4, [r3, #0]
   18c9c:	f04f 35ff 	mov.w	r5, #4294967295
   18ca0:	f7f7 f9c4 	bl	1002c <bsd_os_errno_set>
   18ca4:	e7c4      	b.n	18c30 <mfu_interface_sendto+0x4c>
   18ca6:	f04f 35ff 	mov.w	r5, #4294967295
   18caa:	203c      	movs	r0, #60	; 0x3c
   18cac:	f7f7 f9be 	bl	1002c <bsd_os_errno_set>
   18cb0:	4628      	mov	r0, r5
   18cb2:	b002      	add	sp, #8
   18cb4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18cb8:	46e8      	mov	r8, sp
   18cba:	4619      	mov	r1, r3
   18cbc:	4640      	mov	r0, r8
   18cbe:	f7fd f949 	bl	15f54 <rpc_dfu_client_request_alloc>
   18cc2:	4602      	mov	r2, r0
   18cc4:	2800      	cmp	r0, #0
   18cc6:	d1ae      	bne.n	18c26 <mfu_interface_sendto+0x42>
   18cc8:	f04f 0c08 	mov.w	ip, #8
   18ccc:	492c      	ldr	r1, [pc, #176]	; (18d80 <mfu_interface_sendto+0x19c>)
   18cce:	482f      	ldr	r0, [pc, #188]	; (18d8c <mfu_interface_sendto+0x1a8>)
   18cd0:	880b      	ldrh	r3, [r1, #0]
   18cd2:	6804      	ldr	r4, [r0, #0]
   18cd4:	3301      	adds	r3, #1
   18cd6:	9800      	ldr	r0, [sp, #0]
   18cd8:	b29b      	uxth	r3, r3
   18cda:	800b      	strh	r3, [r1, #0]
   18cdc:	041b      	lsls	r3, r3, #16
   18cde:	f043 0303 	orr.w	r3, r3, #3
   18ce2:	6104      	str	r4, [r0, #16]
   18ce4:	4c27      	ldr	r4, [pc, #156]	; (18d84 <mfu_interface_sendto+0x1a0>)
   18ce6:	60c3      	str	r3, [r0, #12]
   18ce8:	7102      	strb	r2, [r0, #4]
   18cea:	7142      	strb	r2, [r0, #5]
   18cec:	7182      	strb	r2, [r0, #6]
   18cee:	71c2      	strb	r2, [r0, #7]
   18cf0:	7242      	strb	r2, [r0, #9]
   18cf2:	7282      	strb	r2, [r0, #10]
   18cf4:	72c2      	strb	r2, [r0, #11]
   18cf6:	f880 c008 	strb.w	ip, [r0, #8]
   18cfa:	2103      	movs	r1, #3
   18cfc:	6022      	str	r2, [r4, #0]
   18cfe:	f7fd f93d 	bl	15f7c <rpc_dfu_client_request_send>
   18d02:	b9c0      	cbnz	r0, 18d36 <mfu_interface_sendto+0x152>
   18d04:	f04f 33ff 	mov.w	r3, #4294967295
   18d08:	f10d 0908 	add.w	r9, sp, #8
   18d0c:	f849 3d04 	str.w	r3, [r9, #-4]!
   18d10:	46b2      	mov	sl, r6
   18d12:	e005      	b.n	18d20 <mfu_interface_sendto+0x13c>
   18d14:	4649      	mov	r1, r9
   18d16:	4650      	mov	r0, sl
   18d18:	f7f7 f8d2 	bl	fec0 <bsd_os_timedwait>
   18d1c:	2800      	cmp	r0, #0
   18d1e:	d1c2      	bne.n	18ca6 <mfu_interface_sendto+0xc2>
   18d20:	6820      	ldr	r0, [r4, #0]
   18d22:	2800      	cmp	r0, #0
   18d24:	d0f6      	beq.n	18d14 <mfu_interface_sendto+0x130>
   18d26:	6904      	ldr	r4, [r0, #16]
   18d28:	f7fd f93c 	bl	15fa4 <rpc_dfu_client_message_free>
   18d2c:	2c00      	cmp	r4, #0
   18d2e:	d1b2      	bne.n	18c96 <mfu_interface_sendto+0xb2>
   18d30:	2303      	movs	r3, #3
   18d32:	6033      	str	r3, [r6, #0]
   18d34:	e771      	b.n	18c1a <mfu_interface_sendto+0x36>
   18d36:	9800      	ldr	r0, [sp, #0]
   18d38:	6803      	ldr	r3, [r0, #0]
   18d3a:	b11b      	cbz	r3, 18d44 <mfu_interface_sendto+0x160>
   18d3c:	4618      	mov	r0, r3
   18d3e:	f7fd f939 	bl	15fb4 <rpc_dfu_client_data_free>
   18d42:	9800      	ldr	r0, [sp, #0]
   18d44:	f7fd f92e 	bl	15fa4 <rpc_dfu_client_message_free>
   18d48:	e76d      	b.n	18c26 <mfu_interface_sendto+0x42>
   18d4a:	2016      	movs	r0, #22
   18d4c:	f7f7 f96e 	bl	1002c <bsd_os_errno_set>
   18d50:	f04f 35ff 	mov.w	r5, #4294967295
   18d54:	e76c      	b.n	18c30 <mfu_interface_sendto+0x4c>
   18d56:	2038      	movs	r0, #56	; 0x38
   18d58:	f7f7 f968 	bl	1002c <bsd_os_errno_set>
   18d5c:	f04f 35ff 	mov.w	r5, #4294967295
   18d60:	e766      	b.n	18c30 <mfu_interface_sendto+0x4c>
   18d62:	2001      	movs	r0, #1
   18d64:	f7f7 f962 	bl	1002c <bsd_os_errno_set>
   18d68:	f04f 35ff 	mov.w	r5, #4294967295
   18d6c:	e760      	b.n	18c30 <mfu_interface_sendto+0x4c>
   18d6e:	202d      	movs	r0, #45	; 0x2d
   18d70:	f7f7 f95c 	bl	1002c <bsd_os_errno_set>
   18d74:	f04f 35ff 	mov.w	r5, #4294967295
   18d78:	e75a      	b.n	18c30 <mfu_interface_sendto+0x4c>
   18d7a:	bf00      	nop
   18d7c:	20020b2c 	.word	0x20020b2c
   18d80:	2002209c 	.word	0x2002209c
   18d84:	20020b38 	.word	0x20020b38
   18d88:	20020b30 	.word	0x20020b30
   18d8c:	20020b34 	.word	0x20020b34

00018d90 <mfu_interface_setopt>:
   18d90:	b5f0      	push	{r4, r5, r6, r7, lr}
   18d92:	4846      	ldr	r0, [pc, #280]	; (18eac <mfu_interface_setopt+0x11c>)
   18d94:	b083      	sub	sp, #12
   18d96:	6800      	ldr	r0, [r0, #0]
   18d98:	3802      	subs	r0, #2
   18d9a:	2801      	cmp	r0, #1
   18d9c:	d877      	bhi.n	18e8e <mfu_interface_setopt+0xfe>
   18d9e:	f240 2003 	movw	r0, #515	; 0x203
   18da2:	4281      	cmp	r1, r0
   18da4:	d16d      	bne.n	18e82 <mfu_interface_setopt+0xf2>
   18da6:	3a04      	subs	r2, #4
   18da8:	2a03      	cmp	r2, #3
   18daa:	d85c      	bhi.n	18e66 <mfu_interface_setopt+0xd6>
   18dac:	e8df f002 	tbb	[pc, r2]
   18db0:	514e024b 	.word	0x514e024b
   18db4:	2407      	movs	r4, #7
   18db6:	4625      	mov	r5, r4
   18db8:	2100      	movs	r1, #0
   18dba:	4668      	mov	r0, sp
   18dbc:	f7fd f8ca 	bl	15f54 <rpc_dfu_client_request_alloc>
   18dc0:	4603      	mov	r3, r0
   18dc2:	2800      	cmp	r0, #0
   18dc4:	d138      	bne.n	18e38 <mfu_interface_setopt+0xa8>
   18dc6:	2704      	movs	r7, #4
   18dc8:	4e39      	ldr	r6, [pc, #228]	; (18eb0 <mfu_interface_setopt+0x120>)
   18dca:	9800      	ldr	r0, [sp, #0]
   18dcc:	8832      	ldrh	r2, [r6, #0]
   18dce:	4629      	mov	r1, r5
   18dd0:	3201      	adds	r2, #1
   18dd2:	b292      	uxth	r2, r2
   18dd4:	ea44 4502 	orr.w	r5, r4, r2, lsl #16
   18dd8:	4c36      	ldr	r4, [pc, #216]	; (18eb4 <mfu_interface_setopt+0x124>)
   18dda:	60c5      	str	r5, [r0, #12]
   18ddc:	7103      	strb	r3, [r0, #4]
   18dde:	7143      	strb	r3, [r0, #5]
   18de0:	7183      	strb	r3, [r0, #6]
   18de2:	71c3      	strb	r3, [r0, #7]
   18de4:	7243      	strb	r3, [r0, #9]
   18de6:	7283      	strb	r3, [r0, #10]
   18de8:	72c3      	strb	r3, [r0, #11]
   18dea:	7207      	strb	r7, [r0, #8]
   18dec:	8032      	strh	r2, [r6, #0]
   18dee:	6023      	str	r3, [r4, #0]
   18df0:	f7fd f8c4 	bl	15f7c <rpc_dfu_client_request_send>
   18df4:	b9b8      	cbnz	r0, 18e26 <mfu_interface_setopt+0x96>
   18df6:	f04f 33ff 	mov.w	r3, #4294967295
   18dfa:	ad02      	add	r5, sp, #8
   18dfc:	4e2b      	ldr	r6, [pc, #172]	; (18eac <mfu_interface_setopt+0x11c>)
   18dfe:	f845 3d04 	str.w	r3, [r5, #-4]!
   18e02:	e005      	b.n	18e10 <mfu_interface_setopt+0x80>
   18e04:	4629      	mov	r1, r5
   18e06:	4630      	mov	r0, r6
   18e08:	f7f7 f85a 	bl	fec0 <bsd_os_timedwait>
   18e0c:	2800      	cmp	r0, #0
   18e0e:	d131      	bne.n	18e74 <mfu_interface_setopt+0xe4>
   18e10:	6820      	ldr	r0, [r4, #0]
   18e12:	2800      	cmp	r0, #0
   18e14:	d0f6      	beq.n	18e04 <mfu_interface_setopt+0x74>
   18e16:	6904      	ldr	r4, [r0, #16]
   18e18:	f7fd f8c4 	bl	15fa4 <rpc_dfu_client_message_free>
   18e1c:	2c00      	cmp	r4, #0
   18e1e:	d13c      	bne.n	18e9a <mfu_interface_setopt+0x10a>
   18e20:	4620      	mov	r0, r4
   18e22:	b003      	add	sp, #12
   18e24:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18e26:	9800      	ldr	r0, [sp, #0]
   18e28:	6803      	ldr	r3, [r0, #0]
   18e2a:	b11b      	cbz	r3, 18e34 <mfu_interface_setopt+0xa4>
   18e2c:	4618      	mov	r0, r3
   18e2e:	f7fd f8c1 	bl	15fb4 <rpc_dfu_client_data_free>
   18e32:	9800      	ldr	r0, [sp, #0]
   18e34:	f7fd f8b6 	bl	15fa4 <rpc_dfu_client_message_free>
   18e38:	200c      	movs	r0, #12
   18e3a:	f7f7 f8f7 	bl	1002c <bsd_os_errno_set>
   18e3e:	f04f 30ff 	mov.w	r0, #4294967295
   18e42:	b003      	add	sp, #12
   18e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18e46:	2405      	movs	r4, #5
   18e48:	4625      	mov	r5, r4
   18e4a:	e7b5      	b.n	18db8 <mfu_interface_setopt+0x28>
   18e4c:	2408      	movs	r4, #8
   18e4e:	4625      	mov	r5, r4
   18e50:	e7b2      	b.n	18db8 <mfu_interface_setopt+0x28>
   18e52:	b1b3      	cbz	r3, 18e82 <mfu_interface_setopt+0xf2>
   18e54:	9a08      	ldr	r2, [sp, #32]
   18e56:	2a04      	cmp	r2, #4
   18e58:	d113      	bne.n	18e82 <mfu_interface_setopt+0xf2>
   18e5a:	2000      	movs	r0, #0
   18e5c:	681a      	ldr	r2, [r3, #0]
   18e5e:	4b16      	ldr	r3, [pc, #88]	; (18eb8 <mfu_interface_setopt+0x128>)
   18e60:	601a      	str	r2, [r3, #0]
   18e62:	b003      	add	sp, #12
   18e64:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18e66:	202a      	movs	r0, #42	; 0x2a
   18e68:	f7f7 f8e0 	bl	1002c <bsd_os_errno_set>
   18e6c:	f04f 30ff 	mov.w	r0, #4294967295
   18e70:	b003      	add	sp, #12
   18e72:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18e74:	203c      	movs	r0, #60	; 0x3c
   18e76:	f7f7 f8d9 	bl	1002c <bsd_os_errno_set>
   18e7a:	f04f 30ff 	mov.w	r0, #4294967295
   18e7e:	b003      	add	sp, #12
   18e80:	bdf0      	pop	{r4, r5, r6, r7, pc}
   18e82:	2016      	movs	r0, #22
   18e84:	f7f7 f8d2 	bl	1002c <bsd_os_errno_set>
   18e88:	f04f 30ff 	mov.w	r0, #4294967295
   18e8c:	e7c9      	b.n	18e22 <mfu_interface_setopt+0x92>
   18e8e:	2001      	movs	r0, #1
   18e90:	f7f7 f8cc 	bl	1002c <bsd_os_errno_set>
   18e94:	f04f 30ff 	mov.w	r0, #4294967295
   18e98:	e7c3      	b.n	18e22 <mfu_interface_setopt+0x92>
   18e9a:	4b08      	ldr	r3, [pc, #32]	; (18ebc <mfu_interface_setopt+0x12c>)
   18e9c:	2008      	movs	r0, #8
   18e9e:	601c      	str	r4, [r3, #0]
   18ea0:	f7f7 f8c4 	bl	1002c <bsd_os_errno_set>
   18ea4:	f04f 30ff 	mov.w	r0, #4294967295
   18ea8:	e7bb      	b.n	18e22 <mfu_interface_setopt+0x92>
   18eaa:	bf00      	nop
   18eac:	20020b2c 	.word	0x20020b2c
   18eb0:	2002209c 	.word	0x2002209c
   18eb4:	20020b38 	.word	0x20020b38
   18eb8:	20020b34 	.word	0x20020b34
   18ebc:	20020b30 	.word	0x20020b30

00018ec0 <mfu_interface_getopt>:
   18ec0:	f240 2003 	movw	r0, #515	; 0x203
   18ec4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   18ec8:	4281      	cmp	r1, r0
   18eca:	b082      	sub	sp, #8
   18ecc:	9e08      	ldr	r6, [sp, #32]
   18ece:	f040 80ae 	bne.w	1902e <mfu_interface_getopt+0x16e>
   18ed2:	461d      	mov	r5, r3
   18ed4:	2b00      	cmp	r3, #0
   18ed6:	f000 80aa 	beq.w	1902e <mfu_interface_getopt+0x16e>
   18eda:	2e00      	cmp	r6, #0
   18edc:	f000 80a7 	beq.w	1902e <mfu_interface_getopt+0x16e>
   18ee0:	4b5e      	ldr	r3, [pc, #376]	; (1905c <mfu_interface_getopt+0x19c>)
   18ee2:	681b      	ldr	r3, [r3, #0]
   18ee4:	3b02      	subs	r3, #2
   18ee6:	2b01      	cmp	r3, #1
   18ee8:	f200 80a7 	bhi.w	1903a <mfu_interface_getopt+0x17a>
   18eec:	3a01      	subs	r2, #1
   18eee:	2a13      	cmp	r2, #19
   18ef0:	d879      	bhi.n	18fe6 <mfu_interface_getopt+0x126>
   18ef2:	e8df f002 	tbb	[pc, r2]
   18ef6:	5f17      	.short	0x5f17
   18ef8:	78787878 	.word	0x78787878
   18efc:	78787872 	.word	0x78787872
   18f00:	78787878 	.word	0x78787878
   18f04:	78787878 	.word	0x78787878
   18f08:	0a78      	.short	0x0a78
   18f0a:	6833      	ldr	r3, [r6, #0]
   18f0c:	2b04      	cmp	r3, #4
   18f0e:	f040 808e 	bne.w	1902e <mfu_interface_getopt+0x16e>
   18f12:	2200      	movs	r2, #0
   18f14:	4610      	mov	r0, r2
   18f16:	4b52      	ldr	r3, [pc, #328]	; (19060 <mfu_interface_getopt+0x1a0>)
   18f18:	6819      	ldr	r1, [r3, #0]
   18f1a:	601a      	str	r2, [r3, #0]
   18f1c:	6029      	str	r1, [r5, #0]
   18f1e:	b002      	add	sp, #8
   18f20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18f24:	6833      	ldr	r3, [r6, #0]
   18f26:	2b24      	cmp	r3, #36	; 0x24
   18f28:	f040 8081 	bne.w	1902e <mfu_interface_getopt+0x16e>
   18f2c:	2401      	movs	r4, #1
   18f2e:	46a0      	mov	r8, r4
   18f30:	2100      	movs	r1, #0
   18f32:	4668      	mov	r0, sp
   18f34:	f7fd f80e 	bl	15f54 <rpc_dfu_client_request_alloc>
   18f38:	2800      	cmp	r0, #0
   18f3a:	d146      	bne.n	18fca <mfu_interface_getopt+0x10a>
   18f3c:	4949      	ldr	r1, [pc, #292]	; (19064 <mfu_interface_getopt+0x1a4>)
   18f3e:	9b00      	ldr	r3, [sp, #0]
   18f40:	880a      	ldrh	r2, [r1, #0]
   18f42:	f1b8 0f03 	cmp.w	r8, #3
   18f46:	f102 0201 	add.w	r2, r2, #1
   18f4a:	b292      	uxth	r2, r2
   18f4c:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
   18f50:	7118      	strb	r0, [r3, #4]
   18f52:	800a      	strh	r2, [r1, #0]
   18f54:	60dc      	str	r4, [r3, #12]
   18f56:	7158      	strb	r0, [r3, #5]
   18f58:	7198      	strb	r0, [r3, #6]
   18f5a:	71d8      	strb	r0, [r3, #7]
   18f5c:	d04b      	beq.n	18ff6 <mfu_interface_getopt+0x136>
   18f5e:	2104      	movs	r1, #4
   18f60:	2200      	movs	r2, #0
   18f62:	4f41      	ldr	r7, [pc, #260]	; (19068 <mfu_interface_getopt+0x1a8>)
   18f64:	6099      	str	r1, [r3, #8]
   18f66:	4618      	mov	r0, r3
   18f68:	4641      	mov	r1, r8
   18f6a:	603a      	str	r2, [r7, #0]
   18f6c:	f7fd f806 	bl	15f7c <rpc_dfu_client_request_send>
   18f70:	2800      	cmp	r0, #0
   18f72:	d14d      	bne.n	19010 <mfu_interface_getopt+0x150>
   18f74:	f04f 33ff 	mov.w	r3, #4294967295
   18f78:	ac02      	add	r4, sp, #8
   18f7a:	f844 3d04 	str.w	r3, [r4, #-4]!
   18f7e:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 1905c <mfu_interface_getopt+0x19c>
   18f82:	e005      	b.n	18f90 <mfu_interface_getopt+0xd0>
   18f84:	4621      	mov	r1, r4
   18f86:	4640      	mov	r0, r8
   18f88:	f7f6 ff9a 	bl	fec0 <bsd_os_timedwait>
   18f8c:	2800      	cmp	r0, #0
   18f8e:	d137      	bne.n	19000 <mfu_interface_getopt+0x140>
   18f90:	6839      	ldr	r1, [r7, #0]
   18f92:	2900      	cmp	r1, #0
   18f94:	d0f6      	beq.n	18f84 <mfu_interface_getopt+0xc4>
   18f96:	690c      	ldr	r4, [r1, #16]
   18f98:	2c00      	cmp	r4, #0
   18f9a:	d154      	bne.n	19046 <mfu_interface_getopt+0x186>
   18f9c:	6832      	ldr	r2, [r6, #0]
   18f9e:	3114      	adds	r1, #20
   18fa0:	4628      	mov	r0, r5
   18fa2:	f003 f81f 	bl	1bfe4 <memcpy>
   18fa6:	6838      	ldr	r0, [r7, #0]
   18fa8:	f7fc fffc 	bl	15fa4 <rpc_dfu_client_message_free>
   18fac:	4620      	mov	r0, r4
   18fae:	b002      	add	sp, #8
   18fb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18fb4:	6833      	ldr	r3, [r6, #0]
   18fb6:	2b04      	cmp	r3, #4
   18fb8:	d139      	bne.n	1902e <mfu_interface_getopt+0x16e>
   18fba:	2402      	movs	r4, #2
   18fbc:	2100      	movs	r1, #0
   18fbe:	4668      	mov	r0, sp
   18fc0:	46a0      	mov	r8, r4
   18fc2:	f7fc ffc7 	bl	15f54 <rpc_dfu_client_request_alloc>
   18fc6:	2800      	cmp	r0, #0
   18fc8:	d0b8      	beq.n	18f3c <mfu_interface_getopt+0x7c>
   18fca:	200c      	movs	r0, #12
   18fcc:	f7f7 f82e 	bl	1002c <bsd_os_errno_set>
   18fd0:	f04f 30ff 	mov.w	r0, #4294967295
   18fd4:	b002      	add	sp, #8
   18fd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18fda:	6833      	ldr	r3, [r6, #0]
   18fdc:	2b04      	cmp	r3, #4
   18fde:	d126      	bne.n	1902e <mfu_interface_getopt+0x16e>
   18fe0:	2409      	movs	r4, #9
   18fe2:	46a0      	mov	r8, r4
   18fe4:	e7a4      	b.n	18f30 <mfu_interface_getopt+0x70>
   18fe6:	202a      	movs	r0, #42	; 0x2a
   18fe8:	f7f7 f820 	bl	1002c <bsd_os_errno_set>
   18fec:	f04f 30ff 	mov.w	r0, #4294967295
   18ff0:	b002      	add	sp, #8
   18ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   18ff6:	4a1d      	ldr	r2, [pc, #116]	; (1906c <mfu_interface_getopt+0x1ac>)
   18ff8:	2108      	movs	r1, #8
   18ffa:	6812      	ldr	r2, [r2, #0]
   18ffc:	611a      	str	r2, [r3, #16]
   18ffe:	e7af      	b.n	18f60 <mfu_interface_getopt+0xa0>
   19000:	203c      	movs	r0, #60	; 0x3c
   19002:	f7f7 f813 	bl	1002c <bsd_os_errno_set>
   19006:	f04f 30ff 	mov.w	r0, #4294967295
   1900a:	b002      	add	sp, #8
   1900c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   19010:	9800      	ldr	r0, [sp, #0]
   19012:	6803      	ldr	r3, [r0, #0]
   19014:	b11b      	cbz	r3, 1901e <mfu_interface_getopt+0x15e>
   19016:	4618      	mov	r0, r3
   19018:	f7fc ffcc 	bl	15fb4 <rpc_dfu_client_data_free>
   1901c:	9800      	ldr	r0, [sp, #0]
   1901e:	f7fc ffc1 	bl	15fa4 <rpc_dfu_client_message_free>
   19022:	200c      	movs	r0, #12
   19024:	f7f7 f802 	bl	1002c <bsd_os_errno_set>
   19028:	f04f 30ff 	mov.w	r0, #4294967295
   1902c:	e7d2      	b.n	18fd4 <mfu_interface_getopt+0x114>
   1902e:	2016      	movs	r0, #22
   19030:	f7f6 fffc 	bl	1002c <bsd_os_errno_set>
   19034:	f04f 30ff 	mov.w	r0, #4294967295
   19038:	e771      	b.n	18f1e <mfu_interface_getopt+0x5e>
   1903a:	2001      	movs	r0, #1
   1903c:	f7f6 fff6 	bl	1002c <bsd_os_errno_set>
   19040:	f04f 30ff 	mov.w	r0, #4294967295
   19044:	e76b      	b.n	18f1e <mfu_interface_getopt+0x5e>
   19046:	4b06      	ldr	r3, [pc, #24]	; (19060 <mfu_interface_getopt+0x1a0>)
   19048:	2008      	movs	r0, #8
   1904a:	601c      	str	r4, [r3, #0]
   1904c:	f7f6 ffee 	bl	1002c <bsd_os_errno_set>
   19050:	6838      	ldr	r0, [r7, #0]
   19052:	f7fc ffa7 	bl	15fa4 <rpc_dfu_client_message_free>
   19056:	f04f 30ff 	mov.w	r0, #4294967295
   1905a:	e760      	b.n	18f1e <mfu_interface_getopt+0x5e>
   1905c:	20020b2c 	.word	0x20020b2c
   19060:	20020b30 	.word	0x20020b30
   19064:	2002209c 	.word	0x2002209c
   19068:	20020b38 	.word	0x20020b38
   1906c:	20020b34 	.word	0x20020b34

00019070 <interface_init>:
   19070:	b508      	push	{r3, lr}
   19072:	f44f 72b4 	mov.w	r2, #360	; 0x168
   19076:	2100      	movs	r1, #0
   19078:	4802      	ldr	r0, [pc, #8]	; (19084 <interface_init+0x14>)
   1907a:	f002 ffde 	bl	1c03a <memset>
   1907e:	2000      	movs	r0, #0
   19080:	bd08      	pop	{r3, pc}
   19082:	bf00      	nop
   19084:	20023674 	.word	0x20023674

00019088 <interface_socket_allocate>:
   19088:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1908a:	4b30      	ldr	r3, [pc, #192]	; (1914c <interface_socket_allocate+0xc4>)
   1908c:	4606      	mov	r6, r0
   1908e:	681d      	ldr	r5, [r3, #0]
   19090:	4608      	mov	r0, r1
   19092:	b31d      	cbz	r5, 190dc <interface_socket_allocate+0x54>
   19094:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   19096:	2c00      	cmp	r4, #0
   19098:	d04a      	beq.n	19130 <interface_socket_allocate+0xa8>
   1909a:	6d1c      	ldr	r4, [r3, #80]	; 0x50
   1909c:	2c00      	cmp	r4, #0
   1909e:	d049      	beq.n	19134 <interface_socket_allocate+0xac>
   190a0:	6f9c      	ldr	r4, [r3, #120]	; 0x78
   190a2:	2c00      	cmp	r4, #0
   190a4:	d048      	beq.n	19138 <interface_socket_allocate+0xb0>
   190a6:	f8d3 10a0 	ldr.w	r1, [r3, #160]	; 0xa0
   190aa:	2900      	cmp	r1, #0
   190ac:	d046      	beq.n	1913c <interface_socket_allocate+0xb4>
   190ae:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
   190b2:	b191      	cbz	r1, 190da <interface_socket_allocate+0x52>
   190b4:	f8d3 10f0 	ldr.w	r1, [r3, #240]	; 0xf0
   190b8:	2900      	cmp	r1, #0
   190ba:	d043      	beq.n	19144 <interface_socket_allocate+0xbc>
   190bc:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
   190c0:	2900      	cmp	r1, #0
   190c2:	d041      	beq.n	19148 <interface_socket_allocate+0xc0>
   190c4:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
   190c8:	2900      	cmp	r1, #0
   190ca:	d039      	beq.n	19140 <interface_socket_allocate+0xb8>
   190cc:	f04f 35ff 	mov.w	r5, #4294967295
   190d0:	2069      	movs	r0, #105	; 0x69
   190d2:	f7f6 ffab 	bl	1002c <bsd_os_errno_set>
   190d6:	4628      	mov	r0, r5
   190d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   190da:	2505      	movs	r5, #5
   190dc:	f04f 0c01 	mov.w	ip, #1
   190e0:	f04f 37ff 	mov.w	r7, #4294967295
   190e4:	eb05 0485 	add.w	r4, r5, r5, lsl #2
   190e8:	00e4      	lsls	r4, r4, #3
   190ea:	f843 c004 	str.w	ip, [r3, r4]
   190ee:	441c      	add	r4, r3
   190f0:	4611      	mov	r1, r2
   190f2:	61a7      	str	r7, [r4, #24]
   190f4:	4622      	mov	r2, r4
   190f6:	f7fe ff9b 	bl	18030 <packet_handler_create>
   190fa:	4603      	mov	r3, r0
   190fc:	61e0      	str	r0, [r4, #28]
   190fe:	b158      	cbz	r0, 19118 <interface_socket_allocate+0x90>
   19100:	681b      	ldr	r3, [r3, #0]
   19102:	681b      	ldr	r3, [r3, #0]
   19104:	4798      	blx	r3
   19106:	b910      	cbnz	r0, 1910e <interface_socket_allocate+0x86>
   19108:	6034      	str	r4, [r6, #0]
   1910a:	4628      	mov	r0, r5
   1910c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1910e:	69e0      	ldr	r0, [r4, #28]
   19110:	f7fe ffae 	bl	18070 <packet_handler_delete>
   19114:	2300      	movs	r3, #0
   19116:	61e3      	str	r3, [r4, #28]
   19118:	f04f 35ff 	mov.w	r5, #4294967295
   1911c:	2228      	movs	r2, #40	; 0x28
   1911e:	2100      	movs	r1, #0
   19120:	4620      	mov	r0, r4
   19122:	f002 ff8a 	bl	1c03a <memset>
   19126:	200c      	movs	r0, #12
   19128:	f7f6 ff80 	bl	1002c <bsd_os_errno_set>
   1912c:	4628      	mov	r0, r5
   1912e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19130:	2501      	movs	r5, #1
   19132:	e7d3      	b.n	190dc <interface_socket_allocate+0x54>
   19134:	2502      	movs	r5, #2
   19136:	e7d1      	b.n	190dc <interface_socket_allocate+0x54>
   19138:	2503      	movs	r5, #3
   1913a:	e7cf      	b.n	190dc <interface_socket_allocate+0x54>
   1913c:	2504      	movs	r5, #4
   1913e:	e7cd      	b.n	190dc <interface_socket_allocate+0x54>
   19140:	2508      	movs	r5, #8
   19142:	e7cb      	b.n	190dc <interface_socket_allocate+0x54>
   19144:	2506      	movs	r5, #6
   19146:	e7c9      	b.n	190dc <interface_socket_allocate+0x54>
   19148:	2507      	movs	r5, #7
   1914a:	e7c7      	b.n	190dc <interface_socket_allocate+0x54>
   1914c:	20023674 	.word	0x20023674

00019150 <interface_socket_free>:
   19150:	2808      	cmp	r0, #8
   19152:	d900      	bls.n	19156 <interface_socket_free+0x6>
   19154:	4770      	bx	lr
   19156:	b510      	push	{r4, lr}
   19158:	4c07      	ldr	r4, [pc, #28]	; (19178 <interface_socket_free+0x28>)
   1915a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   1915e:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
   19162:	69e0      	ldr	r0, [r4, #28]
   19164:	b108      	cbz	r0, 1916a <interface_socket_free+0x1a>
   19166:	f7fe ff83 	bl	18070 <packet_handler_delete>
   1916a:	4620      	mov	r0, r4
   1916c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   19170:	2228      	movs	r2, #40	; 0x28
   19172:	2100      	movs	r1, #0
   19174:	f002 bf61 	b.w	1c03a <memset>
   19178:	20023674 	.word	0x20023674

0001917c <interface_socket_packet_handler_update>:
   1917c:	2808      	cmp	r0, #8
   1917e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   19182:	d81e      	bhi.n	191c2 <interface_socket_packet_handler_update+0x46>
   19184:	ea4f 0880 	mov.w	r8, r0, lsl #2
   19188:	4e17      	ldr	r6, [pc, #92]	; (191e8 <interface_socket_packet_handler_update+0x6c>)
   1918a:	eb08 0300 	add.w	r3, r8, r0
   1918e:	00db      	lsls	r3, r3, #3
   19190:	58f4      	ldr	r4, [r6, r3]
   19192:	18f5      	adds	r5, r6, r3
   19194:	b1ac      	cbz	r4, 191c2 <interface_socket_packet_handler_update+0x46>
   19196:	460b      	mov	r3, r1
   19198:	4604      	mov	r4, r0
   1919a:	4611      	mov	r1, r2
   1919c:	4618      	mov	r0, r3
   1919e:	462a      	mov	r2, r5
   191a0:	f8d5 901c 	ldr.w	r9, [r5, #28]
   191a4:	f7fe ff44 	bl	18030 <packet_handler_create>
   191a8:	61e8      	str	r0, [r5, #28]
   191aa:	b1d0      	cbz	r0, 191e2 <interface_socket_packet_handler_update+0x66>
   191ac:	6803      	ldr	r3, [r0, #0]
   191ae:	681b      	ldr	r3, [r3, #0]
   191b0:	4798      	blx	r3
   191b2:	4607      	mov	r7, r0
   191b4:	b948      	cbnz	r0, 191ca <interface_socket_packet_handler_update+0x4e>
   191b6:	4648      	mov	r0, r9
   191b8:	f7fe ff5a 	bl	18070 <packet_handler_delete>
   191bc:	4638      	mov	r0, r7
   191be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   191c2:	2705      	movs	r7, #5
   191c4:	4638      	mov	r0, r7
   191c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   191ca:	69e8      	ldr	r0, [r5, #28]
   191cc:	f7fe ff50 	bl	18070 <packet_handler_delete>
   191d0:	eb08 0004 	add.w	r0, r8, r4
   191d4:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
   191d8:	f8c6 901c 	str.w	r9, [r6, #28]
   191dc:	4638      	mov	r0, r7
   191de:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   191e2:	2704      	movs	r7, #4
   191e4:	e7f4      	b.n	191d0 <interface_socket_packet_handler_update+0x54>
   191e6:	bf00      	nop
   191e8:	20023674 	.word	0x20023674

000191ec <interface_socket_wait>:
   191ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   191f0:	4692      	mov	sl, r2
   191f2:	ea4f 0980 	mov.w	r9, r0, lsl #2
   191f6:	4d13      	ldr	r5, [pc, #76]	; (19244 <interface_socket_wait+0x58>)
   191f8:	eb09 0400 	add.w	r4, r9, r0
   191fc:	00e4      	lsls	r4, r4, #3
   191fe:	592a      	ldr	r2, [r5, r4]
   19200:	4606      	mov	r6, r0
   19202:	ea02 020a 	and.w	r2, r2, sl
   19206:	428a      	cmp	r2, r1
   19208:	442c      	add	r4, r5
   1920a:	d013      	beq.n	19234 <interface_socket_wait+0x48>
   1920c:	4698      	mov	r8, r3
   1920e:	6863      	ldr	r3, [r4, #4]
   19210:	b983      	cbnz	r3, 19234 <interface_socket_wait+0x48>
   19212:	460f      	mov	r7, r1
   19214:	46a3      	mov	fp, r4
   19216:	e007      	b.n	19228 <interface_socket_wait+0x3c>
   19218:	f8db 3004 	ldr.w	r3, [fp, #4]
   1921c:	b953      	cbnz	r3, 19234 <interface_socket_wait+0x48>
   1921e:	4641      	mov	r1, r8
   19220:	4620      	mov	r0, r4
   19222:	f7f6 fe4d 	bl	fec0 <bsd_os_timedwait>
   19226:	b958      	cbnz	r0, 19240 <interface_socket_wait+0x54>
   19228:	f8db 3000 	ldr.w	r3, [fp]
   1922c:	ea03 030a 	and.w	r3, r3, sl
   19230:	42bb      	cmp	r3, r7
   19232:	d1f1      	bne.n	19218 <interface_socket_wait+0x2c>
   19234:	444e      	add	r6, r9
   19236:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
   1923a:	6868      	ldr	r0, [r5, #4]
   1923c:	b100      	cbz	r0, 19240 <interface_socket_wait+0x54>
   1923e:	6868      	ldr	r0, [r5, #4]
   19240:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19244:	20023674 	.word	0x20023674

00019248 <interface_from_internal_id_search>:
   19248:	4b27      	ldr	r3, [pc, #156]	; (192e8 <interface_from_internal_id_search+0xa0>)
   1924a:	681a      	ldr	r2, [r3, #0]
   1924c:	b112      	cbz	r2, 19254 <interface_from_internal_id_search+0xc>
   1924e:	699a      	ldr	r2, [r3, #24]
   19250:	4282      	cmp	r2, r0
   19252:	d039      	beq.n	192c8 <interface_from_internal_id_search+0x80>
   19254:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   19256:	b112      	cbz	r2, 1925e <interface_from_internal_id_search+0x16>
   19258:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   1925a:	4282      	cmp	r2, r0
   1925c:	d036      	beq.n	192cc <interface_from_internal_id_search+0x84>
   1925e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   19260:	b112      	cbz	r2, 19268 <interface_from_internal_id_search+0x20>
   19262:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   19264:	4282      	cmp	r2, r0
   19266:	d033      	beq.n	192d0 <interface_from_internal_id_search+0x88>
   19268:	6f9a      	ldr	r2, [r3, #120]	; 0x78
   1926a:	b11a      	cbz	r2, 19274 <interface_from_internal_id_search+0x2c>
   1926c:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   19270:	4282      	cmp	r2, r0
   19272:	d02f      	beq.n	192d4 <interface_from_internal_id_search+0x8c>
   19274:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
   19278:	b11a      	cbz	r2, 19282 <interface_from_internal_id_search+0x3a>
   1927a:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
   1927e:	4282      	cmp	r2, r0
   19280:	d02a      	beq.n	192d8 <interface_from_internal_id_search+0x90>
   19282:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
   19286:	b11a      	cbz	r2, 19290 <interface_from_internal_id_search+0x48>
   19288:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   1928c:	4282      	cmp	r2, r0
   1928e:	d025      	beq.n	192dc <interface_from_internal_id_search+0x94>
   19290:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   19294:	b11a      	cbz	r2, 1929e <interface_from_internal_id_search+0x56>
   19296:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   1929a:	4282      	cmp	r2, r0
   1929c:	d020      	beq.n	192e0 <interface_from_internal_id_search+0x98>
   1929e:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   192a2:	b11a      	cbz	r2, 192ac <interface_from_internal_id_search+0x64>
   192a4:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   192a8:	4282      	cmp	r2, r0
   192aa:	d01b      	beq.n	192e4 <interface_from_internal_id_search+0x9c>
   192ac:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   192b0:	b13a      	cbz	r2, 192c2 <interface_from_internal_id_search+0x7a>
   192b2:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   192b6:	4283      	cmp	r3, r0
   192b8:	bf14      	ite	ne
   192ba:	f04f 30ff 	movne.w	r0, #4294967295
   192be:	2008      	moveq	r0, #8
   192c0:	4770      	bx	lr
   192c2:	f04f 30ff 	mov.w	r0, #4294967295
   192c6:	4770      	bx	lr
   192c8:	2000      	movs	r0, #0
   192ca:	4770      	bx	lr
   192cc:	2001      	movs	r0, #1
   192ce:	4770      	bx	lr
   192d0:	2002      	movs	r0, #2
   192d2:	4770      	bx	lr
   192d4:	2003      	movs	r0, #3
   192d6:	4770      	bx	lr
   192d8:	2004      	movs	r0, #4
   192da:	4770      	bx	lr
   192dc:	2005      	movs	r0, #5
   192de:	4770      	bx	lr
   192e0:	2006      	movs	r0, #6
   192e2:	4770      	bx	lr
   192e4:	2007      	movs	r0, #7
   192e6:	4770      	bx	lr
   192e8:	20023674 	.word	0x20023674

000192ec <interface_socket_from_handle_get>:
   192ec:	2808      	cmp	r0, #8
   192ee:	d807      	bhi.n	19300 <interface_socket_from_handle_get+0x14>
   192f0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   192f4:	4b03      	ldr	r3, [pc, #12]	; (19304 <interface_socket_from_handle_get+0x18>)
   192f6:	00c0      	lsls	r0, r0, #3
   192f8:	581a      	ldr	r2, [r3, r0]
   192fa:	b10a      	cbz	r2, 19300 <interface_socket_from_handle_get+0x14>
   192fc:	4418      	add	r0, r3
   192fe:	4770      	bx	lr
   19300:	2000      	movs	r0, #0
   19302:	4770      	bx	lr
   19304:	20023674 	.word	0x20023674

00019308 <interface_socket_event_get>:
   19308:	b119      	cbz	r1, 19312 <interface_socket_event_get+0xa>
   1930a:	2808      	cmp	r0, #8
   1930c:	d902      	bls.n	19314 <interface_socket_event_get+0xc>
   1930e:	2310      	movs	r3, #16
   19310:	600b      	str	r3, [r1, #0]
   19312:	4770      	bx	lr
   19314:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19318:	4b07      	ldr	r3, [pc, #28]	; (19338 <interface_socket_event_get+0x30>)
   1931a:	00c0      	lsls	r0, r0, #3
   1931c:	581a      	ldr	r2, [r3, r0]
   1931e:	2a00      	cmp	r2, #0
   19320:	d0f5      	beq.n	1930e <interface_socket_event_get+0x6>
   19322:	581b      	ldr	r3, [r3, r0]
   19324:	0c1b      	lsrs	r3, r3, #16
   19326:	f003 020a 	and.w	r2, r3, #10
   1932a:	2a0a      	cmp	r2, #10
   1932c:	bf14      	ite	ne
   1932e:	f003 030f 	andne.w	r3, r3, #15
   19332:	f003 030d 	andeq.w	r3, r3, #13
   19336:	e7eb      	b.n	19310 <interface_socket_event_get+0x8>
   19338:	20023674 	.word	0x20023674

0001933c <interface_socket_setopt>:
   1933c:	2808      	cmp	r0, #8
   1933e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   19340:	d82c      	bhi.n	1939c <interface_socket_setopt+0x60>
   19342:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19346:	4e1e      	ldr	r6, [pc, #120]	; (193c0 <interface_socket_setopt+0x84>)
   19348:	00c0      	lsls	r0, r0, #3
   1934a:	5834      	ldr	r4, [r6, r0]
   1934c:	b334      	cbz	r4, 1939c <interface_socket_setopt+0x60>
   1934e:	2901      	cmp	r1, #1
   19350:	d11e      	bne.n	19390 <interface_socket_setopt+0x54>
   19352:	f1a2 0114 	sub.w	r1, r2, #20
   19356:	2901      	cmp	r1, #1
   19358:	d81a      	bhi.n	19390 <interface_socket_setopt+0x54>
   1935a:	9906      	ldr	r1, [sp, #24]
   1935c:	2908      	cmp	r1, #8
   1935e:	d123      	bne.n	193a8 <interface_socket_setopt+0x6c>
   19360:	b313      	cbz	r3, 193a8 <interface_socket_setopt+0x6c>
   19362:	6859      	ldr	r1, [r3, #4]
   19364:	4c17      	ldr	r4, [pc, #92]	; (193c4 <interface_socket_setopt+0x88>)
   19366:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
   1936a:	fba4 4101 	umull	r4, r1, r4, r1
   1936e:	0989      	lsrs	r1, r1, #6
   19370:	460c      	mov	r4, r1
   19372:	2500      	movs	r5, #0
   19374:	681b      	ldr	r3, [r3, #0]
   19376:	fbe7 4503 	umlal	r4, r5, r7, r3
   1937a:	2d01      	cmp	r5, #1
   1937c:	bf08      	it	eq
   1937e:	2c00      	cmpeq	r4, #0
   19380:	d218      	bcs.n	193b4 <interface_socket_setopt+0x78>
   19382:	4430      	add	r0, r6
   19384:	2a14      	cmp	r2, #20
   19386:	bf0c      	ite	eq
   19388:	6204      	streq	r4, [r0, #32]
   1938a:	6244      	strne	r4, [r0, #36]	; 0x24
   1938c:	2000      	movs	r0, #0
   1938e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   19390:	202a      	movs	r0, #42	; 0x2a
   19392:	f7f6 fe4b 	bl	1002c <bsd_os_errno_set>
   19396:	f04f 30ff 	mov.w	r0, #4294967295
   1939a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1939c:	2009      	movs	r0, #9
   1939e:	f7f6 fe45 	bl	1002c <bsd_os_errno_set>
   193a2:	f04f 30ff 	mov.w	r0, #4294967295
   193a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   193a8:	2016      	movs	r0, #22
   193aa:	f7f6 fe3f 	bl	1002c <bsd_os_errno_set>
   193ae:	f04f 30ff 	mov.w	r0, #4294967295
   193b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   193b4:	2025      	movs	r0, #37	; 0x25
   193b6:	f7f6 fe39 	bl	1002c <bsd_os_errno_set>
   193ba:	f04f 30ff 	mov.w	r0, #4294967295
   193be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   193c0:	20023674 	.word	0x20023674
   193c4:	10624dd3 	.word	0x10624dd3

000193c8 <interface_socket_getopt>:
   193c8:	b570      	push	{r4, r5, r6, lr}
   193ca:	2808      	cmp	r0, #8
   193cc:	9d04      	ldr	r5, [sp, #16]
   193ce:	d835      	bhi.n	1943c <interface_socket_getopt+0x74>
   193d0:	4c20      	ldr	r4, [pc, #128]	; (19454 <interface_socket_getopt+0x8c>)
   193d2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   193d6:	00c0      	lsls	r0, r0, #3
   193d8:	5826      	ldr	r6, [r4, r0]
   193da:	4404      	add	r4, r0
   193dc:	b376      	cbz	r6, 1943c <interface_socket_getopt+0x74>
   193de:	2901      	cmp	r1, #1
   193e0:	d132      	bne.n	19448 <interface_socket_getopt+0x80>
   193e2:	b32b      	cbz	r3, 19430 <interface_socket_getopt+0x68>
   193e4:	b325      	cbz	r5, 19430 <interface_socket_getopt+0x68>
   193e6:	2a04      	cmp	r2, #4
   193e8:	d019      	beq.n	1941e <interface_socket_getopt+0x56>
   193ea:	f1a2 0114 	sub.w	r1, r2, #20
   193ee:	2901      	cmp	r1, #1
   193f0:	d82a      	bhi.n	19448 <interface_socket_getopt+0x80>
   193f2:	6829      	ldr	r1, [r5, #0]
   193f4:	2908      	cmp	r1, #8
   193f6:	d11b      	bne.n	19430 <interface_socket_getopt+0x68>
   193f8:	e9d4 1008 	ldrd	r1, r0, [r4, #32]
   193fc:	2a14      	cmp	r2, #20
   193fe:	bf18      	it	ne
   19400:	4601      	movne	r1, r0
   19402:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   19406:	4a14      	ldr	r2, [pc, #80]	; (19458 <interface_socket_getopt+0x90>)
   19408:	2000      	movs	r0, #0
   1940a:	fba2 5201 	umull	r5, r2, r2, r1
   1940e:	0992      	lsrs	r2, r2, #6
   19410:	fb04 1112 	mls	r1, r4, r2, r1
   19414:	fb04 f101 	mul.w	r1, r4, r1
   19418:	e9c3 2100 	strd	r2, r1, [r3]
   1941c:	bd70      	pop	{r4, r5, r6, pc}
   1941e:	682a      	ldr	r2, [r5, #0]
   19420:	2a04      	cmp	r2, #4
   19422:	d105      	bne.n	19430 <interface_socket_getopt+0x68>
   19424:	2200      	movs	r2, #0
   19426:	6861      	ldr	r1, [r4, #4]
   19428:	4610      	mov	r0, r2
   1942a:	6019      	str	r1, [r3, #0]
   1942c:	6062      	str	r2, [r4, #4]
   1942e:	bd70      	pop	{r4, r5, r6, pc}
   19430:	2016      	movs	r0, #22
   19432:	f7f6 fdfb 	bl	1002c <bsd_os_errno_set>
   19436:	f04f 30ff 	mov.w	r0, #4294967295
   1943a:	bd70      	pop	{r4, r5, r6, pc}
   1943c:	2009      	movs	r0, #9
   1943e:	f7f6 fdf5 	bl	1002c <bsd_os_errno_set>
   19442:	f04f 30ff 	mov.w	r0, #4294967295
   19446:	bd70      	pop	{r4, r5, r6, pc}
   19448:	202a      	movs	r0, #42	; 0x2a
   1944a:	f7f6 fdef 	bl	1002c <bsd_os_errno_set>
   1944e:	f04f 30ff 	mov.w	r0, #4294967295
   19452:	bd70      	pop	{r4, r5, r6, pc}
   19454:	20023674 	.word	0x20023674
   19458:	10624dd3 	.word	0x10624dd3

0001945c <interface_socket_fcntl>:
   1945c:	2808      	cmp	r0, #8
   1945e:	b510      	push	{r4, lr}
   19460:	d826      	bhi.n	194b0 <interface_socket_fcntl+0x54>
   19462:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   19466:	4c1b      	ldr	r4, [pc, #108]	; (194d4 <interface_socket_fcntl+0x78>)
   19468:	00c3      	lsls	r3, r0, #3
   1946a:	58e0      	ldr	r0, [r4, r3]
   1946c:	b300      	cbz	r0, 194b0 <interface_socket_fcntl+0x54>
   1946e:	2901      	cmp	r1, #1
   19470:	d005      	beq.n	1947e <interface_socket_fcntl+0x22>
   19472:	2902      	cmp	r1, #2
   19474:	d122      	bne.n	194bc <interface_socket_fcntl+0x60>
   19476:	58e0      	ldr	r0, [r4, r3]
   19478:	f3c0 7000 	ubfx	r0, r0, #28, #1
   1947c:	bd10      	pop	{r4, pc}
   1947e:	07d2      	lsls	r2, r2, #31
   19480:	d410      	bmi.n	194a4 <interface_socket_fcntl+0x48>
   19482:	58e0      	ldr	r0, [r4, r3]
   19484:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
   19488:	d11e      	bne.n	194c8 <interface_socket_fcntl+0x6c>
   1948a:	58e2      	ldr	r2, [r4, r3]
   1948c:	b292      	uxth	r2, r2
   1948e:	2a0a      	cmp	r2, #10
   19490:	d01a      	beq.n	194c8 <interface_socket_fcntl+0x6c>
   19492:	58e2      	ldr	r2, [r4, r3]
   19494:	b292      	uxth	r2, r2
   19496:	2a0b      	cmp	r2, #11
   19498:	d016      	beq.n	194c8 <interface_socket_fcntl+0x6c>
   1949a:	58e2      	ldr	r2, [r4, r3]
   1949c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
   194a0:	50e2      	str	r2, [r4, r3]
   194a2:	bd10      	pop	{r4, pc}
   194a4:	58e2      	ldr	r2, [r4, r3]
   194a6:	2000      	movs	r0, #0
   194a8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   194ac:	50e2      	str	r2, [r4, r3]
   194ae:	bd10      	pop	{r4, pc}
   194b0:	2009      	movs	r0, #9
   194b2:	f7f6 fdbb 	bl	1002c <bsd_os_errno_set>
   194b6:	f04f 30ff 	mov.w	r0, #4294967295
   194ba:	bd10      	pop	{r4, pc}
   194bc:	2016      	movs	r0, #22
   194be:	f7f6 fdb5 	bl	1002c <bsd_os_errno_set>
   194c2:	f04f 30ff 	mov.w	r0, #4294967295
   194c6:	bd10      	pop	{r4, pc}
   194c8:	2023      	movs	r0, #35	; 0x23
   194ca:	f7f6 fdaf 	bl	1002c <bsd_os_errno_set>
   194ce:	f04f 30ff 	mov.w	r0, #4294967295
   194d2:	bd10      	pop	{r4, pc}
   194d4:	20023674 	.word	0x20023674

000194d8 <at_client_evt_handler>:
   194d8:	b120      	cbz	r0, 194e4 <at_client_evt_handler+0xc>
   194da:	f850 1b08 	ldr.w	r1, [r0], #8
   194de:	0c09      	lsrs	r1, r1, #16
   194e0:	f7fc bf04 	b.w	162ec <rpc_at_event_handler>
   194e4:	4770      	bx	lr
   194e6:	bf00      	nop

000194e8 <rpc_at_client_init>:
   194e8:	4801      	ldr	r0, [pc, #4]	; (194f0 <rpc_at_client_init+0x8>)
   194ea:	f7fb bd2d 	b.w	14f48 <rpc_client_register>
   194ee:	bf00      	nop
   194f0:	0001e0c8 	.word	0x0001e0c8

000194f4 <rpc_at_client_request_alloc>:
   194f4:	b180      	cbz	r0, 19518 <rpc_at_client_request_alloc+0x24>
   194f6:	2300      	movs	r3, #0
   194f8:	b510      	push	{r4, lr}
   194fa:	b082      	sub	sp, #8
   194fc:	aa02      	add	r2, sp, #8
   194fe:	4604      	mov	r4, r0
   19500:	f842 3d04 	str.w	r3, [r2, #-4]!
   19504:	2003      	movs	r0, #3
   19506:	f7fb fd99 	bl	1503c <rpc_message_alloc>
   1950a:	b918      	cbnz	r0, 19514 <rpc_at_client_request_alloc+0x20>
   1950c:	9b01      	ldr	r3, [sp, #4]
   1950e:	b10b      	cbz	r3, 19514 <rpc_at_client_request_alloc+0x20>
   19510:	3308      	adds	r3, #8
   19512:	6023      	str	r3, [r4, #0]
   19514:	b002      	add	sp, #8
   19516:	bd10      	pop	{r4, pc}
   19518:	200e      	movs	r0, #14
   1951a:	4770      	bx	lr

0001951c <rpc_at_client_request_send>:
   1951c:	b150      	cbz	r0, 19534 <rpc_at_client_request_send+0x18>
   1951e:	4603      	mov	r3, r0
   19520:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   19524:	2003      	movs	r0, #3
   19526:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   1952a:	f843 1d08 	str.w	r1, [r3, #-8]!
   1952e:	4619      	mov	r1, r3
   19530:	f7fb bd74 	b.w	1501c <rpc_message_send>
   19534:	200e      	movs	r0, #14
   19536:	4770      	bx	lr

00019538 <rpc_at_client_message_free>:
   19538:	b120      	cbz	r0, 19544 <rpc_at_client_message_free+0xc>
   1953a:	f1a0 0108 	sub.w	r1, r0, #8
   1953e:	2003      	movs	r0, #3
   19540:	f7fb bda8 	b.w	15094 <rpc_message_free>
   19544:	200e      	movs	r0, #14
   19546:	4770      	bx	lr

00019548 <rpc_at_client_data_free>:
   19548:	b118      	cbz	r0, 19552 <rpc_at_client_data_free+0xa>
   1954a:	4601      	mov	r1, r0
   1954c:	2003      	movs	r0, #3
   1954e:	f7fb bdad 	b.w	150ac <rpc_message_data_free>
   19552:	200e      	movs	r0, #14
   19554:	4770      	bx	lr
   19556:	bf00      	nop

00019558 <SystemInit>:
    
    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
    * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
    * operations are not used in your code. */
    #if (__FPU_USED == 1)
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
   19558:	4a07      	ldr	r2, [pc, #28]	; (19578 <SystemInit+0x20>)
   1955a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   1955e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   19562:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   19566:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1956a:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
   1956e:	4b03      	ldr	r3, [pc, #12]	; (1957c <SystemInit+0x24>)
   19570:	4a03      	ldr	r2, [pc, #12]	; (19580 <SystemInit+0x28>)
   19572:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   19574:	4770      	bx	lr
   19576:	bf00      	nop
   19578:	e000ed00 	.word	0xe000ed00
   1957c:	200200f0 	.word	0x200200f0
   19580:	03d09000 	.word	0x03d09000

00019584 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
   19584:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    NRFX_ASSERT(p_config);
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   19588:	2624      	movs	r6, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   1958a:	7904      	ldrb	r4, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   1958c:	4d4a      	ldr	r5, [pc, #296]	; (196b8 <nrfx_spim_init+0x134>)
   1958e:	4366      	muls	r6, r4
   19590:	19af      	adds	r7, r5, r6
   19592:	f897 c01c 	ldrb.w	ip, [r7, #28]
   19596:	f1bc 0f00 	cmp.w	ip, #0
   1959a:	f040 808b 	bne.w	196b4 <nrfx_spim_init+0x130>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif

    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   1959e:	6800      	ldr	r0, [r0, #0]
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
   195a0:	51aa      	str	r2, [r5, r6]
    p_cb->p_context = p_context;
   195a2:	2601      	movs	r6, #1
   195a4:	607b      	str	r3, [r7, #4]
   195a6:	2701      	movs	r7, #1
   195a8:	f891 9000 	ldrb.w	r9, [r1]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPIM_MODE_1)
   195ac:	f891 e00c 	ldrb.w	lr, [r1, #12]
   195b0:	4b42      	ldr	r3, [pc, #264]	; (196bc <nrfx_spim_init+0x138>)
    p_reg->OUTCLR = clr_mask;
   195b2:	fa06 f609 	lsl.w	r6, r6, r9
   195b6:	f1be 0f01 	cmp.w	lr, #1
   195ba:	bf94      	ite	ls
   195bc:	60de      	strls	r6, [r3, #12]
    p_reg->OUTSET = set_mask;
   195be:	609e      	strhi	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   195c0:	f109 0680 	add.w	r6, r9, #128	; 0x80
   195c4:	f843 7026 	str.w	r7, [r3, r6, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   195c8:	784e      	ldrb	r6, [r1, #1]
   195ca:	2eff      	cmp	r6, #255	; 0xff
   195cc:	bf1f      	itttt	ne
   195ce:	f04f 0c03 	movne.w	ip, #3
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   195d2:	40b7      	lslne	r7, r6
    p_reg->OUTCLR = clr_mask;
   195d4:	60df      	strne	r7, [r3, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   195d6:	f106 0780 	addne.w	r7, r6, #128	; 0x80
   195da:	bf18      	it	ne
   195dc:	f843 c027 	strne.w	ip, [r3, r7, lsl #2]
    else
    {
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   195e0:	788f      	ldrb	r7, [r1, #2]
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   195e2:	bf08      	it	eq
   195e4:	f04f 36ff 	moveq.w	r6, #4294967295
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   195e8:	2fff      	cmp	r7, #255	; 0xff
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   195ea:	bf1f      	itttt	ne
   195ec:	f891 c00e 	ldrbne.w	ip, [r1, #14]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   195f0:	f107 0880 	addne.w	r8, r7, #128	; 0x80
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   195f4:	ea4f 0c8c 	movne.w	ip, ip, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   195f8:	f843 c028 	strne.w	ip, [r3, r8, lsl #2]
    }
    // - Slave Select (optional) - output with initial value 1 (inactive).

    // 'p_cb->ss_pin' variable is used during transfers to check if SS pin should be toggled,
    // so this field needs to be initialized even if the pin is not used.
    p_cb->ss_pin = p_config->ss_pin;
   195fc:	f04f 0824 	mov.w	r8, #36	; 0x24
   19600:	fb08 5804 	mla	r8, r8, r4, r5
   19604:	f891 c003 	ldrb.w	ip, [r1, #3]
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   19608:	bf08      	it	eq
   1960a:	f04f 37ff 	moveq.w	r7, #4294967295

    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   1960e:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
   19612:	f888 c01f 	strb.w	ip, [r8, #31]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   19616:	d015      	beq.n	19644 <nrfx_spim_init+0xc0>
    {
        if (p_config->ss_active_high)
   19618:	f04f 0801 	mov.w	r8, #1
   1961c:	f891 a004 	ldrb.w	sl, [r1, #4]
   19620:	fa08 f80c 	lsl.w	r8, r8, ip
   19624:	f1ba 0f00 	cmp.w	sl, #0
   19628:	d03b      	beq.n	196a2 <nrfx_spim_init+0x11e>
    p_reg->OUTCLR = clr_mask;
   1962a:	f8c3 800c 	str.w	r8, [r3, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1962e:	f04f 0803 	mov.w	r8, #3
   19632:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
   19636:	f843 802c 	str.w	r8, [r3, ip, lsl #2]
                                   (p_config->ss_active_high == true ?
                                        NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
                                   p_config->ss_duration);
        }
#endif
        p_cb->ss_active_high = p_config->ss_active_high;
   1963a:	2324      	movs	r3, #36	; 0x24
   1963c:	fb03 5304 	mla	r3, r3, r4, r5
   19640:	f883 a01e 	strb.w	sl, [r3, #30]
    p_reg->FREQUENCY = (uint32_t)frequency;
   19644:	688b      	ldr	r3, [r1, #8]
    p_reg->PSEL.SCK  = sck_pin;
   19646:	f8c0 9508 	str.w	r9, [r0, #1288]	; 0x508
    p_reg->PSEL.MOSI = mosi_pin;
   1964a:	f8c0 650c 	str.w	r6, [r0, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   1964e:	f8c0 7510 	str.w	r7, [r0, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   19652:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   19656:	7b4b      	ldrb	r3, [r1, #13]
   19658:	3b00      	subs	r3, #0
   1965a:	bf18      	it	ne
   1965c:	2301      	movne	r3, #1
    switch (spi_mode)
   1965e:	f1be 0f02 	cmp.w	lr, #2
   19662:	d021      	beq.n	196a8 <nrfx_spim_init+0x124>
   19664:	f1be 0f03 	cmp.w	lr, #3
   19668:	d021      	beq.n	196ae <nrfx_spim_init+0x12a>
   1966a:	f1be 0f01 	cmp.w	lr, #1
   1966e:	d101      	bne.n	19674 <nrfx_spim_init+0xf0>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   19670:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   19674:	f8c0 3554 	str.w	r3, [r0, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   19678:	798b      	ldrb	r3, [r1, #6]
   1967a:	f8c0 35c0 	str.w	r3, [r0, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   1967e:	2307      	movs	r3, #7
   19680:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
   19684:	b11a      	cbz	r2, 1968e <nrfx_spim_init+0x10a>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   19686:	f340 3007 	sbfx	r0, r0, #12, #8
   1968a:	f7f4 fbd7 	bl	de3c <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   1968e:	2324      	movs	r3, #36	; 0x24
   19690:	fb03 5404 	mla	r4, r3, r4, r5
   19694:	2300      	movs	r3, #0
   19696:	7763      	strb	r3, [r4, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   19698:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   1969a:	4809      	ldr	r0, [pc, #36]	; (196c0 <nrfx_spim_init+0x13c>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1969c:	7723      	strb	r3, [r4, #28]
}
   1969e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p_reg->OUTSET = set_mask;
   196a2:	f8c3 8008 	str.w	r8, [r3, #8]
}
   196a6:	e7c2      	b.n	1962e <nrfx_spim_init+0xaa>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   196a8:	f043 0304 	orr.w	r3, r3, #4
        break;
   196ac:	e7e2      	b.n	19674 <nrfx_spim_init+0xf0>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   196ae:	f043 0306 	orr.w	r3, r3, #6
        break;
   196b2:	e7df      	b.n	19674 <nrfx_spim_init+0xf0>
        return err_code;
   196b4:	4803      	ldr	r0, [pc, #12]	; (196c4 <nrfx_spim_init+0x140>)
   196b6:	e7f2      	b.n	1969e <nrfx_spim_init+0x11a>
   196b8:	20020b3c 	.word	0x20020b3c
   196bc:	40842500 	.word	0x40842500
   196c0:	0bad0000 	.word	0x0bad0000
   196c4:	0bad0005 	.word	0x0bad0005

000196c8 <nrfx_spim_xfer>:
    NRFX_ASSERT(!(flags & NRFX_SPIM_FLAG_HOLD_XFER) ||
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   196c8:	2324      	movs	r3, #36	; 0x24
{
   196ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   196ce:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->transfer_in_progress)
   196d0:	4f40      	ldr	r7, [pc, #256]	; (197d4 <nrfx_spim_xfer+0x10c>)
   196d2:	4373      	muls	r3, r6
{
   196d4:	4614      	mov	r4, r2
    if (p_cb->transfer_in_progress)
   196d6:	18fa      	adds	r2, r7, r3
{
   196d8:	460d      	mov	r5, r1
    if (p_cb->transfer_in_progress)
   196da:	7f51      	ldrb	r1, [r2, #29]
{
   196dc:	4686      	mov	lr, r0
    if (p_cb->transfer_in_progress)
   196de:	2900      	cmp	r1, #0
   196e0:	d175      	bne.n	197ce <nrfx_spim_xfer+0x106>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   196e2:	58fb      	ldr	r3, [r7, r3]
   196e4:	b123      	cbz	r3, 196f0 <nrfx_spim_xfer+0x28>
   196e6:	f014 0f14 	tst.w	r4, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   196ea:	bf04      	itt	eq
   196ec:	2301      	moveq	r3, #1
   196ee:	7753      	strbeq	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   196f0:	f04f 0c24 	mov.w	ip, #36	; 0x24
   196f4:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   196f8:	fb0c 7c06 	mla	ip, ip, r6, r7
   196fc:	f10c 080c 	add.w	r8, ip, #12
   19700:	e888 000f 	stmia.w	r8, {r0, r1, r2, r3}

    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   19704:	f89c 201f 	ldrb.w	r2, [ip, #31]
   19708:	2aff      	cmp	r2, #255	; 0xff
   1970a:	d006      	beq.n	1971a <nrfx_spim_xfer+0x52>
    {
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (!p_cb->use_hw_ss)
#endif
        {
            if (p_cb->ss_active_high)
   1970c:	2301      	movs	r3, #1
   1970e:	f89c 101e 	ldrb.w	r1, [ip, #30]
   19712:	4093      	lsls	r3, r2
   19714:	4a30      	ldr	r2, [pc, #192]	; (197d8 <nrfx_spim_xfer+0x110>)
   19716:	b1b1      	cbz	r1, 19746 <nrfx_spim_xfer+0x7e>
    p_reg->OUTSET = set_mask;
   19718:	6093      	str	r3, [r2, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   1971a:	6829      	ldr	r1, [r5, #0]
   1971c:	b121      	cbz	r1, 19728 <nrfx_spim_xfer+0x60>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   1971e:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   19722:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   19726:	d106      	bne.n	19736 <nrfx_spim_xfer+0x6e>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   19728:	68aa      	ldr	r2, [r5, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   1972a:	b172      	cbz	r2, 1974a <nrfx_spim_xfer+0x82>
   1972c:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   19730:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   19734:	d009      	beq.n	1974a <nrfx_spim_xfer+0x82>
        p_cb->transfer_in_progress = false;
   19736:	2324      	movs	r3, #36	; 0x24
   19738:	fb03 7606 	mla	r6, r3, r6, r7
   1973c:	2300      	movs	r3, #0
        return err_code;
   1973e:	4827      	ldr	r0, [pc, #156]	; (197dc <nrfx_spim_xfer+0x114>)
        p_cb->transfer_in_progress = false;
   19740:	7773      	strb	r3, [r6, #29]
            }
        }
    }

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
}
   19742:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    p_reg->OUTCLR = clr_mask;
   19746:	60d3      	str	r3, [r2, #12]
}
   19748:	e7e7      	b.n	1971a <nrfx_spim_xfer+0x52>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   1974a:	f8de 3000 	ldr.w	r3, [lr]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   1974e:	6868      	ldr	r0, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   19750:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   19754:	68e9      	ldr	r1, [r5, #12]
    p_reg->TXD.MAXCNT = length;
   19756:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   1975a:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1975e:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   19760:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19764:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   19768:	f014 0201 	ands.w	r2, r4, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   1976c:	bf18      	it	ne
   1976e:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   19770:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   19774:	f014 0202 	ands.w	r2, r4, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   19778:	bf18      	it	ne
   1977a:	2201      	movne	r2, #1
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   1977c:	f014 0108 	ands.w	r1, r4, #8
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   19780:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19784:	bf04      	itt	eq
   19786:	2201      	moveq	r2, #1
   19788:	611a      	streq	r2, [r3, #16]
    if (!p_cb->handler)
   1978a:	2224      	movs	r2, #36	; 0x24
   1978c:	4372      	muls	r2, r6
   1978e:	58ba      	ldr	r2, [r7, r2]
   19790:	b9a2      	cbnz	r2, 197bc <nrfx_spim_xfer+0xf4>
        if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   19792:	b919      	cbnz	r1, 1979c <nrfx_spim_xfer+0xd4>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19794:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   19798:	2a00      	cmp	r2, #0
   1979a:	d0fb      	beq.n	19794 <nrfx_spim_xfer+0xcc>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   1979c:	2324      	movs	r3, #36	; 0x24
   1979e:	fb03 7606 	mla	r6, r3, r6, r7
   197a2:	7ff2      	ldrb	r2, [r6, #31]
   197a4:	2aff      	cmp	r2, #255	; 0xff
   197a6:	d005      	beq.n	197b4 <nrfx_spim_xfer+0xec>
                if (p_cb->ss_active_high)
   197a8:	2301      	movs	r3, #1
   197aa:	7fb1      	ldrb	r1, [r6, #30]
   197ac:	4093      	lsls	r3, r2
   197ae:	4a0a      	ldr	r2, [pc, #40]	; (197d8 <nrfx_spim_xfer+0x110>)
   197b0:	b111      	cbz	r1, 197b8 <nrfx_spim_xfer+0xf0>
    p_reg->OUTCLR = clr_mask;
   197b2:	60d3      	str	r3, [r2, #12]
    return err_code;
   197b4:	480a      	ldr	r0, [pc, #40]	; (197e0 <nrfx_spim_xfer+0x118>)
   197b6:	e7c4      	b.n	19742 <nrfx_spim_xfer+0x7a>
    p_reg->OUTSET = set_mask;
   197b8:	6093      	str	r3, [r2, #8]
   197ba:	e7fb      	b.n	197b4 <nrfx_spim_xfer+0xec>
    if (!enable)
   197bc:	2240      	movs	r2, #64	; 0x40
   197be:	f014 0f04 	tst.w	r4, #4
    p_reg->INTENCLR = mask;
   197c2:	bf14      	ite	ne
   197c4:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   197c8:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   197cc:	e7f2      	b.n	197b4 <nrfx_spim_xfer+0xec>
        return err_code;
   197ce:	4805      	ldr	r0, [pc, #20]	; (197e4 <nrfx_spim_xfer+0x11c>)
   197d0:	e7b7      	b.n	19742 <nrfx_spim_xfer+0x7a>
   197d2:	bf00      	nop
   197d4:	20020b3c 	.word	0x20020b3c
   197d8:	40842500 	.word	0x40842500
   197dc:	0bad000a 	.word	0x0bad000a
   197e0:	0bad0000 	.word	0x0bad0000
   197e4:	0bad000b 	.word	0x0bad000b

000197e8 <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   197e8:	4b0d      	ldr	r3, [pc, #52]	; (19820 <nrfx_spim_3_irq_handler+0x38>)
   197ea:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
        nrf_spim_task_trigger(p_spim, NRF_SPIM_TASK_START);
        return;
    }
#endif

    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   197ee:	b1aa      	cbz	r2, 1981c <nrfx_spim_3_irq_handler+0x34>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   197f0:	2200      	movs	r2, #0
   197f2:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   197f6:	4b0b      	ldr	r3, [pc, #44]	; (19824 <nrfx_spim_3_irq_handler+0x3c>)
   197f8:	7fd9      	ldrb	r1, [r3, #31]
   197fa:	29ff      	cmp	r1, #255	; 0xff
   197fc:	d005      	beq.n	1980a <nrfx_spim_3_irq_handler+0x22>
            if (p_cb->ss_active_high)
   197fe:	2201      	movs	r2, #1
   19800:	7f98      	ldrb	r0, [r3, #30]
   19802:	408a      	lsls	r2, r1
   19804:	4908      	ldr	r1, [pc, #32]	; (19828 <nrfx_spim_3_irq_handler+0x40>)
   19806:	b138      	cbz	r0, 19818 <nrfx_spim_3_irq_handler+0x30>
    p_reg->OUTCLR = clr_mask;
   19808:	60ca      	str	r2, [r1, #12]
    p_cb->transfer_in_progress = false;
   1980a:	2200      	movs	r2, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   1980c:	4807      	ldr	r0, [pc, #28]	; (1982c <nrfx_spim_3_irq_handler+0x44>)
    p_cb->transfer_in_progress = false;
   1980e:	775a      	strb	r2, [r3, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   19810:	721a      	strb	r2, [r3, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   19812:	e9d3 2100 	ldrd	r2, r1, [r3]
   19816:	4710      	bx	r2
    p_reg->OUTSET = set_mask;
   19818:	608a      	str	r2, [r1, #8]
}
   1981a:	e7f6      	b.n	1980a <nrfx_spim_3_irq_handler+0x22>

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   1981c:	4770      	bx	lr
   1981e:	bf00      	nop
   19820:	4000b000 	.word	0x4000b000
   19824:	20020b3c 	.word	0x20020b3c
   19828:	40842500 	.word	0x40842500
   1982c:	20020b44 	.word	0x20020b44

00019830 <nrfx_twim_init>:
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(p_config->scl != p_config->sda);
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   19830:	f04f 0c34 	mov.w	ip, #52	; 0x34
{
   19834:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   19836:	7906      	ldrb	r6, [r0, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   19838:	4d1b      	ldr	r5, [pc, #108]	; (198a8 <nrfx_twim_init+0x78>)
   1983a:	fb0c fc06 	mul.w	ip, ip, r6
   1983e:	eb05 040c 	add.w	r4, r5, ip
   19842:	f894 702d 	ldrb.w	r7, [r4, #45]	; 0x2d
   19846:	bb67      	cbnz	r7, 198a2 <nrfx_twim_init+0x72>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
   19848:	f845 200c 	str.w	r2, [r5, ip]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1984c:	f240 6c0c 	movw	ip, #1548	; 0x60c
    p_cb->p_context       = p_context;
   19850:	6063      	str	r3, [r4, #4]
    p_cb->int_mask        = 0;
    p_cb->repeated        = false;
    p_cb->busy            = false;
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   19852:	7b4b      	ldrb	r3, [r1, #13]
    p_cb->int_mask        = 0;
   19854:	60a7      	str	r7, [r4, #8]
    p_cb->repeated        = false;
   19856:	f884 7030 	strb.w	r7, [r4, #48]	; 0x30
    p_cb->busy            = false;
   1985a:	f884 702f 	strb.w	r7, [r4, #47]	; 0x2f
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   1985e:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32

    /* To secure correct signal levels on the pins used by the TWI
       master when the system is in OFF mode, and when the TWI master is
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
   19862:	680c      	ldr	r4, [r1, #0]
   19864:	4f11      	ldr	r7, [pc, #68]	; (198ac <nrfx_twim_init+0x7c>)
   19866:	f104 0380 	add.w	r3, r4, #128	; 0x80
   1986a:	f847 c023 	str.w	ip, [r7, r3, lsl #2]
    TWIM_PIN_INIT(p_config->sda);
   1986e:	684b      	ldr	r3, [r1, #4]

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   19870:	6800      	ldr	r0, [r0, #0]
   19872:	f103 0e80 	add.w	lr, r3, #128	; 0x80
   19876:	f847 c02e 	str.w	ip, [r7, lr, lsl #2]

NRF_STATIC_INLINE void nrf_twim_pins_set(NRF_TWIM_Type * p_reg,
                                         uint32_t scl_pin,
                                         uint32_t sda_pin)
{
    p_reg->PSEL.SCL = scl_pin;
   1987a:	f8c0 4508 	str.w	r4, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   1987e:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
   19882:	688b      	ldr	r3, [r1, #8]
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   19884:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
   19888:	b11a      	cbz	r2, 19892 <nrfx_twim_init+0x62>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   1988a:	f340 3007 	sbfx	r0, r0, #12, #8
   1988e:	f7f4 fad5 	bl	de3c <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   19892:	2334      	movs	r3, #52	; 0x34
   19894:	fb03 5506 	mla	r5, r3, r6, r5
   19898:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   1989a:	4805      	ldr	r0, [pc, #20]	; (198b0 <nrfx_twim_init+0x80>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   1989c:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   198a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return err_code;
   198a2:	4804      	ldr	r0, [pc, #16]	; (198b4 <nrfx_twim_init+0x84>)
   198a4:	e7fc      	b.n	198a0 <nrfx_twim_init+0x70>
   198a6:	bf00      	nop
   198a8:	20020b60 	.word	0x20020b60
   198ac:	40842500 	.word	0x40842500
   198b0:	0bad0000 	.word	0x0bad0000
   198b4:	0bad0005 	.word	0x0bad0005

000198b8 <nrfx_twim_enable>:
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   198b8:	2106      	movs	r1, #6
void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);

    nrf_twim_enable(p_instance->p_twim);
   198ba:	6802      	ldr	r2, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   198bc:	7903      	ldrb	r3, [r0, #4]
   198be:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   198c2:	2134      	movs	r1, #52	; 0x34
   198c4:	4a03      	ldr	r2, [pc, #12]	; (198d4 <nrfx_twim_enable+0x1c>)
   198c6:	fb01 2303 	mla	r3, r1, r3, r2
   198ca:	2202      	movs	r2, #2
   198cc:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   198d0:	4770      	bx	lr
   198d2:	bf00      	nop
   198d4:	20020b60 	.word	0x20020b60

000198d8 <nrfx_twim_disable>:
void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   198d8:	6802      	ldr	r2, [r0, #0]
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   198da:	7903      	ldrb	r3, [r0, #4]
    p_cb->int_mask = 0;
   198dc:	2034      	movs	r0, #52	; 0x34
   198de:	490a      	ldr	r1, [pc, #40]	; (19908 <nrfx_twim_disable+0x30>)
   198e0:	fb00 1303 	mla	r3, r0, r3, r1
   198e4:	2000      	movs	r0, #0
    p_reg->INTENCLR = mask;
   198e6:	4909      	ldr	r1, [pc, #36]	; (1990c <nrfx_twim_disable+0x34>)
   198e8:	6098      	str	r0, [r3, #8]
   198ea:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   198ee:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
   198f2:	f421 51bc 	bic.w	r1, r1, #6016	; 0x1780
   198f6:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   198fa:	f8c2 0500 	str.w	r0, [r2, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   198fe:	2201      	movs	r2, #1
   19900:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   19904:	4770      	bx	lr
   19906:	bf00      	nop
   19908:	20020b60 	.word	0x20020b60
   1990c:	019c0202 	.word	0x019c0202

00019910 <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   19910:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    p_cb->error = false;
   19914:	2634      	movs	r6, #52	; 0x34
   19916:	2300      	movs	r3, #0
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
                                     p_xfer_desc->primary_length,
                                     p_xfer_desc->secondary_length));

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   19918:	f890 e004 	ldrb.w	lr, [r0, #4]
    p_cb->error = false;
   1991c:	4fa4      	ldr	r7, [pc, #656]	; (19bb0 <nrfx_twim_xfer+0x2a0>)
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   1991e:	6804      	ldr	r4, [r0, #0]
    p_cb->error = false;
   19920:	fb06 760e 	mla	r6, r6, lr, r7
   19924:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
   19928:	68cb      	ldr	r3, [r1, #12]
{
   1992a:	460d      	mov	r5, r1
   1992c:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   19930:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
{
   19934:	4694      	mov	ip, r2
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   19936:	d003      	beq.n	19940 <nrfx_twim_xfer+0x30>
        return err_code;
   19938:	4e9e      	ldr	r6, [pc, #632]	; (19bb4 <nrfx_twim_xfer+0x2a4>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   1993a:	4630      	mov	r0, r6
   1993c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p_reg->INTENCLR = mask;
   19940:	4b9d      	ldr	r3, [pc, #628]	; (19bb8 <nrfx_twim_xfer+0x2a8>)
   19942:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
   19946:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   1994a:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   1994e:	b123      	cbz	r3, 1995a <nrfx_twim_xfer+0x4a>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   19950:	68b3      	ldr	r3, [r6, #8]
        return err_code;
   19952:	4e9a      	ldr	r6, [pc, #616]	; (19bbc <nrfx_twim_xfer+0x2ac>)
    p_reg->INTENSET = mask;
   19954:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   19958:	e7ef      	b.n	1993a <nrfx_twim_xfer+0x2a>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   1995a:	f012 0f14 	tst.w	r2, #20
   1995e:	bf0c      	ite	eq
   19960:	2301      	moveq	r3, #1
   19962:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   19964:	4689      	mov	r9, r1
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   19966:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   1996a:	f106 080c 	add.w	r8, r6, #12
   1996e:	e8b9 000f 	ldmia.w	r9!, {r0, r1, r2, r3}
   19972:	e8a8 000f 	stmia.w	r8!, {r0, r1, r2, r3}
   19976:	f8d9 3000 	ldr.w	r3, [r9]
    p_cb->flags = flags;
   1997a:	f8c6 c020 	str.w	ip, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   1997e:	f8c8 3000 	str.w	r3, [r8]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   19982:	f3cc 1300 	ubfx	r3, ip, #4, #1
   19986:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   1998a:	786b      	ldrb	r3, [r5, #1]
   1998c:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   19990:	f01c 0301 	ands.w	r3, ip, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   19994:	bf18      	it	ne
   19996:	2301      	movne	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19998:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   1999c:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   199a0:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   199a4:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   199a8:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   199ac:	f01c 0302 	ands.w	r3, ip, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   199b0:	bf18      	it	ne
   199b2:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   199b4:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   199b8:	782b      	ldrb	r3, [r5, #0]
   199ba:	2b03      	cmp	r3, #3
   199bc:	f200 80a9 	bhi.w	19b12 <nrfx_twim_xfer+0x202>
   199c0:	e8df f003 	tbb	[pc, r3]
   199c4:	025d9478 	.word	0x025d9478
   199c8:	692a      	ldr	r2, [r5, #16]
   199ca:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   199ce:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   199d2:	d1b1      	bne.n	19938 <nrfx_twim_xfer+0x28>
    p_reg->SHORTS = mask;
   199d4:	f44f 7380 	mov.w	r3, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   199d8:	68e9      	ldr	r1, [r5, #12]
    p_reg->SHORTS = mask;
   199da:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   199de:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   199e0:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   199e4:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   199e8:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   199ea:	2300      	movs	r3, #0
   199ec:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   199f0:	6221      	str	r1, [r4, #32]
   199f2:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   199f4:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   199f8:	2900      	cmp	r1, #0
   199fa:	d0fb      	beq.n	199f4 <nrfx_twim_xfer+0xe4>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   199fc:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   19a00:	68ab      	ldr	r3, [r5, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   19a02:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   19a06:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   19a0a:	2334      	movs	r3, #52	; 0x34
   19a0c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   19a10:	fb03 730e 	mla	r3, r3, lr, r7
   19a14:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   19a16:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   19a18:	4e69      	ldr	r6, [pc, #420]	; (19bc0 <nrfx_twim_xfer+0x2b0>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   19a1a:	f01c 0f08 	tst.w	ip, #8
   19a1e:	d104      	bne.n	19a2a <nrfx_twim_xfer+0x11a>
   19a20:	782a      	ldrb	r2, [r5, #0]
   19a22:	2a03      	cmp	r2, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19a24:	bf1c      	itt	ne
   19a26:	2201      	movne	r2, #1
   19a28:	50e2      	strne	r2, [r4, r3]
    if (p_cb->handler)
   19a2a:	2334      	movs	r3, #52	; 0x34
   19a2c:	fb03 f30e 	mul.w	r3, r3, lr
   19a30:	18fa      	adds	r2, r7, r3
   19a32:	58fb      	ldr	r3, [r7, r3]
   19a34:	2b00      	cmp	r3, #0
   19a36:	d16f      	bne.n	19b18 <nrfx_twim_xfer+0x208>
                transmission_finished = true;
   19a38:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19a3a:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
   19a3e:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   19a42:	2800      	cmp	r0, #0
   19a44:	f040 8082 	bne.w	19b4c <nrfx_twim_xfer+0x23c>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   19a48:	3a00      	subs	r2, #0
   19a4a:	bf18      	it	ne
   19a4c:	2201      	movne	r2, #1
   19a4e:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   19a52:	2800      	cmp	r0, #0
   19a54:	d07e      	beq.n	19b54 <nrfx_twim_xfer+0x244>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19a56:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19a5a:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   19a5e:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   19a62:	b115      	cbz	r5, 19a6a <nrfx_twim_xfer+0x15a>
   19a64:	f410 7f00 	tst.w	r0, #512	; 0x200
   19a68:	d104      	bne.n	19a74 <nrfx_twim_xfer+0x164>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19a6a:	6221      	str	r1, [r4, #32]
   19a6c:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   19a6e:	2d00      	cmp	r5, #0
   19a70:	d0e3      	beq.n	19a3a <nrfx_twim_xfer+0x12a>
                    transmission_finished = false;
   19a72:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   19a74:	05c0      	lsls	r0, r0, #23
   19a76:	d56d      	bpl.n	19b54 <nrfx_twim_xfer+0x244>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19a78:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
        } while (!transmission_finished);
   19a7c:	e7dd      	b.n	19a3a <nrfx_twim_xfer+0x12a>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   19a7e:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   19a80:	68ea      	ldr	r2, [r5, #12]
   19a82:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   19a86:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   19a8a:	692b      	ldr	r3, [r5, #16]
   19a8c:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   19a90:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   19a94:	f47f af50 	bne.w	19938 <nrfx_twim_xfer+0x28>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   19a98:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   19a9a:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   19a9e:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   19aa2:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   19aa6:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   19aaa:	2334      	movs	r3, #52	; 0x34
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   19aac:	2202      	movs	r2, #2
   19aae:	fb03 730e 	mla	r3, r3, lr, r7
   19ab2:	e012      	b.n	19ada <nrfx_twim_xfer+0x1ca>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   19ab4:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   19ab6:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   19ab8:	f01c 0f20 	tst.w	ip, #32
   19abc:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   19ac0:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   19ac4:	f04f 0334 	mov.w	r3, #52	; 0x34
   19ac8:	d00b      	beq.n	19ae2 <nrfx_twim_xfer+0x1d2>
    p_reg->SHORTS = mask;
   19aca:	f44f 7280 	mov.w	r2, #256	; 0x100
   19ace:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   19ad2:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   19ad6:	fb03 730e 	mla	r3, r3, lr, r7
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   19ada:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19adc:	2301      	movs	r3, #1
   19ade:	6223      	str	r3, [r4, #32]
   19ae0:	e799      	b.n	19a16 <nrfx_twim_xfer+0x106>
    p_reg->SHORTS = mask;
   19ae2:	f44f 7200 	mov.w	r2, #512	; 0x200
   19ae6:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   19aea:	e7df      	b.n	19aac <nrfx_twim_xfer+0x19c>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   19aec:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   19aee:	68ea      	ldr	r2, [r5, #12]
   19af0:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   19af4:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   19af8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   19afc:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   19b00:	2334      	movs	r3, #52	; 0x34
   19b02:	2202      	movs	r2, #2
   19b04:	fb03 730e 	mla	r3, r3, lr, r7
   19b08:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19b0a:	2301      	movs	r3, #1
   19b0c:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   19b0e:	2300      	movs	r3, #0
   19b10:	e782      	b.n	19a18 <nrfx_twim_xfer+0x108>
    switch (p_xfer_desc->type)
   19b12:	2308      	movs	r3, #8
   19b14:	4e2b      	ldr	r6, [pc, #172]	; (19bc4 <nrfx_twim_xfer+0x2b4>)
   19b16:	e780      	b.n	19a1a <nrfx_twim_xfer+0x10a>
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   19b18:	f01c 0f04 	tst.w	ip, #4
            p_cb->int_mask = 0;
   19b1c:	bf1c      	itt	ne
   19b1e:	2300      	movne	r3, #0
   19b20:	6093      	strne	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   19b22:	f01c 0f40 	tst.w	ip, #64	; 0x40
   19b26:	d106      	bne.n	19b36 <nrfx_twim_xfer+0x226>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   19b28:	2334      	movs	r3, #52	; 0x34
   19b2a:	fb03 730e 	mla	r3, r3, lr, r7
   19b2e:	689a      	ldr	r2, [r3, #8]
   19b30:	f042 0202 	orr.w	r2, r2, #2
   19b34:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   19b36:	2334      	movs	r3, #52	; 0x34
   19b38:	fb03 770e 	mla	r7, r3, lr, r7
   19b3c:	68bb      	ldr	r3, [r7, #8]
   19b3e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   19b42:	60bb      	str	r3, [r7, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   19b44:	68bb      	ldr	r3, [r7, #8]
    p_reg->INTENSET = mask;
   19b46:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
   19b4a:	e6f6      	b.n	1993a <nrfx_twim_xfer+0x2a>
                transmission_finished = true;
   19b4c:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19b4e:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
   19b52:	e77c      	b.n	19a4e <nrfx_twim_xfer+0x13e>
        } while (!transmission_finished);
   19b54:	2a00      	cmp	r2, #0
   19b56:	f43f af70 	beq.w	19a3a <nrfx_twim_xfer+0x12a>
        p_cb->busy = false;
   19b5a:	2134      	movs	r1, #52	; 0x34
   19b5c:	2000      	movs	r0, #0
   19b5e:	fb01 720e 	mla	r2, r1, lr, r7
    uint32_t error_source = p_reg->ERRORSRC;
   19b62:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   19b66:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   19b6a:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   19b6e:	b18b      	cbz	r3, 19b94 <nrfx_twim_xfer+0x284>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   19b70:	4a15      	ldr	r2, [pc, #84]	; (19bc8 <nrfx_twim_xfer+0x2b8>)
   19b72:	f013 0f01 	tst.w	r3, #1
   19b76:	4e15      	ldr	r6, [pc, #84]	; (19bcc <nrfx_twim_xfer+0x2bc>)
   19b78:	bf18      	it	ne
   19b7a:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   19b7c:	f013 0f02 	tst.w	r3, #2
   19b80:	f102 0201 	add.w	r2, r2, #1
   19b84:	bf18      	it	ne
   19b86:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   19b88:	f013 0f04 	tst.w	r3, #4
   19b8c:	4b10      	ldr	r3, [pc, #64]	; (19bd0 <nrfx_twim_xfer+0x2c0>)
   19b8e:	bf18      	it	ne
   19b90:	461e      	movne	r6, r3
   19b92:	e6d2      	b.n	1993a <nrfx_twim_xfer+0x2a>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   19b94:	f01c 0f40 	tst.w	ip, #64	; 0x40
   19b98:	f47f aecf 	bne.w	1993a <nrfx_twim_xfer+0x2a>
                !xfer_completeness_check(p_twim, p_cb))
   19b9c:	4620      	mov	r0, r4
   19b9e:	fb0e 7101 	mla	r1, lr, r1, r7
   19ba2:	f003 fa83 	bl	1d0ac <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   19ba6:	4b09      	ldr	r3, [pc, #36]	; (19bcc <nrfx_twim_xfer+0x2bc>)
   19ba8:	2800      	cmp	r0, #0
   19baa:	bf08      	it	eq
   19bac:	461e      	moveq	r6, r3
   19bae:	e6c4      	b.n	1993a <nrfx_twim_xfer+0x2a>
   19bb0:	20020b60 	.word	0x20020b60
   19bb4:	0bad000a 	.word	0x0bad000a
   19bb8:	019c0202 	.word	0x019c0202
   19bbc:	0bad000b 	.word	0x0bad000b
   19bc0:	0bad0000 	.word	0x0bad0000
   19bc4:	0bad0004 	.word	0x0bad0004
   19bc8:	0bae0000 	.word	0x0bae0000
   19bcc:	0bad0001 	.word	0x0bad0001
   19bd0:	0bae0002 	.word	0x0bae0002

00019bd4 <nrfx_twim_2_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM2_ENABLED)
void nrfx_twim_2_irq_handler(void)
{
   19bd4:	b5f0      	push	{r4, r5, r6, r7, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19bd6:	4b56      	ldr	r3, [pc, #344]	; (19d30 <nrfx_twim_2_irq_handler+0x15c>)
   19bd8:	4c56      	ldr	r4, [pc, #344]	; (19d34 <nrfx_twim_2_irq_handler+0x160>)
   19bda:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   19bde:	461d      	mov	r5, r3
   19be0:	b087      	sub	sp, #28
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   19be2:	b1ea      	cbz	r2, 19c20 <nrfx_twim_2_irq_handler+0x4c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19be4:	2200      	movs	r2, #0
   19be6:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19bea:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   19bee:	b9ba      	cbnz	r2, 19c20 <nrfx_twim_2_irq_handler+0x4c>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   19bf0:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   19bf2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   19bf6:	2202      	movs	r2, #2
   19bf8:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   19bfa:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
   19bfc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19c00:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   19c04:	b11a      	cbz	r2, 19c0e <nrfx_twim_2_irq_handler+0x3a>
    return p_reg->SHORTS;
   19c06:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   19c0a:	059e      	lsls	r6, r3, #22
   19c0c:	d403      	bmi.n	19c16 <nrfx_twim_2_irq_handler+0x42>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19c0e:	2201      	movs	r2, #1
   19c10:	4b47      	ldr	r3, [pc, #284]	; (19d30 <nrfx_twim_2_irq_handler+0x15c>)
   19c12:	621a      	str	r2, [r3, #32]
   19c14:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   19c16:	2301      	movs	r3, #1
   19c18:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM2, &m_cb[NRFX_TWIM2_INST_IDX]);
}
   19c1c:	b007      	add	sp, #28
   19c1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   19c20:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   19c24:	2b00      	cmp	r3, #0
   19c26:	d04e      	beq.n	19cc6 <nrfx_twim_2_irq_handler+0xf2>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19c28:	2300      	movs	r3, #0
   19c2a:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   19c2e:	6a23      	ldr	r3, [r4, #32]
   19c30:	065d      	lsls	r5, r3, #25
   19c32:	d40a      	bmi.n	19c4a <nrfx_twim_2_irq_handler+0x76>
   19c34:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   19c38:	b93b      	cbnz	r3, 19c4a <nrfx_twim_2_irq_handler+0x76>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   19c3a:	493e      	ldr	r1, [pc, #248]	; (19d34 <nrfx_twim_2_irq_handler+0x160>)
   19c3c:	483c      	ldr	r0, [pc, #240]	; (19d30 <nrfx_twim_2_irq_handler+0x15c>)
   19c3e:	f003 fa35 	bl	1d0ac <xfer_completeness_check>
   19c42:	f080 0001 	eor.w	r0, r0, #1
   19c46:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   19c4a:	6a23      	ldr	r3, [r4, #32]
   19c4c:	f013 0704 	ands.w	r7, r3, #4
   19c50:	d11e      	bne.n	19c90 <nrfx_twim_2_irq_handler+0xbc>
            event.xfer_desc = p_cb->xfer_desc;
   19c52:	4e39      	ldr	r6, [pc, #228]	; (19d38 <nrfx_twim_2_irq_handler+0x164>)
   19c54:	ad01      	add	r5, sp, #4
   19c56:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   19c58:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   19c5a:	6833      	ldr	r3, [r6, #0]
   19c5c:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
   19c60:	602b      	str	r3, [r5, #0]
   19c62:	4b33      	ldr	r3, [pc, #204]	; (19d30 <nrfx_twim_2_irq_handler+0x15c>)
   19c64:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   19c68:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   19c6c:	f1bc 0f00 	cmp.w	ip, #0
   19c70:	d002      	beq.n	19c78 <nrfx_twim_2_irq_handler+0xa4>
   19c72:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   19c76:	b15a      	cbz	r2, 19c90 <nrfx_twim_2_irq_handler+0xbc>
    p_reg->SHORTS = mask;
   19c78:	2200      	movs	r2, #0
   19c7a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   19c7e:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   19c80:	4a2e      	ldr	r2, [pc, #184]	; (19d3c <nrfx_twim_2_irq_handler+0x168>)
   19c82:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   19c86:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19c8a:	4b2d      	ldr	r3, [pc, #180]	; (19d40 <nrfx_twim_2_irq_handler+0x16c>)
   19c8c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   19c90:	4a27      	ldr	r2, [pc, #156]	; (19d30 <nrfx_twim_2_irq_handler+0x15c>)
   19c92:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   19c96:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   19c98:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   19c9c:	d53a      	bpl.n	19d14 <nrfx_twim_2_irq_handler+0x140>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   19c9e:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   19ca0:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   19ca4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   19ca8:	b90b      	cbnz	r3, 19cae <nrfx_twim_2_irq_handler+0xda>
        p_cb->busy = false;
   19caa:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   19cae:	6a23      	ldr	r3, [r4, #32]
   19cb0:	075b      	lsls	r3, r3, #29
   19cb2:	d503      	bpl.n	19cbc <nrfx_twim_2_irq_handler+0xe8>
   19cb4:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   19cb8:	2b00      	cmp	r3, #0
   19cba:	d0af      	beq.n	19c1c <nrfx_twim_2_irq_handler+0x48>
        p_cb->handler(&event, p_cb->p_context);
   19cbc:	e9d4 3100 	ldrd	r3, r1, [r4]
   19cc0:	4668      	mov	r0, sp
   19cc2:	4798      	blx	r3
}
   19cc4:	e7aa      	b.n	19c1c <nrfx_twim_2_irq_handler+0x48>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   19cc6:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   19cca:	7b23      	ldrb	r3, [r4, #12]
   19ccc:	b983      	cbnz	r3, 19cf0 <nrfx_twim_2_irq_handler+0x11c>
            event.xfer_desc = p_cb->xfer_desc;
   19cce:	4f1a      	ldr	r7, [pc, #104]	; (19d38 <nrfx_twim_2_irq_handler+0x164>)
   19cd0:	ae01      	add	r6, sp, #4
   19cd2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   19cd4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   19cd6:	683b      	ldr	r3, [r7, #0]
   19cd8:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   19cda:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   19cde:	2b00      	cmp	r3, #0
   19ce0:	d1d6      	bne.n	19c90 <nrfx_twim_2_irq_handler+0xbc>
    p_reg->SHORTS = mask;
   19ce2:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   19ce6:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   19ce8:	4b14      	ldr	r3, [pc, #80]	; (19d3c <nrfx_twim_2_irq_handler+0x168>)
   19cea:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   19cee:	e7ca      	b.n	19c86 <nrfx_twim_2_irq_handler+0xb2>
    p_reg->SHORTS = mask;
   19cf0:	f44f 7300 	mov.w	r3, #512	; 0x200
   19cf4:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   19cf8:	f240 2302 	movw	r3, #514	; 0x202
   19cfc:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   19cfe:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   19d02:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   19d06:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   19d08:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   19d0c:	2301      	movs	r3, #1
   19d0e:	60ab      	str	r3, [r5, #8]
   19d10:	622b      	str	r3, [r5, #32]
            return;
   19d12:	e783      	b.n	19c1c <nrfx_twim_2_irq_handler+0x48>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   19d14:	0759      	lsls	r1, r3, #29
   19d16:	d501      	bpl.n	19d1c <nrfx_twim_2_irq_handler+0x148>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   19d18:	2302      	movs	r3, #2
   19d1a:	e7c1      	b.n	19ca0 <nrfx_twim_2_irq_handler+0xcc>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   19d1c:	07da      	lsls	r2, r3, #31
   19d1e:	d501      	bpl.n	19d24 <nrfx_twim_2_irq_handler+0x150>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   19d20:	2303      	movs	r3, #3
   19d22:	e7bd      	b.n	19ca0 <nrfx_twim_2_irq_handler+0xcc>
    else if (p_cb->error)
   19d24:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   19d28:	2b00      	cmp	r3, #0
   19d2a:	d0b9      	beq.n	19ca0 <nrfx_twim_2_irq_handler+0xcc>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   19d2c:	2304      	movs	r3, #4
   19d2e:	e7b7      	b.n	19ca0 <nrfx_twim_2_irq_handler+0xcc>
   19d30:	4000a000 	.word	0x4000a000
   19d34:	20020b60 	.word	0x20020b60
   19d38:	20020b6c 	.word	0x20020b6c
   19d3c:	019c0202 	.word	0x019c0202
   19d40:	e000e100 	.word	0xe000e100

00019d44 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(s32_t level)
{
   19d44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if (dev) {
				/* Initialization failed. Clear the API struct
				 * so that device_get_binding() will not succeed
				 * for it.
				 */
				dev->driver_api = NULL;
   19d46:	2700      	movs	r7, #0
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   19d48:	4b08      	ldr	r3, [pc, #32]	; (19d6c <z_sys_init_run_level+0x28>)
   19d4a:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   19d4e:	3001      	adds	r0, #1
   19d50:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   19d54:	42a6      	cmp	r6, r4
   19d56:	d800      	bhi.n	19d5a <z_sys_init_run_level+0x16>
			}
		}
	}
}
   19d58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		retval = entry->init(dev);
   19d5a:	e9d4 3500 	ldrd	r3, r5, [r4]
   19d5e:	4628      	mov	r0, r5
   19d60:	4798      	blx	r3
		if (retval != 0) {
   19d62:	b108      	cbz	r0, 19d68 <z_sys_init_run_level+0x24>
			if (dev) {
   19d64:	b105      	cbz	r5, 19d68 <z_sys_init_run_level+0x24>
				dev->driver_api = NULL;
   19d66:	60af      	str	r7, [r5, #8]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   19d68:	3408      	adds	r4, #8
   19d6a:	e7f3      	b.n	19d54 <z_sys_init_run_level+0x10>
   19d6c:	0001e0d8 	.word	0x0001e0d8

00019d70 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
   19d70:	4b0f      	ldr	r3, [pc, #60]	; (19db0 <z_impl_device_get_binding+0x40>)
{
   19d72:	b570      	push	{r4, r5, r6, lr}
   19d74:	4605      	mov	r5, r0
   19d76:	461e      	mov	r6, r3
	for (dev = __device_start; dev != __device_end; dev++) {
   19d78:	4c0e      	ldr	r4, [pc, #56]	; (19db4 <z_impl_device_get_binding+0x44>)
   19d7a:	429c      	cmp	r4, r3
   19d7c:	d104      	bne.n	19d88 <z_impl_device_get_binding+0x18>
		    (dev->name == name)) {
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
   19d7e:	4c0d      	ldr	r4, [pc, #52]	; (19db4 <z_impl_device_get_binding+0x44>)
   19d80:	42b4      	cmp	r4, r6
   19d82:	d108      	bne.n	19d96 <z_impl_device_get_binding+0x26>
		    (strcmp(name, dev->name) == 0)) {
			return dev;
		}
	}

	return NULL;
   19d84:	2400      	movs	r4, #0
   19d86:	e010      	b.n	19daa <z_impl_device_get_binding+0x3a>
		if ((dev->driver_api != NULL) &&
   19d88:	68a2      	ldr	r2, [r4, #8]
   19d8a:	b112      	cbz	r2, 19d92 <z_impl_device_get_binding+0x22>
   19d8c:	6822      	ldr	r2, [r4, #0]
   19d8e:	42aa      	cmp	r2, r5
   19d90:	d00b      	beq.n	19daa <z_impl_device_get_binding+0x3a>
	for (dev = __device_start; dev != __device_end; dev++) {
   19d92:	3410      	adds	r4, #16
   19d94:	e7f1      	b.n	19d7a <z_impl_device_get_binding+0xa>
		if ((dev->driver_api != NULL) &&
   19d96:	68a3      	ldr	r3, [r4, #8]
   19d98:	b90b      	cbnz	r3, 19d9e <z_impl_device_get_binding+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
   19d9a:	3410      	adds	r4, #16
   19d9c:	e7f0      	b.n	19d80 <z_impl_device_get_binding+0x10>
		    (strcmp(name, dev->name) == 0)) {
   19d9e:	4628      	mov	r0, r5
   19da0:	6821      	ldr	r1, [r4, #0]
   19da2:	f002 f8f4 	bl	1bf8e <strcmp>
		if ((dev->driver_api != NULL) &&
   19da6:	2800      	cmp	r0, #0
   19da8:	d1f7      	bne.n	19d9a <z_impl_device_get_binding+0x2a>
}
   19daa:	4620      	mov	r0, r4
   19dac:	bd70      	pop	{r4, r5, r6, pc}
   19dae:	bf00      	nop
   19db0:	20020190 	.word	0x20020190
   19db4:	20020100 	.word	0x20020100

00019db8 <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   19db8:	4b01      	ldr	r3, [pc, #4]	; (19dc0 <z_impl_z_errno+0x8>)
   19dba:	6898      	ldr	r0, [r3, #8]
}
   19dbc:	305c      	adds	r0, #92	; 0x5c
   19dbe:	4770      	bx	lr
   19dc0:	20021f64 	.word	0x20021f64

00019dc4 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   19dc4:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   19dc6:	4d0b      	ldr	r5, [pc, #44]	; (19df4 <idle+0x30>)
	__asm__ volatile(
   19dc8:	f04f 0220 	mov.w	r2, #32
   19dcc:	f3ef 8311 	mrs	r3, BASEPRI
   19dd0:	f382 8811 	msr	BASEPRI, r2
   19dd4:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   19dd8:	f003 fc1c 	bl	1d614 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   19ddc:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
   19dde:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   19de0:	2802      	cmp	r0, #2
   19de2:	bfd8      	it	le
   19de4:	4608      	movle	r0, r1
   19de6:	f003 fc25 	bl	1d634 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   19dea:	622c      	str	r4, [r5, #32]
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   19dec:	f7f4 f932 	bl	e054 <arch_cpu_idle>
}
   19df0:	e7ea      	b.n	19dc8 <idle+0x4>
   19df2:	bf00      	nop
   19df4:	20021f64 	.word	0x20021f64

00019df8 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   19df8:	4802      	ldr	r0, [pc, #8]	; (19e04 <z_bss_zero+0xc>)
   19dfa:	4a03      	ldr	r2, [pc, #12]	; (19e08 <z_bss_zero+0x10>)
   19dfc:	2100      	movs	r1, #0
   19dfe:	1a12      	subs	r2, r2, r0
   19e00:	f002 b91b 	b.w	1c03a <memset>
   19e04:	20020280 	.word	0x20020280
   19e08:	200237dc 	.word	0x200237dc

00019e0c <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   19e0c:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
   19e0e:	4806      	ldr	r0, [pc, #24]	; (19e28 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
   19e10:	4a06      	ldr	r2, [pc, #24]	; (19e2c <z_data_copy+0x20>)
   19e12:	4907      	ldr	r1, [pc, #28]	; (19e30 <z_data_copy+0x24>)
   19e14:	1a12      	subs	r2, r2, r0
   19e16:	f002 f8e5 	bl	1bfe4 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   19e1a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
   19e1e:	4a05      	ldr	r2, [pc, #20]	; (19e34 <z_data_copy+0x28>)
   19e20:	4905      	ldr	r1, [pc, #20]	; (19e38 <z_data_copy+0x2c>)
   19e22:	4806      	ldr	r0, [pc, #24]	; (19e3c <z_data_copy+0x30>)
   19e24:	f002 b8de 	b.w	1bfe4 <memcpy>
   19e28:	20020000 	.word	0x20020000
   19e2c:	2002027c 	.word	0x2002027c
   19e30:	0001e6e8 	.word	0x0001e6e8
   19e34:	00000000 	.word	0x00000000
   19e38:	0001e6e8 	.word	0x0001e6e8
   19e3c:	20020000 	.word	0x20020000

00019e40 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   19e40:	2201      	movs	r2, #1
{
   19e42:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   19e44:	4b0b      	ldr	r3, [pc, #44]	; (19e74 <bg_thread_main+0x34>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   19e46:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   19e48:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   19e4a:	f7ff ff7b 	bl	19d44 <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   19e4e:	4a0a      	ldr	r2, [pc, #40]	; (19e78 <bg_thread_main+0x38>)
   19e50:	490a      	ldr	r1, [pc, #40]	; (19e7c <bg_thread_main+0x3c>)
   19e52:	480b      	ldr	r0, [pc, #44]	; (19e80 <bg_thread_main+0x40>)
   19e54:	f001 f927 	bl	1b0a6 <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   19e58:	2003      	movs	r0, #3
   19e5a:	f7ff ff73 	bl	19d44 <z_sys_init_run_level>

	z_init_static_threads();
   19e5e:	f000 fef1 	bl	1ac44 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   19e62:	f7f3 f839 	bl	ced8 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   19e66:	4a07      	ldr	r2, [pc, #28]	; (19e84 <bg_thread_main+0x44>)
   19e68:	7b13      	ldrb	r3, [r2, #12]
   19e6a:	f023 0301 	bic.w	r3, r3, #1
   19e6e:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   19e70:	bd08      	pop	{r3, pc}
   19e72:	bf00      	nop
   19e74:	20023672 	.word	0x20023672
   19e78:	0001e691 	.word	0x0001e691
   19e7c:	0001e692 	.word	0x0001e692
   19e80:	0001e6a2 	.word	0x0001e6a2
   19e84:	20020c4c 	.word	0x20020c4c

00019e88 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   19e88:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
   19e8c:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 19f7c <z_cstart+0xf4>
   19e90:	b0b5      	sub	sp, #212	; 0xd4
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   19e92:	f389 8808 	msr	MSP, r9
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   19e96:	2400      	movs	r4, #0
   19e98:	23e0      	movs	r3, #224	; 0xe0
   19e9a:	4d31      	ldr	r5, [pc, #196]	; (19f60 <z_cstart+0xd8>)
	z_setup_new_thread(&z_main_thread, z_main_stack,
   19e9c:	f04f 0b01 	mov.w	fp, #1
   19ea0:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   19ea4:	77ec      	strb	r4, [r5, #31]
   19ea6:	762c      	strb	r4, [r5, #24]
   19ea8:	766c      	strb	r4, [r5, #25]
   19eaa:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   19eac:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
   19eae:	4e2d      	ldr	r6, [pc, #180]	; (19f64 <z_cstart+0xdc>)
   19eb0:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   19eb4:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   19eb6:	f7f4 f9f7 	bl	e2a8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   19eba:	f7f4 f8c5 	bl	e048 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   19ebe:	f04f 33ff 	mov.w	r3, #4294967295
   19ec2:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   19ec4:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
   19ec6:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif

	_current_cpu->current = dummy_thread;
   19eca:	4d27      	ldr	r5, [pc, #156]	; (19f68 <z_cstart+0xe0>)
	dummy_thread->base.user_options = K_ESSENTIAL;
   19ecc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   19ed0:	ab06      	add	r3, sp, #24
   19ed2:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   19ed4:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
   19ed6:	e9cd 441e 	strd	r4, r4, [sp, #120]	; 0x78
   19eda:	f7ff ff33 	bl	19d44 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   19ede:	2001      	movs	r0, #1
   19ee0:	f7ff ff30 	bl	19d44 <z_sys_init_run_level>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   19ee4:	f8df a098 	ldr.w	sl, [pc, #152]	; 19f80 <z_cstart+0xf8>
	z_sched_init();
   19ee8:	f000 fd72 	bl	1a9d0 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   19eec:	f8df 8094 	ldr.w	r8, [pc, #148]	; 19f84 <z_cstart+0xfc>
   19ef0:	4b1e      	ldr	r3, [pc, #120]	; (19f6c <z_cstart+0xe4>)
	_kernel.ready_q.cache = &z_main_thread;
   19ef2:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   19ef4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   19ef8:	4641      	mov	r1, r8
   19efa:	4630      	mov	r0, r6
   19efc:	9305      	str	r3, [sp, #20]
   19efe:	e9cd 4b03 	strd	r4, fp, [sp, #12]
   19f02:	4653      	mov	r3, sl
   19f04:	e9cd 4401 	strd	r4, r4, [sp, #4]
   19f08:	9400      	str	r4, [sp, #0]
   19f0a:	f000 fe49 	bl	1aba0 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   19f0e:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
   19f10:	4630      	mov	r0, r6
   19f12:	f023 0304 	bic.w	r3, r3, #4
   19f16:	7373      	strb	r3, [r6, #13]
   19f18:	f003 fa98 	bl	1d44c <z_ready_thread>
	z_setup_new_thread(thread, stack,
   19f1c:	230f      	movs	r3, #15
   19f1e:	4f14      	ldr	r7, [pc, #80]	; (19f70 <z_cstart+0xe8>)
   19f20:	f44f 72a0 	mov.w	r2, #320	; 0x140
   19f24:	4638      	mov	r0, r7
   19f26:	e9cd 4302 	strd	r4, r3, [sp, #8]
   19f2a:	4912      	ldr	r1, [pc, #72]	; (19f74 <z_cstart+0xec>)
   19f2c:	4b12      	ldr	r3, [pc, #72]	; (19f78 <z_cstart+0xf0>)
   19f2e:	e9cd b404 	strd	fp, r4, [sp, #16]
   19f32:	e9cd 4400 	strd	r4, r4, [sp]
   19f36:	f000 fe33 	bl	1aba0 <z_setup_new_thread>
   19f3a:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   19f3c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   19f40:	f023 0304 	bic.w	r3, r3, #4
   19f44:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   19f46:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
   19f4a:	e9c5 3306 	strd	r3, r3, [r5, #24]
   19f4e:	4641      	mov	r1, r8
   19f50:	4653      	mov	r3, sl
   19f52:	4630      	mov	r0, r6
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   19f54:	60ef      	str	r7, [r5, #12]
		_kernel.cpus[i].id = i;
   19f56:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
   19f58:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   19f5c:	f7f3 ffbe 	bl	dedc <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   19f60:	e000ed00 	.word	0xe000ed00
   19f64:	20020c4c 	.word	0x20020c4c
   19f68:	20021f64 	.word	0x20021f64
   19f6c:	0001e6c9 	.word	0x0001e6c9
   19f70:	20020b94 	.word	0x20020b94
   19f74:	20024ee0 	.word	0x20024ee0
   19f78:	00019dc5 	.word	0x00019dc5
   19f7c:	20025820 	.word	0x20025820
   19f80:	00019e41 	.word	0x00019e41
   19f84:	20023ee0 	.word	0x20023ee0

00019f88 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
   19f88:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   19f8a:	4c06      	ldr	r4, [pc, #24]	; (19fa4 <statics_init+0x1c>)
   19f8c:	4d06      	ldr	r5, [pc, #24]	; (19fa8 <statics_init+0x20>)
   19f8e:	42ac      	cmp	r4, r5
   19f90:	d301      	bcc.n	19f96 <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
   19f92:	2000      	movs	r0, #0
   19f94:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   19f96:	4620      	mov	r0, r4
   19f98:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   19f9c:	f003 f8d4 	bl	1d148 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   19fa0:	3414      	adds	r4, #20
   19fa2:	e7f4      	b.n	19f8e <statics_init+0x6>
   19fa4:	200201ac 	.word	0x200201ac
   19fa8:	200201c0 	.word	0x200201c0

00019fac <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   19fac:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   19fae:	4b0e      	ldr	r3, [pc, #56]	; (19fe8 <init_mem_slab_module+0x3c>)
   19fb0:	4c0e      	ldr	r4, [pc, #56]	; (19fec <init_mem_slab_module+0x40>)
   19fb2:	42a3      	cmp	r3, r4
   19fb4:	d301      	bcc.n	19fba <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   19fb6:	2000      	movs	r0, #0
	return rc;
}
   19fb8:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   19fba:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
   19fbe:	ea41 0200 	orr.w	r2, r1, r0
   19fc2:	f012 0203 	ands.w	r2, r2, #3
   19fc6:	d10b      	bne.n	19fe0 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
   19fc8:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
   19fca:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   19fcc:	42aa      	cmp	r2, r5
   19fce:	d101      	bne.n	19fd4 <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   19fd0:	331c      	adds	r3, #28
   19fd2:	e7ee      	b.n	19fb2 <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
   19fd4:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   19fd6:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
   19fd8:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
   19fda:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
   19fdc:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
   19fde:	e7f5      	b.n	19fcc <init_mem_slab_module+0x20>
		return -EINVAL;
   19fe0:	f06f 0015 	mvn.w	r0, #21
	return rc;
   19fe4:	e7e8      	b.n	19fb8 <init_mem_slab_module+0xc>
   19fe6:	bf00      	nop
   19fe8:	20020190 	.word	0x20020190
   19fec:	200201ac 	.word	0x200201ac

00019ff0 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   19ff0:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
   19ff2:	460c      	mov	r4, r1
   19ff4:	4616      	mov	r6, r2
   19ff6:	461f      	mov	r7, r3
   19ff8:	f04f 0320 	mov.w	r3, #32
   19ffc:	f3ef 8111 	mrs	r1, BASEPRI
   1a000:	f383 8811 	msr	BASEPRI, r3
   1a004:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   1a008:	6943      	ldr	r3, [r0, #20]
   1a00a:	b15b      	cbz	r3, 1a024 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
   1a00c:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
   1a00e:	681b      	ldr	r3, [r3, #0]
   1a010:	6143      	str	r3, [r0, #20]
		slab->num_used++;
   1a012:	6983      	ldr	r3, [r0, #24]
   1a014:	3301      	adds	r3, #1
   1a016:	6183      	str	r3, [r0, #24]
		result = 0;
   1a018:	2000      	movs	r0, #0
	__asm__ volatile(
   1a01a:	f381 8811 	msr	BASEPRI, r1
   1a01e:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   1a022:	e011      	b.n	1a048 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1a024:	ea56 0207 	orrs.w	r2, r6, r7
   1a028:	d103      	bne.n	1a032 <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
   1a02a:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
   1a02e:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
   1a030:	e7f3      	b.n	1a01a <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   1a032:	4602      	mov	r2, r0
   1a034:	e9cd 6700 	strd	r6, r7, [sp]
   1a038:	4804      	ldr	r0, [pc, #16]	; (1a04c <k_mem_slab_alloc+0x5c>)
   1a03a:	f000 fc71 	bl	1a920 <z_pend_curr>
		if (result == 0) {
   1a03e:	b918      	cbnz	r0, 1a048 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
   1a040:	4b03      	ldr	r3, [pc, #12]	; (1a050 <k_mem_slab_alloc+0x60>)
   1a042:	689b      	ldr	r3, [r3, #8]
   1a044:	695b      	ldr	r3, [r3, #20]
   1a046:	6023      	str	r3, [r4, #0]
}
   1a048:	b002      	add	sp, #8
   1a04a:	bdd0      	pop	{r4, r6, r7, pc}
   1a04c:	20023673 	.word	0x20023673
   1a050:	20021f64 	.word	0x20021f64

0001a054 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   1a054:	b570      	push	{r4, r5, r6, lr}
   1a056:	4604      	mov	r4, r0
   1a058:	460d      	mov	r5, r1
	__asm__ volatile(
   1a05a:	f04f 0320 	mov.w	r3, #32
   1a05e:	f3ef 8611 	mrs	r6, BASEPRI
   1a062:	f383 8811 	msr	BASEPRI, r3
   1a066:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   1a06a:	f003 fa65 	bl	1d538 <z_unpend_first_thread>

	if (pending_thread != NULL) {
   1a06e:	b158      	cbz	r0, 1a088 <k_mem_slab_free+0x34>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   1a070:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   1a072:	682a      	ldr	r2, [r5, #0]
   1a074:	6701      	str	r1, [r0, #112]	; 0x70
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   1a076:	6142      	str	r2, [r0, #20]
		z_ready_thread(pending_thread);
   1a078:	f003 f9e8 	bl	1d44c <z_ready_thread>
		z_reschedule(&lock, key);
   1a07c:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   1a07e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   1a082:	4808      	ldr	r0, [pc, #32]	; (1a0a4 <k_mem_slab_free+0x50>)
   1a084:	f003 b99a 	b.w	1d3bc <z_reschedule>
		**(char ***)mem = slab->free_list;
   1a088:	682b      	ldr	r3, [r5, #0]
   1a08a:	6962      	ldr	r2, [r4, #20]
   1a08c:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   1a08e:	682b      	ldr	r3, [r5, #0]
   1a090:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   1a092:	69a3      	ldr	r3, [r4, #24]
   1a094:	3b01      	subs	r3, #1
   1a096:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
   1a098:	f386 8811 	msr	BASEPRI, r6
   1a09c:	f3bf 8f6f 	isb	sy
}
   1a0a0:	bd70      	pop	{r4, r5, r6, pc}
   1a0a2:	bf00      	nop
   1a0a4:	20023673 	.word	0x20023673

0001a0a8 <k_malloc>:
K_MEM_POOL_DEFINE(_heap_mem_pool, CONFIG_HEAP_MEM_POOL_MIN_SIZE,
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
   1a0a8:	4601      	mov	r1, r0
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   1a0aa:	4801      	ldr	r0, [pc, #4]	; (1a0b0 <k_malloc+0x8>)
   1a0ac:	f003 b8d1 	b.w	1d252 <k_mem_pool_malloc>
   1a0b0:	200200f4 	.word	0x200200f4

0001a0b4 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   1a0b4:	b507      	push	{r0, r1, r2, lr}
   1a0b6:	9001      	str	r0, [sp, #4]
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   1a0b8:	f003 fa8b 	bl	1d5d2 <k_is_in_isr>
   1a0bc:	9901      	ldr	r1, [sp, #4]
   1a0be:	b948      	cbnz	r0, 1a0d4 <z_thread_malloc+0x20>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   1a0c0:	4b07      	ldr	r3, [pc, #28]	; (1a0e0 <z_thread_malloc+0x2c>)
   1a0c2:	689b      	ldr	r3, [r3, #8]
   1a0c4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	}

	if (pool) {
   1a0c6:	b13b      	cbz	r3, 1a0d8 <z_thread_malloc+0x24>
		ret = k_mem_pool_malloc(pool, size);
   1a0c8:	4618      	mov	r0, r3
	} else {
		ret = NULL;
	}

	return ret;
}
   1a0ca:	b003      	add	sp, #12
   1a0cc:	f85d eb04 	ldr.w	lr, [sp], #4
		ret = k_mem_pool_malloc(pool, size);
   1a0d0:	f003 b8bf 	b.w	1d252 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   1a0d4:	4b03      	ldr	r3, [pc, #12]	; (1a0e4 <z_thread_malloc+0x30>)
   1a0d6:	e7f7      	b.n	1a0c8 <z_thread_malloc+0x14>
}
   1a0d8:	b003      	add	sp, #12
   1a0da:	f85d fb04 	ldr.w	pc, [sp], #4
   1a0de:	bf00      	nop
   1a0e0:	20021f64 	.word	0x20021f64
   1a0e4:	200200f4 	.word	0x200200f4

0001a0e8 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   1a0e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1a0ec:	4604      	mov	r4, r0
   1a0ee:	4616      	mov	r6, r2
   1a0f0:	461f      	mov	r7, r3
   1a0f2:	b085      	sub	sp, #20

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   1a0f4:	f100 0908 	add.w	r9, r0, #8
	__asm__ volatile(
   1a0f8:	f04f 0320 	mov.w	r3, #32
   1a0fc:	f3ef 8811 	mrs	r8, BASEPRI
   1a100:	f383 8811 	msr	BASEPRI, r3
   1a104:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs < msgq->max_msgs) {
   1a108:	6a02      	ldr	r2, [r0, #32]
   1a10a:	68c3      	ldr	r3, [r0, #12]
   1a10c:	429a      	cmp	r2, r3
   1a10e:	d22b      	bcs.n	1a168 <z_impl_k_msgq_put+0x80>
   1a110:	9103      	str	r1, [sp, #12]
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   1a112:	f003 fa11 	bl	1d538 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   1a116:	9903      	ldr	r1, [sp, #12]
   1a118:	4605      	mov	r5, r0
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
   1a11a:	68a2      	ldr	r2, [r4, #8]
		if (pending_thread != NULL) {
   1a11c:	b178      	cbz	r0, 1a13e <z_impl_k_msgq_put+0x56>
   1a11e:	2400      	movs	r4, #0
			(void)memcpy(pending_thread->base.swap_data, data,
   1a120:	6940      	ldr	r0, [r0, #20]
   1a122:	f001 ff5f 	bl	1bfe4 <memcpy>
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   1a126:	4628      	mov	r0, r5
   1a128:	672c      	str	r4, [r5, #112]	; 0x70
   1a12a:	f003 f98f 	bl	1d44c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   1a12e:	4648      	mov	r0, r9
   1a130:	4641      	mov	r1, r8
   1a132:	f003 f943 	bl	1d3bc <z_reschedule>
			return 0;
   1a136:	4620      	mov	r0, r4
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   1a138:	b005      	add	sp, #20
   1a13a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			(void)memcpy(msgq->write_ptr, data, msgq->msg_size);
   1a13e:	69e0      	ldr	r0, [r4, #28]
   1a140:	f001 ff50 	bl	1bfe4 <memcpy>
		result = 0;
   1a144:	2000      	movs	r0, #0
			msgq->write_ptr += msgq->msg_size;
   1a146:	69e3      	ldr	r3, [r4, #28]
   1a148:	68a2      	ldr	r2, [r4, #8]
   1a14a:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   1a14c:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   1a14e:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   1a150:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   1a152:	bf04      	itt	eq
   1a154:	6923      	ldreq	r3, [r4, #16]
   1a156:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   1a158:	6a23      	ldr	r3, [r4, #32]
   1a15a:	3301      	adds	r3, #1
   1a15c:	6223      	str	r3, [r4, #32]
	__asm__ volatile(
   1a15e:	f388 8811 	msr	BASEPRI, r8
   1a162:	f3bf 8f6f 	isb	sy
	return result;
   1a166:	e7e7      	b.n	1a138 <z_impl_k_msgq_put+0x50>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1a168:	ea56 0307 	orrs.w	r3, r6, r7
   1a16c:	d00a      	beq.n	1a184 <z_impl_k_msgq_put+0x9c>
		_current->base.swap_data = data;
   1a16e:	4b07      	ldr	r3, [pc, #28]	; (1a18c <z_impl_k_msgq_put+0xa4>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a170:	4602      	mov	r2, r0
		_current->base.swap_data = data;
   1a172:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a174:	4648      	mov	r0, r9
		_current->base.swap_data = data;
   1a176:	6159      	str	r1, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a178:	4641      	mov	r1, r8
   1a17a:	e9cd 6700 	strd	r6, r7, [sp]
   1a17e:	f000 fbcf 	bl	1a920 <z_pend_curr>
   1a182:	e7d9      	b.n	1a138 <z_impl_k_msgq_put+0x50>
		result = -ENOMSG;
   1a184:	f06f 004f 	mvn.w	r0, #79	; 0x4f
   1a188:	e7e9      	b.n	1a15e <z_impl_k_msgq_put+0x76>
   1a18a:	bf00      	nop
   1a18c:	20021f64 	.word	0x20021f64

0001a190 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   1a190:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1a194:	4604      	mov	r4, r0
   1a196:	4616      	mov	r6, r2
   1a198:	4608      	mov	r0, r1
   1a19a:	461f      	mov	r7, r3

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   1a19c:	f104 0908 	add.w	r9, r4, #8
	__asm__ volatile(
   1a1a0:	f04f 0320 	mov.w	r3, #32
   1a1a4:	f3ef 8811 	mrs	r8, BASEPRI
   1a1a8:	f383 8811 	msr	BASEPRI, r3
   1a1ac:	f3bf 8f6f 	isb	sy

	if (msgq->used_msgs > 0) {
   1a1b0:	6a23      	ldr	r3, [r4, #32]
   1a1b2:	2b00      	cmp	r3, #0
   1a1b4:	d032      	beq.n	1a21c <z_impl_k_msgq_get+0x8c>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
   1a1b6:	68a2      	ldr	r2, [r4, #8]
   1a1b8:	69a1      	ldr	r1, [r4, #24]
   1a1ba:	f001 ff13 	bl	1bfe4 <memcpy>
		msgq->read_ptr += msgq->msg_size;
   1a1be:	69a3      	ldr	r3, [r4, #24]
   1a1c0:	68a2      	ldr	r2, [r4, #8]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   1a1c2:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   1a1c4:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   1a1c6:	6962      	ldr	r2, [r4, #20]
		msgq->read_ptr += msgq->msg_size;
   1a1c8:	61a3      	str	r3, [r4, #24]
		if (msgq->read_ptr == msgq->buffer_end) {
   1a1ca:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   1a1cc:	bf04      	itt	eq
   1a1ce:	6923      	ldreq	r3, [r4, #16]
   1a1d0:	61a3      	streq	r3, [r4, #24]
		msgq->used_msgs--;
   1a1d2:	6a23      	ldr	r3, [r4, #32]
   1a1d4:	3b01      	subs	r3, #1
   1a1d6:	6223      	str	r3, [r4, #32]
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   1a1d8:	f003 f9ae 	bl	1d538 <z_unpend_first_thread>
		if (pending_thread != NULL) {
   1a1dc:	4605      	mov	r5, r0
   1a1de:	b368      	cbz	r0, 1a23c <z_impl_k_msgq_get+0xac>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
   1a1e0:	6941      	ldr	r1, [r0, #20]
   1a1e2:	68a2      	ldr	r2, [r4, #8]
   1a1e4:	69e0      	ldr	r0, [r4, #28]
   1a1e6:	f001 fefd 	bl	1bfe4 <memcpy>
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   1a1ea:	69e3      	ldr	r3, [r4, #28]
   1a1ec:	68a2      	ldr	r2, [r4, #8]
			}
			msgq->used_msgs++;

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   1a1ee:	4628      	mov	r0, r5
			msgq->write_ptr += msgq->msg_size;
   1a1f0:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   1a1f2:	6962      	ldr	r2, [r4, #20]
			msgq->write_ptr += msgq->msg_size;
   1a1f4:	61e3      	str	r3, [r4, #28]
			if (msgq->write_ptr == msgq->buffer_end) {
   1a1f6:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   1a1f8:	bf04      	itt	eq
   1a1fa:	6923      	ldreq	r3, [r4, #16]
   1a1fc:	61e3      	streq	r3, [r4, #28]
			msgq->used_msgs++;
   1a1fe:	6a23      	ldr	r3, [r4, #32]
   1a200:	3301      	adds	r3, #1
   1a202:	6223      	str	r3, [r4, #32]
   1a204:	2400      	movs	r4, #0
   1a206:	672c      	str	r4, [r5, #112]	; 0x70
			z_ready_thread(pending_thread);
   1a208:	f003 f920 	bl	1d44c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   1a20c:	4648      	mov	r0, r9
   1a20e:	4641      	mov	r1, r8
   1a210:	f003 f8d4 	bl	1d3bc <z_reschedule>
			return 0;
   1a214:	4620      	mov	r0, r4
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   1a216:	b003      	add	sp, #12
   1a218:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1a21c:	ea56 0307 	orrs.w	r3, r6, r7
   1a220:	d00a      	beq.n	1a238 <z_impl_k_msgq_get+0xa8>
		_current->base.swap_data = data;
   1a222:	4b09      	ldr	r3, [pc, #36]	; (1a248 <z_impl_k_msgq_get+0xb8>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a224:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   1a226:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a228:	4648      	mov	r0, r9
		_current->base.swap_data = data;
   1a22a:	6159      	str	r1, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   1a22c:	4641      	mov	r1, r8
   1a22e:	e9cd 6700 	strd	r6, r7, [sp]
   1a232:	f000 fb75 	bl	1a920 <z_pend_curr>
   1a236:	e7ee      	b.n	1a216 <z_impl_k_msgq_get+0x86>
		result = -ENOMSG;
   1a238:	f06f 004f 	mvn.w	r0, #79	; 0x4f
	__asm__ volatile(
   1a23c:	f388 8811 	msr	BASEPRI, r8
   1a240:	f3bf 8f6f 	isb	sy
	return result;
   1a244:	e7e7      	b.n	1a216 <z_impl_k_msgq_get+0x86>
   1a246:	bf00      	nop
   1a248:	20021f64 	.word	0x20021f64

0001a24c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   1a24c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1a250:	4604      	mov	r4, r0
   1a252:	4616      	mov	r6, r2
   1a254:	461f      	mov	r7, r3
	__asm__ volatile(
   1a256:	f04f 0320 	mov.w	r3, #32
   1a25a:	f3ef 8811 	mrs	r8, BASEPRI
   1a25e:	f383 8811 	msr	BASEPRI, r3
   1a262:	f3bf 8f6f 	isb	sy
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   1a266:	68c3      	ldr	r3, [r0, #12]
   1a268:	4a32      	ldr	r2, [pc, #200]	; (1a334 <z_impl_k_mutex_lock+0xe8>)
   1a26a:	b16b      	cbz	r3, 1a288 <z_impl_k_mutex_lock+0x3c>
   1a26c:	6880      	ldr	r0, [r0, #8]
   1a26e:	6891      	ldr	r1, [r2, #8]
   1a270:	4288      	cmp	r0, r1
   1a272:	d019      	beq.n	1a2a8 <z_impl_k_mutex_lock+0x5c>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   1a274:	ea56 0307 	orrs.w	r3, r6, r7
   1a278:	d118      	bne.n	1a2ac <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
   1a27a:	f388 8811 	msr	BASEPRI, r8
   1a27e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   1a282:	f06f 000f 	mvn.w	r0, #15
   1a286:	e00c      	b.n	1a2a2 <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
   1a288:	6891      	ldr	r1, [r2, #8]
   1a28a:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   1a28e:	3301      	adds	r3, #1
   1a290:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   1a292:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   1a294:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   1a296:	60a3      	str	r3, [r4, #8]
   1a298:	f388 8811 	msr	BASEPRI, r8
   1a29c:	f3bf 8f6f 	isb	sy
		return 0;
   1a2a0:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   1a2a2:	b002      	add	sp, #8
   1a2a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
   1a2a8:	6921      	ldr	r1, [r4, #16]
   1a2aa:	e7f0      	b.n	1a28e <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   1a2ac:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1a2b0:	f991 100e 	ldrsb.w	r1, [r1, #14]
   1a2b4:	4299      	cmp	r1, r3
   1a2b6:	bfa8      	it	ge
   1a2b8:	4619      	movge	r1, r3
   1a2ba:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   1a2be:	428b      	cmp	r3, r1
   1a2c0:	dd2c      	ble.n	1a31c <z_impl_k_mutex_lock+0xd0>
		return z_set_prio(mutex->owner, new_prio);
   1a2c2:	f000 fb41 	bl	1a948 <z_set_prio>
   1a2c6:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   1a2c8:	4622      	mov	r2, r4
   1a2ca:	4641      	mov	r1, r8
   1a2cc:	e9cd 6700 	strd	r6, r7, [sp]
   1a2d0:	4819      	ldr	r0, [pc, #100]	; (1a338 <z_impl_k_mutex_lock+0xec>)
   1a2d2:	f000 fb25 	bl	1a920 <z_pend_curr>
	if (got_mutex == 0) {
   1a2d6:	2800      	cmp	r0, #0
   1a2d8:	d0e3      	beq.n	1a2a2 <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
   1a2da:	f04f 0320 	mov.w	r3, #32
   1a2de:	f3ef 8611 	mrs	r6, BASEPRI
   1a2e2:	f383 8811 	msr	BASEPRI, r3
   1a2e6:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   1a2ea:	6823      	ldr	r3, [r4, #0]
   1a2ec:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1a2ee:	429c      	cmp	r4, r3
   1a2f0:	d007      	beq.n	1a302 <z_impl_k_mutex_lock+0xb6>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   1a2f2:	b133      	cbz	r3, 1a302 <z_impl_k_mutex_lock+0xb6>
   1a2f4:	f993 300e 	ldrsb.w	r3, [r3, #14]
   1a2f8:	4299      	cmp	r1, r3
   1a2fa:	bfa8      	it	ge
   1a2fc:	4619      	movge	r1, r3
   1a2fe:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   1a302:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   1a304:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1a308:	4299      	cmp	r1, r3
   1a30a:	d109      	bne.n	1a320 <z_impl_k_mutex_lock+0xd4>
	if (resched) {
   1a30c:	b16d      	cbz	r5, 1a32a <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
   1a30e:	4631      	mov	r1, r6
   1a310:	4809      	ldr	r0, [pc, #36]	; (1a338 <z_impl_k_mutex_lock+0xec>)
   1a312:	f003 f853 	bl	1d3bc <z_reschedule>
	return -EAGAIN;
   1a316:	f06f 000a 	mvn.w	r0, #10
   1a31a:	e7c2      	b.n	1a2a2 <z_impl_k_mutex_lock+0x56>
	bool resched = false;
   1a31c:	2500      	movs	r5, #0
   1a31e:	e7d3      	b.n	1a2c8 <z_impl_k_mutex_lock+0x7c>
		return z_set_prio(mutex->owner, new_prio);
   1a320:	f000 fb12 	bl	1a948 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   1a324:	2800      	cmp	r0, #0
   1a326:	d1f2      	bne.n	1a30e <z_impl_k_mutex_lock+0xc2>
   1a328:	e7f0      	b.n	1a30c <z_impl_k_mutex_lock+0xc0>
	__asm__ volatile(
   1a32a:	f386 8811 	msr	BASEPRI, r6
   1a32e:	f3bf 8f6f 	isb	sy
   1a332:	e7f0      	b.n	1a316 <z_impl_k_mutex_lock+0xca>
   1a334:	20021f64 	.word	0x20021f64
   1a338:	20023673 	.word	0x20023673

0001a33c <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   1a33c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   1a33e:	6883      	ldr	r3, [r0, #8]
{
   1a340:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   1a342:	2b00      	cmp	r3, #0
   1a344:	d036      	beq.n	1a3b4 <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   1a346:	4a1e      	ldr	r2, [pc, #120]	; (1a3c0 <z_impl_k_mutex_unlock+0x84>)
   1a348:	6892      	ldr	r2, [r2, #8]
   1a34a:	4293      	cmp	r3, r2
   1a34c:	d135      	bne.n	1a3ba <z_impl_k_mutex_unlock+0x7e>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
   1a34e:	7bda      	ldrb	r2, [r3, #15]
   1a350:	3a01      	subs	r2, #1
   1a352:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   1a354:	68c3      	ldr	r3, [r0, #12]
   1a356:	2b01      	cmp	r3, #1
   1a358:	d005      	beq.n	1a366 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
   1a35a:	3b01      	subs	r3, #1
   1a35c:	60c3      	str	r3, [r0, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   1a35e:	f000 f8f7 	bl	1a550 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   1a362:	2000      	movs	r0, #0
}
   1a364:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   1a366:	f04f 0320 	mov.w	r3, #32
   1a36a:	f3ef 8511 	mrs	r5, BASEPRI
   1a36e:	f383 8811 	msr	BASEPRI, r3
   1a372:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   1a376:	6901      	ldr	r1, [r0, #16]
   1a378:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
   1a37a:	f990 300e 	ldrsb.w	r3, [r0, #14]
   1a37e:	4299      	cmp	r1, r3
   1a380:	d001      	beq.n	1a386 <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
   1a382:	f000 fae1 	bl	1a948 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   1a386:	4620      	mov	r0, r4
   1a388:	f003 f8d6 	bl	1d538 <z_unpend_first_thread>
	mutex->owner = new_owner;
   1a38c:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   1a38e:	b158      	cbz	r0, 1a3a8 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
   1a390:	f990 200e 	ldrsb.w	r2, [r0, #14]
   1a394:	6122      	str	r2, [r4, #16]
   1a396:	2200      	movs	r2, #0
   1a398:	6702      	str	r2, [r0, #112]	; 0x70
		z_ready_thread(new_owner);
   1a39a:	f003 f857 	bl	1d44c <z_ready_thread>
		z_reschedule(&lock, key);
   1a39e:	4629      	mov	r1, r5
   1a3a0:	4808      	ldr	r0, [pc, #32]	; (1a3c4 <z_impl_k_mutex_unlock+0x88>)
   1a3a2:	f003 f80b 	bl	1d3bc <z_reschedule>
   1a3a6:	e7da      	b.n	1a35e <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
   1a3a8:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
   1a3aa:	f385 8811 	msr	BASEPRI, r5
   1a3ae:	f3bf 8f6f 	isb	sy
   1a3b2:	e7d4      	b.n	1a35e <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
   1a3b4:	f06f 0015 	mvn.w	r0, #21
   1a3b8:	e7d4      	b.n	1a364 <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
   1a3ba:	f04f 30ff 	mov.w	r0, #4294967295
   1a3be:	e7d1      	b.n	1a364 <z_impl_k_mutex_unlock+0x28>
   1a3c0:	20021f64 	.word	0x20021f64
   1a3c4:	20023673 	.word	0x20023673

0001a3c8 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   1a3c8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1a3ca:	4616      	mov	r6, r2
   1a3cc:	461f      	mov	r7, r3
	__asm__ volatile(
   1a3ce:	f04f 0320 	mov.w	r3, #32
   1a3d2:	f3ef 8511 	mrs	r5, BASEPRI
   1a3d6:	f383 8811 	msr	BASEPRI, r3
   1a3da:	f3bf 8f6f 	isb	sy
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
   1a3de:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   1a3e0:	b19c      	cbz	r4, 1a40a <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1a3e2:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1a3e4:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1a3e6:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   1a3ea:	4294      	cmp	r4, r2
	list->head = node;
   1a3ec:	6003      	str	r3, [r0, #0]
	list->tail = node;
   1a3ee:	bf08      	it	eq
   1a3f0:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   1a3f2:	2101      	movs	r1, #1
   1a3f4:	4620      	mov	r0, r4
   1a3f6:	f002 ffbb 	bl	1d370 <z_queue_node_peek>
   1a3fa:	4604      	mov	r4, r0
	__asm__ volatile(
   1a3fc:	f385 8811 	msr	BASEPRI, r5
   1a400:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   1a404:	4620      	mov	r0, r4
   1a406:	b003      	add	sp, #12
   1a408:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1a40a:	ea56 0307 	orrs.w	r3, r6, r7
   1a40e:	d0f5      	beq.n	1a3fc <z_impl_k_queue_get+0x34>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1a410:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   1a414:	4629      	mov	r1, r5
   1a416:	4610      	mov	r0, r2
   1a418:	e9cd 6700 	strd	r6, r7, [sp]
   1a41c:	f000 fa80 	bl	1a920 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   1a420:	2800      	cmp	r0, #0
   1a422:	d1ef      	bne.n	1a404 <z_impl_k_queue_get+0x3c>
   1a424:	4b01      	ldr	r3, [pc, #4]	; (1a42c <z_impl_k_queue_get+0x64>)
   1a426:	689b      	ldr	r3, [r3, #8]
   1a428:	695c      	ldr	r4, [r3, #20]
   1a42a:	e7eb      	b.n	1a404 <z_impl_k_queue_get+0x3c>
   1a42c:	20021f64 	.word	0x20021f64

0001a430 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
   1a430:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
   1a432:	4c08      	ldr	r4, [pc, #32]	; (1a454 <z_reset_time_slice+0x24>)
   1a434:	6823      	ldr	r3, [r4, #0]
   1a436:	b15b      	cbz	r3, 1a450 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   1a438:	f7f3 fcb2 	bl	dda0 <z_clock_elapsed>
   1a43c:	6822      	ldr	r2, [r4, #0]
   1a43e:	4906      	ldr	r1, [pc, #24]	; (1a458 <z_reset_time_slice+0x28>)
   1a440:	4410      	add	r0, r2
   1a442:	6108      	str	r0, [r1, #16]
		z_set_timeout_expiry(slice_time, false);
	}
}
   1a444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   1a448:	2100      	movs	r1, #0
   1a44a:	4610      	mov	r0, r2
   1a44c:	f003 b8f2 	b.w	1d634 <z_set_timeout_expiry>
}
   1a450:	bd10      	pop	{r4, pc}
   1a452:	bf00      	nop
   1a454:	20021fa0 	.word	0x20021fa0
   1a458:	20021f64 	.word	0x20021f64

0001a45c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
   1a45c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a45e:	460c      	mov	r4, r1
	__asm__ volatile(
   1a460:	f04f 0320 	mov.w	r3, #32
   1a464:	f3ef 8511 	mrs	r5, BASEPRI
   1a468:	f383 8811 	msr	BASEPRI, r3
   1a46c:	f3bf 8f6f 	isb	sy
			return (u32_t)((t * to_hz + off) / from_hz);
   1a470:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   1a474:	f240 36e7 	movw	r6, #999	; 0x3e7
   1a478:	2700      	movs	r7, #0
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
   1a47a:	2200      	movs	r2, #0
   1a47c:	fbe1 6700 	umlal	r6, r7, r1, r0
   1a480:	4b09      	ldr	r3, [pc, #36]	; (1a4a8 <k_sched_time_slice_set+0x4c>)
   1a482:	4630      	mov	r0, r6
   1a484:	611a      	str	r2, [r3, #16]
   1a486:	4639      	mov	r1, r7
   1a488:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1a48c:	2300      	movs	r3, #0
   1a48e:	f7f2 fa0d 	bl	c8ac <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   1a492:	4b06      	ldr	r3, [pc, #24]	; (1a4ac <k_sched_time_slice_set+0x50>)
   1a494:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   1a496:	4b06      	ldr	r3, [pc, #24]	; (1a4b0 <k_sched_time_slice_set+0x54>)
   1a498:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
   1a49a:	f7ff ffc9 	bl	1a430 <z_reset_time_slice>
	__asm__ volatile(
   1a49e:	f385 8811 	msr	BASEPRI, r5
   1a4a2:	f3bf 8f6f 	isb	sy
	}
}
   1a4a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a4a8:	20021f64 	.word	0x20021f64
   1a4ac:	20021fa0 	.word	0x20021fa0
   1a4b0:	20021f9c 	.word	0x20021f9c

0001a4b4 <k_sched_lock>:
	__asm__ volatile(
   1a4b4:	f04f 0320 	mov.w	r3, #32
   1a4b8:	f3ef 8111 	mrs	r1, BASEPRI
   1a4bc:	f383 8811 	msr	BASEPRI, r3
   1a4c0:	f3bf 8f6f 	isb	sy
   1a4c4:	4b04      	ldr	r3, [pc, #16]	; (1a4d8 <k_sched_lock+0x24>)
   1a4c6:	689a      	ldr	r2, [r3, #8]
   1a4c8:	7bd3      	ldrb	r3, [r2, #15]
   1a4ca:	3b01      	subs	r3, #1
   1a4cc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
   1a4ce:	f381 8811 	msr	BASEPRI, r1
   1a4d2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   1a4d6:	4770      	bx	lr
   1a4d8:	20021f64 	.word	0x20021f64

0001a4dc <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   1a4dc:	4b09      	ldr	r3, [pc, #36]	; (1a504 <z_priq_dumb_remove+0x28>)
   1a4de:	f103 0228 	add.w	r2, r3, #40	; 0x28
   1a4e2:	4282      	cmp	r2, r0
   1a4e4:	d105      	bne.n	1a4f2 <z_priq_dumb_remove+0x16>
   1a4e6:	689b      	ldr	r3, [r3, #8]
   1a4e8:	428b      	cmp	r3, r1
   1a4ea:	d102      	bne.n	1a4f2 <z_priq_dumb_remove+0x16>
   1a4ec:	7b4b      	ldrb	r3, [r1, #13]
   1a4ee:	06db      	lsls	r3, r3, #27
   1a4f0:	d106      	bne.n	1a500 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   1a4f2:	e9d1 3200 	ldrd	r3, r2, [r1]
   1a4f6:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1a4f8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1a4fa:	2300      	movs	r3, #0
	node->prev = NULL;
   1a4fc:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   1a500:	4770      	bx	lr
   1a502:	bf00      	nop
   1a504:	20021f64 	.word	0x20021f64

0001a508 <update_cache>:
{
   1a508:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   1a50a:	4c10      	ldr	r4, [pc, #64]	; (1a54c <update_cache+0x44>)
{
   1a50c:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   1a50e:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1a512:	f002 ff91 	bl	1d438 <z_priq_dumb_best>
   1a516:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
   1a518:	68a3      	ldr	r3, [r4, #8]
   1a51a:	7b59      	ldrb	r1, [r3, #13]
   1a51c:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
   1a51e:	bf44      	itt	mi
   1a520:	f041 0108 	orrmi.w	r1, r1, #8
   1a524:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
   1a526:	b905      	cbnz	r5, 1a52a <update_cache+0x22>
   1a528:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   1a52a:	b94e      	cbnz	r6, 1a540 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
   1a52c:	7b5a      	ldrb	r2, [r3, #13]
   1a52e:	06d2      	lsls	r2, r2, #27
   1a530:	d106      	bne.n	1a540 <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   1a532:	69aa      	ldr	r2, [r5, #24]
   1a534:	b922      	cbnz	r2, 1a540 <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
   1a536:	89da      	ldrh	r2, [r3, #14]
   1a538:	2a7f      	cmp	r2, #127	; 0x7f
   1a53a:	d901      	bls.n	1a540 <update_cache+0x38>
		_kernel.ready_q.cache = _current;
   1a53c:	6263      	str	r3, [r4, #36]	; 0x24
}
   1a53e:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
   1a540:	42ab      	cmp	r3, r5
   1a542:	d001      	beq.n	1a548 <update_cache+0x40>
			z_reset_time_slice();
   1a544:	f7ff ff74 	bl	1a430 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   1a548:	6265      	str	r5, [r4, #36]	; 0x24
}
   1a54a:	e7f8      	b.n	1a53e <update_cache+0x36>
   1a54c:	20021f64 	.word	0x20021f64

0001a550 <k_sched_unlock>:
{
   1a550:	b510      	push	{r4, lr}
	__asm__ volatile(
   1a552:	f04f 0320 	mov.w	r3, #32
   1a556:	f3ef 8411 	mrs	r4, BASEPRI
   1a55a:	f383 8811 	msr	BASEPRI, r3
   1a55e:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
   1a562:	4b08      	ldr	r3, [pc, #32]	; (1a584 <k_sched_unlock+0x34>)
		update_cache(0);
   1a564:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   1a566:	689a      	ldr	r2, [r3, #8]
   1a568:	7bd3      	ldrb	r3, [r2, #15]
   1a56a:	3301      	adds	r3, #1
   1a56c:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   1a56e:	f7ff ffcb 	bl	1a508 <update_cache>
	__asm__ volatile(
   1a572:	f384 8811 	msr	BASEPRI, r4
   1a576:	f3bf 8f6f 	isb	sy
}
   1a57a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
   1a57e:	f002 bf34 	b.w	1d3ea <z_reschedule_unlocked>
   1a582:	bf00      	nop
   1a584:	20021f64 	.word	0x20021f64

0001a588 <ready_thread>:
{
   1a588:	b470      	push	{r4, r5, r6}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1a58a:	7b43      	ldrb	r3, [r0, #13]
   1a58c:	06db      	lsls	r3, r3, #27
   1a58e:	d12a      	bne.n	1a5e6 <ready_thread+0x5e>

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(struct _timeout *t)
{
	return !sys_dnode_is_linked(&t->node);
   1a590:	6983      	ldr	r3, [r0, #24]
	if (z_is_thread_ready(thread)) {
   1a592:	bb43      	cbnz	r3, 1a5e6 <ready_thread+0x5e>
	return list->head == list;
   1a594:	4a15      	ldr	r2, [pc, #84]	; (1a5ec <ready_thread+0x64>)
   1a596:	4611      	mov	r1, r2
   1a598:	f851 4f28 	ldr.w	r4, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1a59c:	428c      	cmp	r4, r1
   1a59e:	bf18      	it	ne
   1a5a0:	4623      	movne	r3, r4
   1a5a2:	2b00      	cmp	r3, #0
   1a5a4:	bf38      	it	cc
   1a5a6:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1a5a8:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1a5aa:	b1b3      	cbz	r3, 1a5da <ready_thread+0x52>
	if (thread_1->base.prio < thread_2->base.prio) {
   1a5ac:	f990 600e 	ldrsb.w	r6, [r0, #14]
   1a5b0:	f993 500e 	ldrsb.w	r5, [r3, #14]
   1a5b4:	42ae      	cmp	r6, r5
   1a5b6:	db03      	blt.n	1a5c0 <ready_thread+0x38>
	return (node == list->tail) ? NULL : node->next;
   1a5b8:	42a3      	cmp	r3, r4
   1a5ba:	d00e      	beq.n	1a5da <ready_thread+0x52>
   1a5bc:	681b      	ldr	r3, [r3, #0]
   1a5be:	e7f4      	b.n	1a5aa <ready_thread+0x22>
	node->prev = successor->prev;
   1a5c0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1a5c2:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
   1a5c6:	6010      	str	r0, [r2, #0]
	successor->prev = node;
   1a5c8:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
   1a5ca:	7b43      	ldrb	r3, [r0, #13]
   1a5cc:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1a5d0:	7343      	strb	r3, [r0, #13]
}
   1a5d2:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
   1a5d4:	2000      	movs	r0, #0
   1a5d6:	f7ff bf97 	b.w	1a508 <update_cache>
	node->prev = list->tail;
   1a5da:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
   1a5de:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1a5e0:	6018      	str	r0, [r3, #0]
	list->tail = node;
   1a5e2:	62d0      	str	r0, [r2, #44]	; 0x2c
}
   1a5e4:	e7f1      	b.n	1a5ca <ready_thread+0x42>
}
   1a5e6:	bc70      	pop	{r4, r5, r6}
   1a5e8:	4770      	bx	lr
   1a5ea:	bf00      	nop
   1a5ec:	20021f64 	.word	0x20021f64

0001a5f0 <z_sched_start>:
{
   1a5f0:	b510      	push	{r4, lr}
	__asm__ volatile(
   1a5f2:	f04f 0220 	mov.w	r2, #32
   1a5f6:	f3ef 8411 	mrs	r4, BASEPRI
   1a5fa:	f382 8811 	msr	BASEPRI, r2
   1a5fe:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
   1a602:	7b42      	ldrb	r2, [r0, #13]
   1a604:	0751      	lsls	r1, r2, #29
   1a606:	d404      	bmi.n	1a612 <z_sched_start+0x22>
	__asm__ volatile(
   1a608:	f384 8811 	msr	BASEPRI, r4
   1a60c:	f3bf 8f6f 	isb	sy
}
   1a610:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   1a612:	f022 0204 	bic.w	r2, r2, #4
   1a616:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
   1a618:	f7ff ffb6 	bl	1a588 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   1a61c:	4621      	mov	r1, r4
}
   1a61e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
   1a622:	4801      	ldr	r0, [pc, #4]	; (1a628 <z_sched_start+0x38>)
   1a624:	f002 beca 	b.w	1d3bc <z_reschedule>
   1a628:	20023673 	.word	0x20023673

0001a62c <z_move_thread_to_end_of_prio_q>:
{
   1a62c:	4601      	mov	r1, r0
   1a62e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
   1a630:	f04f 0320 	mov.w	r3, #32
   1a634:	f3ef 8411 	mrs	r4, BASEPRI
   1a638:	f383 8811 	msr	BASEPRI, r3
   1a63c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1a640:	f990 300d 	ldrsb.w	r3, [r0, #13]
   1a644:	2b00      	cmp	r3, #0
   1a646:	da02      	bge.n	1a64e <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1a648:	4819      	ldr	r0, [pc, #100]	; (1a6b0 <z_move_thread_to_end_of_prio_q+0x84>)
   1a64a:	f7ff ff47 	bl	1a4dc <z_priq_dumb_remove>
	return list->head == list;
   1a64e:	4a19      	ldr	r2, [pc, #100]	; (1a6b4 <z_move_thread_to_end_of_prio_q+0x88>)
   1a650:	4610      	mov	r0, r2
   1a652:	f850 3f28 	ldr.w	r3, [r0, #40]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1a656:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1a658:	4283      	cmp	r3, r0
   1a65a:	bf08      	it	eq
   1a65c:	2300      	moveq	r3, #0
   1a65e:	2b00      	cmp	r3, #0
   1a660:	bf38      	it	cc
   1a662:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1a664:	b1eb      	cbz	r3, 1a6a2 <z_move_thread_to_end_of_prio_q+0x76>
	if (thread_1->base.prio < thread_2->base.prio) {
   1a666:	f991 700e 	ldrsb.w	r7, [r1, #14]
   1a66a:	f993 600e 	ldrsb.w	r6, [r3, #14]
   1a66e:	42b7      	cmp	r7, r6
   1a670:	db03      	blt.n	1a67a <z_move_thread_to_end_of_prio_q+0x4e>
	return (node == list->tail) ? NULL : node->next;
   1a672:	429d      	cmp	r5, r3
   1a674:	d015      	beq.n	1a6a2 <z_move_thread_to_end_of_prio_q+0x76>
   1a676:	681b      	ldr	r3, [r3, #0]
   1a678:	e7f4      	b.n	1a664 <z_move_thread_to_end_of_prio_q+0x38>
	node->prev = successor->prev;
   1a67a:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
   1a67c:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
   1a680:	6001      	str	r1, [r0, #0]
	successor->prev = node;
   1a682:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
   1a684:	7b4b      	ldrb	r3, [r1, #13]
		update_cache(thread == _current);
   1a686:	6890      	ldr	r0, [r2, #8]
   1a688:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1a68c:	734b      	strb	r3, [r1, #13]
   1a68e:	1a43      	subs	r3, r0, r1
   1a690:	4258      	negs	r0, r3
   1a692:	4158      	adcs	r0, r3
   1a694:	f7ff ff38 	bl	1a508 <update_cache>
	__asm__ volatile(
   1a698:	f384 8811 	msr	BASEPRI, r4
   1a69c:	f3bf 8f6f 	isb	sy
}
   1a6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node->prev = list->tail;
   1a6a2:	e9c1 0500 	strd	r0, r5, [r1]
	list->tail->next = node;
   1a6a6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   1a6a8:	6019      	str	r1, [r3, #0]
	list->tail = node;
   1a6aa:	62d1      	str	r1, [r2, #44]	; 0x2c
}
   1a6ac:	e7ea      	b.n	1a684 <z_move_thread_to_end_of_prio_q+0x58>
   1a6ae:	bf00      	nop
   1a6b0:	20021f8c 	.word	0x20021f8c
   1a6b4:	20021f64 	.word	0x20021f64

0001a6b8 <z_time_slice>:
{
   1a6b8:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   1a6ba:	4a15      	ldr	r2, [pc, #84]	; (1a710 <z_time_slice+0x58>)
   1a6bc:	4b15      	ldr	r3, [pc, #84]	; (1a714 <z_time_slice+0x5c>)
   1a6be:	6814      	ldr	r4, [r2, #0]
{
   1a6c0:	4601      	mov	r1, r0
	if (pending_current == _current) {
   1a6c2:	6898      	ldr	r0, [r3, #8]
   1a6c4:	42a0      	cmp	r0, r4
   1a6c6:	461c      	mov	r4, r3
   1a6c8:	d103      	bne.n	1a6d2 <z_time_slice+0x1a>
}
   1a6ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   1a6ce:	f7ff beaf 	b.w	1a430 <z_reset_time_slice>
	pending_current = NULL;
   1a6d2:	2500      	movs	r5, #0
   1a6d4:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
   1a6d6:	4a10      	ldr	r2, [pc, #64]	; (1a718 <z_time_slice+0x60>)
   1a6d8:	6812      	ldr	r2, [r2, #0]
   1a6da:	b1b2      	cbz	r2, 1a70a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   1a6dc:	89c2      	ldrh	r2, [r0, #14]
   1a6de:	2a7f      	cmp	r2, #127	; 0x7f
   1a6e0:	d813      	bhi.n	1a70a <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   1a6e2:	4a0e      	ldr	r2, [pc, #56]	; (1a71c <z_time_slice+0x64>)
   1a6e4:	f990 500e 	ldrsb.w	r5, [r0, #14]
   1a6e8:	6812      	ldr	r2, [r2, #0]
   1a6ea:	4295      	cmp	r5, r2
   1a6ec:	db0d      	blt.n	1a70a <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   1a6ee:	4a0c      	ldr	r2, [pc, #48]	; (1a720 <z_time_slice+0x68>)
   1a6f0:	4290      	cmp	r0, r2
   1a6f2:	d00a      	beq.n	1a70a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   1a6f4:	6982      	ldr	r2, [r0, #24]
   1a6f6:	b942      	cbnz	r2, 1a70a <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   1a6f8:	691a      	ldr	r2, [r3, #16]
   1a6fa:	428a      	cmp	r2, r1
   1a6fc:	dc02      	bgt.n	1a704 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   1a6fe:	f7ff ff95 	bl	1a62c <z_move_thread_to_end_of_prio_q>
   1a702:	e7e2      	b.n	1a6ca <z_time_slice+0x12>
			_current_cpu->slice_ticks -= ticks;
   1a704:	1a52      	subs	r2, r2, r1
   1a706:	611a      	str	r2, [r3, #16]
}
   1a708:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   1a70a:	2300      	movs	r3, #0
   1a70c:	6123      	str	r3, [r4, #16]
   1a70e:	e7fb      	b.n	1a708 <z_time_slice+0x50>
   1a710:	20021f98 	.word	0x20021f98
   1a714:	20021f64 	.word	0x20021f64
   1a718:	20021fa0 	.word	0x20021fa0
   1a71c:	20021f9c 	.word	0x20021f9c
   1a720:	20020b94 	.word	0x20020b94

0001a724 <z_impl_k_thread_suspend>:
{
   1a724:	b570      	push	{r4, r5, r6, lr}
   1a726:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   1a728:	3018      	adds	r0, #24
   1a72a:	f002 ff5d 	bl	1d5e8 <z_abort_timeout>
	__asm__ volatile(
   1a72e:	f04f 0320 	mov.w	r3, #32
   1a732:	f3ef 8611 	mrs	r6, BASEPRI
   1a736:	f383 8811 	msr	BASEPRI, r3
   1a73a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
   1a73e:	f994 300d 	ldrsb.w	r3, [r4, #13]
   1a742:	2b00      	cmp	r3, #0
   1a744:	da07      	bge.n	1a756 <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   1a746:	4621      	mov	r1, r4
   1a748:	480e      	ldr	r0, [pc, #56]	; (1a784 <z_impl_k_thread_suspend+0x60>)
   1a74a:	f7ff fec7 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1a74e:	7b63      	ldrb	r3, [r4, #13]
   1a750:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1a754:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   1a756:	4d0c      	ldr	r5, [pc, #48]	; (1a788 <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1a758:	7b63      	ldrb	r3, [r4, #13]
   1a75a:	68a8      	ldr	r0, [r5, #8]
   1a75c:	f043 0310 	orr.w	r3, r3, #16
   1a760:	7363      	strb	r3, [r4, #13]
   1a762:	1b03      	subs	r3, r0, r4
   1a764:	4258      	negs	r0, r3
   1a766:	4158      	adcs	r0, r3
   1a768:	f7ff fece 	bl	1a508 <update_cache>
	__asm__ volatile(
   1a76c:	f386 8811 	msr	BASEPRI, r6
   1a770:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   1a774:	68ab      	ldr	r3, [r5, #8]
   1a776:	42a3      	cmp	r3, r4
   1a778:	d103      	bne.n	1a782 <z_impl_k_thread_suspend+0x5e>
}
   1a77a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   1a77e:	f002 be34 	b.w	1d3ea <z_reschedule_unlocked>
}
   1a782:	bd70      	pop	{r4, r5, r6, pc}
   1a784:	20021f8c 	.word	0x20021f8c
   1a788:	20021f64 	.word	0x20021f64

0001a78c <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   1a78c:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
   1a78e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a792:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   1a794:	b103      	cbz	r3, 1a798 <z_thread_single_abort+0xc>
		thread->fn_abort();
   1a796:	4798      	blx	r3
   1a798:	f104 0018 	add.w	r0, r4, #24
   1a79c:	f002 ff24 	bl	1d5e8 <z_abort_timeout>
	__asm__ volatile(
   1a7a0:	f04f 0320 	mov.w	r3, #32
   1a7a4:	f3ef 8611 	mrs	r6, BASEPRI
   1a7a8:	f383 8811 	msr	BASEPRI, r3
   1a7ac:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1a7b0:	7b63      	ldrb	r3, [r4, #13]
   1a7b2:	06d8      	lsls	r0, r3, #27
   1a7b4:	d123      	bne.n	1a7fe <z_thread_single_abort+0x72>
		if (z_is_thread_ready(thread)) {
   1a7b6:	69a2      	ldr	r2, [r4, #24]
   1a7b8:	bb0a      	cbnz	r2, 1a7fe <z_thread_single_abort+0x72>
			if (z_is_thread_queued(thread)) {
   1a7ba:	0619      	lsls	r1, r3, #24
   1a7bc:	d507      	bpl.n	1a7ce <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
   1a7be:	4621      	mov	r1, r4
   1a7c0:	481e      	ldr	r0, [pc, #120]	; (1a83c <z_thread_single_abort+0xb0>)
   1a7c2:	f7ff fe8b 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1a7c6:	7b63      	ldrb	r3, [r4, #13]
   1a7c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1a7cc:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   1a7ce:	4b1c      	ldr	r3, [pc, #112]	; (1a840 <z_thread_single_abort+0xb4>)
   1a7d0:	6898      	ldr	r0, [r3, #8]
   1a7d2:	1b02      	subs	r2, r0, r4
   1a7d4:	4250      	negs	r0, r2
   1a7d6:	4150      	adcs	r0, r2
   1a7d8:	f7ff fe96 	bl	1a508 <update_cache>
			waiter->base.pended_on = NULL;
   1a7dc:	2700      	movs	r7, #0
		thread->base.thread_state |= mask;
   1a7de:	7b63      	ldrb	r3, [r4, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   1a7e0:	f104 0828 	add.w	r8, r4, #40	; 0x28
   1a7e4:	f043 0308 	orr.w	r3, r3, #8
   1a7e8:	7363      	strb	r3, [r4, #13]
	return list->head == list;
   1a7ea:	6aa5      	ldr	r5, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1a7ec:	4545      	cmp	r5, r8
   1a7ee:	d000      	beq.n	1a7f2 <z_thread_single_abort+0x66>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   1a7f0:	b995      	cbnz	r5, 1a818 <z_thread_single_abort+0x8c>
	__asm__ volatile(
   1a7f2:	f386 8811 	msr	BASEPRI, r6
   1a7f6:	f3bf 8f6f 	isb	sy
}
   1a7fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (z_is_thread_pending(thread)) {
   1a7fe:	079b      	lsls	r3, r3, #30
   1a800:	d5ec      	bpl.n	1a7dc <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
   1a802:	4621      	mov	r1, r4
   1a804:	68a0      	ldr	r0, [r4, #8]
   1a806:	f7ff fe69 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1a80a:	7b63      	ldrb	r3, [r4, #13]
   1a80c:	f023 0302 	bic.w	r3, r3, #2
   1a810:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   1a812:	2300      	movs	r3, #0
   1a814:	60a3      	str	r3, [r4, #8]
   1a816:	e7e1      	b.n	1a7dc <z_thread_single_abort+0x50>
   1a818:	f105 0018 	add.w	r0, r5, #24
   1a81c:	f002 fee4 	bl	1d5e8 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   1a820:	68a8      	ldr	r0, [r5, #8]
   1a822:	4629      	mov	r1, r5
   1a824:	f7ff fe5a 	bl	1a4dc <z_priq_dumb_remove>
   1a828:	7b6b      	ldrb	r3, [r5, #13]
			ready_thread(waiter);
   1a82a:	4628      	mov	r0, r5
   1a82c:	f023 0302 	bic.w	r3, r3, #2
   1a830:	736b      	strb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
   1a832:	60af      	str	r7, [r5, #8]
   1a834:	672f      	str	r7, [r5, #112]	; 0x70
			ready_thread(waiter);
   1a836:	f7ff fea7 	bl	1a588 <ready_thread>
   1a83a:	e7d6      	b.n	1a7ea <z_thread_single_abort+0x5e>
   1a83c:	20021f8c 	.word	0x20021f8c
   1a840:	20021f64 	.word	0x20021f64

0001a844 <unready_thread>:
{
   1a844:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
   1a846:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
   1a84a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
   1a84c:	2b00      	cmp	r3, #0
   1a84e:	da06      	bge.n	1a85e <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   1a850:	4807      	ldr	r0, [pc, #28]	; (1a870 <unready_thread+0x2c>)
   1a852:	f7ff fe43 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   1a856:	7b4b      	ldrb	r3, [r1, #13]
   1a858:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   1a85c:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
   1a85e:	4b05      	ldr	r3, [pc, #20]	; (1a874 <unready_thread+0x30>)
   1a860:	6898      	ldr	r0, [r3, #8]
   1a862:	1a43      	subs	r3, r0, r1
   1a864:	4258      	negs	r0, r3
   1a866:	4158      	adcs	r0, r3
}
   1a868:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
   1a86c:	f7ff be4c 	b.w	1a508 <update_cache>
   1a870:	20021f8c 	.word	0x20021f8c
   1a874:	20021f64 	.word	0x20021f64

0001a878 <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
   1a878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1a87a:	4605      	mov	r5, r0
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
   1a87c:	f002 fef5 	bl	1d66a <z_tick_get_32>
   1a880:	182c      	adds	r4, r5, r0
	__asm__ volatile(
   1a882:	f04f 0320 	mov.w	r3, #32
   1a886:	f3ef 8711 	mrs	r7, BASEPRI
   1a88a:	f383 8811 	msr	BASEPRI, r3
   1a88e:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
   1a892:	4e0d      	ldr	r6, [pc, #52]	; (1a8c8 <z_tick_sleep.part.0+0x50>)
   1a894:	4b0d      	ldr	r3, [pc, #52]	; (1a8cc <z_tick_sleep.part.0+0x54>)
   1a896:	68b0      	ldr	r0, [r6, #8]
   1a898:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
   1a89a:	f002 fe12 	bl	1d4c2 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, timeout);
   1a89e:	68b0      	ldr	r0, [r6, #8]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   1a8a0:	490b      	ldr	r1, [pc, #44]	; (1a8d0 <z_tick_sleep.part.0+0x58>)
   1a8a2:	462a      	mov	r2, r5
   1a8a4:	17eb      	asrs	r3, r5, #31
   1a8a6:	3018      	adds	r0, #24
   1a8a8:	f000 fa90 	bl	1adcc <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   1a8ac:	68b2      	ldr	r2, [r6, #8]
	ret = arch_swap(key);
   1a8ae:	4638      	mov	r0, r7
	thread->base.thread_state |= _THREAD_SUSPENDED;
   1a8b0:	7b53      	ldrb	r3, [r2, #13]
   1a8b2:	f043 0310 	orr.w	r3, r3, #16
   1a8b6:	7353      	strb	r3, [r2, #13]
   1a8b8:	f7f3 faa6 	bl	de08 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
   1a8bc:	f002 fed5 	bl	1d66a <z_tick_get_32>
   1a8c0:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
   1a8c2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   1a8c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a8c8:	20021f64 	.word	0x20021f64
   1a8cc:	20021f98 	.word	0x20021f98
   1a8d0:	0001d46d 	.word	0x0001d46d

0001a8d4 <pend>:
{
   1a8d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a8d8:	4606      	mov	r6, r0
   1a8da:	4614      	mov	r4, r2
   1a8dc:	461d      	mov	r5, r3
   1a8de:	f04f 0320 	mov.w	r3, #32
   1a8e2:	f3ef 8711 	mrs	r7, BASEPRI
   1a8e6:	f383 8811 	msr	BASEPRI, r3
   1a8ea:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
   1a8ee:	f002 fdf8 	bl	1d4e2 <add_to_waitq_locked>
	__asm__ volatile(
   1a8f2:	f387 8811 	msr	BASEPRI, r7
   1a8f6:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1a8fa:	1c6b      	adds	r3, r5, #1
   1a8fc:	bf08      	it	eq
   1a8fe:	f1b4 3fff 	cmpeq.w	r4, #4294967295
   1a902:	d008      	beq.n	1a916 <pend+0x42>
   1a904:	4622      	mov	r2, r4
   1a906:	462b      	mov	r3, r5
   1a908:	f106 0018 	add.w	r0, r6, #24
   1a90c:	4903      	ldr	r1, [pc, #12]	; (1a91c <pend+0x48>)
}
   1a90e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1a912:	f000 ba5b 	b.w	1adcc <z_add_timeout>
   1a916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1a91a:	bf00      	nop
   1a91c:	0001d46d 	.word	0x0001d46d

0001a920 <z_pend_curr>:
{
   1a920:	b510      	push	{r4, lr}
   1a922:	460c      	mov	r4, r1
	pending_current = _current;
   1a924:	4b06      	ldr	r3, [pc, #24]	; (1a940 <z_pend_curr+0x20>)
{
   1a926:	4611      	mov	r1, r2
	pending_current = _current;
   1a928:	6898      	ldr	r0, [r3, #8]
   1a92a:	4b06      	ldr	r3, [pc, #24]	; (1a944 <z_pend_curr+0x24>)
   1a92c:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
   1a92e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1a932:	f7ff ffcf 	bl	1a8d4 <pend>
   1a936:	4620      	mov	r0, r4
}
   1a938:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1a93c:	f7f3 ba64 	b.w	de08 <arch_swap>
   1a940:	20021f64 	.word	0x20021f64
   1a944:	20021f98 	.word	0x20021f98

0001a948 <z_set_prio>:
{
   1a948:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1a94c:	4604      	mov	r4, r0
	__asm__ volatile(
   1a94e:	f04f 0320 	mov.w	r3, #32
   1a952:	f3ef 8811 	mrs	r8, BASEPRI
   1a956:	f383 8811 	msr	BASEPRI, r3
   1a95a:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1a95e:	7b43      	ldrb	r3, [r0, #13]
   1a960:	b24e      	sxtb	r6, r1
   1a962:	06db      	lsls	r3, r3, #27
   1a964:	d12e      	bne.n	1a9c4 <z_set_prio+0x7c>
	return !sys_dnode_is_linked(&t->node);
   1a966:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
   1a968:	bb65      	cbnz	r5, 1a9c4 <z_set_prio+0x7c>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   1a96a:	4f18      	ldr	r7, [pc, #96]	; (1a9cc <z_set_prio+0x84>)
   1a96c:	4621      	mov	r1, r4
   1a96e:	f107 0028 	add.w	r0, r7, #40	; 0x28
   1a972:	f7ff fdb3 	bl	1a4dc <z_priq_dumb_remove>
	return list->head == list;
   1a976:	6abb      	ldr	r3, [r7, #40]	; 0x28
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1a978:	6afa      	ldr	r2, [r7, #44]	; 0x2c
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1a97a:	4283      	cmp	r3, r0
   1a97c:	bf18      	it	ne
   1a97e:	461d      	movne	r5, r3
   1a980:	2d00      	cmp	r5, #0
   1a982:	bf38      	it	cc
   1a984:	2500      	movcc	r5, #0
				thread->base.prio = prio;
   1a986:	73a6      	strb	r6, [r4, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1a988:	b1b5      	cbz	r5, 1a9b8 <z_set_prio+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   1a98a:	f995 100e 	ldrsb.w	r1, [r5, #14]
   1a98e:	42b1      	cmp	r1, r6
   1a990:	dc03      	bgt.n	1a99a <z_set_prio+0x52>
	return (node == list->tail) ? NULL : node->next;
   1a992:	42aa      	cmp	r2, r5
   1a994:	d010      	beq.n	1a9b8 <z_set_prio+0x70>
   1a996:	682d      	ldr	r5, [r5, #0]
   1a998:	e7f6      	b.n	1a988 <z_set_prio+0x40>
	node->prev = successor->prev;
   1a99a:	686a      	ldr	r2, [r5, #4]
	node->next = successor;
   1a99c:	e9c4 5200 	strd	r5, r2, [r4]
	successor->prev->next = node;
   1a9a0:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   1a9a2:	606c      	str	r4, [r5, #4]
			update_cache(1);
   1a9a4:	2001      	movs	r0, #1
   1a9a6:	f7ff fdaf 	bl	1a508 <update_cache>
   1a9aa:	2001      	movs	r0, #1
	__asm__ volatile(
   1a9ac:	f388 8811 	msr	BASEPRI, r8
   1a9b0:	f3bf 8f6f 	isb	sy
}
   1a9b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->prev = list->tail;
   1a9b8:	e9c4 0200 	strd	r0, r2, [r4]
	list->tail->next = node;
   1a9bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a9be:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1a9c0:	62fc      	str	r4, [r7, #44]	; 0x2c
}
   1a9c2:	e7ef      	b.n	1a9a4 <z_set_prio+0x5c>
			thread->base.prio = prio;
   1a9c4:	2000      	movs	r0, #0
   1a9c6:	73a6      	strb	r6, [r4, #14]
   1a9c8:	e7f0      	b.n	1a9ac <z_set_prio+0x64>
   1a9ca:	bf00      	nop
   1a9cc:	20021f64 	.word	0x20021f64

0001a9d0 <z_sched_init>:
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   1a9d0:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   1a9d2:	4b04      	ldr	r3, [pc, #16]	; (1a9e4 <z_sched_init+0x14>)
   1a9d4:	4608      	mov	r0, r1
   1a9d6:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   1a9da:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   1a9de:	f7ff bd3d 	b.w	1a45c <k_sched_time_slice_set>
   1a9e2:	bf00      	nop
   1a9e4:	20021f64 	.word	0x20021f64

0001a9e8 <z_impl_k_yield>:
{
   1a9e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
   1a9ea:	4c24      	ldr	r4, [pc, #144]	; (1aa7c <z_impl_k_yield+0x94>)
   1a9ec:	4b24      	ldr	r3, [pc, #144]	; (1aa80 <z_impl_k_yield+0x98>)
   1a9ee:	68a2      	ldr	r2, [r4, #8]
   1a9f0:	429a      	cmp	r2, r3
   1a9f2:	d030      	beq.n	1aa56 <z_impl_k_yield+0x6e>
	__asm__ volatile(
   1a9f4:	f04f 0320 	mov.w	r3, #32
   1a9f8:	f3ef 8511 	mrs	r5, BASEPRI
   1a9fc:	f383 8811 	msr	BASEPRI, r3
   1aa00:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
   1aa04:	68a1      	ldr	r1, [r4, #8]
   1aa06:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1aa0a:	f7ff fd67 	bl	1a4dc <z_priq_dumb_remove>
	return list->head == list;
   1aa0e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
   1aa10:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1aa12:	4283      	cmp	r3, r0
   1aa14:	bf08      	it	eq
   1aa16:	2300      	moveq	r3, #0
   1aa18:	2b00      	cmp	r3, #0
   1aa1a:	bf38      	it	cc
   1aa1c:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1aa1e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1aa20:	b32b      	cbz	r3, 1aa6e <z_impl_k_yield+0x86>
	if (thread_1->base.prio < thread_2->base.prio) {
   1aa22:	f992 700e 	ldrsb.w	r7, [r2, #14]
   1aa26:	f993 600e 	ldrsb.w	r6, [r3, #14]
   1aa2a:	42b7      	cmp	r7, r6
   1aa2c:	db03      	blt.n	1aa36 <z_impl_k_yield+0x4e>
	return (node == list->tail) ? NULL : node->next;
   1aa2e:	428b      	cmp	r3, r1
   1aa30:	d01d      	beq.n	1aa6e <z_impl_k_yield+0x86>
   1aa32:	681b      	ldr	r3, [r3, #0]
   1aa34:	e7f4      	b.n	1aa20 <z_impl_k_yield+0x38>
	node->prev = successor->prev;
   1aa36:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   1aa38:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
   1aa3c:	600a      	str	r2, [r1, #0]
	successor->prev = node;
   1aa3e:	605a      	str	r2, [r3, #4]
	thread->base.thread_state |= states;
   1aa40:	7b53      	ldrb	r3, [r2, #13]
			update_cache(1);
   1aa42:	2001      	movs	r0, #1
   1aa44:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1aa48:	7353      	strb	r3, [r2, #13]
   1aa4a:	f7ff fd5d 	bl	1a508 <update_cache>
	__asm__ volatile(
   1aa4e:	f385 8811 	msr	BASEPRI, r5
   1aa52:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1aa56:	f04f 0320 	mov.w	r3, #32
   1aa5a:	f3ef 8011 	mrs	r0, BASEPRI
   1aa5e:	f383 8811 	msr	BASEPRI, r3
   1aa62:	f3bf 8f6f 	isb	sy
}
   1aa66:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1aa6a:	f7f3 b9cd 	b.w	de08 <arch_swap>
	node->prev = list->tail;
   1aa6e:	e9c2 0100 	strd	r0, r1, [r2]
	list->tail->next = node;
   1aa72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1aa74:	601a      	str	r2, [r3, #0]
	list->tail = node;
   1aa76:	62e2      	str	r2, [r4, #44]	; 0x2c
}
   1aa78:	e7e2      	b.n	1aa40 <z_impl_k_yield+0x58>
   1aa7a:	bf00      	nop
   1aa7c:	20021f64 	.word	0x20021f64
   1aa80:	20020b94 	.word	0x20020b94

0001aa84 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
   1aa84:	460b      	mov	r3, r1
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1aa86:	3301      	adds	r3, #1
   1aa88:	bf08      	it	eq
   1aa8a:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   1aa8e:	b510      	push	{r4, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1aa90:	d106      	bne.n	1aaa0 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
   1aa92:	4b0b      	ldr	r3, [pc, #44]	; (1aac0 <z_impl_k_sleep+0x3c>)
   1aa94:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   1aa96:	f7ff fe45 	bl	1a724 <z_impl_k_thread_suspend>
		return (s32_t) K_TICKS_FOREVER;
   1aa9a:	f04f 30ff 	mov.w	r0, #4294967295
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   1aa9e:	bd10      	pop	{r4, pc}
	ticks = z_tick_sleep(ticks);
   1aaa0:	4604      	mov	r4, r0
	if (ticks == 0) {
   1aaa2:	b948      	cbnz	r0, 1aab8 <z_impl_k_sleep+0x34>
	z_impl_k_yield();
   1aaa4:	f7ff ffa0 	bl	1a9e8 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
   1aaa8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   1aaac:	fb84 3400 	smull	r3, r4, r4, r0
   1aab0:	0bd8      	lsrs	r0, r3, #15
   1aab2:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   1aab6:	e7f2      	b.n	1aa9e <z_impl_k_sleep+0x1a>
   1aab8:	f7ff fede 	bl	1a878 <z_tick_sleep.part.0>
   1aabc:	4604      	mov	r4, r0
   1aabe:	e7f3      	b.n	1aaa8 <z_impl_k_sleep+0x24>
   1aac0:	20021f64 	.word	0x20021f64

0001aac4 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   1aac4:	4b01      	ldr	r3, [pc, #4]	; (1aacc <z_impl_k_current_get+0x8>)
   1aac6:	6898      	ldr	r0, [r3, #8]
   1aac8:	4770      	bx	lr
   1aaca:	bf00      	nop
   1aacc:	20021f64 	.word	0x20021f64

0001aad0 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   1aad0:	b538      	push	{r3, r4, r5, lr}
   1aad2:	4604      	mov	r4, r0
   1aad4:	f04f 0320 	mov.w	r3, #32
   1aad8:	f3ef 8511 	mrs	r5, BASEPRI
   1aadc:	f383 8811 	msr	BASEPRI, r3
   1aae0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   1aae4:	f002 fd28 	bl	1d538 <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   1aae8:	b148      	cbz	r0, 1aafe <z_impl_k_sem_give+0x2e>
   1aaea:	2200      	movs	r2, #0
   1aaec:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   1aaee:	f002 fcad 	bl	1d44c <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   1aaf2:	4629      	mov	r1, r5
}
   1aaf4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   1aaf8:	4807      	ldr	r0, [pc, #28]	; (1ab18 <z_impl_k_sem_give+0x48>)
   1aafa:	f002 bc5f 	b.w	1d3bc <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   1aafe:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   1ab02:	429a      	cmp	r2, r3
   1ab04:	bf18      	it	ne
   1ab06:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   1ab08:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   1ab0a:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   1ab0c:	f104 0010 	add.w	r0, r4, #16
   1ab10:	f002 fed4 	bl	1d8bc <z_handle_obj_poll_events>
}
   1ab14:	e7ed      	b.n	1aaf2 <z_impl_k_sem_give+0x22>
   1ab16:	bf00      	nop
   1ab18:	20023673 	.word	0x20023673

0001ab1c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   1ab1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1ab1e:	4614      	mov	r4, r2
   1ab20:	461d      	mov	r5, r3
   1ab22:	f04f 0320 	mov.w	r3, #32
   1ab26:	f3ef 8111 	mrs	r1, BASEPRI
   1ab2a:	f383 8811 	msr	BASEPRI, r3
   1ab2e:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   1ab32:	6883      	ldr	r3, [r0, #8]
   1ab34:	b143      	cbz	r3, 1ab48 <z_impl_k_sem_take+0x2c>
		sem->count--;
   1ab36:	3b01      	subs	r3, #1
   1ab38:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
   1ab3a:	f381 8811 	msr	BASEPRI, r1
   1ab3e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   1ab42:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   1ab44:	b003      	add	sp, #12
   1ab46:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1ab48:	ea54 0305 	orrs.w	r3, r4, r5
   1ab4c:	d106      	bne.n	1ab5c <z_impl_k_sem_take+0x40>
   1ab4e:	f381 8811 	msr	BASEPRI, r1
   1ab52:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   1ab56:	f06f 000f 	mvn.w	r0, #15
   1ab5a:	e7f3      	b.n	1ab44 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   1ab5c:	4602      	mov	r2, r0
   1ab5e:	e9cd 4500 	strd	r4, r5, [sp]
   1ab62:	4802      	ldr	r0, [pc, #8]	; (1ab6c <z_impl_k_sem_take+0x50>)
   1ab64:	f7ff fedc 	bl	1a920 <z_pend_curr>
	return ret;
   1ab68:	e7ec      	b.n	1ab44 <z_impl_k_sem_take+0x28>
   1ab6a:	bf00      	nop
   1ab6c:	20023673 	.word	0x20023673

0001ab70 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   1ab70:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   1ab72:	4c08      	ldr	r4, [pc, #32]	; (1ab94 <k_sys_work_q_init+0x24>)
   1ab74:	f04f 33ff 	mov.w	r3, #4294967295
   1ab78:	f44f 6280 	mov.w	r2, #1024	; 0x400
   1ab7c:	4620      	mov	r0, r4
   1ab7e:	4906      	ldr	r1, [pc, #24]	; (1ab98 <k_sys_work_q_init+0x28>)
   1ab80:	f000 f8c2 	bl	1ad08 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   1ab84:	4905      	ldr	r1, [pc, #20]	; (1ab9c <k_sys_work_q_init+0x2c>)
   1ab86:	f104 0018 	add.w	r0, r4, #24
   1ab8a:	f002 fd2a 	bl	1d5e2 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   1ab8e:	2000      	movs	r0, #0
   1ab90:	bd10      	pop	{r4, pc}
   1ab92:	bf00      	nop
   1ab94:	20021fa4 	.word	0x20021fa4
   1ab98:	20025820 	.word	0x20025820
   1ab9c:	0001e6ce 	.word	0x0001e6ce

0001aba0 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   1aba0:	b5f0      	push	{r4, r5, r6, r7, lr}
	sys_dlist_init(&w->waitq);
   1aba2:	f100 0528 	add.w	r5, r0, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   1aba6:	e9c0 550a 	strd	r5, r5, [r0, #40]	; 0x28
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
	thread_base->thread_state = (u8_t)initial_state;
   1abaa:	2504      	movs	r5, #4
   1abac:	7345      	strb	r5, [r0, #13]

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
   1abae:	2500      	movs	r5, #0
{
   1abb0:	4604      	mov	r4, r0
   1abb2:	b087      	sub	sp, #28
   1abb4:	e9dd 670f 	ldrd	r6, r7, [sp, #60]	; 0x3c
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abb8:	e9cd 6703 	strd	r6, r7, [sp, #12]
	thread_base->prio = priority;
   1abbc:	7386      	strb	r6, [r0, #14]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abbe:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	node->prev = NULL;
   1abc0:	e9c0 5506 	strd	r5, r5, [r0, #24]
   1abc4:	9602      	str	r6, [sp, #8]
   1abc6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
	thread_base->user_options = (u8_t)options;
   1abc8:	7307      	strb	r7, [r0, #12]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abca:	9601      	str	r6, [sp, #4]
   1abcc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	thread_base->sched_locked = 0U;
   1abce:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abd0:	9600      	str	r6, [sp, #0]
   1abd2:	f7f3 f967 	bl	dea4 <arch_new_thread>
	if (!_current) {
   1abd6:	4b04      	ldr	r3, [pc, #16]	; (1abe8 <z_setup_new_thread+0x48>)
	new_thread->fn_abort = NULL;
   1abd8:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
	if (!_current) {
   1abdc:	689b      	ldr	r3, [r3, #8]
   1abde:	b103      	cbz	r3, 1abe2 <z_setup_new_thread+0x42>
	new_thread->resource_pool = _current->resource_pool;
   1abe0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   1abe2:	66a3      	str	r3, [r4, #104]	; 0x68
}
   1abe4:	b007      	add	sp, #28
   1abe6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1abe8:	20021f64 	.word	0x20021f64

0001abec <z_impl_k_thread_create>:
{
   1abec:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abee:	2500      	movs	r5, #0
{
   1abf0:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abf2:	9505      	str	r5, [sp, #20]
   1abf4:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
   1abf6:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1abfa:	9504      	str	r5, [sp, #16]
   1abfc:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
   1abfe:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   1ac00:	9503      	str	r5, [sp, #12]
   1ac02:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   1ac04:	9502      	str	r5, [sp, #8]
   1ac06:	9d0d      	ldr	r5, [sp, #52]	; 0x34
   1ac08:	9501      	str	r5, [sp, #4]
   1ac0a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   1ac0c:	9500      	str	r5, [sp, #0]
   1ac0e:	f7ff ffc7 	bl	1aba0 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   1ac12:	1c7b      	adds	r3, r7, #1
   1ac14:	bf08      	it	eq
   1ac16:	f1b6 3fff 	cmpeq.w	r6, #4294967295
   1ac1a:	d005      	beq.n	1ac28 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   1ac1c:	ea56 0307 	orrs.w	r3, r6, r7
   1ac20:	d105      	bne.n	1ac2e <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
   1ac22:	4620      	mov	r0, r4
   1ac24:	f7ff fce4 	bl	1a5f0 <z_sched_start>
}
   1ac28:	4620      	mov	r0, r4
   1ac2a:	b007      	add	sp, #28
   1ac2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   1ac2e:	4632      	mov	r2, r6
   1ac30:	463b      	mov	r3, r7
   1ac32:	4903      	ldr	r1, [pc, #12]	; (1ac40 <z_impl_k_thread_create+0x54>)
   1ac34:	f104 0018 	add.w	r0, r4, #24
   1ac38:	f000 f8c8 	bl	1adcc <z_add_timeout>
   1ac3c:	e7f4      	b.n	1ac28 <z_impl_k_thread_create+0x3c>
   1ac3e:	bf00      	nop
   1ac40:	0001d46d 	.word	0x0001d46d

0001ac44 <z_init_static_threads>:
{
   1ac44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   1ac48:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 1ad00 <z_init_static_threads+0xbc>
   1ac4c:	4d2b      	ldr	r5, [pc, #172]	; (1acfc <z_init_static_threads+0xb8>)
   1ac4e:	46c8      	mov	r8, r9
{
   1ac50:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   1ac52:	454d      	cmp	r5, r9
   1ac54:	f105 0430 	add.w	r4, r5, #48	; 0x30
   1ac58:	d30d      	bcc.n	1ac76 <z_init_static_threads+0x32>
	k_sched_lock();
   1ac5a:	f7ff fc2b 	bl	1a4b4 <k_sched_lock>
			return (u32_t)((t * to_hz + off) / from_hz);
   1ac5e:	f44f 4900 	mov.w	r9, #32768	; 0x8000
	_FOREACH_STATIC_THREAD(thread_data) {
   1ac62:	4c26      	ldr	r4, [pc, #152]	; (1acfc <z_init_static_threads+0xb8>)
   1ac64:	f8df a09c 	ldr.w	sl, [pc, #156]	; 1ad04 <z_init_static_threads+0xc0>
   1ac68:	4544      	cmp	r4, r8
   1ac6a:	d321      	bcc.n	1acb0 <z_init_static_threads+0x6c>
}
   1ac6c:	b007      	add	sp, #28
   1ac6e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
   1ac72:	f7ff bc6d 	b.w	1a550 <k_sched_unlock>
		z_setup_new_thread(
   1ac76:	f854 3c04 	ldr.w	r3, [r4, #-4]
   1ac7a:	9305      	str	r3, [sp, #20]
   1ac7c:	f854 3c10 	ldr.w	r3, [r4, #-16]
   1ac80:	9304      	str	r3, [sp, #16]
   1ac82:	f854 3c14 	ldr.w	r3, [r4, #-20]
   1ac86:	9303      	str	r3, [sp, #12]
   1ac88:	f854 3c18 	ldr.w	r3, [r4, #-24]
   1ac8c:	9302      	str	r3, [sp, #8]
   1ac8e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   1ac92:	9301      	str	r3, [sp, #4]
   1ac94:	f854 3c20 	ldr.w	r3, [r4, #-32]
   1ac98:	9300      	str	r3, [sp, #0]
   1ac9a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   1ac9e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   1aca2:	f7ff ff7d 	bl	1aba0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   1aca6:	f854 3c30 	ldr.w	r3, [r4, #-48]
   1acaa:	655d      	str	r5, [r3, #84]	; 0x54
   1acac:	4625      	mov	r5, r4
   1acae:	e7d0      	b.n	1ac52 <z_init_static_threads+0xe>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   1acb0:	6a61      	ldr	r1, [r4, #36]	; 0x24
   1acb2:	1c4b      	adds	r3, r1, #1
   1acb4:	d017      	beq.n	1ace6 <z_init_static_threads+0xa2>
   1acb6:	f240 3be7 	movw	fp, #999	; 0x3e7
   1acba:	f04f 0c00 	mov.w	ip, #0
					    K_MSEC(thread_data->init_delay));
   1acbe:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
   1acc2:	fbc9 bc01 	smlal	fp, ip, r9, r1
   1acc6:	2300      	movs	r3, #0
   1acc8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   1accc:	4658      	mov	r0, fp
   1acce:	4661      	mov	r1, ip
   1acd0:	f7f1 fdec 	bl	c8ac <__aeabi_uldivmod>
   1acd4:	2700      	movs	r7, #0
   1acd6:	4606      	mov	r6, r0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   1acd8:	ea56 0307 	orrs.w	r3, r6, r7
			schedule_new_thread(thread_data->init_thread,
   1acdc:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   1acde:	d104      	bne.n	1acea <z_init_static_threads+0xa6>
	z_sched_start(thread);
   1ace0:	4628      	mov	r0, r5
   1ace2:	f7ff fc85 	bl	1a5f0 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   1ace6:	3430      	adds	r4, #48	; 0x30
   1ace8:	e7be      	b.n	1ac68 <z_init_static_threads+0x24>
   1acea:	4602      	mov	r2, r0
   1acec:	463b      	mov	r3, r7
   1acee:	4651      	mov	r1, sl
   1acf0:	f105 0018 	add.w	r0, r5, #24
   1acf4:	f000 f86a 	bl	1adcc <z_add_timeout>
   1acf8:	e7f5      	b.n	1ace6 <z_init_static_threads+0xa2>
   1acfa:	bf00      	nop
   1acfc:	20020190 	.word	0x20020190
   1ad00:	20020190 	.word	0x20020190
   1ad04:	0001d46d 	.word	0x0001d46d

0001ad08 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   1ad08:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
   1ad0c:	b08a      	sub	sp, #40	; 0x28
   1ad0e:	4604      	mov	r4, r0
   1ad10:	461d      	mov	r5, r3
   1ad12:	e9cd 2108 	strd	r2, r1, [sp, #32]
	z_impl_k_queue_init(queue);
   1ad16:	f002 fb37 	bl	1d388 <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   1ad1a:	f104 0618 	add.w	r6, r4, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   1ad1e:	2000      	movs	r0, #0
   1ad20:	e9dd 2108 	ldrd	r2, r1, [sp, #32]
   1ad24:	f04f 0800 	mov.w	r8, #0
   1ad28:	f04f 0900 	mov.w	r9, #0
   1ad2c:	e9cd 5003 	strd	r5, r0, [sp, #12]
   1ad30:	e9cd 0001 	strd	r0, r0, [sp, #4]
   1ad34:	e9cd 8906 	strd	r8, r9, [sp, #24]
   1ad38:	4630      	mov	r0, r6
   1ad3a:	4b05      	ldr	r3, [pc, #20]	; (1ad50 <k_work_q_start+0x48>)
   1ad3c:	9400      	str	r4, [sp, #0]
   1ad3e:	f7ff ff55 	bl	1abec <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   1ad42:	4630      	mov	r0, r6
   1ad44:	4903      	ldr	r1, [pc, #12]	; (1ad54 <k_work_q_start+0x4c>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   1ad46:	b00a      	add	sp, #40	; 0x28
   1ad48:	e8bd 4370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, lr}
   1ad4c:	f002 bc49 	b.w	1d5e2 <z_impl_k_thread_name_set>
   1ad50:	0001b0ef 	.word	0x0001b0ef
   1ad54:	0001e6d7 	.word	0x0001e6d7

0001ad58 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   1ad58:	4b03      	ldr	r3, [pc, #12]	; (1ad68 <elapsed+0x10>)
   1ad5a:	681b      	ldr	r3, [r3, #0]
   1ad5c:	b90b      	cbnz	r3, 1ad62 <elapsed+0xa>
   1ad5e:	f7f3 b81f 	b.w	dda0 <z_clock_elapsed>
}
   1ad62:	2000      	movs	r0, #0
   1ad64:	4770      	bx	lr
   1ad66:	bf00      	nop
   1ad68:	20022074 	.word	0x20022074

0001ad6c <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1ad6c:	6803      	ldr	r3, [r0, #0]
   1ad6e:	b140      	cbz	r0, 1ad82 <remove_timeout+0x16>
   1ad70:	4a07      	ldr	r2, [pc, #28]	; (1ad90 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   1ad72:	6852      	ldr	r2, [r2, #4]
   1ad74:	4290      	cmp	r0, r2
   1ad76:	d004      	beq.n	1ad82 <remove_timeout+0x16>
	if (next(t) != NULL) {
   1ad78:	b11b      	cbz	r3, 1ad82 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   1ad7a:	689a      	ldr	r2, [r3, #8]
   1ad7c:	6881      	ldr	r1, [r0, #8]
   1ad7e:	440a      	add	r2, r1
   1ad80:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   1ad82:	6842      	ldr	r2, [r0, #4]
   1ad84:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1ad86:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1ad88:	2300      	movs	r3, #0
	node->prev = NULL;
   1ad8a:	e9c0 3300 	strd	r3, r3, [r0]
}
   1ad8e:	4770      	bx	lr
   1ad90:	200200f8 	.word	0x200200f8

0001ad94 <next_timeout>:
	return list->head == list;
   1ad94:	4b0b      	ldr	r3, [pc, #44]	; (1adc4 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   1ad96:	b510      	push	{r4, lr}
   1ad98:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1ad9a:	429c      	cmp	r4, r3
   1ad9c:	bf08      	it	eq
   1ad9e:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   1ada0:	f7ff ffda 	bl	1ad58 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   1ada4:	b154      	cbz	r4, 1adbc <next_timeout+0x28>
   1ada6:	68a3      	ldr	r3, [r4, #8]
   1ada8:	1a18      	subs	r0, r3, r0
   1adaa:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   1adae:	4b06      	ldr	r3, [pc, #24]	; (1adc8 <next_timeout+0x34>)
   1adb0:	691b      	ldr	r3, [r3, #16]
   1adb2:	b113      	cbz	r3, 1adba <next_timeout+0x26>
   1adb4:	4298      	cmp	r0, r3
   1adb6:	bfa8      	it	ge
   1adb8:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   1adba:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   1adbc:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   1adc0:	e7f5      	b.n	1adae <next_timeout+0x1a>
   1adc2:	bf00      	nop
   1adc4:	200200f8 	.word	0x200200f8
   1adc8:	20021f64 	.word	0x20021f64

0001adcc <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
   1adcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1add0:	9101      	str	r1, [sp, #4]
   1add2:	4619      	mov	r1, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1add4:	1c4b      	adds	r3, r1, #1
   1add6:	bf08      	it	eq
   1add8:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
   1addc:	4682      	mov	sl, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1adde:	d061      	beq.n	1aea4 <z_add_timeout+0xd8>
#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   1ade0:	f06f 0301 	mvn.w	r3, #1
   1ade4:	f04f 3bff 	mov.w	fp, #4294967295
	k_ticks_t ticks = timeout.ticks + 1;
   1ade8:	1c54      	adds	r4, r2, #1
   1adea:	f141 0500 	adc.w	r5, r1, #0
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
   1adee:	ebb3 0804 	subs.w	r8, r3, r4
   1adf2:	eb6b 0905 	sbc.w	r9, fp, r5
   1adf6:	f1b8 0f00 	cmp.w	r8, #0
   1adfa:	f179 0300 	sbcs.w	r3, r9, #0
   1adfe:	db0f      	blt.n	1ae20 <z_add_timeout+0x54>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
   1ae00:	f7ff ffaa 	bl	1ad58 <elapsed>
   1ae04:	f06f 0301 	mvn.w	r3, #1
   1ae08:	4a2b      	ldr	r2, [pc, #172]	; (1aeb8 <z_add_timeout+0xec>)
   1ae0a:	e9d2 1c00 	ldrd	r1, ip, [r2]
   1ae0e:	1a5b      	subs	r3, r3, r1
   1ae10:	eb6b 020c 	sbc.w	r2, fp, ip
   1ae14:	1b1e      	subs	r6, r3, r4
   1ae16:	eb62 0705 	sbc.w	r7, r2, r5
   1ae1a:	1a34      	subs	r4, r6, r0
   1ae1c:	eb67 75e0 	sbc.w	r5, r7, r0, asr #31
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
   1ae20:	9b01      	ldr	r3, [sp, #4]
   1ae22:	f8ca 300c 	str.w	r3, [sl, #12]
	__asm__ volatile(
   1ae26:	f04f 0320 	mov.w	r3, #32
   1ae2a:	f3ef 8611 	mrs	r6, BASEPRI
   1ae2e:	f383 8811 	msr	BASEPRI, r3
   1ae32:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
   1ae36:	f7ff ff8f 	bl	1ad58 <elapsed>
	ticks = MAX(1, ticks);
   1ae3a:	2c01      	cmp	r4, #1
   1ae3c:	f175 0300 	sbcs.w	r3, r5, #0
   1ae40:	bfb8      	it	lt
   1ae42:	2401      	movlt	r4, #1
	return list->head == list;
   1ae44:	4b1d      	ldr	r3, [pc, #116]	; (1aebc <z_add_timeout+0xf0>)
		to->dticks = ticks + elapsed();
   1ae46:	4420      	add	r0, r4
   1ae48:	681a      	ldr	r2, [r3, #0]
   1ae4a:	f8ca 0008 	str.w	r0, [sl, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1ae4e:	429a      	cmp	r2, r3
   1ae50:	d001      	beq.n	1ae56 <z_add_timeout+0x8a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   1ae52:	685c      	ldr	r4, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
   1ae54:	b952      	cbnz	r2, 1ae6c <z_add_timeout+0xa0>
	node->prev = list->tail;
   1ae56:	685a      	ldr	r2, [r3, #4]
	node->next = list;
   1ae58:	f8ca 3000 	str.w	r3, [sl]
	node->prev = list->tail;
   1ae5c:	f8ca 2004 	str.w	r2, [sl, #4]
	list->tail->next = node;
   1ae60:	685a      	ldr	r2, [r3, #4]
   1ae62:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   1ae66:	f8c3 a004 	str.w	sl, [r3, #4]
}
   1ae6a:	e00d      	b.n	1ae88 <z_add_timeout+0xbc>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
   1ae6c:	6890      	ldr	r0, [r2, #8]
   1ae6e:	f8da 1008 	ldr.w	r1, [sl, #8]
   1ae72:	4288      	cmp	r0, r1
   1ae74:	dd19      	ble.n	1aeaa <z_add_timeout+0xde>
				t->dticks -= to->dticks;
   1ae76:	1a41      	subs	r1, r0, r1
   1ae78:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
   1ae7a:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
   1ae7c:	e9ca 2100 	strd	r2, r1, [sl]
	successor->prev->next = node;
   1ae80:	f8c1 a000 	str.w	sl, [r1]
	successor->prev = node;
   1ae84:	f8c2 a004 	str.w	sl, [r2, #4]
	return list->head == list;
   1ae88:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1ae8a:	429a      	cmp	r2, r3
   1ae8c:	d006      	beq.n	1ae9c <z_add_timeout+0xd0>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
   1ae8e:	4592      	cmp	sl, r2
   1ae90:	d104      	bne.n	1ae9c <z_add_timeout+0xd0>
			z_clock_set_timeout(next_timeout(), false);
   1ae92:	f7ff ff7f 	bl	1ad94 <next_timeout>
   1ae96:	2100      	movs	r1, #0
   1ae98:	f7f2 ff1e 	bl	dcd8 <z_clock_set_timeout>
	__asm__ volatile(
   1ae9c:	f386 8811 	msr	BASEPRI, r6
   1aea0:	f3bf 8f6f 	isb	sy
		}
	}
}
   1aea4:	b003      	add	sp, #12
   1aea6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			to->dticks -= t->dticks;
   1aeaa:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
   1aeac:	4294      	cmp	r4, r2
   1aeae:	f8ca 1008 	str.w	r1, [sl, #8]
   1aeb2:	d0d0      	beq.n	1ae56 <z_add_timeout+0x8a>
   1aeb4:	6812      	ldr	r2, [r2, #0]
   1aeb6:	e7cd      	b.n	1ae54 <z_add_timeout+0x88>
   1aeb8:	20020280 	.word	0x20020280
   1aebc:	200200f8 	.word	0x200200f8

0001aec0 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
   1aec0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1aec4:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   1aec6:	f7ff fbf7 	bl	1a6b8 <z_time_slice>
	__asm__ volatile(
   1aeca:	f04f 0320 	mov.w	r3, #32
   1aece:	f3ef 8411 	mrs	r4, BASEPRI
   1aed2:	f383 8811 	msr	BASEPRI, r3
   1aed6:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   1aeda:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1af60 <z_clock_announce+0xa0>
   1aede:	4d1f      	ldr	r5, [pc, #124]	; (1af5c <z_clock_announce+0x9c>)
   1aee0:	46c1      	mov	r9, r8
	return list->head == list;
   1aee2:	f8df a080 	ldr.w	sl, [pc, #128]	; 1af64 <z_clock_announce+0xa4>
   1aee6:	602e      	str	r6, [r5, #0]
   1aee8:	f8da 0000 	ldr.w	r0, [sl]
   1aeec:	682a      	ldr	r2, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1aeee:	4550      	cmp	r0, sl
   1aef0:	e9d8 6700 	ldrd	r6, r7, [r8]
   1aef4:	d005      	beq.n	1af02 <z_clock_announce+0x42>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   1aef6:	b120      	cbz	r0, 1af02 <z_clock_announce+0x42>
   1aef8:	6883      	ldr	r3, [r0, #8]
   1aefa:	4293      	cmp	r3, r2
   1aefc:	dd13      	ble.n	1af26 <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   1aefe:	1a9b      	subs	r3, r3, r2
   1af00:	6083      	str	r3, [r0, #8]
	}

	curr_tick += announce_remaining;
   1af02:	18b6      	adds	r6, r6, r2
   1af04:	eb47 77e2 	adc.w	r7, r7, r2, asr #31
   1af08:	e9c9 6700 	strd	r6, r7, [r9]
	announce_remaining = 0;
   1af0c:	2600      	movs	r6, #0
   1af0e:	602e      	str	r6, [r5, #0]

	z_clock_set_timeout(next_timeout(), false);
   1af10:	f7ff ff40 	bl	1ad94 <next_timeout>
   1af14:	4631      	mov	r1, r6
   1af16:	f7f2 fedf 	bl	dcd8 <z_clock_set_timeout>
	__asm__ volatile(
   1af1a:	f384 8811 	msr	BASEPRI, r4
   1af1e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   1af22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_tick += dt;
   1af26:	18f6      	adds	r6, r6, r3
   1af28:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
		announce_remaining -= dt;
   1af2c:	1ad3      	subs	r3, r2, r3
   1af2e:	602b      	str	r3, [r5, #0]
		t->dticks = 0;
   1af30:	2300      	movs	r3, #0
   1af32:	6083      	str	r3, [r0, #8]
		curr_tick += dt;
   1af34:	e9c8 6700 	strd	r6, r7, [r8]
		remove_timeout(t);
   1af38:	f7ff ff18 	bl	1ad6c <remove_timeout>
   1af3c:	f384 8811 	msr	BASEPRI, r4
   1af40:	f3bf 8f6f 	isb	sy
		t->fn(t);
   1af44:	68c3      	ldr	r3, [r0, #12]
   1af46:	4798      	blx	r3
	__asm__ volatile(
   1af48:	f04f 0320 	mov.w	r3, #32
   1af4c:	f3ef 8411 	mrs	r4, BASEPRI
   1af50:	f383 8811 	msr	BASEPRI, r3
   1af54:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
   1af58:	e7c6      	b.n	1aee8 <z_clock_announce+0x28>
   1af5a:	bf00      	nop
   1af5c:	20022074 	.word	0x20022074
   1af60:	20020280 	.word	0x20020280
   1af64:	200200f8 	.word	0x200200f8

0001af68 <z_tick_get>:

s64_t z_tick_get(void)
{
   1af68:	b510      	push	{r4, lr}
   1af6a:	f04f 0320 	mov.w	r3, #32
   1af6e:	f3ef 8411 	mrs	r4, BASEPRI
   1af72:	f383 8811 	msr	BASEPRI, r3
   1af76:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   1af7a:	f7f2 ff11 	bl	dda0 <z_clock_elapsed>
   1af7e:	4b06      	ldr	r3, [pc, #24]	; (1af98 <z_tick_get+0x30>)
   1af80:	e9d3 2300 	ldrd	r2, r3, [r3]
   1af84:	1812      	adds	r2, r2, r0
   1af86:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
   1af8a:	f384 8811 	msr	BASEPRI, r4
   1af8e:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   1af92:	4610      	mov	r0, r2
   1af94:	4619      	mov	r1, r3
   1af96:	bd10      	pop	{r4, pc}
   1af98:	20020280 	.word	0x20020280

0001af9c <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
   1af9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1afa0:	461f      	mov	r7, r3
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   1afa2:	2301      	movs	r3, #1
{
   1afa4:	b089      	sub	sp, #36	; 0x24
	struct _poller poller = { .is_polling = true,
   1afa6:	f88d 3014 	strb.w	r3, [sp, #20]
				  .thread     = _current,
   1afaa:	4b29      	ldr	r3, [pc, #164]	; (1b050 <z_impl_k_poll+0xb4>)
{
   1afac:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
   1afae:	689b      	ldr	r3, [r3, #8]
{
   1afb0:	4605      	mov	r5, r0
	struct _poller poller = { .is_polling = true,
   1afb2:	9306      	str	r3, [sp, #24]
   1afb4:	4b27      	ldr	r3, [pc, #156]	; (1b054 <z_impl_k_poll+0xb8>)
   1afb6:	9307      	str	r3, [sp, #28]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
   1afb8:	ea52 0307 	orrs.w	r3, r2, r7
   1afbc:	bf0c      	ite	eq
   1afbe:	2301      	moveq	r3, #1
   1afc0:	2300      	movne	r3, #0
   1afc2:	aa05      	add	r2, sp, #20
   1afc4:	f002 fc19 	bl	1d7fa <register_events>
   1afc8:	4680      	mov	r8, r0
	__asm__ volatile(
   1afca:	f04f 0320 	mov.w	r3, #32
   1afce:	f3ef 8911 	mrs	r9, BASEPRI
   1afd2:	f383 8811 	msr	BASEPRI, r3
   1afd6:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   1afda:	f89d 3014 	ldrb.w	r3, [sp, #20]
   1afde:	f003 04ff 	and.w	r4, r3, #255	; 0xff
   1afe2:	b963      	cbnz	r3, 1affe <z_impl_k_poll+0x62>
		clear_event_registrations(events, events_registered, key);
   1afe4:	4601      	mov	r1, r0
   1afe6:	464a      	mov	r2, r9
   1afe8:	4628      	mov	r0, r5
   1afea:	f002 fb6d 	bl	1d6c8 <clear_event_registrations>
	__asm__ volatile(
   1afee:	f389 8811 	msr	BASEPRI, r9
   1aff2:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   1aff6:	4620      	mov	r0, r4
   1aff8:	b009      	add	sp, #36	; 0x24
   1affa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	poller.is_polling = false;
   1affe:	2300      	movs	r3, #0
   1b000:	f88d 3014 	strb.w	r3, [sp, #20]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1b004:	ea56 0307 	orrs.w	r3, r6, r7
   1b008:	d106      	bne.n	1b018 <z_impl_k_poll+0x7c>
   1b00a:	f389 8811 	msr	BASEPRI, r9
   1b00e:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   1b012:	f06f 040a 	mvn.w	r4, #10
   1b016:	e7ee      	b.n	1aff6 <z_impl_k_poll+0x5a>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   1b018:	aa03      	add	r2, sp, #12
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   1b01a:	4649      	mov	r1, r9
   1b01c:	e9cd 6700 	strd	r6, r7, [sp]
   1b020:	480d      	ldr	r0, [pc, #52]	; (1b058 <z_impl_k_poll+0xbc>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   1b022:	e9cd 2203 	strd	r2, r2, [sp, #12]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   1b026:	f7ff fc7b 	bl	1a920 <z_pend_curr>
   1b02a:	4604      	mov	r4, r0
	__asm__ volatile(
   1b02c:	f04f 0320 	mov.w	r3, #32
   1b030:	f3ef 8611 	mrs	r6, BASEPRI
   1b034:	f383 8811 	msr	BASEPRI, r3
   1b038:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
   1b03c:	4632      	mov	r2, r6
   1b03e:	4641      	mov	r1, r8
   1b040:	4628      	mov	r0, r5
   1b042:	f002 fb41 	bl	1d6c8 <clear_event_registrations>
	__asm__ volatile(
   1b046:	f386 8811 	msr	BASEPRI, r6
   1b04a:	f3bf 8f6f 	isb	sy
	return swap_rc;
   1b04e:	e7d2      	b.n	1aff6 <z_impl_k_poll+0x5a>
   1b050:	20021f64 	.word	0x20021f64
   1b054:	0001d755 	.word	0x0001d755
   1b058:	20023673 	.word	0x20023673

0001b05c <z_errno>:
   1b05c:	f7fe beac 	b.w	19db8 <z_impl_z_errno>

0001b060 <arch_printk_char_out>:
}
   1b060:	2000      	movs	r0, #0
   1b062:	4770      	bx	lr

0001b064 <print_err>:
{
   1b064:	b570      	push	{r4, r5, r6, lr}
   1b066:	460d      	mov	r5, r1
   1b068:	4604      	mov	r4, r0
	out('E', ctx);
   1b06a:	2045      	movs	r0, #69	; 0x45
   1b06c:	47a0      	blx	r4
	out('R', ctx);
   1b06e:	4629      	mov	r1, r5
   1b070:	2052      	movs	r0, #82	; 0x52
   1b072:	47a0      	blx	r4
	out('R', ctx);
   1b074:	4629      	mov	r1, r5
   1b076:	4623      	mov	r3, r4
}
   1b078:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   1b07c:	2052      	movs	r0, #82	; 0x52
   1b07e:	4718      	bx	r3

0001b080 <str_out>:
{
   1b080:	b530      	push	{r4, r5, lr}
   1b082:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   1b084:	680c      	ldr	r4, [r1, #0]
   1b086:	1c55      	adds	r5, r2, #1
   1b088:	b114      	cbz	r4, 1b090 <str_out+0x10>
   1b08a:	684b      	ldr	r3, [r1, #4]
   1b08c:	4293      	cmp	r3, r2
   1b08e:	dc01      	bgt.n	1b094 <str_out+0x14>
		ctx->count++;
   1b090:	608d      	str	r5, [r1, #8]
}
   1b092:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   1b094:	3b01      	subs	r3, #1
   1b096:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   1b098:	bf08      	it	eq
   1b09a:	2200      	moveq	r2, #0
   1b09c:	608d      	str	r5, [r1, #8]
   1b09e:	bf0c      	ite	eq
   1b0a0:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   1b0a2:	54a0      	strbne	r0, [r4, r2]
   1b0a4:	e7f5      	b.n	1b092 <str_out+0x12>

0001b0a6 <printk>:
{
   1b0a6:	b40f      	push	{r0, r1, r2, r3}
   1b0a8:	b507      	push	{r0, r1, r2, lr}
   1b0aa:	a904      	add	r1, sp, #16
   1b0ac:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   1b0b0:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
   1b0b2:	f7f2 fb4d 	bl	d750 <vprintk>
}
   1b0b6:	b003      	add	sp, #12
   1b0b8:	f85d eb04 	ldr.w	lr, [sp], #4
   1b0bc:	b004      	add	sp, #16
   1b0be:	4770      	bx	lr

0001b0c0 <snprintk>:
{
   1b0c0:	b40c      	push	{r2, r3}
   1b0c2:	b507      	push	{r0, r1, r2, lr}
   1b0c4:	ab04      	add	r3, sp, #16
   1b0c6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   1b0ca:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   1b0cc:	f7f2 fb4e 	bl	d76c <vsnprintk>
}
   1b0d0:	b003      	add	sp, #12
   1b0d2:	f85d eb04 	ldr.w	lr, [sp], #4
   1b0d6:	b002      	add	sp, #8
   1b0d8:	4770      	bx	lr

0001b0da <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   1b0da:	4604      	mov	r4, r0
   1b0dc:	b508      	push	{r3, lr}
   1b0de:	4608      	mov	r0, r1
   1b0e0:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   1b0e2:	461a      	mov	r2, r3
   1b0e4:	47a0      	blx	r4
	return z_impl_k_current_get();
   1b0e6:	f7ff fced 	bl	1aac4 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   1b0ea:	f7f3 f903 	bl	e2f4 <z_impl_k_thread_abort>

0001b0ee <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   1b0ee:	b510      	push	{r4, lr}
   1b0f0:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   1b0f2:	f04f 33ff 	mov.w	r3, #4294967295
   1b0f6:	f04f 32ff 	mov.w	r2, #4294967295
   1b0fa:	4620      	mov	r0, r4
   1b0fc:	f7ff f964 	bl	1a3c8 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   1b100:	4603      	mov	r3, r0
   1b102:	2800      	cmp	r0, #0
   1b104:	d0f5      	beq.n	1b0f2 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   1b106:	6842      	ldr	r2, [r0, #4]
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   1b108:	3308      	adds	r3, #8
   1b10a:	e8d3 1fef 	ldaex	r1, [r3]
   1b10e:	f021 0c01 	bic.w	ip, r1, #1
   1b112:	e8c3 cfee 	stlex	lr, ip, [r3]
   1b116:	f1be 0f00 	cmp.w	lr, #0
   1b11a:	d1f6      	bne.n	1b10a <z_work_q_main+0x1c>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   1b11c:	07cb      	lsls	r3, r1, #31
   1b11e:	d500      	bpl.n	1b122 <z_work_q_main+0x34>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   1b120:	4790      	blx	r2
	z_impl_k_yield();
   1b122:	f7ff fc61 	bl	1a9e8 <z_impl_k_yield>
   1b126:	e7e4      	b.n	1b0f2 <z_work_q_main+0x4>

0001b128 <chunk_field>:
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
	void *cmem = &h->buf[c];
   1b128:	6803      	ldr	r3, [r0, #0]
   1b12a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3

	if (big_heap(h)) {
   1b12e:	6883      	ldr	r3, [r0, #8]
   1b130:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((u32_t *)cmem)[f];
   1b134:	bf2c      	ite	cs
   1b136:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((u16_t *)cmem)[f];
   1b13a:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
   1b13e:	4770      	bx	lr

0001b140 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
   1b140:	b510      	push	{r4, lr}
	CHECK(c >= h->chunk0 && c < h->len);
	CHECK((val & ~((h->size_mask << 1) + 1)) == 0);
	CHECK((val & h->size_mask) < h->len);

	void *cmem = &h->buf[c];
   1b142:	6804      	ldr	r4, [r0, #0]

	if (big_heap(h)) {
   1b144:	6880      	ldr	r0, [r0, #8]
	void *cmem = &h->buf[c];
   1b146:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	if (big_heap(h)) {
   1b14a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		((u32_t *)cmem)[f] = (u32_t) val;
   1b14e:	bf2c      	ite	cs
   1b150:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		((u16_t *)cmem)[f] = (u16_t) val;
   1b154:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
   1b158:	bd10      	pop	{r4, pc}

0001b15a <right_chunk>:
{
	return c - left_size(h, c);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
   1b15a:	b538      	push	{r3, r4, r5, lr}
   1b15c:	4605      	mov	r5, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b15e:	2200      	movs	r2, #0
{
   1b160:	460c      	mov	r4, r1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b162:	f7ff ffe1 	bl	1b128 <chunk_field>
   1b166:	68eb      	ldr	r3, [r5, #12]
   1b168:	4018      	ands	r0, r3
	return c + size(h, c);
}
   1b16a:	4420      	add	r0, r4
   1b16c:	bd38      	pop	{r3, r4, r5, pc}

0001b16e <free_list_remove>:
	return ret;
}

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
   1b16e:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1b172:	460d      	mov	r5, r1
	struct z_heap_bucket *b = &h->buckets[bidx];
   1b174:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
   1b178:	4611      	mov	r1, r2
	struct z_heap_bucket *b = &h->buckets[bidx];
   1b17a:	eb08 02c5 	add.w	r2, r8, r5, lsl #3
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
   1b17e:	6853      	ldr	r3, [r2, #4]
{
   1b180:	4604      	mov	r4, r0
	b->list_size--;
   1b182:	3b01      	subs	r3, #1
   1b184:	6053      	str	r3, [r2, #4]

	if (b->list_size == 0) {
   1b186:	b95b      	cbnz	r3, 1b1a0 <free_list_remove+0x32>
		h->avail_buckets &= ~(1 << bidx);
   1b188:	2201      	movs	r2, #1
   1b18a:	fa02 f105 	lsl.w	r1, r2, r5
   1b18e:	6942      	ldr	r2, [r0, #20]
   1b190:	ea22 0201 	bic.w	r2, r2, r1
   1b194:	6142      	str	r2, [r0, #20]
		b->next = 0;
   1b196:	f848 3035 	str.w	r3, [r8, r5, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
   1b19a:	b002      	add	sp, #8
   1b19c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
   1b1a0:	2202      	movs	r2, #2
   1b1a2:	9101      	str	r1, [sp, #4]
   1b1a4:	f7ff ffc0 	bl	1b128 <chunk_field>
	return chunk_field(h, c, FREE_NEXT);
   1b1a8:	9901      	ldr	r1, [sp, #4]
	return chunk_field(h, c, FREE_PREV);
   1b1aa:	4607      	mov	r7, r0
	return chunk_field(h, c, FREE_NEXT);
   1b1ac:	2203      	movs	r2, #3
   1b1ae:	4620      	mov	r0, r4
   1b1b0:	f7ff ffba 	bl	1b128 <chunk_field>
   1b1b4:	4606      	mov	r6, r0
		chunk_set(h, first, FREE_NEXT, second);
   1b1b6:	4603      	mov	r3, r0
   1b1b8:	4639      	mov	r1, r7
		b->next = second;
   1b1ba:	f848 0035 	str.w	r0, [r8, r5, lsl #3]
		chunk_set(h, first, FREE_NEXT, second);
   1b1be:	2203      	movs	r2, #3
   1b1c0:	4620      	mov	r0, r4
   1b1c2:	f7ff ffbd 	bl	1b140 <chunk_set>
		chunk_set(h, second, FREE_PREV, first);
   1b1c6:	463b      	mov	r3, r7
   1b1c8:	2202      	movs	r2, #2
   1b1ca:	4631      	mov	r1, r6
   1b1cc:	4620      	mov	r0, r4
}
   1b1ce:	b002      	add	sp, #8
   1b1d0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, first);
   1b1d4:	f7ff bfb4 	b.w	1b140 <chunk_set>

0001b1d8 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   1b1d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b1dc:	4604      	mov	r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b1de:	2200      	movs	r2, #0
   1b1e0:	460d      	mov	r5, r1
   1b1e2:	f7ff ffa1 	bl	1b128 <chunk_field>
   1b1e6:	68e2      	ldr	r2, [r4, #12]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b1e8:	68a3      	ldr	r3, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b1ea:	4010      	ands	r0, r2
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b1ec:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b1f0:	fab0 f280 	clz	r2, r0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b1f4:	bf34      	ite	cc
   1b1f6:	2000      	movcc	r0, #0
   1b1f8:	2001      	movcs	r0, #1
	int b = bucket_idx(h, size(h, c));

	if (h->buckets[b].list_size++ == 0) {
   1b1fa:	6863      	ldr	r3, [r4, #4]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b1fc:	f1c0 001f 	rsb	r0, r0, #31
   1b200:	1a80      	subs	r0, r0, r2
   1b202:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
   1b206:	684a      	ldr	r2, [r1, #4]
   1b208:	1c56      	adds	r6, r2, #1
   1b20a:	604e      	str	r6, [r1, #4]
   1b20c:	b9a2      	cbnz	r2, 1b238 <free_list_add+0x60>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
   1b20e:	2201      	movs	r2, #1
   1b210:	fa02 f100 	lsl.w	r1, r2, r0
   1b214:	6962      	ldr	r2, [r4, #20]
   1b216:	430a      	orrs	r2, r1
   1b218:	6162      	str	r2, [r4, #20]
		h->buckets[b].next = c;
		chunk_set(h, c, FREE_PREV, c);
   1b21a:	4629      	mov	r1, r5
		h->buckets[b].next = c;
   1b21c:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
		chunk_set(h, c, FREE_PREV, c);
   1b220:	2202      	movs	r2, #2
   1b222:	462b      	mov	r3, r5
   1b224:	4620      	mov	r0, r4
   1b226:	f7ff ff8b 	bl	1b140 <chunk_set>
		chunk_set(h, c, FREE_NEXT, c);
   1b22a:	2203      	movs	r2, #3
   1b22c:	4629      	mov	r1, r5
		chunkid_t first = free_prev(h, second);

		chunk_set(h, c, FREE_PREV, first);
		chunk_set(h, c, FREE_NEXT, second);
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
   1b22e:	4620      	mov	r0, r4
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
   1b230:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, c);
   1b234:	f7ff bf84 	b.w	1b140 <chunk_set>
		chunkid_t second = h->buckets[b].next;
   1b238:	f853 7030 	ldr.w	r7, [r3, r0, lsl #3]
	return chunk_field(h, c, FREE_PREV);
   1b23c:	2202      	movs	r2, #2
   1b23e:	4639      	mov	r1, r7
   1b240:	4620      	mov	r0, r4
   1b242:	f7ff ff71 	bl	1b128 <chunk_field>
   1b246:	4606      	mov	r6, r0
		chunk_set(h, c, FREE_PREV, first);
   1b248:	4603      	mov	r3, r0
   1b24a:	2202      	movs	r2, #2
   1b24c:	4629      	mov	r1, r5
   1b24e:	4620      	mov	r0, r4
   1b250:	f7ff ff76 	bl	1b140 <chunk_set>
		chunk_set(h, c, FREE_NEXT, second);
   1b254:	463b      	mov	r3, r7
   1b256:	2203      	movs	r2, #3
   1b258:	4629      	mov	r1, r5
   1b25a:	4620      	mov	r0, r4
   1b25c:	f7ff ff70 	bl	1b140 <chunk_set>
		chunk_set(h, first, FREE_NEXT, c);
   1b260:	2203      	movs	r2, #3
   1b262:	4631      	mov	r1, r6
   1b264:	462b      	mov	r3, r5
   1b266:	4620      	mov	r0, r4
   1b268:	f7ff ff6a 	bl	1b140 <chunk_set>
		chunk_set(h, second, FREE_PREV, c);
   1b26c:	2202      	movs	r2, #2
   1b26e:	4639      	mov	r1, r7
   1b270:	e7dd      	b.n	1b22e <free_list_add+0x56>

0001b272 <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
   1b272:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b276:	4604      	mov	r4, r0
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
   1b278:	6843      	ldr	r3, [r0, #4]
{
   1b27a:	4617      	mov	r7, r2
	chunkid_t c = h->buckets[bidx].next;
   1b27c:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]

	free_list_remove(h, bidx, c);
   1b280:	462a      	mov	r2, r5
   1b282:	f7ff ff74 	bl	1b16e <free_list_remove>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b286:	2200      	movs	r2, #0
   1b288:	4629      	mov	r1, r5
   1b28a:	4620      	mov	r0, r4
   1b28c:	f7ff ff4c 	bl	1b128 <chunk_field>
	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
   1b290:	68a3      	ldr	r3, [r4, #8]
   1b292:	68e6      	ldr	r6, [r4, #12]
   1b294:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1b298:	bf2c      	ite	cs
   1b29a:	2302      	movcs	r3, #2
   1b29c:	2301      	movcc	r3, #1
   1b29e:	4030      	ands	r0, r6
	size_t rem = size(h, c) - sz;
   1b2a0:	1bc6      	subs	r6, r0, r7
	if (rem >= (big_heap(h) ? 2 : 1)) {
   1b2a2:	42b3      	cmp	r3, r6
   1b2a4:	d82d      	bhi.n	1b302 <split_alloc+0x90>
		chunkid_t c2 = c + sz;
		chunkid_t c3 = right_chunk(h, c);
   1b2a6:	4629      	mov	r1, r5
   1b2a8:	4620      	mov	r0, r4
   1b2aa:	f7ff ff56 	bl	1b15a <right_chunk>
		chunkid_t c2 = c + sz;
   1b2ae:	eb05 0807 	add.w	r8, r5, r7

		chunk_set(h, c, SIZE_AND_USED, sz);
   1b2b2:	463b      	mov	r3, r7
   1b2b4:	2200      	movs	r2, #0
   1b2b6:	4629      	mov	r1, r5
		chunkid_t c3 = right_chunk(h, c);
   1b2b8:	4681      	mov	r9, r0
		chunk_set(h, c, SIZE_AND_USED, sz);
   1b2ba:	4620      	mov	r0, r4
   1b2bc:	f7ff ff40 	bl	1b140 <chunk_set>
		chunk_set(h, c2, SIZE_AND_USED, rem);
   1b2c0:	4633      	mov	r3, r6
   1b2c2:	2200      	movs	r2, #0
   1b2c4:	4641      	mov	r1, r8
   1b2c6:	4620      	mov	r0, r4
   1b2c8:	f7ff ff3a 	bl	1b140 <chunk_set>
		chunk_set(h, c2, LEFT_SIZE, sz);
   1b2cc:	463b      	mov	r3, r7
   1b2ce:	2201      	movs	r2, #1
   1b2d0:	4641      	mov	r1, r8
   1b2d2:	4620      	mov	r0, r4
   1b2d4:	f7ff ff34 	bl	1b140 <chunk_set>
   1b2d8:	2200      	movs	r2, #0
   1b2da:	4641      	mov	r1, r8
   1b2dc:	4620      	mov	r0, r4
   1b2de:	f7ff ff23 	bl	1b128 <chunk_field>
   1b2e2:	68e3      	ldr	r3, [r4, #12]
		if (!last_chunk(h, c2)) {
   1b2e4:	68a2      	ldr	r2, [r4, #8]
   1b2e6:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
   1b2e8:	4443      	add	r3, r8
		if (!last_chunk(h, c2)) {
   1b2ea:	4293      	cmp	r3, r2
   1b2ec:	d005      	beq.n	1b2fa <split_alloc+0x88>
			chunk_set(h, c3, LEFT_SIZE, rem);
   1b2ee:	4633      	mov	r3, r6
   1b2f0:	2201      	movs	r2, #1
   1b2f2:	4649      	mov	r1, r9
   1b2f4:	4620      	mov	r0, r4
   1b2f6:	f7ff ff23 	bl	1b140 <chunk_set>
		}
		free_list_add(h, c2);
   1b2fa:	4641      	mov	r1, r8
   1b2fc:	4620      	mov	r0, r4
   1b2fe:	f7ff ff6b 	bl	1b1d8 <free_list_add>
   1b302:	4629      	mov	r1, r5
   1b304:	2200      	movs	r2, #0
   1b306:	4620      	mov	r0, r4
   1b308:	f7ff ff0e 	bl	1b128 <chunk_field>
   1b30c:	68e2      	ldr	r2, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
   1b30e:	4629      	mov	r1, r5
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b310:	4010      	ands	r0, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
   1b312:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
   1b314:	ea40 0302 	orr.w	r3, r0, r2
   1b318:	4620      	mov	r0, r4
   1b31a:	2200      	movs	r2, #0
   1b31c:	f7ff ff10 	bl	1b140 <chunk_set>
	return big_heap(h) ? 8 : 4;
   1b320:	68a3      	ldr	r3, [r4, #8]
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
   1b322:	6820      	ldr	r0, [r4, #0]
   1b324:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1b328:	bf2c      	ite	cs
   1b32a:	2308      	movcs	r3, #8
   1b32c:	2304      	movcc	r3, #4
   1b32e:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
}
   1b332:	4428      	add	r0, r5
   1b334:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0001b338 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
   1b338:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	if (mem == NULL) {
   1b33c:	2900      	cmp	r1, #0
   1b33e:	f000 80ae 	beq.w	1b49e <sys_heap_free+0x166>
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
   1b342:	6804      	ldr	r4, [r0, #0]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b344:	2200      	movs	r2, #0
	return big_heap(h) ? 8 : 4;
   1b346:	68a7      	ldr	r7, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b348:	4620      	mov	r0, r4
	return big_heap(h) ? 8 : 4;
   1b34a:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   1b34e:	bf2c      	ite	cs
   1b350:	2508      	movcs	r5, #8
   1b352:	2504      	movcc	r5, #4
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
   1b354:	1b49      	subs	r1, r1, r5
		       - (u8_t *)h->buf) / CHUNK_UNIT;
   1b356:	6825      	ldr	r5, [r4, #0]
   1b358:	1b4d      	subs	r5, r1, r5
   1b35a:	bf48      	it	mi
   1b35c:	3507      	addmi	r5, #7
   1b35e:	10ed      	asrs	r5, r5, #3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b360:	4629      	mov	r1, r5
   1b362:	f7ff fee1 	bl	1b128 <chunk_field>
   1b366:	68e6      	ldr	r6, [r4, #12]
   1b368:	ea06 0800 	and.w	r8, r6, r0
	return (c + size(h, c)) == h->len;
   1b36c:	eb05 0308 	add.w	r3, r5, r8

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
   1b370:	42bb      	cmp	r3, r7
   1b372:	d036      	beq.n	1b3e2 <sys_heap_free+0xaa>
   1b374:	4629      	mov	r1, r5
   1b376:	4620      	mov	r0, r4
   1b378:	f7ff feef 	bl	1b15a <right_chunk>
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   1b37c:	2200      	movs	r2, #0
   1b37e:	4601      	mov	r1, r0
   1b380:	4682      	mov	sl, r0
   1b382:	4620      	mov	r0, r4
   1b384:	f7ff fed0 	bl	1b128 <chunk_field>
   1b388:	ea30 0906 	bics.w	r9, r0, r6
   1b38c:	d129      	bne.n	1b3e2 <sys_heap_free+0xaa>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b38e:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   1b392:	bf34      	ite	cc
   1b394:	2700      	movcc	r7, #0
   1b396:	2701      	movcs	r7, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b398:	4006      	ands	r6, r0
		chunkid_t rc = right_chunk(h, c);
		size_t newsz = size(h, c) + size(h, rc);
   1b39a:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b39c:	fab6 f686 	clz	r6, r6
   1b3a0:	f1c7 071f 	rsb	r7, r7, #31

		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
   1b3a4:	4652      	mov	r2, sl
   1b3a6:	4620      	mov	r0, r4
   1b3a8:	1bb9      	subs	r1, r7, r6
   1b3aa:	f7ff fee0 	bl	1b16e <free_list_remove>
		chunk_set(h, c, SIZE_AND_USED, newsz);
   1b3ae:	4643      	mov	r3, r8
   1b3b0:	464a      	mov	r2, r9
   1b3b2:	4629      	mov	r1, r5
   1b3b4:	4620      	mov	r0, r4
   1b3b6:	f7ff fec3 	bl	1b140 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b3ba:	4629      	mov	r1, r5
   1b3bc:	4620      	mov	r0, r4
   1b3be:	f7ff feb3 	bl	1b128 <chunk_field>
   1b3c2:	68e3      	ldr	r3, [r4, #12]
   1b3c4:	4018      	ands	r0, r3
		if (!last_chunk(h, c)) {
   1b3c6:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   1b3c8:	4428      	add	r0, r5
		if (!last_chunk(h, c)) {
   1b3ca:	4283      	cmp	r3, r0
   1b3cc:	d009      	beq.n	1b3e2 <sys_heap_free+0xaa>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
   1b3ce:	4629      	mov	r1, r5
   1b3d0:	4620      	mov	r0, r4
   1b3d2:	f7ff fec2 	bl	1b15a <right_chunk>
   1b3d6:	4643      	mov	r3, r8
   1b3d8:	4601      	mov	r1, r0
   1b3da:	2201      	movs	r2, #1
   1b3dc:	4620      	mov	r0, r4
   1b3de:	f7ff feaf 	bl	1b140 <chunk_set>
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
   1b3e2:	6923      	ldr	r3, [r4, #16]
   1b3e4:	42ab      	cmp	r3, r5
   1b3e6:	d047      	beq.n	1b478 <sys_heap_free+0x140>
	return chunk_field(h, c, LEFT_SIZE);
   1b3e8:	2201      	movs	r2, #1
   1b3ea:	4629      	mov	r1, r5
   1b3ec:	4620      	mov	r0, r4
   1b3ee:	f7ff fe9b 	bl	1b128 <chunk_field>
	return c - left_size(h, c);
   1b3f2:	1a2f      	subs	r7, r5, r0
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   1b3f4:	2200      	movs	r2, #0
   1b3f6:	4639      	mov	r1, r7
   1b3f8:	4620      	mov	r0, r4
   1b3fa:	f7ff fe95 	bl	1b128 <chunk_field>
   1b3fe:	f8d4 800c 	ldr.w	r8, [r4, #12]
   1b402:	4606      	mov	r6, r0
   1b404:	ea30 0908 	bics.w	r9, r0, r8
   1b408:	d136      	bne.n	1b478 <sys_heap_free+0x140>
   1b40a:	464a      	mov	r2, r9
   1b40c:	4629      	mov	r1, r5
   1b40e:	4620      	mov	r0, r4
   1b410:	f7ff fe8a 	bl	1b128 <chunk_field>
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
   1b414:	4629      	mov	r1, r5
   1b416:	4682      	mov	sl, r0
   1b418:	4620      	mov	r0, r4
   1b41a:	f7ff fe9e 	bl	1b15a <right_chunk>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b41e:	68a1      	ldr	r1, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b420:	ea06 0608 	and.w	r6, r6, r8
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b424:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   1b428:	bf34      	ite	cc
   1b42a:	2100      	movcc	r1, #0
   1b42c:	2101      	movcs	r1, #1
   1b42e:	4605      	mov	r5, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b430:	ea08 000a 	and.w	r0, r8, sl
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
   1b434:	1983      	adds	r3, r0, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b436:	fab6 f686 	clz	r6, r6
   1b43a:	f1c1 011f 	rsb	r1, r1, #31

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   1b43e:	463a      	mov	r2, r7
   1b440:	4620      	mov	r0, r4
   1b442:	1b89      	subs	r1, r1, r6
		size_t merged_sz = csz + size(h, lc);
   1b444:	9301      	str	r3, [sp, #4]
		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   1b446:	f7ff fe92 	bl	1b16e <free_list_remove>
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
   1b44a:	464a      	mov	r2, r9
   1b44c:	4639      	mov	r1, r7
   1b44e:	4620      	mov	r0, r4
   1b450:	9b01      	ldr	r3, [sp, #4]
   1b452:	f7ff fe75 	bl	1b140 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b456:	4639      	mov	r1, r7
   1b458:	4620      	mov	r0, r4
   1b45a:	f7ff fe65 	bl	1b128 <chunk_field>
   1b45e:	68e2      	ldr	r2, [r4, #12]
   1b460:	4010      	ands	r0, r2
		if (!last_chunk(h, lc)) {
   1b462:	68a2      	ldr	r2, [r4, #8]
	return (c + size(h, c)) == h->len;
   1b464:	4438      	add	r0, r7
		if (!last_chunk(h, lc)) {
   1b466:	4290      	cmp	r0, r2
   1b468:	d005      	beq.n	1b476 <sys_heap_free+0x13e>
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
   1b46a:	2201      	movs	r2, #1
   1b46c:	4629      	mov	r1, r5
   1b46e:	4620      	mov	r0, r4
   1b470:	9b01      	ldr	r3, [sp, #4]
   1b472:	f7ff fe65 	bl	1b140 <chunk_set>
		}

		c = lc;
   1b476:	463d      	mov	r5, r7
   1b478:	4629      	mov	r1, r5
   1b47a:	2200      	movs	r2, #0
   1b47c:	4620      	mov	r0, r4
   1b47e:	f7ff fe53 	bl	1b128 <chunk_field>
   1b482:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
   1b484:	4629      	mov	r1, r5
   1b486:	4003      	ands	r3, r0
   1b488:	2200      	movs	r2, #0
   1b48a:	4620      	mov	r0, r4
   1b48c:	f7ff fe58 	bl	1b140 <chunk_set>
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
   1b490:	4629      	mov	r1, r5
   1b492:	4620      	mov	r0, r4
}
   1b494:	b002      	add	sp, #8
   1b496:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	free_list_add(h, c);
   1b49a:	f7ff be9d 	b.w	1b1d8 <free_list_add>
}
   1b49e:	b002      	add	sp, #8
   1b4a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001b4a4 <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   1b4a4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	struct z_heap *h = heap->heap;
   1b4a8:	6804      	ldr	r4, [r0, #0]
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   1b4aa:	1dcd      	adds	r5, r1, #7
	return big_heap(h) ? 8 : 4;
   1b4ac:	68a2      	ldr	r2, [r4, #8]
   1b4ae:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   1b4b2:	bf2c      	ite	cs
   1b4b4:	2308      	movcs	r3, #8
   1b4b6:	2304      	movcc	r3, #4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   1b4b8:	441d      	add	r5, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b4ba:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   1b4be:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b4c2:	fab5 f685 	clz	r6, r5
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b4c6:	bf34      	ite	cc
   1b4c8:	2300      	movcc	r3, #0
   1b4ca:	2301      	movcs	r3, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b4cc:	441e      	add	r6, r3
   1b4ce:	f1c6 081f 	rsb	r8, r6, #31
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
   1b4d2:	2900      	cmp	r1, #0
   1b4d4:	d03b      	beq.n	1b54e <sys_heap_alloc+0xaa>
   1b4d6:	fab2 f282 	clz	r2, r2
   1b4da:	f1c3 031f 	rsb	r3, r3, #31
   1b4de:	1a9b      	subs	r3, r3, r2
   1b4e0:	4598      	cmp	r8, r3
   1b4e2:	dc34      	bgt.n	1b54e <sys_heap_alloc+0xaa>
	struct z_heap_bucket *b = &h->buckets[bi];
   1b4e4:	6867      	ldr	r7, [r4, #4]
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);

	for (int i = 0; i < loops; i++) {
   1b4e6:	f04f 0a00 	mov.w	sl, #0
	struct z_heap_bucket *b = &h->buckets[bi];
   1b4ea:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
   1b4ee:	687b      	ldr	r3, [r7, #4]
   1b4f0:	2b03      	cmp	r3, #3
   1b4f2:	bf28      	it	cs
   1b4f4:	2303      	movcs	r3, #3
   1b4f6:	4699      	mov	r9, r3
	for (int i = 0; i < loops; i++) {
   1b4f8:	45ca      	cmp	sl, r9
   1b4fa:	db0d      	blt.n	1b518 <sys_heap_alloc+0x74>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
   1b4fc:	f04f 31ff 	mov.w	r1, #4294967295
   1b500:	6963      	ldr	r3, [r4, #20]
   1b502:	f1c6 0620 	rsb	r6, r6, #32
   1b506:	40b1      	lsls	r1, r6

	if ((bmask & h->avail_buckets) != 0) {
   1b508:	4019      	ands	r1, r3
   1b50a:	d020      	beq.n	1b54e <sys_heap_alloc+0xaa>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);

		return split_alloc(h, minbucket, sz);
   1b50c:	fa91 f1a1 	rbit	r1, r1
   1b510:	462a      	mov	r2, r5
   1b512:	fab1 f181 	clz	r1, r1
   1b516:	e00c      	b.n	1b532 <sys_heap_alloc+0x8e>
		if (size(h, b->next) >= sz) {
   1b518:	6839      	ldr	r1, [r7, #0]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   1b51a:	2200      	movs	r2, #0
   1b51c:	4620      	mov	r0, r4
   1b51e:	9101      	str	r1, [sp, #4]
   1b520:	f7ff fe02 	bl	1b128 <chunk_field>
   1b524:	68e3      	ldr	r3, [r4, #12]
   1b526:	9901      	ldr	r1, [sp, #4]
   1b528:	4018      	ands	r0, r3
   1b52a:	42a8      	cmp	r0, r5
   1b52c:	d307      	bcc.n	1b53e <sys_heap_alloc+0x9a>
			return split_alloc(h, bi, sz);
   1b52e:	462a      	mov	r2, r5
   1b530:	4641      	mov	r1, r8
		return split_alloc(h, minbucket, sz);
   1b532:	4620      	mov	r0, r4
	}

	return NULL;
}
   1b534:	b002      	add	sp, #8
   1b536:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return split_alloc(h, minbucket, sz);
   1b53a:	f7ff be9a 	b.w	1b272 <split_alloc>
	return chunk_field(h, c, FREE_NEXT);
   1b53e:	2203      	movs	r2, #3
   1b540:	4620      	mov	r0, r4
   1b542:	f7ff fdf1 	bl	1b128 <chunk_field>
	for (int i = 0; i < loops; i++) {
   1b546:	f10a 0a01 	add.w	sl, sl, #1
		b->next = free_next(h, b->next);
   1b54a:	6038      	str	r0, [r7, #0]
	for (int i = 0; i < loops; i++) {
   1b54c:	e7d4      	b.n	1b4f8 <sys_heap_alloc+0x54>
}
   1b54e:	2000      	movs	r0, #0
   1b550:	b002      	add	sp, #8
   1b552:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0001b556 <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   1b556:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   1b558:	188b      	adds	r3, r1, r2

	heap->heap = (struct z_heap *)addr;
	h->buf = (u64_t *)addr;
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
	h->len = buf_sz;
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   1b55a:	f647 72ff 	movw	r2, #32767	; 0x7fff
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
   1b55e:	1dcc      	adds	r4, r1, #7
   1b560:	f024 0407 	bic.w	r4, r4, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   1b564:	f023 0307 	bic.w	r3, r3, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   1b568:	1b1b      	subs	r3, r3, r4
   1b56a:	08db      	lsrs	r3, r3, #3
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   1b56c:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   1b570:	bf2c      	ite	cs
   1b572:	f06f 4100 	mvncs.w	r1, #2147483648	; 0x80000000
   1b576:	4611      	movcc	r1, r2
	heap->heap = (struct z_heap *)addr;
   1b578:	6004      	str	r4, [r0, #0]
	h->avail_buckets = 0;
   1b57a:	2000      	movs	r0, #0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b57c:	4293      	cmp	r3, r2
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   1b57e:	60e1      	str	r1, [r4, #12]
   1b580:	bf94      	ite	ls
   1b582:	2100      	movls	r1, #0
   1b584:	2101      	movhi	r1, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b586:	fab3 f683 	clz	r6, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b58a:	4617      	mov	r7, r2
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
		heap->heap->buckets[i].list_size = 0;
   1b58c:	4684      	mov	ip, r0
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
   1b58e:	f1c1 0120 	rsb	r1, r1, #32
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
   1b592:	f104 0518 	add.w	r5, r4, #24
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
   1b596:	1b89      	subs	r1, r1, r6
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   1b598:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
	h->len = buf_sz;
   1b59c:	e9c4 5301 	strd	r5, r3, [r4, #4]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   1b5a0:	3103      	adds	r1, #3
	h->buf = (u64_t *)addr;
   1b5a2:	6024      	str	r4, [r4, #0]
	h->avail_buckets = 0;
   1b5a4:	6160      	str	r0, [r4, #20]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   1b5a6:	6121      	str	r1, [r4, #16]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   1b5a8:	68a2      	ldr	r2, [r4, #8]
   1b5aa:	42ba      	cmp	r2, r7
   1b5ac:	bf94      	ite	ls
   1b5ae:	2200      	movls	r2, #0
   1b5b0:	2201      	movhi	r2, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   1b5b2:	f1c2 021f 	rsb	r2, r2, #31
   1b5b6:	1b92      	subs	r2, r2, r6
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   1b5b8:	4290      	cmp	r0, r2
   1b5ba:	dd0a      	ble.n	1b5d2 <sys_heap_init+0x7c>
		heap->heap->buckets[i].next = 0;
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
   1b5bc:	4620      	mov	r0, r4
   1b5be:	1a5b      	subs	r3, r3, r1
   1b5c0:	2200      	movs	r2, #0
   1b5c2:	f7ff fdbd 	bl	1b140 <chunk_set>
	free_list_add(h, h->chunk0);
   1b5c6:	4620      	mov	r0, r4
   1b5c8:	6921      	ldr	r1, [r4, #16]
}
   1b5ca:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, h->chunk0);
   1b5ce:	f7ff be03 	b.w	1b1d8 <free_list_add>
		heap->heap->buckets[i].list_size = 0;
   1b5d2:	f8c5 c004 	str.w	ip, [r5, #4]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   1b5d6:	3001      	adds	r0, #1
		heap->heap->buckets[i].next = 0;
   1b5d8:	f845 cb08 	str.w	ip, [r5], #8
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   1b5dc:	e7e4      	b.n	1b5a8 <sys_heap_init+0x52>

0001b5de <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   1b5de:	4770      	bx	lr

0001b5e0 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   1b5e0:	f7fd bfba 	b.w	19558 <SystemInit>

0001b5e4 <append_u8>:
{
   1b5e4:	b510      	push	{r4, lr}
	if (!cpkt) {
   1b5e6:	b158      	cbz	r0, 1b600 <append_u8+0x1c>
	if (cpkt->max_len - cpkt->offset < 1) {
   1b5e8:	8883      	ldrh	r3, [r0, #4]
   1b5ea:	88c2      	ldrh	r2, [r0, #6]
   1b5ec:	1ad2      	subs	r2, r2, r3
   1b5ee:	2a00      	cmp	r2, #0
	cpkt->data[cpkt->offset++] = data;
   1b5f0:	bfc3      	ittte	gt
   1b5f2:	1c5c      	addgt	r4, r3, #1
   1b5f4:	6802      	ldrgt	r2, [r0, #0]
   1b5f6:	8084      	strhgt	r4, [r0, #4]
		return false;
   1b5f8:	2000      	movle	r0, #0
	return true;
   1b5fa:	bfc4      	itt	gt
   1b5fc:	2001      	movgt	r0, #1
	cpkt->data[cpkt->offset++] = data;
   1b5fe:	54d1      	strbgt	r1, [r2, r3]
}
   1b600:	bd10      	pop	{r4, pc}

0001b602 <append_be16>:
{
   1b602:	b510      	push	{r4, lr}
	if (!cpkt) {
   1b604:	b178      	cbz	r0, 1b626 <append_be16+0x24>
	if (cpkt->max_len - cpkt->offset < 2) {
   1b606:	8883      	ldrh	r3, [r0, #4]
   1b608:	88c2      	ldrh	r2, [r0, #6]
   1b60a:	1ad2      	subs	r2, r2, r3
   1b60c:	2a01      	cmp	r2, #1
   1b60e:	dd0b      	ble.n	1b628 <append_be16+0x26>
	cpkt->data[cpkt->offset++] = data >> 8;
   1b610:	6802      	ldr	r2, [r0, #0]
   1b612:	1c5c      	adds	r4, r3, #1
   1b614:	8084      	strh	r4, [r0, #4]
   1b616:	0a0c      	lsrs	r4, r1, #8
   1b618:	54d4      	strb	r4, [r2, r3]
	cpkt->data[cpkt->offset++] = (u8_t) data;
   1b61a:	8883      	ldrh	r3, [r0, #4]
   1b61c:	6802      	ldr	r2, [r0, #0]
   1b61e:	1c5c      	adds	r4, r3, #1
   1b620:	8084      	strh	r4, [r0, #4]
	return true;
   1b622:	2001      	movs	r0, #1
	cpkt->data[cpkt->offset++] = (u8_t) data;
   1b624:	54d1      	strb	r1, [r2, r3]
}
   1b626:	bd10      	pop	{r4, pc}
		return false;
   1b628:	2000      	movs	r0, #0
   1b62a:	e7fc      	b.n	1b626 <append_be16+0x24>

0001b62c <decode_delta>:
{
   1b62c:	b570      	push	{r4, r5, r6, lr}
   1b62e:	f8bd 4010 	ldrh.w	r4, [sp, #16]
   1b632:	9d06      	ldr	r5, [sp, #24]
	if (opt == COAP_OPTION_EXT_13) {
   1b634:	2c0d      	cmp	r4, #13
   1b636:	d111      	bne.n	1b65c <decode_delta+0x30>
		*hdr_len = 1U;
   1b638:	2401      	movs	r4, #1
   1b63a:	802c      	strh	r4, [r5, #0]
	if (max_len - offset < 1) {
   1b63c:	1a5c      	subs	r4, r3, r1
   1b63e:	2c00      	cmp	r4, #0
   1b640:	dc02      	bgt.n	1b648 <decode_delta+0x1c>
			return -EINVAL;
   1b642:	f06f 0015 	mvn.w	r0, #21
}
   1b646:	bd70      	pop	{r4, r5, r6, pc}
	*value = data[offset++];
   1b648:	1c4d      	adds	r5, r1, #1
   1b64a:	b2ad      	uxth	r5, r5
   1b64c:	5c44      	ldrb	r4, [r0, r1]
		if (ret < 0) {
   1b64e:	1b58      	subs	r0, r3, r5
	*pos = offset;
   1b650:	8015      	strh	r5, [r2, #0]
		if (ret < 0) {
   1b652:	d4f6      	bmi.n	1b642 <decode_delta+0x16>
		opt = val + COAP_OPTION_EXT_13;
   1b654:	340d      	adds	r4, #13
	*opt_ext = opt;
   1b656:	9b05      	ldr	r3, [sp, #20]
   1b658:	801c      	strh	r4, [r3, #0]
	return ret;
   1b65a:	e7f4      	b.n	1b646 <decode_delta+0x1a>
	} else if (opt == COAP_OPTION_EXT_14) {
   1b65c:	2c0e      	cmp	r4, #14
   1b65e:	d113      	bne.n	1b688 <decode_delta+0x5c>
		*hdr_len = 2U;
   1b660:	2402      	movs	r4, #2
   1b662:	802c      	strh	r4, [r5, #0]
	if (max_len - offset < 2) {
   1b664:	1a5c      	subs	r4, r3, r1
   1b666:	2c01      	cmp	r4, #1
   1b668:	ddeb      	ble.n	1b642 <decode_delta+0x16>
	*value = data[offset++] << 8;
   1b66a:	5c46      	ldrb	r6, [r0, r1]
	*value |= data[offset++];
   1b66c:	1c8d      	adds	r5, r1, #2
	*value = data[offset++] << 8;
   1b66e:	3101      	adds	r1, #1
	*value |= data[offset++];
   1b670:	b289      	uxth	r1, r1
   1b672:	5c44      	ldrb	r4, [r0, r1]
   1b674:	b2ad      	uxth	r5, r5
		if (ret < 0) {
   1b676:	1b58      	subs	r0, r3, r5
	*value |= data[offset++];
   1b678:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
	*pos = offset;
   1b67c:	8015      	strh	r5, [r2, #0]
		if (ret < 0) {
   1b67e:	d4e0      	bmi.n	1b642 <decode_delta+0x16>
		opt = val + COAP_OPTION_EXT_269;
   1b680:	f204 140d 	addw	r4, r4, #269	; 0x10d
   1b684:	b2a4      	uxth	r4, r4
   1b686:	e7e6      	b.n	1b656 <decode_delta+0x2a>
	} else if (opt == COAP_OPTION_EXT_15) {
   1b688:	2c0f      	cmp	r4, #15
   1b68a:	d0da      	beq.n	1b642 <decode_delta+0x16>
	int ret = 0;
   1b68c:	2000      	movs	r0, #0
   1b68e:	e7e2      	b.n	1b656 <decode_delta+0x2a>

0001b690 <append>:
{
   1b690:	b538      	push	{r3, r4, r5, lr}
   1b692:	4615      	mov	r5, r2
	if (!cpkt || !data) {
   1b694:	4604      	mov	r4, r0
   1b696:	b170      	cbz	r0, 1b6b6 <append+0x26>
   1b698:	b169      	cbz	r1, 1b6b6 <append+0x26>
	if (cpkt->max_len - cpkt->offset < len) {
   1b69a:	8880      	ldrh	r0, [r0, #4]
   1b69c:	88e3      	ldrh	r3, [r4, #6]
   1b69e:	1a1b      	subs	r3, r3, r0
   1b6a0:	4293      	cmp	r3, r2
   1b6a2:	db08      	blt.n	1b6b6 <append+0x26>
	memcpy(cpkt->data + cpkt->offset, data, len);
   1b6a4:	6823      	ldr	r3, [r4, #0]
   1b6a6:	4418      	add	r0, r3
   1b6a8:	f000 fc9c 	bl	1bfe4 <memcpy>
	return true;
   1b6ac:	2001      	movs	r0, #1
	cpkt->offset += len;
   1b6ae:	88a2      	ldrh	r2, [r4, #4]
   1b6b0:	4415      	add	r5, r2
   1b6b2:	80a5      	strh	r5, [r4, #4]
}
   1b6b4:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   1b6b6:	2000      	movs	r0, #0
   1b6b8:	e7fc      	b.n	1b6b4 <append+0x24>

0001b6ba <parse_option>:
{
   1b6ba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (max_len - offset < 1) {
   1b6be:	1a5c      	subs	r4, r3, r1
{
   1b6c0:	b087      	sub	sp, #28
	if (max_len - offset < 1) {
   1b6c2:	2c00      	cmp	r4, #0
{
   1b6c4:	4681      	mov	r9, r0
   1b6c6:	e9dd a710 	ldrd	sl, r7, [sp, #64]	; 0x40
   1b6ca:	4616      	mov	r6, r2
   1b6cc:	461d      	mov	r5, r3
   1b6ce:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
	if (max_len - offset < 1) {
   1b6d2:	dd14      	ble.n	1b6fe <parse_option+0x44>
	*value = data[offset++];
   1b6d4:	f101 0c01 	add.w	ip, r1, #1
   1b6d8:	fa1f fc8c 	uxth.w	ip, ip
   1b6dc:	5c44      	ldrb	r4, [r0, r1]
	if (r < 0) {
   1b6de:	ebb3 010c 	subs.w	r1, r3, ip
	*pos = offset;
   1b6e2:	f8a2 c000 	strh.w	ip, [r2]
	if (r < 0) {
   1b6e6:	d452      	bmi.n	1b78e <parse_option+0xd4>
	*opt_len += 1U;
   1b6e8:	f8b7 c000 	ldrh.w	ip, [r7]
	if (opt == COAP_MARKER) {
   1b6ec:	2cff      	cmp	r4, #255	; 0xff
	*opt_len += 1U;
   1b6ee:	f10c 0c01 	add.w	ip, ip, #1
   1b6f2:	f8a7 c000 	strh.w	ip, [r7]
	if (opt == COAP_MARKER) {
   1b6f6:	d105      	bne.n	1b704 <parse_option+0x4a>
		return r > 0 ? 0 : -EINVAL;
   1b6f8:	2900      	cmp	r1, #0
   1b6fa:	f040 8090 	bne.w	1b81e <parse_option+0x164>
		return -EINVAL;
   1b6fe:	f06f 0115 	mvn.w	r1, #21
   1b702:	e044      	b.n	1b78e <parse_option+0xd4>
	return (opt & 0xF0) >> 4;
   1b704:	ea4f 1e14 	mov.w	lr, r4, lsr #4
	len = option_header_get_len(opt);
   1b708:	f004 040f 	and.w	r4, r4, #15
	delta = option_header_get_delta(opt);
   1b70c:	f8ad e014 	strh.w	lr, [sp, #20]
	len = option_header_get_len(opt);
   1b710:	f8ad 4016 	strh.w	r4, [sp, #22]
	if (r == 0 && delta > COAP_OPTION_NO_EXT) {
   1b714:	2900      	cmp	r1, #0
   1b716:	d13e      	bne.n	1b796 <parse_option+0xdc>
   1b718:	f1be 0f0c 	cmp.w	lr, #12
   1b71c:	d8ef      	bhi.n	1b6fe <parse_option+0x44>
	if (len > COAP_OPTION_NO_EXT) {
   1b71e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1b722:	2b0c      	cmp	r3, #12
   1b724:	d916      	bls.n	1b754 <parse_option+0x9a>
		r = decode_delta(data, *pos, pos, max_len,
   1b726:	f10d 0212 	add.w	r2, sp, #18
   1b72a:	9202      	str	r2, [sp, #8]
   1b72c:	f10d 0216 	add.w	r2, sp, #22
   1b730:	e9cd 3200 	strd	r3, r2, [sp]
   1b734:	8831      	ldrh	r1, [r6, #0]
   1b736:	462b      	mov	r3, r5
   1b738:	4632      	mov	r2, r6
   1b73a:	4648      	mov	r0, r9
   1b73c:	f7ff ff76 	bl	1b62c <decode_delta>
		if (r < 0) {
   1b740:	1e01      	subs	r1, r0, #0
   1b742:	dbdc      	blt.n	1b6fe <parse_option+0x44>
#endif

#if use_builtin(__builtin_add_overflow)
static inline bool u16_add_overflow(u16_t a, u16_t b, u16_t *result)
{
	return __builtin_add_overflow(a, b, result);
   1b744:	883b      	ldrh	r3, [r7, #0]
   1b746:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1b74a:	4413      	add	r3, r2
   1b74c:	b29a      	uxth	r2, r3
		if (u16_add_overflow(*opt_len, hdr_len, opt_len)) {
   1b74e:	4293      	cmp	r3, r2
   1b750:	803b      	strh	r3, [r7, #0]
   1b752:	d1d4      	bne.n	1b6fe <parse_option+0x44>
   1b754:	f8ba 4000 	ldrh.w	r4, [sl]
   1b758:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1b75c:	441c      	add	r4, r3
   1b75e:	b2a3      	uxth	r3, r4
   1b760:	f8aa 4000 	strh.w	r4, [sl]
	if (u16_add_overflow(*opt_delta, delta, opt_delta) ||
   1b764:	1ae4      	subs	r4, r4, r3
   1b766:	bf18      	it	ne
   1b768:	2401      	movne	r4, #1
   1b76a:	2c00      	cmp	r4, #0
   1b76c:	d1c7      	bne.n	1b6fe <parse_option+0x44>
   1b76e:	883b      	ldrh	r3, [r7, #0]
	    u16_add_overflow(*opt_len, len, opt_len)) {
   1b770:	f8bd b016 	ldrh.w	fp, [sp, #22]
   1b774:	445b      	add	r3, fp
   1b776:	b29a      	uxth	r2, r3
   1b778:	4293      	cmp	r3, r2
   1b77a:	bf18      	it	ne
   1b77c:	2401      	movne	r4, #1
	if (u16_add_overflow(*opt_delta, delta, opt_delta) ||
   1b77e:	b2a4      	uxth	r4, r4
   1b780:	803b      	strh	r3, [r7, #0]
   1b782:	2c00      	cmp	r4, #0
   1b784:	d1bb      	bne.n	1b6fe <parse_option+0x44>
	if (r == 0) {
   1b786:	bb11      	cbnz	r1, 1b7ce <parse_option+0x114>
		if (len == 0U) {
   1b788:	f1bb 0f00 	cmp.w	fp, #0
   1b78c:	d1b7      	bne.n	1b6fe <parse_option+0x44>
}
   1b78e:	4608      	mov	r0, r1
   1b790:	b007      	add	sp, #28
   1b792:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (delta > COAP_OPTION_NO_EXT) {
   1b796:	f1be 0f0c 	cmp.w	lr, #12
   1b79a:	d9c0      	bls.n	1b71e <parse_option+0x64>
		r = decode_delta(data, *pos, pos, max_len,
   1b79c:	f10d 0112 	add.w	r1, sp, #18
   1b7a0:	9102      	str	r1, [sp, #8]
   1b7a2:	a905      	add	r1, sp, #20
   1b7a4:	e9cd e100 	strd	lr, r1, [sp]
   1b7a8:	8811      	ldrh	r1, [r2, #0]
   1b7aa:	f7ff ff3f 	bl	1b62c <decode_delta>
		if ((r < 0) || (r == 0 && len > COAP_OPTION_NO_EXT)) {
   1b7ae:	1e01      	subs	r1, r0, #0
   1b7b0:	dba5      	blt.n	1b6fe <parse_option+0x44>
   1b7b2:	d103      	bne.n	1b7bc <parse_option+0x102>
   1b7b4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1b7b8:	2b0c      	cmp	r3, #12
   1b7ba:	d8a0      	bhi.n	1b6fe <parse_option+0x44>
   1b7bc:	883b      	ldrh	r3, [r7, #0]
   1b7be:	f8bd 2012 	ldrh.w	r2, [sp, #18]
   1b7c2:	4413      	add	r3, r2
   1b7c4:	b29a      	uxth	r2, r3
		if (u16_add_overflow(*opt_len, hdr_len, opt_len)) {
   1b7c6:	4293      	cmp	r3, r2
   1b7c8:	803b      	strh	r3, [r7, #0]
   1b7ca:	d0a8      	beq.n	1b71e <parse_option+0x64>
   1b7cc:	e797      	b.n	1b6fe <parse_option+0x44>
	if (option) {
   1b7ce:	f1b8 0f00 	cmp.w	r8, #0
   1b7d2:	d01a      	beq.n	1b80a <parse_option+0x150>
		if (len > sizeof(option->value)) {
   1b7d4:	f1bb 0f0c 	cmp.w	fp, #12
   1b7d8:	d891      	bhi.n	1b6fe <parse_option+0x44>
		option->delta = *opt_delta;
   1b7da:	f8ba 3000 	ldrh.w	r3, [sl]
		option->len = len;
   1b7de:	f888 b002 	strb.w	fp, [r8, #2]
		option->delta = *opt_delta;
   1b7e2:	f8a8 3000 	strh.w	r3, [r8]
		r = read(data, *pos, pos, max_len, len, &option->value[0]);
   1b7e6:	8834      	ldrh	r4, [r6, #0]
   1b7e8:	f108 0003 	add.w	r0, r8, #3
	if (max_len - offset < len) {
   1b7ec:	1b2b      	subs	r3, r5, r4
   1b7ee:	459b      	cmp	fp, r3
   1b7f0:	dc85      	bgt.n	1b6fe <parse_option+0x44>
	memcpy(value, data + offset, len);
   1b7f2:	eb09 0104 	add.w	r1, r9, r4
   1b7f6:	465a      	mov	r2, fp
   1b7f8:	f000 fbf4 	bl	1bfe4 <memcpy>
	offset += len;
   1b7fc:	eb0b 0104 	add.w	r1, fp, r4
   1b800:	b289      	uxth	r1, r1
	*pos = offset;
   1b802:	8031      	strh	r1, [r6, #0]
		if (r < 0) {
   1b804:	1a69      	subs	r1, r5, r1
   1b806:	d5c2      	bpl.n	1b78e <parse_option+0xd4>
   1b808:	e779      	b.n	1b6fe <parse_option+0x44>
   1b80a:	8832      	ldrh	r2, [r6, #0]
   1b80c:	4493      	add	fp, r2
   1b80e:	fa1f f18b 	uxth.w	r1, fp
		if (u16_add_overflow(*pos, len, pos)) {
   1b812:	458b      	cmp	fp, r1
   1b814:	8031      	strh	r1, [r6, #0]
   1b816:	f47f af72 	bne.w	1b6fe <parse_option+0x44>
		r = max_len - *pos;
   1b81a:	1a69      	subs	r1, r5, r1
   1b81c:	e7b7      	b.n	1b78e <parse_option+0xd4>
		return r > 0 ? 0 : -EINVAL;
   1b81e:	2100      	movs	r1, #0
   1b820:	e7b5      	b.n	1b78e <parse_option+0xd4>

0001b822 <coap_packet_init>:
{
   1b822:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1b826:	9f0a      	ldr	r7, [sp, #40]	; 0x28
   1b828:	4689      	mov	r9, r1
   1b82a:	4616      	mov	r6, r2
   1b82c:	4698      	mov	r8, r3
	if (!cpkt || !data || !max_len) {
   1b82e:	4604      	mov	r4, r0
{
   1b830:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
	if (!cpkt || !data || !max_len) {
   1b834:	b918      	cbnz	r0, 1b83e <coap_packet_init+0x1c>
		return -EINVAL;
   1b836:	f06f 0015 	mvn.w	r0, #21
}
   1b83a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!cpkt || !data || !max_len) {
   1b83e:	2900      	cmp	r1, #0
   1b840:	d0f9      	beq.n	1b836 <coap_packet_init+0x14>
   1b842:	2a00      	cmp	r2, #0
   1b844:	d0f7      	beq.n	1b836 <coap_packet_init+0x14>
	memset(cpkt, 0, sizeof(*cpkt));
   1b846:	2210      	movs	r2, #16
   1b848:	2100      	movs	r1, #0
   1b84a:	f000 fbf6 	bl	1c03a <memset>
	cpkt->offset = 0U;
   1b84e:	2300      	movs	r3, #0
	hdr |= (type & 0x3) << 4;
   1b850:	f89d 2020 	ldrb.w	r2, [sp, #32]
	cpkt->offset = 0U;
   1b854:	80a3      	strh	r3, [r4, #4]
	hdr |= (type & 0x3) << 4;
   1b856:	0112      	lsls	r2, r2, #4
   1b858:	f002 0230 	and.w	r2, r2, #48	; 0x30
	cpkt->delta = 0U;
   1b85c:	81a3      	strh	r3, [r4, #12]
	hdr |= tokenlen & 0xF;
   1b85e:	f005 010f 	and.w	r1, r5, #15
	hdr |= (type & 0x3) << 4;
   1b862:	ea42 1388 	orr.w	r3, r2, r8, lsl #6
	hdr |= tokenlen & 0xF;
   1b866:	4319      	orrs	r1, r3
	cpkt->max_len = max_len;
   1b868:	80e6      	strh	r6, [r4, #6]
	res = append_u8(cpkt, hdr);
   1b86a:	4620      	mov	r0, r4
	cpkt->data = data;
   1b86c:	f8c4 9000 	str.w	r9, [r4]
	res = append_u8(cpkt, hdr);
   1b870:	b2c9      	uxtb	r1, r1
	hdr |= tokenlen & 0xF;
   1b872:	b26e      	sxtb	r6, r5
	res = append_u8(cpkt, hdr);
   1b874:	f7ff feb6 	bl	1b5e4 <append_u8>
	if (!res) {
   1b878:	2800      	cmp	r0, #0
   1b87a:	d0dc      	beq.n	1b836 <coap_packet_init+0x14>
	res = append_u8(cpkt, code);
   1b87c:	4620      	mov	r0, r4
   1b87e:	f89d 102c 	ldrb.w	r1, [sp, #44]	; 0x2c
   1b882:	f7ff feaf 	bl	1b5e4 <append_u8>
	if (!res) {
   1b886:	2800      	cmp	r0, #0
   1b888:	d0d5      	beq.n	1b836 <coap_packet_init+0x14>
	res = append_be16(cpkt, id);
   1b88a:	4620      	mov	r0, r4
   1b88c:	f8bd 1030 	ldrh.w	r1, [sp, #48]	; 0x30
   1b890:	f7ff feb7 	bl	1b602 <append_be16>
	if (!res) {
   1b894:	2800      	cmp	r0, #0
   1b896:	d0ce      	beq.n	1b836 <coap_packet_init+0x14>
	if (token && tokenlen) {
   1b898:	b91f      	cbnz	r7, 1b8a2 <coap_packet_init+0x80>
	cpkt->hdr_len = 1 + 1 + 2 + tokenlen;
   1b89a:	3604      	adds	r6, #4
	return 0;
   1b89c:	2000      	movs	r0, #0
	cpkt->hdr_len = 1 + 1 + 2 + tokenlen;
   1b89e:	7226      	strb	r6, [r4, #8]
	return 0;
   1b8a0:	e7cb      	b.n	1b83a <coap_packet_init+0x18>
	if (token && tokenlen) {
   1b8a2:	2d00      	cmp	r5, #0
   1b8a4:	d0f9      	beq.n	1b89a <coap_packet_init+0x78>
		res = append(cpkt, token, tokenlen);
   1b8a6:	462a      	mov	r2, r5
   1b8a8:	4639      	mov	r1, r7
   1b8aa:	4620      	mov	r0, r4
   1b8ac:	f7ff fef0 	bl	1b690 <append>
		if (!res) {
   1b8b0:	2800      	cmp	r0, #0
   1b8b2:	d1f2      	bne.n	1b89a <coap_packet_init+0x78>
   1b8b4:	e7bf      	b.n	1b836 <coap_packet_init+0x14>

0001b8b6 <coap_packet_append_option>:
{
   1b8b6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b8ba:	460f      	mov	r7, r1
   1b8bc:	4692      	mov	sl, r2
   1b8be:	461c      	mov	r4, r3
	if (!cpkt) {
   1b8c0:	4606      	mov	r6, r0
   1b8c2:	b918      	cbnz	r0, 1b8cc <coap_packet_append_option+0x16>
		return -EINVAL;
   1b8c4:	f06f 0015 	mvn.w	r0, #21
}
   1b8c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (len && !value) {
   1b8cc:	b10b      	cbz	r3, 1b8d2 <coap_packet_append_option+0x1c>
   1b8ce:	2a00      	cmp	r2, #0
   1b8d0:	d0f8      	beq.n	1b8c4 <coap_packet_append_option+0xe>
	if (code < cpkt->delta) {
   1b8d2:	89b1      	ldrh	r1, [r6, #12]
   1b8d4:	42b9      	cmp	r1, r7
   1b8d6:	d8f5      	bhi.n	1b8c4 <coap_packet_append_option+0xe>
	if (cpkt->opt_len) {
   1b8d8:	8973      	ldrh	r3, [r6, #10]
   1b8da:	b11b      	cbz	r3, 1b8e4 <coap_packet_append_option+0x2e>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
   1b8dc:	42b9      	cmp	r1, r7
   1b8de:	d034      	beq.n	1b94a <coap_packet_append_option+0x94>
   1b8e0:	1a7f      	subs	r7, r7, r1
   1b8e2:	b2bf      	uxth	r7, r7
	if (num < COAP_OPTION_EXT_13) {
   1b8e4:	2f0c      	cmp	r7, #12
   1b8e6:	d832      	bhi.n	1b94e <coap_packet_append_option+0x98>
		*ext = 0U;
   1b8e8:	f04f 0b00 	mov.w	fp, #0
		return 0;
   1b8ec:	46d9      	mov	r9, fp
		*opt = num;
   1b8ee:	b2fb      	uxtb	r3, r7
	if (num < COAP_OPTION_EXT_13) {
   1b8f0:	2c0c      	cmp	r4, #12
   1b8f2:	d842      	bhi.n	1b97a <coap_packet_append_option+0xc4>
		*ext = 0U;
   1b8f4:	2500      	movs	r5, #0
		return 0;
   1b8f6:	46a8      	mov	r8, r5
		*opt = num;
   1b8f8:	b2e1      	uxtb	r1, r4
	*opt |= (len & 0xF);
   1b8fa:	ea41 1103 	orr.w	r1, r1, r3, lsl #4
	res = append_u8(cpkt, opt);
   1b8fe:	4630      	mov	r0, r6
   1b900:	b2c9      	uxtb	r1, r1
   1b902:	f7ff fe6f 	bl	1b5e4 <append_u8>
	if (!res) {
   1b906:	2800      	cmp	r0, #0
   1b908:	d0dc      	beq.n	1b8c4 <coap_packet_append_option+0xe>
	if (delta_size == 1U) {
   1b90a:	f1b9 0f01 	cmp.w	r9, #1
   1b90e:	d146      	bne.n	1b99e <coap_packet_append_option+0xe8>
		res = append_u8(cpkt, (u8_t)delta_ext);
   1b910:	4630      	mov	r0, r6
   1b912:	fa5f f18b 	uxtb.w	r1, fp
   1b916:	f7ff fe65 	bl	1b5e4 <append_u8>
		if (!res) {
   1b91a:	2800      	cmp	r0, #0
   1b91c:	d0d2      	beq.n	1b8c4 <coap_packet_append_option+0xe>
	if (len_size == 1U) {
   1b91e:	f1b8 0f01 	cmp.w	r8, #1
   1b922:	d105      	bne.n	1b930 <coap_packet_append_option+0x7a>
		res = append_u8(cpkt, (u8_t)len_ext);
   1b924:	4630      	mov	r0, r6
   1b926:	b2e9      	uxtb	r1, r5
   1b928:	f7ff fe5c 	bl	1b5e4 <append_u8>
		if (!res) {
   1b92c:	2800      	cmp	r0, #0
   1b92e:	d0c9      	beq.n	1b8c4 <coap_packet_append_option+0xe>
	if (len && value) {
   1b930:	2c00      	cmp	r4, #0
   1b932:	d145      	bne.n	1b9c0 <coap_packet_append_option+0x10a>
	return  (1 + delta_size + len_size + len);
   1b934:	3401      	adds	r4, #1
	cpkt->opt_len += r;
   1b936:	8973      	ldrh	r3, [r6, #10]
	cpkt->delta += code;
   1b938:	89b1      	ldrh	r1, [r6, #12]
	return  (1 + delta_size + len_size + len);
   1b93a:	444c      	add	r4, r9
   1b93c:	4444      	add	r4, r8
	cpkt->opt_len += r;
   1b93e:	441c      	add	r4, r3
	cpkt->delta += code;
   1b940:	440f      	add	r7, r1
	return 0;
   1b942:	2000      	movs	r0, #0
	cpkt->opt_len += r;
   1b944:	8174      	strh	r4, [r6, #10]
	cpkt->delta += code;
   1b946:	81b7      	strh	r7, [r6, #12]
	return 0;
   1b948:	e7be      	b.n	1b8c8 <coap_packet_append_option+0x12>
		code = (code == cpkt->delta) ? 0 : code - cpkt->delta;
   1b94a:	2700      	movs	r7, #0
   1b94c:	e7cc      	b.n	1b8e8 <coap_packet_append_option+0x32>
	} else if (num < COAP_OPTION_EXT_269) {
   1b94e:	f5b7 7f86 	cmp.w	r7, #268	; 0x10c
   1b952:	fa0f fb87 	sxth.w	fp, r7
   1b956:	d807      	bhi.n	1b968 <coap_packet_append_option+0xb2>
		*ext = num - COAP_OPTION_EXT_13;
   1b958:	f1ab 0b0d 	sub.w	fp, fp, #13
		*opt = COAP_OPTION_EXT_13;
   1b95c:	230d      	movs	r3, #13
		return 1;
   1b95e:	f04f 0901 	mov.w	r9, #1
		*ext = num - COAP_OPTION_EXT_13;
   1b962:	fa1f fb8b 	uxth.w	fp, fp
		return 1;
   1b966:	e7c3      	b.n	1b8f0 <coap_packet_append_option+0x3a>
	*ext = num - COAP_OPTION_EXT_269;
   1b968:	f46f 7186 	mvn.w	r1, #268	; 0x10c
   1b96c:	448b      	add	fp, r1
	*opt = COAP_OPTION_EXT_14;
   1b96e:	230e      	movs	r3, #14
	return 2;
   1b970:	f04f 0902 	mov.w	r9, #2
	*ext = num - COAP_OPTION_EXT_269;
   1b974:	fa1f fb8b 	uxth.w	fp, fp
	return 2;
   1b978:	e7ba      	b.n	1b8f0 <coap_packet_append_option+0x3a>
	} else if (num < COAP_OPTION_EXT_269) {
   1b97a:	f5b4 7f86 	cmp.w	r4, #268	; 0x10c
   1b97e:	b225      	sxth	r5, r4
   1b980:	d805      	bhi.n	1b98e <coap_packet_append_option+0xd8>
		*ext = num - COAP_OPTION_EXT_13;
   1b982:	3d0d      	subs	r5, #13
		*opt = COAP_OPTION_EXT_13;
   1b984:	210d      	movs	r1, #13
		return 1;
   1b986:	f04f 0801 	mov.w	r8, #1
		*ext = num - COAP_OPTION_EXT_13;
   1b98a:	b2ad      	uxth	r5, r5
		return 1;
   1b98c:	e7b5      	b.n	1b8fa <coap_packet_append_option+0x44>
	*ext = num - COAP_OPTION_EXT_269;
   1b98e:	f46f 7286 	mvn.w	r2, #268	; 0x10c
   1b992:	4415      	add	r5, r2
	*opt = COAP_OPTION_EXT_14;
   1b994:	210e      	movs	r1, #14
	return 2;
   1b996:	f04f 0802 	mov.w	r8, #2
	*ext = num - COAP_OPTION_EXT_269;
   1b99a:	b2ad      	uxth	r5, r5
	return 2;
   1b99c:	e7ad      	b.n	1b8fa <coap_packet_append_option+0x44>
	} else if (delta_size == 2U) {
   1b99e:	f1b9 0f02 	cmp.w	r9, #2
   1b9a2:	d1bc      	bne.n	1b91e <coap_packet_append_option+0x68>
		res = append_be16(cpkt, delta_ext);
   1b9a4:	4659      	mov	r1, fp
   1b9a6:	4630      	mov	r0, r6
   1b9a8:	f7ff fe2b 	bl	1b602 <append_be16>
		if (!res) {
   1b9ac:	2800      	cmp	r0, #0
   1b9ae:	d089      	beq.n	1b8c4 <coap_packet_append_option+0xe>
	if (len_size == 1U) {
   1b9b0:	f1b8 0f01 	cmp.w	r8, #1
   1b9b4:	d0b6      	beq.n	1b924 <coap_packet_append_option+0x6e>
		res = append_be16(cpkt, len_ext);
   1b9b6:	4629      	mov	r1, r5
   1b9b8:	4630      	mov	r0, r6
   1b9ba:	f7ff fe22 	bl	1b602 <append_be16>
   1b9be:	e7b5      	b.n	1b92c <coap_packet_append_option+0x76>
	if (len && value) {
   1b9c0:	f1ba 0f00 	cmp.w	sl, #0
   1b9c4:	d0b6      	beq.n	1b934 <coap_packet_append_option+0x7e>
		res = append(cpkt, value, len);
   1b9c6:	4622      	mov	r2, r4
   1b9c8:	4651      	mov	r1, sl
   1b9ca:	4630      	mov	r0, r6
   1b9cc:	f7ff fe60 	bl	1b690 <append>
		if (!res) {
   1b9d0:	2800      	cmp	r0, #0
   1b9d2:	d1af      	bne.n	1b934 <coap_packet_append_option+0x7e>
   1b9d4:	e776      	b.n	1b8c4 <coap_packet_append_option+0xe>

0001b9d6 <coap_packet_parse>:
{
   1b9d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1b9da:	b086      	sub	sp, #24
   1b9dc:	4688      	mov	r8, r1
   1b9de:	4617      	mov	r7, r2
   1b9e0:	461d      	mov	r5, r3
	if (!cpkt || !data) {
   1b9e2:	4604      	mov	r4, r0
{
   1b9e4:	f89d 6030 	ldrb.w	r6, [sp, #48]	; 0x30
	if (!cpkt || !data) {
   1b9e8:	b920      	cbnz	r0, 1b9f4 <coap_packet_parse+0x1e>
		return -EINVAL;
   1b9ea:	f06f 0015 	mvn.w	r0, #21
}
   1b9ee:	b006      	add	sp, #24
   1b9f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!cpkt || !data) {
   1b9f4:	2900      	cmp	r1, #0
   1b9f6:	d0f8      	beq.n	1b9ea <coap_packet_parse+0x14>
	if (len < BASIC_HEADER_SIZE) {
   1b9f8:	2a03      	cmp	r2, #3
   1b9fa:	d9f6      	bls.n	1b9ea <coap_packet_parse+0x14>
	if (options) {
   1b9fc:	b123      	cbz	r3, 1ba08 <coap_packet_parse+0x32>
		memset(options, 0, opt_num * sizeof(struct coap_option));
   1b9fe:	2100      	movs	r1, #0
   1ba00:	4618      	mov	r0, r3
   1ba02:	0132      	lsls	r2, r6, #4
   1ba04:	f000 fb19 	bl	1c03a <memset>
	cpkt->offset = 0U;
   1ba08:	2000      	movs	r0, #0
	cpkt->data = data;
   1ba0a:	f8c4 8000 	str.w	r8, [r4]
	cpkt->offset = 0U;
   1ba0e:	80a0      	strh	r0, [r4, #4]
	cpkt->max_len = len;
   1ba10:	80e7      	strh	r7, [r4, #6]
	cpkt->opt_len = 0U;
   1ba12:	8160      	strh	r0, [r4, #10]
	cpkt->hdr_len = 0U;
   1ba14:	7220      	strb	r0, [r4, #8]
	cpkt->delta = 0U;
   1ba16:	81a0      	strh	r0, [r4, #12]
	tkl = cpkt->data[0] & 0x0f;
   1ba18:	f898 1000 	ldrb.w	r1, [r8]
   1ba1c:	f001 010f 	and.w	r1, r1, #15
	if (tkl > 8) {
   1ba20:	2908      	cmp	r1, #8
   1ba22:	d8e2      	bhi.n	1b9ea <coap_packet_parse+0x14>
	cpkt->hdr_len = BASIC_HEADER_SIZE + tkl;
   1ba24:	3104      	adds	r1, #4
	if (cpkt->hdr_len > len) {
   1ba26:	42b9      	cmp	r1, r7
	cpkt->hdr_len = BASIC_HEADER_SIZE + tkl;
   1ba28:	7221      	strb	r1, [r4, #8]
	if (cpkt->hdr_len > len) {
   1ba2a:	b28b      	uxth	r3, r1
   1ba2c:	d8dd      	bhi.n	1b9ea <coap_packet_parse+0x14>
	cpkt->offset = cpkt->hdr_len;
   1ba2e:	80a3      	strh	r3, [r4, #4]
	if (cpkt->hdr_len == len) {
   1ba30:	d0dd      	beq.n	1b9ee <coap_packet_parse+0x18>
	num = 0U;
   1ba32:	4607      	mov	r7, r0
	offset = cpkt->offset;
   1ba34:	f8ad 3014 	strh.w	r3, [sp, #20]
	opt_len = 0U;
   1ba38:	f8ad 0012 	strh.w	r0, [sp, #18]
	delta = 0U;
   1ba3c:	f8ad 0016 	strh.w	r0, [sp, #22]
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   1ba40:	f10d 0812 	add.w	r8, sp, #18
		option = num < opt_num ? &options[num++] : NULL;
   1ba44:	42b7      	cmp	r7, r6
   1ba46:	bf2c      	ite	cs
   1ba48:	2300      	movcs	r3, #0
   1ba4a:	eb05 1307 	addcc.w	r3, r5, r7, lsl #4
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   1ba4e:	e9cd 8301 	strd	r8, r3, [sp, #4]
   1ba52:	f10d 0316 	add.w	r3, sp, #22
		option = num < opt_num ? &options[num++] : NULL;
   1ba56:	bf38      	it	cc
   1ba58:	1c7a      	addcc	r2, r7, #1
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   1ba5a:	9300      	str	r3, [sp, #0]
		option = num < opt_num ? &options[num++] : NULL;
   1ba5c:	bf38      	it	cc
   1ba5e:	b2d7      	uxtbcc	r7, r2
		ret = parse_option(cpkt->data, offset, &offset, cpkt->max_len,
   1ba60:	88e3      	ldrh	r3, [r4, #6]
   1ba62:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   1ba66:	6820      	ldr	r0, [r4, #0]
   1ba68:	aa05      	add	r2, sp, #20
   1ba6a:	f7ff fe26 	bl	1b6ba <parse_option>
		if (ret < 0) {
   1ba6e:	2800      	cmp	r0, #0
   1ba70:	dbbd      	blt.n	1b9ee <coap_packet_parse+0x18>
		} else if (ret == 0) {
   1ba72:	d1e7      	bne.n	1ba44 <coap_packet_parse+0x6e>
	cpkt->opt_len = opt_len;
   1ba74:	f8bd 3012 	ldrh.w	r3, [sp, #18]
   1ba78:	8163      	strh	r3, [r4, #10]
	cpkt->delta = delta;
   1ba7a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   1ba7e:	81a3      	strh	r3, [r4, #12]
	cpkt->offset = offset;
   1ba80:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1ba84:	80a3      	strh	r3, [r4, #4]
	return 0;
   1ba86:	e7b2      	b.n	1b9ee <coap_packet_parse+0x18>

0001ba88 <coap_header_get_token>:
{
   1ba88:	b510      	push	{r4, lr}
   1ba8a:	4604      	mov	r4, r0
   1ba8c:	4608      	mov	r0, r1
	if (!cpkt || !cpkt->data) {
   1ba8e:	b14c      	cbz	r4, 1baa4 <coap_header_get_token+0x1c>
   1ba90:	6821      	ldr	r1, [r4, #0]
   1ba92:	b149      	cbz	r1, 1baa8 <coap_header_get_token+0x20>
	tkl = cpkt->data[0] & 0x0f;
   1ba94:	780c      	ldrb	r4, [r1, #0]
	if (tkl) {
   1ba96:	f014 040f 	ands.w	r4, r4, #15
   1ba9a:	d003      	beq.n	1baa4 <coap_header_get_token+0x1c>
		memcpy(token, cpkt->data + BASIC_HEADER_SIZE, tkl);
   1ba9c:	4622      	mov	r2, r4
   1ba9e:	3104      	adds	r1, #4
   1baa0:	f000 faa0 	bl	1bfe4 <memcpy>
}
   1baa4:	4620      	mov	r0, r4
   1baa6:	bd10      	pop	{r4, pc}
		return 0;
   1baa8:	460c      	mov	r4, r1
   1baaa:	e7fb      	b.n	1baa4 <coap_header_get_token+0x1c>

0001baac <coap_header_get_code>:
	if (!cpkt || !cpkt->data) {
   1baac:	b338      	cbz	r0, 1bafe <coap_header_get_code+0x52>
   1baae:	6800      	ldr	r0, [r0, #0]
   1bab0:	b328      	cbz	r0, 1bafe <coap_header_get_code+0x52>
	return cpkt->data[1];
   1bab2:	7840      	ldrb	r0, [r0, #1]
	switch (code) {
   1bab4:	288f      	cmp	r0, #143	; 0x8f
   1bab6:	d81a      	bhi.n	1baee <coap_header_get_code+0x42>
   1bab8:	0603      	lsls	r3, r0, #24
   1baba:	d406      	bmi.n	1baca <coap_header_get_code+0x1e>
   1babc:	2845      	cmp	r0, #69	; 0x45
   1babe:	d812      	bhi.n	1bae6 <coap_header_get_code+0x3a>
   1bac0:	1f43      	subs	r3, r0, #5
   1bac2:	2b3a      	cmp	r3, #58	; 0x3a
		return COAP_CODE_EMPTY;
   1bac4:	bf98      	it	ls
   1bac6:	2000      	movls	r0, #0
   1bac8:	4770      	bx	lr
   1baca:	f1a0 0380 	sub.w	r3, r0, #128	; 0x80
   1bace:	2b0f      	cmp	r3, #15
   1bad0:	d814      	bhi.n	1bafc <coap_header_get_code+0x50>
   1bad2:	e8df f003 	tbb	[pc, r3]
   1bad6:	1414      	.short	0x1414
   1bad8:	14141414 	.word	0x14141414
   1badc:	13141314 	.word	0x13141314
   1bae0:	14141313 	.word	0x14141313
   1bae4:	1413      	.short	0x1413
	switch (code) {
   1bae6:	285f      	cmp	r0, #95	; 0x5f
		return COAP_CODE_EMPTY;
   1bae8:	bf18      	it	ne
   1baea:	2000      	movne	r0, #0
   1baec:	4770      	bx	lr
	switch (code) {
   1baee:	f100 0360 	add.w	r3, r0, #96	; 0x60
   1baf2:	b2db      	uxtb	r3, r3
		return COAP_CODE_EMPTY;
   1baf4:	2b06      	cmp	r3, #6
   1baf6:	bf28      	it	cs
   1baf8:	2000      	movcs	r0, #0
   1bafa:	4770      	bx	lr
   1bafc:	2000      	movs	r0, #0
}
   1bafe:	4770      	bx	lr

0001bb00 <coap_packet_get_payload>:
{
   1bb00:	b510      	push	{r4, lr}
	if (!cpkt || !len) {
   1bb02:	b908      	cbnz	r0, 1bb08 <coap_packet_get_payload+0x8>
		return NULL;
   1bb04:	2000      	movs	r0, #0
}
   1bb06:	bd10      	pop	{r4, pc}
	if (!cpkt || !len) {
   1bb08:	2900      	cmp	r1, #0
   1bb0a:	d0fb      	beq.n	1bb04 <coap_packet_get_payload+0x4>
	payload_len = cpkt->max_len - cpkt->hdr_len - cpkt->opt_len;
   1bb0c:	7a02      	ldrb	r2, [r0, #8]
   1bb0e:	8944      	ldrh	r4, [r0, #10]
   1bb10:	88c3      	ldrh	r3, [r0, #6]
   1bb12:	4422      	add	r2, r4
   1bb14:	1a9b      	subs	r3, r3, r2
	if (payload_len > 0) {
   1bb16:	ea23 72e3 	bic.w	r2, r3, r3, asr #31
	return !(*len) ? NULL :
   1bb1a:	2b00      	cmp	r3, #0
   1bb1c:	800a      	strh	r2, [r1, #0]
   1bb1e:	ddf1      	ble.n	1bb04 <coap_packet_get_payload+0x4>
		cpkt->data + cpkt->hdr_len + cpkt->opt_len;
   1bb20:	7a03      	ldrb	r3, [r0, #8]
   1bb22:	8942      	ldrh	r2, [r0, #10]
	return !(*len) ? NULL :
   1bb24:	6800      	ldr	r0, [r0, #0]
		cpkt->data + cpkt->hdr_len + cpkt->opt_len;
   1bb26:	4413      	add	r3, r2
	return !(*len) ? NULL :
   1bb28:	4418      	add	r0, r3
   1bb2a:	e7ec      	b.n	1bb06 <coap_packet_get_payload+0x6>

0001bb2c <zsock_getaddrinfo>:
int zsock_getaddrinfo(const char *host, const char *service,
		      const struct zsock_addrinfo *hints,
		      struct zsock_addrinfo **res)
{
	if (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD)) {
		return socket_offload_getaddrinfo(host, service, hints, res);
   1bb2c:	f7f1 bf6c 	b.w	da08 <socket_offload_getaddrinfo>

0001bb30 <zsock_freeaddrinfo>:
}

void zsock_freeaddrinfo(struct zsock_addrinfo *ai)
{
	if (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD)) {
		return socket_offload_freeaddrinfo(ai);
   1bb30:	f7f1 bf74 	b.w	da1c <socket_offload_freeaddrinfo>

0001bb34 <z_errno>:
   1bb34:	f7fe b940 	b.w	19db8 <z_impl_z_errno>

0001bb38 <z_fdtable_call_ioctl>:
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
				       unsigned long request, ...)
{
   1bb38:	b40c      	push	{r2, r3}
   1bb3a:	4603      	mov	r3, r0
   1bb3c:	b507      	push	{r0, r1, r2, lr}
   1bb3e:	aa04      	add	r2, sp, #16
   1bb40:	4608      	mov	r0, r1
   1bb42:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list args;
	int res;

	va_start(args, request);
	res = vtable->ioctl(obj, request, args);
   1bb46:	689b      	ldr	r3, [r3, #8]
	va_start(args, request);
   1bb48:	9201      	str	r2, [sp, #4]
	res = vtable->ioctl(obj, request, args);
   1bb4a:	4798      	blx	r3
	va_end(args);

	return res;
}
   1bb4c:	b003      	add	sp, #12
   1bb4e:	f85d eb04 	ldr.w	lr, [sp], #4
   1bb52:	b002      	add	sp, #8
   1bb54:	4770      	bx	lr

0001bb56 <z_impl_zsock_close>:
{
   1bb56:	b537      	push	{r0, r1, r2, r4, r5, lr}
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   1bb58:	a901      	add	r1, sp, #4
{
   1bb5a:	4605      	mov	r5, r0
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   1bb5c:	f7f1 fbb8 	bl	d2d0 <z_get_fd_obj_and_vtable>
	if (ctx == NULL) {
   1bb60:	4604      	mov	r4, r0
   1bb62:	b150      	cbz	r0, 1bb7a <z_impl_zsock_close+0x24>
	z_free_fd(sock);
   1bb64:	4628      	mov	r0, r5
   1bb66:	f7f1 fbf5 	bl	d354 <z_free_fd>
	return z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_CLOSE);
   1bb6a:	f44f 7280 	mov.w	r2, #256	; 0x100
   1bb6e:	4621      	mov	r1, r4
   1bb70:	9801      	ldr	r0, [sp, #4]
   1bb72:	f7ff ffe1 	bl	1bb38 <z_fdtable_call_ioctl>
}
   1bb76:	b003      	add	sp, #12
   1bb78:	bd30      	pop	{r4, r5, pc}
		return -1;
   1bb7a:	f04f 30ff 	mov.w	r0, #4294967295
   1bb7e:	e7fa      	b.n	1bb76 <z_impl_zsock_close+0x20>

0001bb80 <z_impl_zsock_connect>:
{
   1bb80:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   1bb82:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   1bb84:	a903      	add	r1, sp, #12
{
   1bb86:	9201      	str	r2, [sp, #4]
	return z_get_fd_obj_and_vtable(sock,
   1bb88:	f7f1 fba2 	bl	d2d0 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(connect, sock, addr, addrlen);
   1bb8c:	b138      	cbz	r0, 1bb9e <z_impl_zsock_connect+0x1e>
   1bb8e:	9b03      	ldr	r3, [sp, #12]
   1bb90:	691b      	ldr	r3, [r3, #16]
   1bb92:	b123      	cbz	r3, 1bb9e <z_impl_zsock_connect+0x1e>
   1bb94:	4621      	mov	r1, r4
   1bb96:	9a01      	ldr	r2, [sp, #4]
   1bb98:	4798      	blx	r3
}
   1bb9a:	b004      	add	sp, #16
   1bb9c:	bd10      	pop	{r4, pc}
	VTABLE_CALL(connect, sock, addr, addrlen);
   1bb9e:	f04f 30ff 	mov.w	r0, #4294967295
   1bba2:	e7fa      	b.n	1bb9a <z_impl_zsock_connect+0x1a>

0001bba4 <z_impl_zsock_sendto>:
{
   1bba4:	b530      	push	{r4, r5, lr}
   1bba6:	b087      	sub	sp, #28
   1bba8:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   1bbaa:	a905      	add	r1, sp, #20
{
   1bbac:	e9cd 3202 	strd	r3, r2, [sp, #8]
	return z_get_fd_obj_and_vtable(sock,
   1bbb0:	f7f1 fb8e 	bl	d2d0 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   1bbb4:	b160      	cbz	r0, 1bbd0 <z_impl_zsock_sendto+0x2c>
   1bbb6:	9905      	ldr	r1, [sp, #20]
   1bbb8:	69cd      	ldr	r5, [r1, #28]
   1bbba:	b14d      	cbz	r5, 1bbd0 <z_impl_zsock_sendto+0x2c>
   1bbbc:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
   1bbc0:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1bbc2:	9101      	str	r1, [sp, #4]
   1bbc4:	990a      	ldr	r1, [sp, #40]	; 0x28
   1bbc6:	9100      	str	r1, [sp, #0]
   1bbc8:	4621      	mov	r1, r4
   1bbca:	47a8      	blx	r5
}
   1bbcc:	b007      	add	sp, #28
   1bbce:	bd30      	pop	{r4, r5, pc}
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   1bbd0:	f04f 30ff 	mov.w	r0, #4294967295
   1bbd4:	e7fa      	b.n	1bbcc <z_impl_zsock_sendto+0x28>

0001bbd6 <z_impl_zsock_recvfrom>:
{
   1bbd6:	b530      	push	{r4, r5, lr}
   1bbd8:	b087      	sub	sp, #28
   1bbda:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   1bbdc:	a905      	add	r1, sp, #20
{
   1bbde:	e9cd 3202 	strd	r3, r2, [sp, #8]
	return z_get_fd_obj_and_vtable(sock,
   1bbe2:	f7f1 fb75 	bl	d2d0 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   1bbe6:	b160      	cbz	r0, 1bc02 <z_impl_zsock_recvfrom+0x2c>
   1bbe8:	9905      	ldr	r1, [sp, #20]
   1bbea:	6a0d      	ldr	r5, [r1, #32]
   1bbec:	b14d      	cbz	r5, 1bc02 <z_impl_zsock_recvfrom+0x2c>
   1bbee:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
   1bbf2:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1bbf4:	9101      	str	r1, [sp, #4]
   1bbf6:	990a      	ldr	r1, [sp, #40]	; 0x28
   1bbf8:	9100      	str	r1, [sp, #0]
   1bbfa:	4621      	mov	r1, r4
   1bbfc:	47a8      	blx	r5
}
   1bbfe:	b007      	add	sp, #28
   1bc00:	bd30      	pop	{r4, r5, pc}
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   1bc02:	f04f 30ff 	mov.w	r0, #4294967295
   1bc06:	e7fa      	b.n	1bbfe <z_impl_zsock_recvfrom+0x28>

0001bc08 <get_status>:
	if (data->started) {
   1bc08:	220c      	movs	r2, #12
	data = get_sub_data(dev, type);
   1bc0a:	68c3      	ldr	r3, [r0, #12]
	return &data->subsys[type];
   1bc0c:	b2c9      	uxtb	r1, r1
	if (data->started) {
   1bc0e:	fb02 3101 	mla	r1, r2, r1, r3
   1bc12:	7a4b      	ldrb	r3, [r1, #9]
   1bc14:	b923      	cbnz	r3, 1bc20 <get_status+0x18>
	if (data->ref > 0) {
   1bc16:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   1bc18:	fab0 f080 	clz	r0, r0
   1bc1c:	0940      	lsrs	r0, r0, #5
   1bc1e:	4770      	bx	lr
   1bc20:	2002      	movs	r0, #2
}
   1bc22:	4770      	bx	lr

0001bc24 <clock_stop>:
{
   1bc24:	b570      	push	{r4, r5, r6, lr}
   1bc26:	b2c9      	uxtb	r1, r1
	config = get_sub_config(dev, type);
   1bc28:	6844      	ldr	r4, [r0, #4]
	data = get_sub_data(dev, type);
   1bc2a:	68c5      	ldr	r5, [r0, #12]
	__asm__ volatile(
   1bc2c:	f04f 0320 	mov.w	r3, #32
   1bc30:	f3ef 8611 	mrs	r6, BASEPRI
   1bc34:	f383 8811 	msr	BASEPRI, r3
   1bc38:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   1bc3c:	230c      	movs	r3, #12
   1bc3e:	434b      	muls	r3, r1
   1bc40:	18ea      	adds	r2, r5, r3
   1bc42:	7a10      	ldrb	r0, [r2, #8]
   1bc44:	b1a0      	cbz	r0, 1bc70 <clock_stop+0x4c>
	data->ref--;
   1bc46:	3801      	subs	r0, #1
   1bc48:	b2c0      	uxtb	r0, r0
   1bc4a:	7210      	strb	r0, [r2, #8]
	if (data->ref == 0) {
   1bc4c:	b998      	cbnz	r0, 1bc76 <clock_stop+0x52>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   1bc4e:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	list->head = NULL;
   1bc52:	50e8      	str	r0, [r5, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1bc54:	78cb      	ldrb	r3, [r1, #3]
   1bc56:	2101      	movs	r1, #1
   1bc58:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1bc5c:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
	list->tail = NULL;
   1bc60:	6050      	str	r0, [r2, #4]
   1bc62:	6019      	str	r1, [r3, #0]
		data->started = false;
   1bc64:	7250      	strb	r0, [r2, #9]
	__asm__ volatile(
   1bc66:	f386 8811 	msr	BASEPRI, r6
   1bc6a:	f3bf 8f6f 	isb	sy
}
   1bc6e:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
   1bc70:	f06f 0044 	mvn.w	r0, #68	; 0x44
   1bc74:	e7f7      	b.n	1bc66 <clock_stop+0x42>
	int err = 0;
   1bc76:	2000      	movs	r0, #0
   1bc78:	e7f5      	b.n	1bc66 <clock_stop+0x42>

0001bc7a <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   1bc7a:	2200      	movs	r2, #0
   1bc7c:	f7f1 befc 	b.w	da78 <clock_async_start>

0001bc80 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   1bc80:	4770      	bx	lr

0001bc82 <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   1bc82:	4770      	bx	lr

0001bc84 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   1bc84:	2100      	movs	r1, #0
   1bc86:	2001      	movs	r0, #1
   1bc88:	f000 b800 	b.w	1bc8c <z_arm_fatal_error>

0001bc8c <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   1bc8c:	f001 ba3e 	b.w	1d10c <z_fatal_error>

0001bc90 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   1bc90:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   1bc92:	6800      	ldr	r0, [r0, #0]
   1bc94:	f001 ba3a 	b.w	1d10c <z_fatal_error>

0001bc98 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   1bc98:	b508      	push	{r3, lr}
	handler();
   1bc9a:	f7f2 f9e9 	bl	e070 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   1bc9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   1bca2:	f7f2 ba2b 	b.w	e0fc <z_arm_exc_exit>

0001bca6 <mpu_configure_region>:
{
   1bca6:	b530      	push	{r4, r5, lr}
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   1bca8:	684b      	ldr	r3, [r1, #4]
	region_conf.base = new_region->start;
   1bcaa:	680c      	ldr	r4, [r1, #0]
{
   1bcac:	b085      	sub	sp, #20
	p_attr->rbar = attr->rbar &
   1bcae:	890a      	ldrh	r2, [r1, #8]
   1bcb0:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
   1bcb2:	9400      	str	r4, [sp, #0]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1bcb4:	3b01      	subs	r3, #1
   1bcb6:	f024 041f 	bic.w	r4, r4, #31
   1bcba:	4423      	add	r3, r4
	p_attr->rbar = attr->rbar &
   1bcbc:	f002 021f 	and.w	r2, r2, #31
   1bcc0:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1bcc4:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
   1bcc8:	280f      	cmp	r0, #15
   1bcca:	4604      	mov	r4, r0
	p_attr->rbar = attr->rbar &
   1bccc:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   1bcd0:	9303      	str	r3, [sp, #12]
   1bcd2:	d805      	bhi.n	1bce0 <mpu_configure_region+0x3a>
	region_init(index, region_conf);
   1bcd4:	4669      	mov	r1, sp
   1bcd6:	f7f2 fb5d 	bl	e394 <region_init>
}
   1bcda:	4620      	mov	r0, r4
   1bcdc:	b005      	add	sp, #20
   1bcde:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
   1bce0:	f06f 0415 	mvn.w	r4, #21
	return region_allocate_and_init(index,
   1bce4:	e7f9      	b.n	1bcda <mpu_configure_region+0x34>

0001bce6 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   1bce6:	e840 f000 	tt	r0, r0
   1bcea:	b2c3      	uxtb	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   1bcec:	f410 3f80 	tst.w	r0, #65536	; 0x10000
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   1bcf0:	bf14      	ite	ne
   1bcf2:	4618      	movne	r0, r3
   1bcf4:	f06f 0015 	mvneq.w	r0, #21
   1bcf8:	4770      	bx	lr

0001bcfa <atoi>:

#include <stdlib.h>
#include <ctype.h>

int atoi(const char *s)
{
   1bcfa:	b530      	push	{r4, r5, lr}
	int n = 0;
	int neg = 0;

	while (isspace(*s)) {
   1bcfc:	7802      	ldrb	r2, [r0, #0]
   1bcfe:	4603      	mov	r3, r0
   1bd00:	2a20      	cmp	r2, #32
   1bd02:	f100 0001 	add.w	r0, r0, #1
   1bd06:	d0f9      	beq.n	1bcfc <atoi+0x2>
   1bd08:	f1a2 0109 	sub.w	r1, r2, #9
   1bd0c:	2904      	cmp	r1, #4
   1bd0e:	d9f5      	bls.n	1bcfc <atoi+0x2>
		s++;
	}
	switch (*s) {
   1bd10:	2a2b      	cmp	r2, #43	; 0x2b
   1bd12:	d008      	beq.n	1bd26 <atoi+0x2c>
	case '-':
		neg = 1;
		s++;
   1bd14:	2a2d      	cmp	r2, #45	; 0x2d
   1bd16:	bf0a      	itet	eq
   1bd18:	4603      	moveq	r3, r0
   1bd1a:	2100      	movne	r1, #0
   1bd1c:	2101      	moveq	r1, #1
	switch (*s) {
   1bd1e:	2000      	movs	r0, #0
	case '+':
		s++;
	}
	/* Compute n as a negative number to avoid overflow on INT_MIN */
	while (isdigit(*s)) {
		n = 10*n - (*s++ - '0');
   1bd20:	250a      	movs	r5, #10
   1bd22:	3b01      	subs	r3, #1
   1bd24:	e006      	b.n	1bd34 <atoi+0x3a>
		s++;
   1bd26:	4603      	mov	r3, r0
	int neg = 0;
   1bd28:	2100      	movs	r1, #0
   1bd2a:	e7f8      	b.n	1bd1e <atoi+0x24>
		n = 10*n - (*s++ - '0');
   1bd2c:	f1c2 0230 	rsb	r2, r2, #48	; 0x30
   1bd30:	fb05 2000 	mla	r0, r5, r0, r2
	while (isdigit(*s)) {
   1bd34:	f813 2f01 	ldrb.w	r2, [r3, #1]!
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1bd38:	f1a2 0430 	sub.w	r4, r2, #48	; 0x30
   1bd3c:	2c09      	cmp	r4, #9
   1bd3e:	d9f5      	bls.n	1bd2c <atoi+0x32>
	}
	return neg ? n : -n;
   1bd40:	b901      	cbnz	r1, 1bd44 <atoi+0x4a>
   1bd42:	4240      	negs	r0, r0
}
   1bd44:	bd30      	pop	{r4, r5, pc}

0001bd46 <strtol>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
long strtol(const char *nptr, char **endptr, register int base)
{
   1bd46:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1bd4a:	4684      	mov	ip, r0
   1bd4c:	4688      	mov	r8, r1
	register const char *s = nptr;
   1bd4e:	4601      	mov	r1, r0
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
   1bd50:	460c      	mov	r4, r1
   1bd52:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   1bd56:	2b20      	cmp	r3, #32
   1bd58:	d033      	beq.n	1bdc2 <strtol+0x7c>
   1bd5a:	f1a3 0009 	sub.w	r0, r3, #9
   1bd5e:	2804      	cmp	r0, #4
   1bd60:	d92f      	bls.n	1bdc2 <strtol+0x7c>
	} while (isspace(c));
	if (c == '-') {
   1bd62:	2b2d      	cmp	r3, #45	; 0x2d
   1bd64:	d12f      	bne.n	1bdc6 <strtol+0x80>
		neg = 1;
		c = *s++;
   1bd66:	784b      	ldrb	r3, [r1, #1]
   1bd68:	1c8c      	adds	r4, r1, #2
		neg = 1;
   1bd6a:	2101      	movs	r1, #1
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   1bd6c:	2a00      	cmp	r2, #0
   1bd6e:	d05c      	beq.n	1be2a <strtol+0xe4>
   1bd70:	2a10      	cmp	r2, #16
   1bd72:	d109      	bne.n	1bd88 <strtol+0x42>
   1bd74:	2b30      	cmp	r3, #48	; 0x30
   1bd76:	d107      	bne.n	1bd88 <strtol+0x42>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   1bd78:	7823      	ldrb	r3, [r4, #0]
   1bd7a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   1bd7e:	2b58      	cmp	r3, #88	; 0x58
   1bd80:	d14e      	bne.n	1be20 <strtol+0xda>
		c = s[1];
		s += 2;
		base = 16;
   1bd82:	2210      	movs	r2, #16
		c = s[1];
   1bd84:	7863      	ldrb	r3, [r4, #1]
		s += 2;
   1bd86:	3402      	adds	r4, #2
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   1bd88:	2600      	movs	r6, #0
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
   1bd8a:	f101 4700 	add.w	r7, r1, #2147483648	; 0x80000000
   1bd8e:	3f01      	subs	r7, #1
	cutlim = cutoff % (unsigned long)base;
   1bd90:	fbb7 fef2 	udiv	lr, r7, r2
	for (acc = 0, any = 0;; c = *s++) {
   1bd94:	4630      	mov	r0, r6
	cutlim = cutoff % (unsigned long)base;
   1bd96:	fb02 791e 	mls	r9, r2, lr, r7
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1bd9a:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   1bd9e:	2d09      	cmp	r5, #9
   1bda0:	d817      	bhi.n	1bdd2 <strtol+0x8c>
			c -= '0';
   1bda2:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   1bda4:	429a      	cmp	r2, r3
   1bda6:	dd24      	ble.n	1bdf2 <strtol+0xac>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   1bda8:	1c75      	adds	r5, r6, #1
   1bdaa:	d007      	beq.n	1bdbc <strtol+0x76>
   1bdac:	4570      	cmp	r0, lr
   1bdae:	d81d      	bhi.n	1bdec <strtol+0xa6>
   1bdb0:	d101      	bne.n	1bdb6 <strtol+0x70>
   1bdb2:	454b      	cmp	r3, r9
   1bdb4:	dc1a      	bgt.n	1bdec <strtol+0xa6>
			any = -1;
		} else {
			any = 1;
   1bdb6:	2601      	movs	r6, #1
			acc *= base;
			acc += c;
   1bdb8:	fb00 3002 	mla	r0, r0, r2, r3
	for (acc = 0, any = 0;; c = *s++) {
   1bdbc:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   1bdc0:	e7eb      	b.n	1bd9a <strtol+0x54>
{
   1bdc2:	4621      	mov	r1, r4
   1bdc4:	e7c4      	b.n	1bd50 <strtol+0xa>
	} else if (c == '+') {
   1bdc6:	2b2b      	cmp	r3, #43	; 0x2b
		c = *s++;
   1bdc8:	bf04      	itt	eq
   1bdca:	784b      	ldrbeq	r3, [r1, #1]
   1bdcc:	1c8c      	addeq	r4, r1, #2
	register int neg = 0, any, cutlim;
   1bdce:	2100      	movs	r1, #0
   1bdd0:	e7cc      	b.n	1bd6c <strtol+0x26>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   1bdd2:	f043 0520 	orr.w	r5, r3, #32
   1bdd6:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   1bdd8:	2d19      	cmp	r5, #25
   1bdda:	d80a      	bhi.n	1bdf2 <strtol+0xac>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   1bddc:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   1bde0:	2d1a      	cmp	r5, #26
   1bde2:	bf34      	ite	cc
   1bde4:	2537      	movcc	r5, #55	; 0x37
   1bde6:	2557      	movcs	r5, #87	; 0x57
   1bde8:	1b5b      	subs	r3, r3, r5
   1bdea:	e7db      	b.n	1bda4 <strtol+0x5e>
			any = -1;
   1bdec:	f04f 36ff 	mov.w	r6, #4294967295
   1bdf0:	e7e4      	b.n	1bdbc <strtol+0x76>
		}
	}

	if (any < 0) {
   1bdf2:	1c73      	adds	r3, r6, #1
   1bdf4:	d109      	bne.n	1be0a <strtol+0xc4>
   1bdf6:	f7fd ffdf 	bl	19db8 <z_impl_z_errno>
		acc = neg ? LONG_MIN : LONG_MAX;
		errno = ERANGE;
   1bdfa:	2326      	movs	r3, #38	; 0x26
   1bdfc:	6003      	str	r3, [r0, #0]
		acc = neg ? LONG_MIN : LONG_MAX;
   1bdfe:	4638      	mov	r0, r7
	} else if (neg) {
		acc = -acc;
	}

	if (endptr != NULL) {
   1be00:	f1b8 0f00 	cmp.w	r8, #0
   1be04:	d107      	bne.n	1be16 <strtol+0xd0>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   1be06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (neg) {
   1be0a:	b101      	cbz	r1, 1be0e <strtol+0xc8>
		acc = -acc;
   1be0c:	4240      	negs	r0, r0
	if (endptr != NULL) {
   1be0e:	f1b8 0f00 	cmp.w	r8, #0
   1be12:	d0f8      	beq.n	1be06 <strtol+0xc0>
		*endptr = (char *)(any ? s - 1 : nptr);
   1be14:	b10e      	cbz	r6, 1be1a <strtol+0xd4>
   1be16:	f104 3cff 	add.w	ip, r4, #4294967295
   1be1a:	f8c8 c000 	str.w	ip, [r8]
	return acc;
   1be1e:	e7f2      	b.n	1be06 <strtol+0xc0>
	if (base == 0) {
   1be20:	2330      	movs	r3, #48	; 0x30
   1be22:	2a00      	cmp	r2, #0
   1be24:	d1b0      	bne.n	1bd88 <strtol+0x42>
		base = c == '0' ? 8 : 10;
   1be26:	2208      	movs	r2, #8
   1be28:	e7ae      	b.n	1bd88 <strtol+0x42>
	if ((base == 0 || base == 16) &&
   1be2a:	2b30      	cmp	r3, #48	; 0x30
   1be2c:	d0a4      	beq.n	1bd78 <strtol+0x32>
		base = c == '0' ? 8 : 10;
   1be2e:	220a      	movs	r2, #10
   1be30:	e7aa      	b.n	1bd88 <strtol+0x42>

0001be32 <strtoul>:
 *
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 */
unsigned long strtoul(const char *nptr, char **endptr, register int base)
{
   1be32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1be36:	4684      	mov	ip, r0
   1be38:	460f      	mov	r7, r1
	register const char *s = nptr;
   1be3a:	4605      	mov	r5, r0

	/*
	 * See strtol for comments as to the logic used.
	 */
	do {
		c = *s++;
   1be3c:	462c      	mov	r4, r5
   1be3e:	f814 3b01 	ldrb.w	r3, [r4], #1
	return (int)(c == (int)' ' || ((unsigned)c-(unsigned)'\t') < 5U);
   1be42:	2b20      	cmp	r3, #32
   1be44:	d035      	beq.n	1beb2 <strtoul+0x80>
   1be46:	f1a3 0109 	sub.w	r1, r3, #9
   1be4a:	2904      	cmp	r1, #4
   1be4c:	d931      	bls.n	1beb2 <strtoul+0x80>
	} while (isspace(c));
	if (c == '-') {
   1be4e:	2b2d      	cmp	r3, #45	; 0x2d
   1be50:	d131      	bne.n	1beb6 <strtoul+0x84>
		neg = 1;
   1be52:	f04f 0e01 	mov.w	lr, #1
		c = *s++;
   1be56:	786b      	ldrb	r3, [r5, #1]
   1be58:	1cac      	adds	r4, r5, #2
	} else if (c == '+') {
		c = *s++;
	}

	if ((base == 0 || base == 16) &&
   1be5a:	2a00      	cmp	r2, #0
   1be5c:	d05e      	beq.n	1bf1c <strtoul+0xea>
   1be5e:	2a10      	cmp	r2, #16
   1be60:	d109      	bne.n	1be76 <strtoul+0x44>
   1be62:	2b30      	cmp	r3, #48	; 0x30
   1be64:	d107      	bne.n	1be76 <strtoul+0x44>
	    c == '0' && (*s == 'x' || *s == 'X')) {
   1be66:	7823      	ldrb	r3, [r4, #0]
   1be68:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   1be6c:	2b58      	cmp	r3, #88	; 0x58
   1be6e:	d150      	bne.n	1bf12 <strtoul+0xe0>
		c = s[1];
		s += 2;
		base = 16;
   1be70:	2210      	movs	r2, #16
		c = s[1];
   1be72:	7863      	ldrb	r3, [r4, #1]
		s += 2;
   1be74:	3402      	adds	r4, #2

	if (base == 0) {
		base = c == '0' ? 8 : 10;
	}

	cutoff = (unsigned long)ULONG_MAX / (unsigned long)base;
   1be76:	f04f 31ff 	mov.w	r1, #4294967295
   1be7a:	fbb1 f1f2 	udiv	r1, r1, r2
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
   1be7e:	2600      	movs	r6, #0
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
   1be80:	fb02 f801 	mul.w	r8, r2, r1
	for (acc = 0, any = 0;; c = *s++) {
   1be84:	4630      	mov	r0, r6
	cutlim = (unsigned long)ULONG_MAX % (unsigned long)base;
   1be86:	ea6f 0808 	mvn.w	r8, r8
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
   1be8a:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
		if (isdigit(c)) {
   1be8e:	2d09      	cmp	r5, #9
   1be90:	d818      	bhi.n	1bec4 <strtoul+0x92>
			c -= '0';
   1be92:	462b      	mov	r3, r5
		} else if (isalpha(c)) {
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		} else {
			break;
		}
		if (c >= base) {
   1be94:	429a      	cmp	r2, r3
   1be96:	dd25      	ble.n	1bee4 <strtoul+0xb2>
			break;
		}
		if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim)) {
   1be98:	2e00      	cmp	r6, #0
   1be9a:	db20      	blt.n	1bede <strtoul+0xac>
   1be9c:	4288      	cmp	r0, r1
   1be9e:	d81e      	bhi.n	1bede <strtoul+0xac>
   1bea0:	d101      	bne.n	1bea6 <strtoul+0x74>
   1bea2:	4543      	cmp	r3, r8
   1bea4:	dc1b      	bgt.n	1bede <strtoul+0xac>
			any = -1;
		} else {
			any = 1;
   1bea6:	2601      	movs	r6, #1
			acc *= base;
			acc += c;
   1bea8:	fb00 3002 	mla	r0, r0, r2, r3
	for (acc = 0, any = 0;; c = *s++) {
   1beac:	f814 3b01 	ldrb.w	r3, [r4], #1
		if (isdigit(c)) {
   1beb0:	e7eb      	b.n	1be8a <strtoul+0x58>
{
   1beb2:	4625      	mov	r5, r4
   1beb4:	e7c2      	b.n	1be3c <strtoul+0xa>
	} else if (c == '+') {
   1beb6:	2b2b      	cmp	r3, #43	; 0x2b
	register int neg = 0, any, cutlim;
   1beb8:	f04f 0e00 	mov.w	lr, #0
		c = *s++;
   1bebc:	bf04      	itt	eq
   1bebe:	786b      	ldrbeq	r3, [r5, #1]
   1bec0:	1cac      	addeq	r4, r5, #2
   1bec2:	e7ca      	b.n	1be5a <strtoul+0x28>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
   1bec4:	f043 0520 	orr.w	r5, r3, #32
   1bec8:	3d61      	subs	r5, #97	; 0x61
		} else if (isalpha(c)) {
   1beca:	2d19      	cmp	r5, #25
   1becc:	d80a      	bhi.n	1bee4 <strtoul+0xb2>
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   1bece:	f1a3 0541 	sub.w	r5, r3, #65	; 0x41
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
   1bed2:	2d1a      	cmp	r5, #26
   1bed4:	bf34      	ite	cc
   1bed6:	2537      	movcc	r5, #55	; 0x37
   1bed8:	2557      	movcs	r5, #87	; 0x57
   1beda:	1b5b      	subs	r3, r3, r5
   1bedc:	e7da      	b.n	1be94 <strtoul+0x62>
			any = -1;
   1bede:	f04f 36ff 	mov.w	r6, #4294967295
   1bee2:	e7e3      	b.n	1beac <strtoul+0x7a>
		}
	}
	if (any < 0) {
   1bee4:	2e00      	cmp	r6, #0
   1bee6:	da08      	bge.n	1befa <strtoul+0xc8>
   1bee8:	f7fd ff66 	bl	19db8 <z_impl_z_errno>
		acc = ULONG_MAX;
		errno = ERANGE;
   1beec:	2326      	movs	r3, #38	; 0x26
   1beee:	6003      	str	r3, [r0, #0]
		acc = ULONG_MAX;
   1bef0:	f04f 30ff 	mov.w	r0, #4294967295
	} else if (neg) {
		acc = -acc;
	}
	if (endptr != NULL) {
   1bef4:	b947      	cbnz	r7, 1bf08 <strtoul+0xd6>
		*endptr = (char *)(any ? s - 1 : nptr);
	}
	return acc;
}
   1bef6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (neg) {
   1befa:	f1be 0f00 	cmp.w	lr, #0
   1befe:	d000      	beq.n	1bf02 <strtoul+0xd0>
		acc = -acc;
   1bf00:	4240      	negs	r0, r0
	if (endptr != NULL) {
   1bf02:	2f00      	cmp	r7, #0
   1bf04:	d0f7      	beq.n	1bef6 <strtoul+0xc4>
		*endptr = (char *)(any ? s - 1 : nptr);
   1bf06:	b10e      	cbz	r6, 1bf0c <strtoul+0xda>
   1bf08:	f104 3cff 	add.w	ip, r4, #4294967295
   1bf0c:	f8c7 c000 	str.w	ip, [r7]
	return acc;
   1bf10:	e7f1      	b.n	1bef6 <strtoul+0xc4>
	if (base == 0) {
   1bf12:	2330      	movs	r3, #48	; 0x30
   1bf14:	2a00      	cmp	r2, #0
   1bf16:	d1ae      	bne.n	1be76 <strtoul+0x44>
		base = c == '0' ? 8 : 10;
   1bf18:	2208      	movs	r2, #8
   1bf1a:	e7ac      	b.n	1be76 <strtoul+0x44>
	if ((base == 0 || base == 16) &&
   1bf1c:	2b30      	cmp	r3, #48	; 0x30
   1bf1e:	d0a2      	beq.n	1be66 <strtoul+0x34>
		base = c == '0' ? 8 : 10;
   1bf20:	220a      	movs	r2, #10
   1bf22:	e7a8      	b.n	1be76 <strtoul+0x44>

0001bf24 <strstr>:
/*
 * Find the first occurrence of find in s.
 */
char *
strstr(const char *s, const char *find)
{
   1bf24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	char c, sc;
	size_t len;

	c = *find++;
   1bf28:	f891 8000 	ldrb.w	r8, [r1]
{
   1bf2c:	4605      	mov	r5, r0
	if (c != 0) {
   1bf2e:	f1b8 0f00 	cmp.w	r8, #0
   1bf32:	d010      	beq.n	1bf56 <strstr+0x32>
	c = *find++;
   1bf34:	1c4c      	adds	r4, r1, #1
		len = strlen(find);
   1bf36:	4620      	mov	r0, r4
   1bf38:	f000 f822 	bl	1bf80 <strlen>
   1bf3c:	4607      	mov	r7, r0
		do {
			do {
				sc = *s++;
   1bf3e:	462e      	mov	r6, r5
   1bf40:	f816 3b01 	ldrb.w	r3, [r6], #1
				if (sc == 0) {
   1bf44:	b163      	cbz	r3, 1bf60 <strstr+0x3c>
					return NULL;
				}
			} while (sc != c);
   1bf46:	4598      	cmp	r8, r3
   1bf48:	d108      	bne.n	1bf5c <strstr+0x38>
		} while (strncmp(s, find, len) != 0);
   1bf4a:	463a      	mov	r2, r7
   1bf4c:	4621      	mov	r1, r4
   1bf4e:	4630      	mov	r0, r6
   1bf50:	f000 f829 	bl	1bfa6 <strncmp>
   1bf54:	b910      	cbnz	r0, 1bf5c <strstr+0x38>
	s--;
	}
	return (char *)s;
}
   1bf56:	4628      	mov	r0, r5
   1bf58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
   1bf5c:	4635      	mov	r5, r6
   1bf5e:	e7ee      	b.n	1bf3e <strstr+0x1a>
					return NULL;
   1bf60:	461d      	mov	r5, r3
   1bf62:	e7f8      	b.n	1bf56 <strstr+0x32>

0001bf64 <strchr>:
 * @return pointer to 1st instance of found byte, or NULL if not found
 */

char *strchr(const char *s, int c)
{
	char tmp = (char) c;
   1bf64:	4603      	mov	r3, r0
   1bf66:	b2c9      	uxtb	r1, r1

	while ((*s != tmp) && (*s != '\0')) {
   1bf68:	781a      	ldrb	r2, [r3, #0]
   1bf6a:	4618      	mov	r0, r3
   1bf6c:	428a      	cmp	r2, r1
   1bf6e:	f103 0301 	add.w	r3, r3, #1
   1bf72:	d004      	beq.n	1bf7e <strchr+0x1a>
   1bf74:	2a00      	cmp	r2, #0
   1bf76:	d1f7      	bne.n	1bf68 <strchr+0x4>
		s++;
	}

	return (*s == tmp) ? (char *) s : NULL;
   1bf78:	2900      	cmp	r1, #0
   1bf7a:	bf18      	it	ne
   1bf7c:	2000      	movne	r0, #0
}
   1bf7e:	4770      	bx	lr

0001bf80 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   1bf80:	4603      	mov	r3, r0
	size_t n = 0;
   1bf82:	2000      	movs	r0, #0

	while (*s != '\0') {
   1bf84:	5c1a      	ldrb	r2, [r3, r0]
   1bf86:	b902      	cbnz	r2, 1bf8a <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   1bf88:	4770      	bx	lr
		n++;
   1bf8a:	3001      	adds	r0, #1
   1bf8c:	e7fa      	b.n	1bf84 <strlen+0x4>

0001bf8e <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   1bf8e:	3801      	subs	r0, #1
   1bf90:	3901      	subs	r1, #1
   1bf92:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   1bf96:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   1bf9a:	4293      	cmp	r3, r2
   1bf9c:	d101      	bne.n	1bfa2 <strcmp+0x14>
   1bf9e:	2b00      	cmp	r3, #0
   1bfa0:	d1f7      	bne.n	1bf92 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   1bfa2:	1a98      	subs	r0, r3, r2
   1bfa4:	4770      	bx	lr

0001bfa6 <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
   1bfa6:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
   1bfa8:	2400      	movs	r4, #0
   1bfaa:	42a2      	cmp	r2, r4
   1bfac:	d008      	beq.n	1bfc0 <strncmp+0x1a>
   1bfae:	5d03      	ldrb	r3, [r0, r4]
   1bfb0:	5d0d      	ldrb	r5, [r1, r4]
   1bfb2:	42ab      	cmp	r3, r5
   1bfb4:	d102      	bne.n	1bfbc <strncmp+0x16>
   1bfb6:	3401      	adds	r4, #1
   1bfb8:	2b00      	cmp	r3, #0
   1bfba:	d1f6      	bne.n	1bfaa <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
   1bfbc:	1b58      	subs	r0, r3, r5
   1bfbe:	e000      	b.n	1bfc2 <strncmp+0x1c>
   1bfc0:	2000      	movs	r0, #0
}
   1bfc2:	bd30      	pop	{r4, r5, pc}

0001bfc4 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
   1bfc4:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
   1bfc6:	b15a      	cbz	r2, 1bfe0 <memcmp+0x1c>
   1bfc8:	3901      	subs	r1, #1
   1bfca:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
   1bfcc:	f810 2b01 	ldrb.w	r2, [r0], #1
   1bfd0:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1bfd4:	42a0      	cmp	r0, r4
   1bfd6:	d001      	beq.n	1bfdc <memcmp+0x18>
   1bfd8:	429a      	cmp	r2, r3
   1bfda:	d0f7      	beq.n	1bfcc <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
   1bfdc:	1ad0      	subs	r0, r2, r3
}
   1bfde:	bd10      	pop	{r4, pc}
		return 0;
   1bfe0:	4610      	mov	r0, r2
   1bfe2:	e7fc      	b.n	1bfde <memcmp+0x1a>

0001bfe4 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   1bfe4:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   1bfe6:	ea81 0400 	eor.w	r4, r1, r0
   1bfea:	07a5      	lsls	r5, r4, #30
   1bfec:	4603      	mov	r3, r0
   1bfee:	d00b      	beq.n	1c008 <memcpy+0x24>
   1bff0:	3b01      	subs	r3, #1
   1bff2:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   1bff4:	4291      	cmp	r1, r2
   1bff6:	d11b      	bne.n	1c030 <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   1bff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   1bffa:	2a00      	cmp	r2, #0
   1bffc:	d0fc      	beq.n	1bff8 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   1bffe:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
   1c002:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
   1c004:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
   1c008:	079c      	lsls	r4, r3, #30
   1c00a:	d1f6      	bne.n	1bffa <memcpy+0x16>
   1c00c:	f022 0403 	bic.w	r4, r2, #3
   1c010:	1f1d      	subs	r5, r3, #4
   1c012:	0896      	lsrs	r6, r2, #2
   1c014:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   1c016:	42b9      	cmp	r1, r7
   1c018:	d105      	bne.n	1c026 <memcpy+0x42>
   1c01a:	f06f 0503 	mvn.w	r5, #3
   1c01e:	4423      	add	r3, r4
   1c020:	fb05 2206 	mla	r2, r5, r6, r2
   1c024:	e7e4      	b.n	1bff0 <memcpy+0xc>
			*(d_word++) = *(s_word++);
   1c026:	f851 cb04 	ldr.w	ip, [r1], #4
   1c02a:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
   1c02e:	e7f2      	b.n	1c016 <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
   1c030:	f811 4b01 	ldrb.w	r4, [r1], #1
   1c034:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   1c038:	e7dc      	b.n	1bff4 <memcpy+0x10>

0001c03a <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   1c03a:	4603      	mov	r3, r0
{
   1c03c:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
   1c03e:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   1c040:	079c      	lsls	r4, r3, #30
   1c042:	d111      	bne.n	1c068 <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   1c044:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   1c048:	f022 0603 	bic.w	r6, r2, #3
   1c04c:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   1c050:	441e      	add	r6, r3
   1c052:	0894      	lsrs	r4, r2, #2
   1c054:	42b3      	cmp	r3, r6
   1c056:	d10d      	bne.n	1c074 <memset+0x3a>
   1c058:	f06f 0503 	mvn.w	r5, #3
   1c05c:	fb05 2204 	mla	r2, r5, r4, r2
   1c060:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   1c062:	4293      	cmp	r3, r2
   1c064:	d109      	bne.n	1c07a <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   1c066:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   1c068:	2a00      	cmp	r2, #0
   1c06a:	d0fc      	beq.n	1c066 <memset+0x2c>
		*(d_byte++) = c_byte;
   1c06c:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1c070:	3a01      	subs	r2, #1
   1c072:	e7e5      	b.n	1c040 <memset+0x6>
		*(d_word++) = c_word;
   1c074:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   1c078:	e7ec      	b.n	1c054 <memset+0x1a>
		*(d_byte++) = c_byte;
   1c07a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1c07e:	e7f0      	b.n	1c062 <memset+0x28>

0001c080 <_to_x>:
{
   1c080:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c082:	4603      	mov	r3, r0
   1c084:	4604      	mov	r4, r0
		unsigned int d = n % base;
   1c086:	fbb1 f0f2 	udiv	r0, r1, r2
   1c08a:	fb02 1510 	mls	r5, r2, r0, r1
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   1c08e:	2d09      	cmp	r5, #9
   1c090:	460f      	mov	r7, r1
   1c092:	bf8c      	ite	hi
   1c094:	2627      	movhi	r6, #39	; 0x27
   1c096:	2600      	movls	r6, #0
		n /= base;
   1c098:	4601      	mov	r1, r0
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   1c09a:	4620      	mov	r0, r4
   1c09c:	3530      	adds	r5, #48	; 0x30
   1c09e:	4435      	add	r5, r6
	} while (n);
   1c0a0:	4297      	cmp	r7, r2
		*buf++ = '0' + d + (d > 9 ? ('a' - '0' - 10) : 0);
   1c0a2:	f800 5b01 	strb.w	r5, [r0], #1
	} while (n);
   1c0a6:	d206      	bcs.n	1c0b6 <_to_x+0x36>
	*buf = 0;
   1c0a8:	2200      	movs	r2, #0
   1c0aa:	7002      	strb	r2, [r0, #0]
	len = buf - start;
   1c0ac:	4622      	mov	r2, r4
   1c0ae:	1ac0      	subs	r0, r0, r3
	for (buf--; buf > start; buf--, start++) {
   1c0b0:	429a      	cmp	r2, r3
   1c0b2:	d802      	bhi.n	1c0ba <_to_x+0x3a>
}
   1c0b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1c0b6:	4604      	mov	r4, r0
   1c0b8:	e7e5      	b.n	1c086 <_to_x+0x6>
		char tmp = *buf;
   1c0ba:	7811      	ldrb	r1, [r2, #0]
		*buf = *start;
   1c0bc:	781c      	ldrb	r4, [r3, #0]
   1c0be:	f802 4901 	strb.w	r4, [r2], #-1
		*start = tmp;
   1c0c2:	f803 1b01 	strb.w	r1, [r3], #1
	for (buf--; buf > start; buf--, start++) {
   1c0c6:	e7f3      	b.n	1c0b0 <_to_x+0x30>

0001c0c8 <_rlrshift>:
	*v = (*v & 1) + (*v >> 1);
   1c0c8:	2100      	movs	r1, #0
{
   1c0ca:	b570      	push	{r4, r5, r6, lr}
	*v = (*v & 1) + (*v >> 1);
   1c0cc:	e9d0 6500 	ldrd	r6, r5, [r0]
   1c0d0:	0872      	lsrs	r2, r6, #1
   1c0d2:	f006 0301 	and.w	r3, r6, #1
   1c0d6:	ea42 72c5 	orr.w	r2, r2, r5, lsl #31
   1c0da:	189b      	adds	r3, r3, r2
   1c0dc:	ea4f 0455 	mov.w	r4, r5, lsr #1
   1c0e0:	eb44 0101 	adc.w	r1, r4, r1
   1c0e4:	e9c0 3100 	strd	r3, r1, [r0]
}
   1c0e8:	bd70      	pop	{r4, r5, r6, pc}

0001c0ea <_ldiv5>:
{
   1c0ea:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint64_t rem = *v, quot = 0U, q;
   1c0ec:	e9d0 3200 	ldrd	r3, r2, [r0]
		q = (uint64_t)(hi / 5U) << shifts[i];
   1c0f0:	2705      	movs	r7, #5
	rem += 2U;
   1c0f2:	3302      	adds	r3, #2
   1c0f4:	f142 0200 	adc.w	r2, r2, #0
		q = (uint64_t)(hi / 5U) << shifts[i];
   1c0f8:	fbb2 fef7 	udiv	lr, r2, r7
   1c0fc:	f04f 0c00 	mov.w	ip, #0
		rem -= q * 5U;
   1c100:	fb07 f10e 	mul.w	r1, r7, lr
   1c104:	ebb3 060c 	subs.w	r6, r3, ip
   1c108:	eb62 0101 	sbc.w	r1, r2, r1
		hi = rem >> shifts[i];
   1c10c:	08f2      	lsrs	r2, r6, #3
   1c10e:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
		q = (uint64_t)(hi / 5U) << shifts[i];
   1c112:	fbb2 f1f7 	udiv	r1, r2, r7
   1c116:	00ca      	lsls	r2, r1, #3
		quot += q;
   1c118:	eb1c 0402 	adds.w	r4, ip, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   1c11c:	ea4f 7351 	mov.w	r3, r1, lsr #29
		quot += q;
   1c120:	eb4e 0503 	adc.w	r5, lr, r3
		rem -= q * 5U;
   1c124:	fba2 2307 	umull	r2, r3, r2, r7
   1c128:	1ab3      	subs	r3, r6, r2
		q = (uint64_t)(hi / 5U) << shifts[i];
   1c12a:	fbb3 f3f7 	udiv	r3, r3, r7
		quot += q;
   1c12e:	18e4      	adds	r4, r4, r3
   1c130:	f145 0500 	adc.w	r5, r5, #0
	*v = quot;
   1c134:	e9c0 4500 	strd	r4, r5, [r0]
}
   1c138:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001c13a <_get_digit>:
	if (*digit_count > 0) {
   1c13a:	680b      	ldr	r3, [r1, #0]
{
   1c13c:	b570      	push	{r4, r5, r6, lr}
	if (*digit_count > 0) {
   1c13e:	2b00      	cmp	r3, #0
   1c140:	dd10      	ble.n	1c164 <_get_digit+0x2a>
		*digit_count -= 1;
   1c142:	3b01      	subs	r3, #1
   1c144:	600b      	str	r3, [r1, #0]
		*fr = *fr * 10U;
   1c146:	210a      	movs	r1, #10
   1c148:	6802      	ldr	r2, [r0, #0]
   1c14a:	6844      	ldr	r4, [r0, #4]
   1c14c:	fba2 5601 	umull	r5, r6, r2, r1
   1c150:	fb01 6604 	mla	r6, r1, r4, r6
		*fr &= 0x0FFFFFFFFFFFFFFFull;
   1c154:	f026 4370 	bic.w	r3, r6, #4026531840	; 0xf0000000
   1c158:	e9c0 5300 	strd	r5, r3, [r0]
		rval = ((*fr >> 60) & 0xF) + '0';
   1c15c:	0f31      	lsrs	r1, r6, #28
   1c15e:	3130      	adds	r1, #48	; 0x30
}
   1c160:	4608      	mov	r0, r1
   1c162:	bd70      	pop	{r4, r5, r6, pc}
		rval = '0';
   1c164:	2130      	movs	r1, #48	; 0x30
   1c166:	e7fb      	b.n	1c160 <_get_digit+0x26>

0001c168 <_stdout_hook_default>:
}
   1c168:	f04f 30ff 	mov.w	r0, #4294967295
   1c16c:	4770      	bx	lr

0001c16e <fputc>:
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&c, *(uintptr_t *)&stream, K_SYSCALL_ZEPHYR_FPUTC);
	}
#endif
	compiler_barrier();
	return z_impl_zephyr_fputc(c, stream);
   1c16e:	f7f2 bf55 	b.w	f01c <z_impl_zephyr_fputc>

0001c172 <sprintf_out>:
	if (p->len > 1) { /* need to reserve a byte for EOS */
   1c172:	684b      	ldr	r3, [r1, #4]
   1c174:	2b01      	cmp	r3, #1
   1c176:	dd07      	ble.n	1c188 <sprintf_out+0x16>
		*(p->ptr) = c;
   1c178:	680b      	ldr	r3, [r1, #0]
   1c17a:	7018      	strb	r0, [r3, #0]
		p->ptr += 1;
   1c17c:	680b      	ldr	r3, [r1, #0]
   1c17e:	3301      	adds	r3, #1
   1c180:	600b      	str	r3, [r1, #0]
		p->len -= 1;
   1c182:	684b      	ldr	r3, [r1, #4]
   1c184:	3b01      	subs	r3, #1
   1c186:	604b      	str	r3, [r1, #4]
}
   1c188:	2000      	movs	r0, #0
   1c18a:	4770      	bx	lr

0001c18c <close>:
   1c18c:	f7ff bce3 	b.w	1bb56 <z_impl_zsock_close>

0001c190 <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   1c190:	b508      	push	{r3, lr}
	net_if_init();
   1c192:	f7f2 fff3 	bl	f17c <net_if_init>
	net_if_post_init();
   1c196:	f7f3 f805 	bl	f1a4 <net_if_post_init>
	net_coap_init();
   1c19a:	f7f1 fb19 	bl	d7d0 <net_coap_init>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
   1c19e:	2000      	movs	r0, #0
   1c1a0:	bd08      	pop	{r3, pc}

0001c1a2 <net_if_l2>:
	if (!iface || !iface->if_dev) {
   1c1a2:	b110      	cbz	r0, 1c1aa <net_if_l2+0x8>
   1c1a4:	6800      	ldr	r0, [r0, #0]
   1c1a6:	b100      	cbz	r0, 1c1aa <net_if_l2+0x8>
	return iface->if_dev->l2;
   1c1a8:	6840      	ldr	r0, [r0, #4]
}
   1c1aa:	4770      	bx	lr

0001c1ac <l2_flags_get>:
{
   1c1ac:	b510      	push	{r4, lr}
   1c1ae:	4603      	mov	r3, r0
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
   1c1b0:	f7ff fff7 	bl	1c1a2 <net_if_l2>
   1c1b4:	b128      	cbz	r0, 1c1c2 <l2_flags_get+0x16>
   1c1b6:	68c2      	ldr	r2, [r0, #12]
   1c1b8:	b11a      	cbz	r2, 1c1c2 <l2_flags_get+0x16>
}
   1c1ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		flags = net_if_l2(iface)->get_flags(iface);
   1c1be:	4618      	mov	r0, r3
   1c1c0:	4710      	bx	r2
}
   1c1c2:	2000      	movs	r0, #0
   1c1c4:	bd10      	pop	{r4, pc}

0001c1c6 <net_if_up>:
{
   1c1c6:	b510      	push	{r4, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c1c8:	6803      	ldr	r3, [r0, #0]
   1c1ca:	4604      	mov	r4, r0
   1c1cc:	330c      	adds	r3, #12
   1c1ce:	e8d3 3faf 	lda	r3, [r3]
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   1c1d2:	f013 0301 	ands.w	r3, r3, #1
   1c1d6:	d10b      	bne.n	1c1f0 <net_if_up+0x2a>
	     net_if_is_socket_offloaded(iface))) {
   1c1d8:	6802      	ldr	r2, [r0, #0]
	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
   1c1da:	7e91      	ldrb	r1, [r2, #26]
   1c1dc:	b151      	cbz	r1, 1c1f4 <net_if_up+0x2e>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c1de:	320c      	adds	r2, #12
   1c1e0:	e8d2 1fef 	ldaex	r1, [r2]
   1c1e4:	f041 0101 	orr.w	r1, r1, #1
   1c1e8:	e8c2 1fe0 	stlex	r0, r1, [r2]
   1c1ec:	2800      	cmp	r0, #0
   1c1ee:	d1f7      	bne.n	1c1e0 <net_if_up+0x1a>
		return 0;
   1c1f0:	2000      	movs	r0, #0
   1c1f2:	e018      	b.n	1c226 <net_if_up+0x60>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   1c1f4:	f7ff ffd5 	bl	1c1a2 <net_if_l2>
   1c1f8:	b968      	cbnz	r0, 1c216 <net_if_up+0x50>
   1c1fa:	6823      	ldr	r3, [r4, #0]
   1c1fc:	330c      	adds	r3, #12
   1c1fe:	e8d3 2fef 	ldaex	r2, [r3]
   1c202:	f042 0201 	orr.w	r2, r2, #1
   1c206:	e8c3 2fe1 	stlex	r1, r2, [r3]
   1c20a:	2900      	cmp	r1, #0
   1c20c:	d1f7      	bne.n	1c1fe <net_if_up+0x38>
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
   1c20e:	4620      	mov	r0, r4
   1c210:	f7ff ffcc 	bl	1c1ac <l2_flags_get>
   1c214:	e7ec      	b.n	1c1f0 <net_if_up+0x2a>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   1c216:	6883      	ldr	r3, [r0, #8]
   1c218:	2b00      	cmp	r3, #0
   1c21a:	d0ee      	beq.n	1c1fa <net_if_up+0x34>
	status = net_if_l2(iface)->enable(iface, true);
   1c21c:	2101      	movs	r1, #1
   1c21e:	4620      	mov	r0, r4
   1c220:	4798      	blx	r3
	if (status < 0) {
   1c222:	2800      	cmp	r0, #0
   1c224:	dae9      	bge.n	1c1fa <net_if_up+0x34>
}
   1c226:	bd10      	pop	{r4, pc}

0001c228 <net_byte_to_hex>:
{
   1c228:	b530      	push	{r4, r5, lr}
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   1c22a:	090d      	lsrs	r5, r1, #4
		if (i == 0 && !pad && !val) {
   1c22c:	b1bb      	cbz	r3, 1c25e <net_byte_to_hex+0x36>
		if (val < 10) {
   1c22e:	2d09      	cmp	r5, #9
			*ptr++ = (char) (val - 10 + base);
   1c230:	b26b      	sxtb	r3, r5
   1c232:	bf86      	itte	hi
   1c234:	f1a2 050a 	subhi.w	r5, r2, #10
   1c238:	195b      	addhi	r3, r3, r5
			*ptr++ = (char) (val + '0');
   1c23a:	3330      	addls	r3, #48	; 0x30
   1c23c:	1c44      	adds	r4, r0, #1
   1c23e:	7003      	strb	r3, [r0, #0]
	for (i = 0, val = (byte & 0xf0) >> 4; i < 2; i++, val = byte & 0x0f) {
   1c240:	f001 030f 	and.w	r3, r1, #15
		if (val < 10) {
   1c244:	4619      	mov	r1, r3
   1c246:	2b09      	cmp	r3, #9
	*ptr = '\0';
   1c248:	f04f 0300 	mov.w	r3, #0
			*ptr++ = (char) (val - 10 + base);
   1c24c:	bf83      	ittte	hi
   1c24e:	3a0a      	subhi	r2, #10
   1c250:	1889      	addhi	r1, r1, r2
   1c252:	b2c9      	uxtbhi	r1, r1
			*ptr++ = (char) (val + '0');
   1c254:	3130      	addls	r1, #48	; 0x30
   1c256:	7021      	strb	r1, [r4, #0]
	*ptr = '\0';
   1c258:	7063      	strb	r3, [r4, #1]
   1c25a:	1c60      	adds	r0, r4, #1
}
   1c25c:	bd30      	pop	{r4, r5, pc}
		if (i == 0 && !pad && !val) {
   1c25e:	2d00      	cmp	r5, #0
   1c260:	d1e5      	bne.n	1c22e <net_byte_to_hex+0x6>
   1c262:	4604      	mov	r4, r0
   1c264:	e7ec      	b.n	1c240 <net_byte_to_hex+0x18>

0001c266 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c266:	6843      	ldr	r3, [r0, #4]
}
   1c268:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c26a:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   1c26c:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   1c26e:	600b      	str	r3, [r1, #0]
}
   1c270:	4770      	bx	lr

0001c272 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c272:	6843      	ldr	r3, [r0, #4]
   1c274:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   1c276:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   1c278:	4042      	eors	r2, r0
   1c27a:	400a      	ands	r2, r1
   1c27c:	4042      	eors	r2, r0
    p_reg->OUT = value;
   1c27e:	605a      	str	r2, [r3, #4]
}
   1c280:	2000      	movs	r0, #0
   1c282:	4770      	bx	lr

0001c284 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c284:	6843      	ldr	r3, [r0, #4]
}
   1c286:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c288:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   1c28a:	6099      	str	r1, [r3, #8]
}
   1c28c:	4770      	bx	lr

0001c28e <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c28e:	6843      	ldr	r3, [r0, #4]
}
   1c290:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c292:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   1c294:	60d9      	str	r1, [r3, #12]
}
   1c296:	4770      	bx	lr

0001c298 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c298:	6843      	ldr	r3, [r0, #4]
}
   1c29a:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1c29c:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   1c29e:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   1c2a0:	4059      	eors	r1, r3
    p_reg->OUT = value;
   1c2a2:	6051      	str	r1, [r2, #4]
}
   1c2a4:	4770      	bx	lr

0001c2a6 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1c2a6:	68c3      	ldr	r3, [r0, #12]
{
   1c2a8:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   1c2aa:	6858      	ldr	r0, [r3, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
   1c2ac:	b158      	cbz	r0, 1c2c6 <gpio_nrfx_manage_callback+0x20>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1c2ae:	2400      	movs	r4, #0
   1c2b0:	4281      	cmp	r1, r0
   1c2b2:	d113      	bne.n	1c2dc <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   1c2b4:	6808      	ldr	r0, [r1, #0]
   1c2b6:	b95c      	cbnz	r4, 1c2d0 <gpio_nrfx_manage_callback+0x2a>
   1c2b8:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   1c2ba:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   1c2bc:	42a1      	cmp	r1, r4
   1c2be:	d100      	bne.n	1c2c2 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   1c2c0:	6098      	str	r0, [r3, #8]
	parent->next = child;
   1c2c2:	2000      	movs	r0, #0
   1c2c4:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   1c2c6:	b972      	cbnz	r2, 1c2e6 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1c2c8:	2000      	movs	r0, #0
}
   1c2ca:	bd30      	pop	{r4, r5, pc}
   1c2cc:	4628      	mov	r0, r5
   1c2ce:	e7ef      	b.n	1c2b0 <gpio_nrfx_manage_callback+0xa>
   1c2d0:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c2d2:	6898      	ldr	r0, [r3, #8]
   1c2d4:	4281      	cmp	r1, r0
	list->tail = node;
   1c2d6:	bf08      	it	eq
   1c2d8:	609c      	streq	r4, [r3, #8]
}
   1c2da:	e7f2      	b.n	1c2c2 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c2dc:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1c2de:	4604      	mov	r4, r0
   1c2e0:	2d00      	cmp	r5, #0
   1c2e2:	d1f3      	bne.n	1c2cc <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   1c2e4:	b13a      	cbz	r2, 1c2f6 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   1c2e6:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   1c2e8:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   1c2ea:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   1c2ec:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   1c2ee:	2800      	cmp	r0, #0
   1c2f0:	d1ea      	bne.n	1c2c8 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   1c2f2:	6099      	str	r1, [r3, #8]
}
   1c2f4:	e7e9      	b.n	1c2ca <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   1c2f6:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1c2fa:	e7e6      	b.n	1c2ca <gpio_nrfx_manage_callback+0x24>

0001c2fc <gpio_nrfx_pin_disable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
   1c2fc:	2201      	movs	r2, #1
{
   1c2fe:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   1c300:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
   1c302:	408a      	lsls	r2, r1
   1c304:	6923      	ldr	r3, [r4, #16]
   1c306:	ea23 0302 	bic.w	r3, r3, r2
   1c30a:	6123      	str	r3, [r4, #16]
}
   1c30c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return gpiote_pin_int_cfg(port, pin);
   1c310:	f7f3 b8d2 	b.w	f4b8 <gpiote_pin_int_cfg>

0001c314 <gpio_nrfx_pin_enable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
   1c314:	2201      	movs	r2, #1
{
   1c316:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   1c318:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
   1c31a:	408a      	lsls	r2, r1
   1c31c:	6923      	ldr	r3, [r4, #16]
   1c31e:	4313      	orrs	r3, r2
   1c320:	6123      	str	r3, [r4, #16]
}
   1c322:	f85d 4b04 	ldr.w	r4, [sp], #4
	return gpiote_pin_int_cfg(port, pin);
   1c326:	f7f3 b8c7 	b.w	f4b8 <gpiote_pin_int_cfg>

0001c32a <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & dev_config) {
   1c32a:	07ca      	lsls	r2, r1, #31
	nrfx_twim_t const *inst = &(get_dev_config(dev)->twim);
   1c32c:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & dev_config) {
   1c32e:	d405      	bmi.n	1c33c <i2c_nrfx_twim_configure+0x12>
	switch (I2C_SPEED_GET(dev_config)) {
   1c330:	f3c1 0242 	ubfx	r2, r1, #1, #3
   1c334:	2a01      	cmp	r2, #1
   1c336:	d004      	beq.n	1c342 <i2c_nrfx_twim_configure+0x18>
   1c338:	2a02      	cmp	r2, #2
   1c33a:	d00b      	beq.n	1c354 <i2c_nrfx_twim_configure+0x2a>
		return -EINVAL;
   1c33c:	f06f 0015 	mvn.w	r0, #21
}
   1c340:	4770      	bx	lr
    p_reg->FREQUENCY = frequency;
   1c342:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   1c346:	681b      	ldr	r3, [r3, #0]
   1c348:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   1c34c:	68c3      	ldr	r3, [r0, #12]
	return 0;
   1c34e:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   1c350:	6359      	str	r1, [r3, #52]	; 0x34
	return 0;
   1c352:	4770      	bx	lr
   1c354:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   1c358:	681b      	ldr	r3, [r3, #0]
   1c35a:	e7f5      	b.n	1c348 <i2c_nrfx_twim_configure+0x1e>

0001c35c <gpio_pin_set>:

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1c35c:	2301      	movs	r3, #1
   1c35e:	fa03 f101 	lsl.w	r1, r3, r1
   1c362:	68c3      	ldr	r3, [r0, #12]
   1c364:	681b      	ldr	r3, [r3, #0]
   1c366:	4219      	tst	r1, r3
		value = (value != 0) ? 0 : 1;
   1c368:	bf18      	it	ne
   1c36a:	f082 0201 	eorne.w	r2, r2, #1
	if (value != 0)	{
   1c36e:	b112      	cbz	r2, 1c376 <gpio_pin_set+0x1a>
	return api->port_set_bits_raw(port, pins);
   1c370:	6883      	ldr	r3, [r0, #8]
   1c372:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   1c374:	4718      	bx	r3
   1c376:	6883      	ldr	r3, [r0, #8]
   1c378:	691b      	ldr	r3, [r3, #16]
   1c37a:	e7fb      	b.n	1c374 <gpio_pin_set+0x18>

0001c37c <_spi_context_cs_control.isra.0>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   1c37c:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   1c37e:	6805      	ldr	r5, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   1c380:	4604      	mov	r4, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   1c382:	b325      	cbz	r5, 1c3ce <_spi_context_cs_control.isra.0+0x52>
   1c384:	68ab      	ldr	r3, [r5, #8]
   1c386:	b313      	cbz	r3, 1c3ce <_spi_context_cs_control.isra.0+0x52>
   1c388:	6818      	ldr	r0, [r3, #0]
   1c38a:	b300      	cbz	r0, 1c3ce <_spi_context_cs_control.isra.0+0x52>
		if (on) {
   1c38c:	b161      	cbz	r1, 1c3a8 <_spi_context_cs_control.isra.0+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   1c38e:	f9b5 2004 	ldrsh.w	r2, [r5, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1c392:	7919      	ldrb	r1, [r3, #4]
   1c394:	0fd2      	lsrs	r2, r2, #31
   1c396:	f7ff ffe1 	bl	1c35c <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
   1c39a:	6823      	ldr	r3, [r4, #0]
   1c39c:	689b      	ldr	r3, [r3, #8]
   1c39e:	6898      	ldr	r0, [r3, #8]
}
   1c3a0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   1c3a4:	f001 b91b 	b.w	1d5de <z_impl_k_busy_wait>
			if (!force_off &&
   1c3a8:	b912      	cbnz	r2, 1c3b0 <_spi_context_cs_control.isra.0+0x34>
   1c3aa:	88aa      	ldrh	r2, [r5, #4]
   1c3ac:	0492      	lsls	r2, r2, #18
   1c3ae:	d40e      	bmi.n	1c3ce <_spi_context_cs_control.isra.0+0x52>
			k_busy_wait(ctx->config->cs->delay);
   1c3b0:	6898      	ldr	r0, [r3, #8]
   1c3b2:	f001 f914 	bl	1d5de <z_impl_k_busy_wait>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1c3b6:	6822      	ldr	r2, [r4, #0]
   1c3b8:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   1c3ba:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1c3be:	7919      	ldrb	r1, [r3, #4]
   1c3c0:	43d2      	mvns	r2, r2
   1c3c2:	6818      	ldr	r0, [r3, #0]
   1c3c4:	0fd2      	lsrs	r2, r2, #31
}
   1c3c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set(ctx->config->cs->gpio_dev,
   1c3ca:	f7ff bfc7 	b.w	1c35c <gpio_pin_set>
}
   1c3ce:	bd38      	pop	{r3, r4, r5, pc}

0001c3d0 <spi_context_unlock_unconditionally>:
{
   1c3d0:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   1c3d2:	2201      	movs	r2, #1
   1c3d4:	2100      	movs	r1, #0
{
   1c3d6:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   1c3d8:	f7ff ffd0 	bl	1c37c <_spi_context_cs_control.isra.0>
	if (!k_sem_count_get(&ctx->lock)) {
   1c3dc:	68e3      	ldr	r3, [r4, #12]
   1c3de:	b923      	cbnz	r3, 1c3ea <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   1c3e0:	1d20      	adds	r0, r4, #4
}
   1c3e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1c3e6:	f7fe bb73 	b.w	1aad0 <z_impl_k_sem_give>
   1c3ea:	bd10      	pop	{r4, pc}

0001c3ec <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1c3ec:	68c0      	ldr	r0, [r0, #12]
{
   1c3ee:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   1c3f0:	6803      	ldr	r3, [r0, #0]
   1c3f2:	428b      	cmp	r3, r1
   1c3f4:	d106      	bne.n	1c404 <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   1c3f6:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   1c3fa:	b934      	cbnz	r4, 1c40a <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   1c3fc:	f7ff ffe8 	bl	1c3d0 <spi_context_unlock_unconditionally>
	return 0;
   1c400:	4620      	mov	r0, r4
}
   1c402:	bd10      	pop	{r4, pc}
		return -EINVAL;
   1c404:	f06f 0015 	mvn.w	r0, #21
   1c408:	e7fb      	b.n	1c402 <spi_nrfx_release+0x16>
		return -EBUSY;
   1c40a:	f06f 000f 	mvn.w	r0, #15
   1c40e:	e7f8      	b.n	1c402 <spi_nrfx_release+0x16>

0001c410 <event_handler>:
{
   1c410:	b410      	push	{r4}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   1c412:	7803      	ldrb	r3, [r0, #0]
   1c414:	2b00      	cmp	r3, #0
   1c416:	d13a      	bne.n	1c48e <event_handler+0x7e>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1c418:	68cb      	ldr	r3, [r1, #12]
	if (!ctx->tx_len) {
   1c41a:	6cdc      	ldr	r4, [r3, #76]	; 0x4c
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   1c41c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
   1c41e:	b184      	cbz	r4, 1c442 <event_handler+0x32>
	if (len > ctx->tx_len) {
   1c420:	42a2      	cmp	r2, r4
   1c422:	d80e      	bhi.n	1c442 <event_handler+0x32>
	ctx->tx_len -= len;
   1c424:	1aa4      	subs	r4, r4, r2
   1c426:	64dc      	str	r4, [r3, #76]	; 0x4c
	if (!ctx->tx_len) {
   1c428:	bb2c      	cbnz	r4, 1c476 <event_handler+0x66>
		ctx->tx_count--;
   1c42a:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
   1c42c:	3c01      	subs	r4, #1
   1c42e:	63dc      	str	r4, [r3, #60]	; 0x3c
		if (ctx->tx_count) {
   1c430:	b1fc      	cbz	r4, 1c472 <event_handler+0x62>
			ctx->current_tx++;
   1c432:	6b98      	ldr	r0, [r3, #56]	; 0x38
   1c434:	f100 0408 	add.w	r4, r0, #8
   1c438:	639c      	str	r4, [r3, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1c43a:	6884      	ldr	r4, [r0, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   1c43c:	68c0      	ldr	r0, [r0, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1c43e:	649c      	str	r4, [r3, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   1c440:	64d8      	str	r0, [r3, #76]	; 0x4c
	if (!ctx->rx_len) {
   1c442:	6d5c      	ldr	r4, [r3, #84]	; 0x54
   1c444:	b184      	cbz	r4, 1c468 <event_handler+0x58>
	if (len > ctx->rx_len) {
   1c446:	42a2      	cmp	r2, r4
   1c448:	d80e      	bhi.n	1c468 <event_handler+0x58>
	ctx->rx_len -= len;
   1c44a:	1aa4      	subs	r4, r4, r2
   1c44c:	655c      	str	r4, [r3, #84]	; 0x54
	if (!ctx->rx_len) {
   1c44e:	b9c4      	cbnz	r4, 1c482 <event_handler+0x72>
		ctx->rx_count--;
   1c450:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   1c452:	3a01      	subs	r2, #1
   1c454:	645a      	str	r2, [r3, #68]	; 0x44
		if (ctx->rx_count) {
   1c456:	b1c2      	cbz	r2, 1c48a <event_handler+0x7a>
			ctx->current_rx++;
   1c458:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   1c45a:	f102 0008 	add.w	r0, r2, #8
   1c45e:	6418      	str	r0, [r3, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1c460:	6890      	ldr	r0, [r2, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   1c462:	68d2      	ldr	r2, [r2, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1c464:	6518      	str	r0, [r3, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   1c466:	655a      	str	r2, [r3, #84]	; 0x54
		transfer_next_chunk(dev);
   1c468:	4608      	mov	r0, r1
}
   1c46a:	f85d 4b04 	ldr.w	r4, [sp], #4
		transfer_next_chunk(dev);
   1c46e:	f7f3 ba67 	b.w	f940 <transfer_next_chunk>
			ctx->tx_buf = NULL;
   1c472:	649c      	str	r4, [r3, #72]	; 0x48
   1c474:	e7e5      	b.n	1c442 <event_handler+0x32>
	} else if (ctx->tx_buf) {
   1c476:	6c98      	ldr	r0, [r3, #72]	; 0x48
   1c478:	2800      	cmp	r0, #0
   1c47a:	d0e2      	beq.n	1c442 <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   1c47c:	4410      	add	r0, r2
   1c47e:	6498      	str	r0, [r3, #72]	; 0x48
   1c480:	e7df      	b.n	1c442 <event_handler+0x32>
	} else if (ctx->rx_buf) {
   1c482:	6d18      	ldr	r0, [r3, #80]	; 0x50
   1c484:	2800      	cmp	r0, #0
   1c486:	d0ef      	beq.n	1c468 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   1c488:	4402      	add	r2, r0
   1c48a:	651a      	str	r2, [r3, #80]	; 0x50
   1c48c:	e7ec      	b.n	1c468 <event_handler+0x58>
}
   1c48e:	f85d 4b04 	ldr.w	r4, [sp], #4
   1c492:	4770      	bx	lr

0001c494 <uarte_nrfx_isr_int>:
	if (data->int_driven->disable_tx_irq &&
   1c494:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   1c496:	6843      	ldr	r3, [r0, #4]
	if (data->int_driven->disable_tx_irq &&
   1c498:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   1c49a:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   1c49c:	7b91      	ldrb	r1, [r2, #14]
   1c49e:	b159      	cbz	r1, 1c4b8 <uarte_nrfx_isr_int+0x24>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c4a0:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   1c4a4:	b141      	cbz	r1, 1c4b8 <uarte_nrfx_isr_int+0x24>
    p_reg->INTENCLR = mask;
   1c4a6:	f44f 7180 	mov.w	r1, #256	; 0x100
   1c4aa:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c4ae:	2101      	movs	r1, #1
   1c4b0:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
   1c4b2:	2300      	movs	r3, #0
   1c4b4:	7393      	strb	r3, [r2, #14]
		return;
   1c4b6:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c4b8:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   1c4bc:	b111      	cbz	r1, 1c4c4 <uarte_nrfx_isr_int+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c4be:	2100      	movs	r1, #0
   1c4c0:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
   1c4c4:	6813      	ldr	r3, [r2, #0]
   1c4c6:	b10b      	cbz	r3, 1c4cc <uarte_nrfx_isr_int+0x38>
		data->int_driven->cb(data->int_driven->cb_data);
   1c4c8:	6850      	ldr	r0, [r2, #4]
   1c4ca:	4718      	bx	r3
}
   1c4cc:	4770      	bx	lr

0001c4ce <uarte_nrfx_config_get>:
{
   1c4ce:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   1c4d0:	68c2      	ldr	r2, [r0, #12]
   1c4d2:	e892 0003 	ldmia.w	r2, {r0, r1}
   1c4d6:	e883 0003 	stmia.w	r3, {r0, r1}
}
   1c4da:	2000      	movs	r0, #0
   1c4dc:	4770      	bx	lr

0001c4de <uarte_nrfx_err_check>:
	return config->uarte_regs;
   1c4de:	6843      	ldr	r3, [r0, #4]
   1c4e0:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   1c4e2:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   1c4e6:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   1c4ea:	4770      	bx	lr

0001c4ec <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   1c4ec:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   1c4ee:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   1c4f0:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c4f2:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   1c4f6:	b138      	cbz	r0, 1c508 <uarte_nrfx_poll_in+0x1c>
	*c = data->rx_data;
   1c4f8:	7c12      	ldrb	r2, [r2, #16]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c4fa:	2000      	movs	r0, #0
   1c4fc:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c4fe:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c500:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c504:	601a      	str	r2, [r3, #0]
	return 0;
   1c506:	4770      	bx	lr
		return -1;
   1c508:	f04f 30ff 	mov.w	r0, #4294967295
}
   1c50c:	4770      	bx	lr

0001c50e <uarte_nrfx_fifo_fill>:
	return config->uarte_regs;
   1c50e:	6843      	ldr	r3, [r0, #4]
{
   1c510:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
   1c512:	681c      	ldr	r4, [r3, #0]
{
   1c514:	4605      	mov	r5, r0
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c516:	f8d4 0120 	ldr.w	r0, [r4, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   1c51a:	b190      	cbz	r0, 1c542 <uarte_nrfx_fifo_fill+0x34>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1c51c:	68ed      	ldr	r5, [r5, #12]
	if (len > data->int_driven->tx_buff_size) {
   1c51e:	68ab      	ldr	r3, [r5, #8]
   1c520:	8998      	ldrh	r0, [r3, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c522:	2300      	movs	r3, #0
   1c524:	4290      	cmp	r0, r2
   1c526:	bfa8      	it	ge
   1c528:	4610      	movge	r0, r2
   1c52a:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	for (int i = 0; i < len; i++) {
   1c52e:	68aa      	ldr	r2, [r5, #8]
   1c530:	4283      	cmp	r3, r0
   1c532:	6892      	ldr	r2, [r2, #8]
   1c534:	db06      	blt.n	1c544 <uarte_nrfx_fifo_fill+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c536:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1c538:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1c53c:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c540:	60a3      	str	r3, [r4, #8]
}
   1c542:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   1c544:	5cce      	ldrb	r6, [r1, r3]
   1c546:	54d6      	strb	r6, [r2, r3]
	for (int i = 0; i < len; i++) {
   1c548:	3301      	adds	r3, #1
   1c54a:	e7f0      	b.n	1c52e <uarte_nrfx_fifo_fill+0x20>

0001c54c <uarte_nrfx_fifo_read>:
	return config->uarte_regs;
   1c54c:	6843      	ldr	r3, [r0, #4]
   1c54e:	681a      	ldr	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c550:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   1c554:	b143      	cbz	r3, 1c568 <uarte_nrfx_fifo_read+0x1c>
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   1c556:	68c3      	ldr	r3, [r0, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c558:	2000      	movs	r0, #0
   1c55a:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c55e:	2001      	movs	r0, #1
		rx_data[num_rx++] = (u8_t)data->rx_data;
   1c560:	7c1b      	ldrb	r3, [r3, #16]
   1c562:	700b      	strb	r3, [r1, #0]
   1c564:	6010      	str	r0, [r2, #0]
}
   1c566:	4770      	bx	lr
	int num_rx = 0;
   1c568:	4618      	mov	r0, r3
}
   1c56a:	4770      	bx	lr

0001c56c <uarte_nrfx_irq_tx_enable>:
	data->int_driven->disable_tx_irq = false;
   1c56c:	2100      	movs	r1, #0
   1c56e:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   1c570:	6843      	ldr	r3, [r0, #4]
	data->int_driven->disable_tx_irq = false;
   1c572:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   1c574:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   1c576:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   1c578:	f44f 7280 	mov.w	r2, #256	; 0x100
   1c57c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1c580:	4770      	bx	lr

0001c582 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   1c582:	2201      	movs	r2, #1
   1c584:	68c3      	ldr	r3, [r0, #12]
   1c586:	689b      	ldr	r3, [r3, #8]
   1c588:	739a      	strb	r2, [r3, #14]
}
   1c58a:	4770      	bx	lr

0001c58c <uarte_nrfx_irq_tx_ready_complete>:
	return !data->int_driven->disable_tx_irq &&
   1c58c:	68c3      	ldr	r3, [r0, #12]
   1c58e:	689b      	ldr	r3, [r3, #8]
   1c590:	7b9b      	ldrb	r3, [r3, #14]
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   1c592:	b94b      	cbnz	r3, 1c5a8 <uarte_nrfx_irq_tx_ready_complete+0x1c>
	return config->uarte_regs;
   1c594:	6843      	ldr	r3, [r0, #4]
   1c596:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c598:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return !data->int_driven->disable_tx_irq &&
   1c59c:	b128      	cbz	r0, 1c5aa <uarte_nrfx_irq_tx_ready_complete+0x1e>
    return p_reg->INTENSET & mask;
   1c59e:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   1c5a2:	f3c0 2000 	ubfx	r0, r0, #8, #1
   1c5a6:	4770      	bx	lr
   1c5a8:	2000      	movs	r0, #0
}
   1c5aa:	4770      	bx	lr

0001c5ac <uarte_nrfx_irq_rx_ready>:
	return config->uarte_regs;
   1c5ac:	6843      	ldr	r3, [r0, #4]
   1c5ae:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c5b0:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   1c5b4:	3800      	subs	r0, #0
   1c5b6:	bf18      	it	ne
   1c5b8:	2001      	movne	r0, #1
   1c5ba:	4770      	bx	lr

0001c5bc <uarte_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   1c5bc:	2210      	movs	r2, #16
	return config->uarte_regs;
   1c5be:	6843      	ldr	r3, [r0, #4]
   1c5c0:	681b      	ldr	r3, [r3, #0]
   1c5c2:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1c5c6:	4770      	bx	lr

0001c5c8 <uarte_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   1c5c8:	2210      	movs	r2, #16
	return config->uarte_regs;
   1c5ca:	6843      	ldr	r3, [r0, #4]
   1c5cc:	681b      	ldr	r3, [r3, #0]
   1c5ce:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   1c5d2:	4770      	bx	lr

0001c5d4 <uarte_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   1c5d4:	f44f 7200 	mov.w	r2, #512	; 0x200
	return config->uarte_regs;
   1c5d8:	6843      	ldr	r3, [r0, #4]
   1c5da:	681b      	ldr	r3, [r3, #0]
   1c5dc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   1c5e0:	4770      	bx	lr

0001c5e2 <uarte_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   1c5e2:	f44f 7200 	mov.w	r2, #512	; 0x200
	return config->uarte_regs;
   1c5e6:	6843      	ldr	r3, [r0, #4]
   1c5e8:	681b      	ldr	r3, [r3, #0]
   1c5ea:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   1c5ee:	4770      	bx	lr

0001c5f0 <uarte_nrfx_irq_update>:
}
   1c5f0:	2001      	movs	r0, #1
   1c5f2:	4770      	bx	lr

0001c5f4 <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   1c5f4:	68c3      	ldr	r3, [r0, #12]
   1c5f6:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   1c5f8:	e9c3 1200 	strd	r1, r2, [r3]
}
   1c5fc:	4770      	bx	lr

0001c5fe <uarte_nrfx_irq_is_pending>:
{
   1c5fe:	b508      	push	{r3, lr}
	return config->uarte_regs;
   1c600:	6843      	ldr	r3, [r0, #4]
{
   1c602:	4602      	mov	r2, r0
	return config->uarte_regs;
   1c604:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   1c606:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   1c60a:	05db      	lsls	r3, r3, #23
   1c60c:	d405      	bmi.n	1c61a <uarte_nrfx_irq_is_pending+0x1c>
   1c60e:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   1c612:	f010 0010 	ands.w	r0, r0, #16
   1c616:	d106      	bne.n	1c626 <uarte_nrfx_irq_is_pending+0x28>
}
   1c618:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   1c61a:	f7ff ffb7 	bl	1c58c <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   1c61e:	2800      	cmp	r0, #0
   1c620:	d0f5      	beq.n	1c60e <uarte_nrfx_irq_is_pending+0x10>
		||
   1c622:	2001      	movs	r0, #1
   1c624:	e7f8      	b.n	1c618 <uarte_nrfx_irq_is_pending+0x1a>
		 uarte_nrfx_irq_rx_ready(dev)));
   1c626:	4610      	mov	r0, r2
   1c628:	f7ff ffc0 	bl	1c5ac <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   1c62c:	3800      	subs	r0, #0
   1c62e:	bf18      	it	ne
   1c630:	2001      	movne	r0, #1
   1c632:	e7f1      	b.n	1c618 <uarte_nrfx_irq_is_pending+0x1a>

0001c634 <uarte_nrfx_poll_out>:
{
   1c634:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return config->uarte_regs;
   1c638:	6843      	ldr	r3, [r0, #4]
{
   1c63a:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   1c63e:	681c      	ldr	r4, [r3, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1c640:	68c6      	ldr	r6, [r0, #12]
	if (!k_is_in_isr()) {
   1c642:	f000 ffc6 	bl	1d5d2 <k_is_in_isr>
   1c646:	b9c0      	cbnz	r0, 1c67a <uarte_nrfx_poll_out+0x46>
		lock = &data->poll_out_lock;
   1c648:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   1c64a:	f04f 0801 	mov.w	r8, #1
   1c64e:	f106 070c 	add.w	r7, r6, #12
   1c652:	e8d7 3fef 	ldaex	r3, [r7]
   1c656:	2b00      	cmp	r3, #0
   1c658:	d103      	bne.n	1c662 <uarte_nrfx_poll_out+0x2e>
   1c65a:	e8c7 8fe2 	stlex	r2, r8, [r7]
   1c65e:	2a00      	cmp	r2, #0
   1c660:	d1f7      	bne.n	1c652 <uarte_nrfx_poll_out+0x1e>
		while (atomic_cas((atomic_t *) lock,
   1c662:	d00c      	beq.n	1c67e <uarte_nrfx_poll_out+0x4a>
	return z_impl_k_sleep(timeout);
   1c664:	2021      	movs	r0, #33	; 0x21
   1c666:	2100      	movs	r1, #0
   1c668:	3d01      	subs	r5, #1
   1c66a:	f7fe fa0b 	bl	1aa84 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
   1c66e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   1c672:	d1ee      	bne.n	1c652 <uarte_nrfx_poll_out+0x1e>
}
   1c674:	b002      	add	sp, #8
   1c676:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*lock = 1;
   1c67a:	2301      	movs	r3, #1
   1c67c:	60f3      	str	r3, [r6, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1c67e:	2300      	movs	r3, #0
   1c680:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1c684:	f10d 0307 	add.w	r3, sp, #7
   1c688:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1c68c:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c68e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    p_reg->TXD.MAXCNT = length;
   1c692:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c696:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1c698:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
   1c69c:	b923      	cbnz	r3, 1c6a8 <uarte_nrfx_poll_out+0x74>
   1c69e:	2001      	movs	r0, #1
   1c6a0:	f000 fd02 	bl	1d0a8 <nrfx_busy_wait>
   1c6a4:	3d01      	subs	r5, #1
   1c6a6:	d1f7      	bne.n	1c698 <uarte_nrfx_poll_out+0x64>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1c6a8:	2301      	movs	r3, #1
   1c6aa:	60e3      	str	r3, [r4, #12]
	*lock = 0;
   1c6ac:	2300      	movs	r3, #0
   1c6ae:	60f3      	str	r3, [r6, #12]
   1c6b0:	e7e0      	b.n	1c674 <uarte_nrfx_poll_out+0x40>

0001c6b2 <entropy_cc310_rng_init>:
{
	/* No initialization is required */
	(void)dev;

	return 0;
}
   1c6b2:	2000      	movs	r0, #0
   1c6b4:	4770      	bx	lr

0001c6b6 <entropy_cc310_rng_get_entropy>:
{
   1c6b6:	b513      	push	{r0, r1, r4, lr}
   1c6b8:	4614      	mov	r4, r2
   1c6ba:	4608      	mov	r0, r1
	res = spm_request_random_number(buffer, length, &olen);
   1c6bc:	aa01      	add	r2, sp, #4
   1c6be:	4621      	mov	r1, r4
   1c6c0:	f7eb fc96 	bl	7ff0 <spm_request_random_number>
	if (olen != length) {
   1c6c4:	9b01      	ldr	r3, [sp, #4]
   1c6c6:	429c      	cmp	r4, r3
}
   1c6c8:	bf18      	it	ne
   1c6ca:	f06f 0015 	mvnne.w	r0, #21
   1c6ce:	b002      	add	sp, #8
   1c6d0:	bd10      	pop	{r4, pc}

0001c6d2 <z_errno>:
   1c6d2:	f7fd bb71 	b.w	19db8 <z_impl_z_errno>

0001c6d6 <trace_proxy_irq_handler>:
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   1c6d6:	4668      	mov	r0, sp
   1c6d8:	f020 0107 	bic.w	r1, r0, #7
   1c6dc:	468d      	mov	sp, r1
   1c6de:	b501      	push	{r0, lr}
	bsd_os_trace_irq_handler();
   1c6e0:	f7f5 fb50 	bl	11d84 <bsd_os_trace_irq_handler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   1c6e4:	f7f1 fbd0 	bl	de88 <_arch_isr_direct_pm>
   1c6e8:	f7f1 fd08 	bl	e0fc <z_arm_exc_exit>
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   1c6ec:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   1c6f0:	4685      	mov	sp, r0
   1c6f2:	4770      	bx	lr

0001c6f4 <ipc_proxy_irq_handler>:
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   1c6f4:	4668      	mov	r0, sp
   1c6f6:	f020 0107 	bic.w	r1, r0, #7
   1c6fa:	468d      	mov	sp, r1
   1c6fc:	b501      	push	{r0, lr}
	IPC_IRQHandler();
   1c6fe:	f7f5 fe6b 	bl	123d8 <IPC_IRQHandler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   1c702:	f7f1 fbc1 	bl	de88 <_arch_isr_direct_pm>
   1c706:	f7f1 fcf9 	bl	e0fc <z_arm_exc_exit>
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   1c70a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   1c70e:	4685      	mov	sp, r0
   1c710:	4770      	bx	lr

0001c712 <trace_task_create>:
{
   1c712:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(TRACE_IRQ, TRACE_IRQ_PRIORITY,
   1c714:	201d      	movs	r0, #29
   1c716:	2200      	movs	r2, #0
   1c718:	2106      	movs	r1, #6
   1c71a:	f7f1 fb9f 	bl	de5c <z_arm_irq_priority_set>
}
   1c71e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(TRACE_IRQ);
   1c722:	201d      	movs	r0, #29
   1c724:	f7f1 bb8a 	b.w	de3c <arch_irq_enable>

0001c728 <read_task_create>:
{
   1c728:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_APPLICATION_IRQ, BSD_APPLICATION_IRQ_PRIORITY,
   1c72a:	201c      	movs	r0, #28
   1c72c:	2200      	movs	r2, #0
   1c72e:	2106      	movs	r1, #6
   1c730:	f7f1 fb94 	bl	de5c <z_arm_irq_priority_set>
}
   1c734:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(BSD_APPLICATION_IRQ);
   1c738:	201c      	movs	r0, #28
   1c73a:	f7f1 bb7f 	b.w	de3c <arch_irq_enable>

0001c73e <bsd_os_trace_put>:
		remaining_bytes -= transfer_len;
	}
#endif

	return 0;
}
   1c73e:	2000      	movs	r0, #0
   1c740:	4770      	bx	lr

0001c742 <z_to_nrf_flags>:
{
   1c742:	4603      	mov	r3, r0
		nrf_flags |= NRF_MSG_DONTWAIT;
   1c744:	f010 0040 	ands.w	r0, r0, #64	; 0x40
   1c748:	bf18      	it	ne
   1c74a:	2002      	movne	r0, #2
	if (z_flags & MSG_PEEK) {
   1c74c:	079b      	lsls	r3, r3, #30
		nrf_flags |= NRF_MSG_PEEK;
   1c74e:	bf48      	it	mi
   1c750:	f040 0008 	orrmi.w	r0, r0, #8
}
   1c754:	4770      	bx	lr

0001c756 <z_to_nrf_family>:
	switch (z_family) {
   1c756:	2806      	cmp	r0, #6
   1c758:	d80a      	bhi.n	1c770 <z_to_nrf_family+0x1a>
   1c75a:	b198      	cbz	r0, 1c784 <z_to_nrf_family+0x2e>
   1c75c:	3801      	subs	r0, #1
   1c75e:	2805      	cmp	r0, #5
   1c760:	d810      	bhi.n	1c784 <z_to_nrf_family+0x2e>
   1c762:	e8df f000 	tbb	[pc, r0]
   1c766:	0312      	.short	0x0312
   1c768:	0b0f0f0d 	.word	0x0b0f0f0d
   1c76c:	200a      	movs	r0, #10
   1c76e:	4770      	bx	lr
   1c770:	2866      	cmp	r0, #102	; 0x66
		return NRF_AF_LTE;
   1c772:	bf14      	ite	ne
   1c774:	f06f 002e 	mvnne.w	r0, #46	; 0x2e
   1c778:	2066      	moveq	r0, #102	; 0x66
   1c77a:	4770      	bx	lr
		return NRF_AF_LOCAL;
   1c77c:	2001      	movs	r0, #1
   1c77e:	4770      	bx	lr
		return NRF_AF_PACKET;
   1c780:	2005      	movs	r0, #5
   1c782:	4770      	bx	lr
		return -EAFNOSUPPORT;
   1c784:	f06f 002e 	mvn.w	r0, #46	; 0x2e
   1c788:	4770      	bx	lr
		return NRF_AF_INET;
   1c78a:	2002      	movs	r0, #2
}
   1c78c:	4770      	bx	lr

0001c78e <z_to_nrf_protocol>:
	switch (proto) {
   1c78e:	f240 1311 	movw	r3, #273	; 0x111
   1c792:	4298      	cmp	r0, r3
   1c794:	d023      	beq.n	1c7de <z_to_nrf_protocol+0x50>
   1c796:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
   1c79a:	da11      	bge.n	1c7c0 <z_to_nrf_protocol+0x32>
   1c79c:	2811      	cmp	r0, #17
   1c79e:	d021      	beq.n	1c7e4 <z_to_nrf_protocol+0x56>
   1c7a0:	dc06      	bgt.n	1c7b0 <z_to_nrf_protocol+0x22>
   1c7a2:	b300      	cbz	r0, 1c7e6 <z_to_nrf_protocol+0x58>
		return NRF_IPPROTO_TCP;
   1c7a4:	2806      	cmp	r0, #6
   1c7a6:	bf14      	ite	ne
   1c7a8:	f06f 002a 	mvnne.w	r0, #42	; 0x2a
   1c7ac:	2001      	moveq	r0, #1
   1c7ae:	4770      	bx	lr
		return NRF_SPROTO_TLS1v2;
   1c7b0:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
   1c7b4:	bf14      	ite	ne
   1c7b6:	f06f 002a 	mvnne.w	r0, #42	; 0x2a
   1c7ba:	f44f 7082 	moveq.w	r0, #260	; 0x104
   1c7be:	4770      	bx	lr
	switch (proto) {
   1c7c0:	f240 2302 	movw	r3, #514	; 0x202
   1c7c4:	4298      	cmp	r0, r3
   1c7c6:	d00e      	beq.n	1c7e6 <z_to_nrf_protocol+0x58>
   1c7c8:	f240 2303 	movw	r3, #515	; 0x203
   1c7cc:	4298      	cmp	r0, r3
   1c7ce:	d00a      	beq.n	1c7e6 <z_to_nrf_protocol+0x58>
   1c7d0:	f240 2301 	movw	r3, #513	; 0x201
		return -EPROTONOSUPPORT;
   1c7d4:	4298      	cmp	r0, r3
   1c7d6:	bf18      	it	ne
   1c7d8:	f06f 002a 	mvnne.w	r0, #42	; 0x2a
   1c7dc:	4770      	bx	lr
		return NRF_SPROTO_DTLS1v2;
   1c7de:	f44f 7087 	mov.w	r0, #270	; 0x10e
   1c7e2:	4770      	bx	lr
	switch (proto) {
   1c7e4:	2002      	movs	r0, #2
}
   1c7e6:	4770      	bx	lr

0001c7e8 <nrf91_socket_is_supported>:
}
   1c7e8:	2001      	movs	r0, #1
   1c7ea:	4770      	bx	lr

0001c7ec <nrf91_bsdlib_socket_offload_init>:
}
   1c7ec:	2000      	movs	r0, #0
   1c7ee:	4770      	bx	lr

0001c7f0 <z_errno>:
   1c7f0:	f7fd bae2 	b.w	19db8 <z_impl_z_errno>

0001c7f4 <nrf91_socket_offload_getsockopt>:
{
   1c7f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c7f8:	461d      	mov	r5, r3
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   1c7fa:	2300      	movs	r3, #0
{
   1c7fc:	b086      	sub	sp, #24
   1c7fe:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	struct nrf_timeval nrf_rcvtimeo = {0, 0};
   1c802:	e9cd 3304 	strd	r3, r3, [sp, #16]
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   1c806:	f8d8 3000 	ldr.w	r3, [r8]
{
   1c80a:	460c      	mov	r4, r1
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   1c80c:	9303      	str	r3, [sp, #12]
	switch (z_in_level) {
   1c80e:	f240 2302 	movw	r3, #514	; 0x202
   1c812:	4299      	cmp	r1, r3
{
   1c814:	4616      	mov	r6, r2
	int sd = OBJ_TO_SD(obj);
   1c816:	f100 37ff 	add.w	r7, r0, #4294967295
	switch (z_in_level) {
   1c81a:	d005      	beq.n	1c828 <nrf91_socket_offload_getsockopt+0x34>
   1c81c:	dc2e      	bgt.n	1c87c <nrf91_socket_offload_getsockopt+0x88>
   1c81e:	2901      	cmp	r1, #1
   1c820:	d002      	beq.n	1c828 <nrf91_socket_offload_getsockopt+0x34>
   1c822:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   1c826:	d139      	bne.n	1c89c <nrf91_socket_offload_getsockopt+0xa8>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   1c828:	4631      	mov	r1, r6
   1c82a:	4620      	mov	r0, r4
   1c82c:	aa02      	add	r2, sp, #8
   1c82e:	f7f3 fd8f 	bl	10350 <z_to_nrf_optname>
   1c832:	2800      	cmp	r0, #0
   1c834:	db32      	blt.n	1c89c <nrf91_socket_offload_getsockopt+0xa8>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   1c836:	2c01      	cmp	r4, #1
   1c838:	d124      	bne.n	1c884 <nrf91_socket_offload_getsockopt+0x90>
   1c83a:	2e14      	cmp	r6, #20
   1c83c:	d122      	bne.n	1c884 <nrf91_socket_offload_getsockopt+0x90>
		nrf_optlen = sizeof(struct nrf_timeval);
   1c83e:	2308      	movs	r3, #8
   1c840:	9303      	str	r3, [sp, #12]
		nrf_optval = &nrf_rcvtimeo;
   1c842:	ab04      	add	r3, sp, #16
	retval = nrf_getsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   1c844:	aa03      	add	r2, sp, #12
   1c846:	4638      	mov	r0, r7
   1c848:	9200      	str	r2, [sp, #0]
   1c84a:	4621      	mov	r1, r4
   1c84c:	9a02      	ldr	r2, [sp, #8]
   1c84e:	f7fb f969 	bl	17b24 <nrf_getsockopt>
	if ((retval == 0) && (optval != NULL)) {
   1c852:	4607      	mov	r7, r0
   1c854:	b970      	cbnz	r0, 1c874 <nrf91_socket_offload_getsockopt+0x80>
   1c856:	b16d      	cbz	r5, 1c874 <nrf91_socket_offload_getsockopt+0x80>
		*optlen = nrf_optlen;
   1c858:	9b03      	ldr	r3, [sp, #12]
		if (level == SOL_SOCKET) {
   1c85a:	2c01      	cmp	r4, #1
		*optlen = nrf_optlen;
   1c85c:	f8c8 3000 	str.w	r3, [r8]
		if (level == SOL_SOCKET) {
   1c860:	d108      	bne.n	1c874 <nrf91_socket_offload_getsockopt+0x80>
			if (optname == SO_ERROR) {
   1c862:	2e04      	cmp	r6, #4
   1c864:	d110      	bne.n	1c888 <nrf91_socket_offload_getsockopt+0x94>
				bsd_os_errno_set(*(int *)optval);
   1c866:	6828      	ldr	r0, [r5, #0]
   1c868:	f7f3 fbe0 	bl	1002c <bsd_os_errno_set>
				*(int *)optval = errno;
   1c86c:	f7ff ffc0 	bl	1c7f0 <z_errno>
   1c870:	6803      	ldr	r3, [r0, #0]
   1c872:	602b      	str	r3, [r5, #0]
}
   1c874:	4638      	mov	r0, r7
   1c876:	b006      	add	sp, #24
   1c878:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   1c87c:	f240 2303 	movw	r3, #515	; 0x203
   1c880:	4299      	cmp	r1, r3
   1c882:	e7d0      	b.n	1c826 <nrf91_socket_offload_getsockopt+0x32>
   1c884:	462b      	mov	r3, r5
   1c886:	e7dd      	b.n	1c844 <nrf91_socket_offload_getsockopt+0x50>
			} else if (optname == SO_RCVTIMEO) {
   1c888:	2e14      	cmp	r6, #20
   1c88a:	d1f3      	bne.n	1c874 <nrf91_socket_offload_getsockopt+0x80>
				((struct timeval *)optval)->tv_sec =
   1c88c:	9b04      	ldr	r3, [sp, #16]
   1c88e:	602b      	str	r3, [r5, #0]
				((struct timeval *)optval)->tv_usec =
   1c890:	9b05      	ldr	r3, [sp, #20]
   1c892:	606b      	str	r3, [r5, #4]
				*optlen = sizeof(struct timeval);
   1c894:	2308      	movs	r3, #8
   1c896:	f8c8 3000 	str.w	r3, [r8]
   1c89a:	e7eb      	b.n	1c874 <nrf91_socket_offload_getsockopt+0x80>
	errno = ENOPROTOOPT;
   1c89c:	f7ff ffa8 	bl	1c7f0 <z_errno>
   1c8a0:	232a      	movs	r3, #42	; 0x2a
	return retval;
   1c8a2:	f04f 37ff 	mov.w	r7, #4294967295
	errno = ENOPROTOOPT;
   1c8a6:	6003      	str	r3, [r0, #0]
	return retval;
   1c8a8:	e7e4      	b.n	1c874 <nrf91_socket_offload_getsockopt+0x80>

0001c8aa <nrf91_socket_offload_recvfrom>:
{
   1c8aa:	b570      	push	{r4, r5, r6, lr}
	int sd = OBJ_TO_SD(obj);
   1c8ac:	1e45      	subs	r5, r0, #1
{
   1c8ae:	b08c      	sub	sp, #48	; 0x30
   1c8b0:	4618      	mov	r0, r3
   1c8b2:	e9dd 4610 	ldrd	r4, r6, [sp, #64]	; 0x40
   1c8b6:	f7ff ff44 	bl	1c742 <z_to_nrf_flags>
   1c8ba:	4603      	mov	r3, r0
	if (from == NULL) {
   1c8bc:	b944      	cbnz	r4, 1c8d0 <nrf91_socket_offload_recvfrom+0x26>
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags), NULL,
   1c8be:	4628      	mov	r0, r5
   1c8c0:	e9cd 4400 	strd	r4, r4, [sp]
   1c8c4:	f7fb f8ac 	bl	17a20 <nrf_recvfrom>
   1c8c8:	4605      	mov	r5, r0
}
   1c8ca:	4628      	mov	r0, r5
   1c8cc:	b00c      	add	sp, #48	; 0x30
   1c8ce:	bd70      	pop	{r4, r5, r6, pc}
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   1c8d0:	2024      	movs	r0, #36	; 0x24
   1c8d2:	9002      	str	r0, [sp, #8]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   1c8d4:	a802      	add	r0, sp, #8
   1c8d6:	9001      	str	r0, [sp, #4]
   1c8d8:	a803      	add	r0, sp, #12
   1c8da:	9000      	str	r0, [sp, #0]
   1c8dc:	4628      	mov	r0, r5
   1c8de:	f7fb f89f 	bl	17a20 <nrf_recvfrom>
		if (cliaddr->sa_family == NRF_AF_INET) {
   1c8e2:	9b04      	ldr	r3, [sp, #16]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   1c8e4:	4605      	mov	r5, r0
		if (cliaddr->sa_family == NRF_AF_INET) {
   1c8e6:	2b02      	cmp	r3, #2
   1c8e8:	d109      	bne.n	1c8fe <nrf91_socket_offload_recvfrom+0x54>
	ptr->sin_port = nrf_in->sin_port;
   1c8ea:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   1c8ee:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   1c8f0:	2301      	movs	r3, #1
   1c8f2:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   1c8f4:	9b06      	ldr	r3, [sp, #24]
   1c8f6:	6063      	str	r3, [r4, #4]
			*fromlen = sizeof(struct sockaddr_in);
   1c8f8:	2308      	movs	r3, #8
			*fromlen = sizeof(struct sockaddr_in6);
   1c8fa:	6033      	str	r3, [r6, #0]
	return retval;
   1c8fc:	e7e5      	b.n	1c8ca <nrf91_socket_offload_recvfrom+0x20>
		} else if (cliaddr->sa_family == NRF_AF_INET6) {
   1c8fe:	2b0a      	cmp	r3, #10
   1c900:	d1e3      	bne.n	1c8ca <nrf91_socket_offload_recvfrom+0x20>
	ptr->sin6_port = nrf_in->sin6_port;
   1c902:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	ptr->sin6_family = AF_INET6;
   1c906:	4620      	mov	r0, r4
	ptr->sin6_port = nrf_in->sin6_port;
   1c908:	8063      	strh	r3, [r4, #2]
	ptr->sin6_family = AF_INET6;
   1c90a:	2302      	movs	r3, #2
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1c90c:	2210      	movs	r2, #16
	ptr->sin6_family = AF_INET6;
   1c90e:	f820 3b04 	strh.w	r3, [r0], #4
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1c912:	a907      	add	r1, sp, #28
   1c914:	f7ff fb66 	bl	1bfe4 <memcpy>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   1c918:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   1c91a:	7523      	strb	r3, [r4, #20]
			*fromlen = sizeof(struct sockaddr_in6);
   1c91c:	2318      	movs	r3, #24
   1c91e:	e7ec      	b.n	1c8fa <nrf91_socket_offload_recvfrom+0x50>

0001c920 <nrf91_socket_offload_read>:
	return nrf91_socket_offload_recvfrom(obj, buffer, count, 0, NULL, 0);
   1c920:	2300      	movs	r3, #0
{
   1c922:	b507      	push	{r0, r1, r2, lr}
	return nrf91_socket_offload_recvfrom(obj, buffer, count, 0, NULL, 0);
   1c924:	e9cd 3300 	strd	r3, r3, [sp]
   1c928:	f7ff ffbf 	bl	1c8aa <nrf91_socket_offload_recvfrom>
}
   1c92c:	b003      	add	sp, #12
   1c92e:	f85d fb04 	ldr.w	pc, [sp], #4

0001c932 <nrf91_socket_offload_listen>:
	return nrf_listen(sd, backlog);
   1c932:	3801      	subs	r0, #1
   1c934:	f7fb b8a2 	b.w	17a7c <nrf_listen>

0001c938 <nrf91_socket_offload_freeaddrinfo>:
{
   1c938:	b538      	push	{r3, r4, r5, lr}
   1c93a:	4604      	mov	r4, r0
	while (next != NULL) {
   1c93c:	b904      	cbnz	r4, 1c940 <nrf91_socket_offload_freeaddrinfo+0x8>
}
   1c93e:	bd38      	pop	{r3, r4, r5, pc}
		k_free(this->ai_addr);
   1c940:	69a0      	ldr	r0, [r4, #24]
		next = next->ai_next;
   1c942:	6825      	ldr	r5, [r4, #0]
		k_free(this->ai_addr);
   1c944:	f000 fc9d 	bl	1d282 <k_free>
		k_free(this);
   1c948:	4620      	mov	r0, r4
   1c94a:	f000 fc9a 	bl	1d282 <k_free>
		next = next->ai_next;
   1c94e:	462c      	mov	r4, r5
   1c950:	e7f4      	b.n	1c93c <nrf91_socket_offload_freeaddrinfo+0x4>

0001c952 <z_to_nrf_addrinfo_hints>:
{
   1c952:	b538      	push	{r3, r4, r5, lr}
   1c954:	460c      	mov	r4, r1
   1c956:	4605      	mov	r5, r0
	memset(nrf_out, 0, sizeof(struct nrf_addrinfo));
   1c958:	2220      	movs	r2, #32
   1c95a:	2100      	movs	r1, #0
   1c95c:	4620      	mov	r0, r4
   1c95e:	f7ff fb6c 	bl	1c03a <memset>
	nrf_out->ai_flags = z_to_nrf_addrinfo_flags(z_in->ai_flags);
   1c962:	2300      	movs	r3, #0
   1c964:	6023      	str	r3, [r4, #0]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   1c966:	68eb      	ldr	r3, [r5, #12]
	switch (socktype) {
   1c968:	2b03      	cmp	r3, #3
   1c96a:	d003      	beq.n	1c974 <z_to_nrf_addrinfo_hints+0x22>
   1c96c:	2b04      	cmp	r3, #4
   1c96e:	bf08      	it	eq
   1c970:	f44f 7300 	moveq.w	r3, #512	; 0x200
	family = z_to_nrf_family(z_in->ai_family);
   1c974:	8928      	ldrh	r0, [r5, #8]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   1c976:	60a3      	str	r3, [r4, #8]
	family = z_to_nrf_family(z_in->ai_family);
   1c978:	f7ff feed 	bl	1c756 <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   1c97c:	f110 0f2f 	cmn.w	r0, #47	; 0x2f
   1c980:	d00b      	beq.n	1c99a <z_to_nrf_addrinfo_hints+0x48>
	nrf_out->ai_family = family;
   1c982:	6060      	str	r0, [r4, #4]
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   1c984:	6928      	ldr	r0, [r5, #16]
   1c986:	f7ff ff02 	bl	1c78e <z_to_nrf_protocol>
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   1c98a:	f110 0f2b 	cmn.w	r0, #43	; 0x2b
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   1c98e:	60e0      	str	r0, [r4, #12]
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   1c990:	d003      	beq.n	1c99a <z_to_nrf_addrinfo_hints+0x48>
	if (z_in->ai_canonname != NULL) {
   1c992:	69e8      	ldr	r0, [r5, #28]
   1c994:	b108      	cbz	r0, 1c99a <z_to_nrf_addrinfo_hints+0x48>
		nrf_out->ai_canonname = z_in->ai_canonname;
   1c996:	61a0      	str	r0, [r4, #24]
	return 0;
   1c998:	2000      	movs	r0, #0
}
   1c99a:	bd38      	pop	{r3, r4, r5, pc}

0001c99c <nrf91_socket_offload_connect>:
{
   1c99c:	b570      	push	{r4, r5, r6, lr}
	if (addr->sa_family == AF_INET) {
   1c99e:	880b      	ldrh	r3, [r1, #0]
{
   1c9a0:	460c      	mov	r4, r1
	if (addr->sa_family == AF_INET) {
   1c9a2:	2b01      	cmp	r3, #1
{
   1c9a4:	b08a      	sub	sp, #40	; 0x28
	int sd = OBJ_TO_SD(obj);
   1c9a6:	f100 35ff 	add.w	r5, r0, #4294967295
	if (addr->sa_family == AF_INET) {
   1c9aa:	d10f      	bne.n	1c9cc <nrf91_socket_offload_connect+0x30>
	nrf_out->sin_port = ptr->sin_port;
   1c9ac:	884b      	ldrh	r3, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1c9ae:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   1c9b0:	f8ad 300c 	strh.w	r3, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   1c9b4:	2302      	movs	r3, #2
   1c9b6:	9302      	str	r3, [sp, #8]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1c9b8:	684b      	ldr	r3, [r1, #4]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1c9ba:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1c9be:	9304      	str	r3, [sp, #16]
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   1c9c0:	4628      	mov	r0, r5
   1c9c2:	a901      	add	r1, sp, #4
   1c9c4:	f7fb f848 	bl	17a58 <nrf_connect>
}
   1c9c8:	b00a      	add	sp, #40	; 0x28
   1c9ca:	bd70      	pop	{r4, r5, r6, pc}
	} else if (addr->sa_family == AF_INET6) {
   1c9cc:	2b02      	cmp	r3, #2
   1c9ce:	d110      	bne.n	1c9f2 <nrf91_socket_offload_connect+0x56>
	nrf_out->sin6_port = ptr->sin6_port;
   1c9d0:	884b      	ldrh	r3, [r1, #2]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1c9d2:	2624      	movs	r6, #36	; 0x24
	nrf_out->sin6_port = ptr->sin6_port;
   1c9d4:	f8ad 300c 	strh.w	r3, [sp, #12]
	nrf_out->sin6_family = NRF_AF_INET6;
   1c9d8:	230a      	movs	r3, #10
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1c9da:	2210      	movs	r2, #16
   1c9dc:	3104      	adds	r1, #4
   1c9de:	a805      	add	r0, sp, #20
	nrf_out->sin6_family = NRF_AF_INET6;
   1c9e0:	9302      	str	r3, [sp, #8]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1c9e2:	f88d 6004 	strb.w	r6, [sp, #4]
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1c9e6:	f7ff fafd 	bl	1bfe4 <memcpy>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1c9ea:	7d23      	ldrb	r3, [r4, #20]
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   1c9ec:	4632      	mov	r2, r6
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1c9ee:	9309      	str	r3, [sp, #36]	; 0x24
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   1c9f0:	e7e6      	b.n	1c9c0 <nrf91_socket_offload_connect+0x24>
		retval = nrf_connect(sd, (void *)addr, addrlen);
   1c9f2:	4628      	mov	r0, r5
   1c9f4:	f7fb f830 	bl	17a58 <nrf_connect>
		if (retval < 0) {
   1c9f8:	2800      	cmp	r0, #0
   1c9fa:	dae5      	bge.n	1c9c8 <nrf91_socket_offload_connect+0x2c>
	errno = ENOTSUP;
   1c9fc:	f7ff fef8 	bl	1c7f0 <z_errno>
   1ca00:	2323      	movs	r3, #35	; 0x23
   1ca02:	6003      	str	r3, [r0, #0]
   1ca04:	f04f 30ff 	mov.w	r0, #4294967295
   1ca08:	e7de      	b.n	1c9c8 <nrf91_socket_offload_connect+0x2c>

0001ca0a <nrf91_socket_offload_getaddrinfo>:
{
   1ca0a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ca0e:	4614      	mov	r4, r2
   1ca10:	460e      	mov	r6, r1
	struct nrf_addrinfo *nrf_res = NULL;
   1ca12:	2100      	movs	r1, #0
{
   1ca14:	b093      	sub	sp, #76	; 0x4c
   1ca16:	4605      	mov	r5, r0
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   1ca18:	2220      	movs	r2, #32
   1ca1a:	a802      	add	r0, sp, #8
{
   1ca1c:	4698      	mov	r8, r3
	struct nrf_addrinfo *nrf_res = NULL;
   1ca1e:	9101      	str	r1, [sp, #4]
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   1ca20:	f7ff fb0b 	bl	1c03a <memset>
	if (hints != NULL) {
   1ca24:	b194      	cbz	r4, 1ca4c <nrf91_socket_offload_getaddrinfo+0x42>
		error = z_to_nrf_addrinfo_hints(hints, &nrf_hints);
   1ca26:	4620      	mov	r0, r4
   1ca28:	a902      	add	r1, sp, #8
   1ca2a:	f7ff ff92 	bl	1c952 <z_to_nrf_addrinfo_hints>
		if (error == -EPROTONOSUPPORT) {
   1ca2e:	f110 0f2b 	cmn.w	r0, #43	; 0x2b
   1ca32:	f000 80d8 	beq.w	1cbe6 <nrf91_socket_offload_getaddrinfo+0x1dc>
		} else if (error == -EAFNOSUPPORT) {
   1ca36:	302f      	adds	r0, #47	; 0x2f
   1ca38:	f000 80d8 	beq.w	1cbec <nrf91_socket_offload_getaddrinfo+0x1e2>
		if (hints->ai_next != NULL) {
   1ca3c:	6820      	ldr	r0, [r4, #0]
   1ca3e:	b120      	cbz	r0, 1ca4a <nrf91_socket_offload_getaddrinfo+0x40>
			z_to_nrf_addrinfo_hints(hints->ai_next, &nrf_hints_pdn);
   1ca40:	ac0a      	add	r4, sp, #40	; 0x28
   1ca42:	4621      	mov	r1, r4
   1ca44:	f7ff ff85 	bl	1c952 <z_to_nrf_addrinfo_hints>
			nrf_hints.ai_next = &nrf_hints_pdn;
   1ca48:	9409      	str	r4, [sp, #36]	; 0x24
		nrf_hints_ptr = &nrf_hints;
   1ca4a:	ac02      	add	r4, sp, #8
	int retval = nrf_getaddrinfo(node, service, nrf_hints_ptr, &nrf_res);
   1ca4c:	4628      	mov	r0, r5
   1ca4e:	4622      	mov	r2, r4
   1ca50:	4631      	mov	r1, r6
   1ca52:	ab01      	add	r3, sp, #4
   1ca54:	f7fb f882 	bl	17b5c <nrf_getaddrinfo>
	if (retval != 0) {
   1ca58:	4605      	mov	r5, r0
   1ca5a:	b1b8      	cbz	r0, 1ca8c <nrf91_socket_offload_getaddrinfo+0x82>
	switch (nrf_error) {
   1ca5c:	282f      	cmp	r0, #47	; 0x2f
   1ca5e:	f000 80c8 	beq.w	1cbf2 <nrf91_socket_offload_getaddrinfo+0x1e8>
   1ca62:	dc0c      	bgt.n	1ca7e <nrf91_socket_offload_getaddrinfo+0x74>
   1ca64:	280c      	cmp	r0, #12
   1ca66:	f000 80c7 	beq.w	1cbf8 <nrf91_socket_offload_getaddrinfo+0x1ee>
   1ca6a:	2823      	cmp	r0, #35	; 0x23
   1ca6c:	bf14      	ite	ne
   1ca6e:	f06f 050a 	mvnne.w	r5, #10
   1ca72:	f06f 0502 	mvneq.w	r5, #2
}
   1ca76:	4628      	mov	r0, r5
   1ca78:	b013      	add	sp, #76	; 0x4c
   1ca7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return DNS_EAI_INPROGRESS;
   1ca7e:	2873      	cmp	r0, #115	; 0x73
   1ca80:	bf14      	ite	ne
   1ca82:	f06f 050a 	mvnne.w	r5, #10
   1ca86:	f06f 0563 	mvneq.w	r5, #99	; 0x63
   1ca8a:	e7f4      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>
	struct zsock_addrinfo *latest_z_res = NULL;
   1ca8c:	4681      	mov	r9, r0
	z_out->ai_next = NULL;
   1ca8e:	4682      	mov	sl, r0
	struct nrf_addrinfo *next_nrf_res = nrf_res;
   1ca90:	9e01      	ldr	r6, [sp, #4]
	*res = NULL;
   1ca92:	f8c8 0000 	str.w	r0, [r8]
	while ((retval == 0) && (next_nrf_res != NULL)) {
   1ca96:	b91e      	cbnz	r6, 1caa0 <nrf91_socket_offload_getaddrinfo+0x96>
	nrf_freeaddrinfo(nrf_res);
   1ca98:	9801      	ldr	r0, [sp, #4]
   1ca9a:	f7fb f861 	bl	17b60 <nrf_freeaddrinfo>
	return retval;
   1ca9e:	e7ea      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>
					k_malloc(sizeof(struct zsock_addrinfo));
   1caa0:	2050      	movs	r0, #80	; 0x50
   1caa2:	f7fd fb01 	bl	1a0a8 <k_malloc>
		if (next_z_res == NULL) {
   1caa6:	4604      	mov	r4, r0
   1caa8:	2800      	cmp	r0, #0
   1caaa:	f000 808f 	beq.w	1cbcc <nrf91_socket_offload_getaddrinfo+0x1c2>
	z_out->ai_socktype = nrf_in->ai_socktype;
   1caae:	68b3      	ldr	r3, [r6, #8]
	z_out->ai_next = NULL;
   1cab0:	f8c0 a000 	str.w	sl, [r0]
	z_out->ai_socktype = nrf_in->ai_socktype;
   1cab4:	60c3      	str	r3, [r0, #12]
	family = nrf_to_z_family(nrf_in->ai_family);
   1cab6:	6873      	ldr	r3, [r6, #4]
	z_out->ai_canonname = NULL; /* TODO Do proper content copy. */
   1cab8:	f8c0 a01c 	str.w	sl, [r0, #28]
	switch (nrf_family) {
   1cabc:	2b0a      	cmp	r3, #10
	z_out->ai_flags = nrf_to_z_addrinfo_flags(nrf_in->ai_flags);
   1cabe:	f8c0 a004 	str.w	sl, [r0, #4]
	switch (nrf_family) {
   1cac2:	dc23      	bgt.n	1cb0c <nrf91_socket_offload_getaddrinfo+0x102>
   1cac4:	2b00      	cmp	r3, #0
   1cac6:	dd23      	ble.n	1cb10 <nrf91_socket_offload_getaddrinfo+0x106>
   1cac8:	1e5a      	subs	r2, r3, #1
   1caca:	2a09      	cmp	r2, #9
   1cacc:	d820      	bhi.n	1cb10 <nrf91_socket_offload_getaddrinfo+0x106>
   1cace:	e8df f002 	tbb	[pc, r2]
   1cad2:	2905      	.short	0x2905
   1cad4:	1f251f1f 	.word	0x1f251f1f
   1cad8:	271f1f1f 	.word	0x271f1f1f
		return AF_LOCAL;
   1cadc:	2206      	movs	r2, #6
	z_out->ai_family = family;
   1cade:	60a2      	str	r2, [r4, #8]
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   1cae0:	68f2      	ldr	r2, [r6, #12]
	switch (proto) {
   1cae2:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   1cae6:	d04c      	beq.n	1cb82 <nrf91_socket_offload_getaddrinfo+0x178>
   1cae8:	dc26      	bgt.n	1cb38 <nrf91_socket_offload_getaddrinfo+0x12e>
   1caea:	2a02      	cmp	r2, #2
   1caec:	d04c      	beq.n	1cb88 <nrf91_socket_offload_getaddrinfo+0x17e>
   1caee:	dc1d      	bgt.n	1cb2c <nrf91_socket_offload_getaddrinfo+0x122>
   1caf0:	b372      	cbz	r2, 1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
   1caf2:	2a01      	cmp	r2, #1
   1caf4:	d04a      	beq.n	1cb8c <nrf91_socket_offload_getaddrinfo+0x182>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   1caf6:	f06f 032a 	mvn.w	r3, #42	; 0x2a
   1cafa:	6123      	str	r3, [r4, #16]
		z_out->ai_addr = NULL;
   1cafc:	2300      	movs	r3, #0
   1cafe:	61a3      	str	r3, [r4, #24]
			k_free(next_z_res);
   1cb00:	4620      	mov	r0, r4
   1cb02:	f000 fbbe 	bl	1d282 <k_free>
			retval = DNS_EAI_SOCKTYPE;
   1cb06:	f06f 0506 	mvn.w	r5, #6
   1cb0a:	e061      	b.n	1cbd0 <nrf91_socket_offload_getaddrinfo+0x1c6>
	switch (nrf_family) {
   1cb0c:	2b66      	cmp	r3, #102	; 0x66
   1cb0e:	d00b      	beq.n	1cb28 <nrf91_socket_offload_getaddrinfo+0x11e>
			k_free(next_z_res);
   1cb10:	4620      	mov	r0, r4
   1cb12:	f000 fbb6 	bl	1d282 <k_free>
			retval = DNS_EAI_ADDRFAMILY;
   1cb16:	f06f 0508 	mvn.w	r5, #8
   1cb1a:	e059      	b.n	1cbd0 <nrf91_socket_offload_getaddrinfo+0x1c6>
		return AF_PACKET;
   1cb1c:	2203      	movs	r2, #3
   1cb1e:	e7de      	b.n	1cade <nrf91_socket_offload_getaddrinfo+0xd4>
		return AF_INET6;
   1cb20:	2202      	movs	r2, #2
   1cb22:	e7dc      	b.n	1cade <nrf91_socket_offload_getaddrinfo+0xd4>
	switch (nrf_family) {
   1cb24:	2201      	movs	r2, #1
   1cb26:	e7da      	b.n	1cade <nrf91_socket_offload_getaddrinfo+0xd4>
		return AF_LTE;
   1cb28:	461a      	mov	r2, r3
   1cb2a:	e7d8      	b.n	1cade <nrf91_socket_offload_getaddrinfo+0xd4>
	switch (proto) {
   1cb2c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   1cb30:	d1e1      	bne.n	1caf6 <nrf91_socket_offload_getaddrinfo+0xec>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   1cb32:	f44f 7281 	mov.w	r2, #258	; 0x102
   1cb36:	e00b      	b.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
	switch (proto) {
   1cb38:	f240 2102 	movw	r1, #514	; 0x202
   1cb3c:	428a      	cmp	r2, r1
   1cb3e:	d007      	beq.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
   1cb40:	f240 2103 	movw	r1, #515	; 0x203
   1cb44:	428a      	cmp	r2, r1
   1cb46:	d003      	beq.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
   1cb48:	f240 2101 	movw	r1, #513	; 0x201
   1cb4c:	428a      	cmp	r2, r1
   1cb4e:	d1d2      	bne.n	1caf6 <nrf91_socket_offload_getaddrinfo+0xec>
	if (nrf_in->ai_family == NRF_AF_INET) {
   1cb50:	2b02      	cmp	r3, #2
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   1cb52:	6122      	str	r2, [r4, #16]
	if (nrf_in->ai_family == NRF_AF_INET) {
   1cb54:	d11c      	bne.n	1cb90 <nrf91_socket_offload_getaddrinfo+0x186>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in));
   1cb56:	2008      	movs	r0, #8
   1cb58:	f7fd faa6 	bl	1a0a8 <k_malloc>
   1cb5c:	61a0      	str	r0, [r4, #24]
		if (z_out->ai_addr == NULL) {
   1cb5e:	b390      	cbz	r0, 1cbc6 <nrf91_socket_offload_getaddrinfo+0x1bc>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in);
   1cb60:	2308      	movs	r3, #8
   1cb62:	6163      	str	r3, [r4, #20]
			(const struct nrf_sockaddr_in *)nrf_in->ai_addr);
   1cb64:	6973      	ldr	r3, [r6, #20]
	ptr->sin_port = nrf_in->sin_port;
   1cb66:	891a      	ldrh	r2, [r3, #8]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   1cb68:	68db      	ldr	r3, [r3, #12]
	ptr->sin_port = nrf_in->sin_port;
   1cb6a:	8042      	strh	r2, [r0, #2]
	ptr->sin_family = AF_INET;
   1cb6c:	2201      	movs	r2, #1
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   1cb6e:	6043      	str	r3, [r0, #4]
	ptr->sin_family = AF_INET;
   1cb70:	8002      	strh	r2, [r0, #0]
		if (latest_z_res == NULL) {
   1cb72:	f1b9 0f00 	cmp.w	r9, #0
   1cb76:	d133      	bne.n	1cbe0 <nrf91_socket_offload_getaddrinfo+0x1d6>
			*res = next_z_res;
   1cb78:	f8c8 4000 	str.w	r4, [r8]
		next_nrf_res = next_nrf_res->ai_next;
   1cb7c:	46a1      	mov	r9, r4
   1cb7e:	69f6      	ldr	r6, [r6, #28]
   1cb80:	e789      	b.n	1ca96 <nrf91_socket_offload_getaddrinfo+0x8c>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   1cb82:	f240 1211 	movw	r2, #273	; 0x111
   1cb86:	e7e3      	b.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
   1cb88:	2211      	movs	r2, #17
   1cb8a:	e7e1      	b.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
   1cb8c:	2206      	movs	r2, #6
   1cb8e:	e7df      	b.n	1cb50 <nrf91_socket_offload_getaddrinfo+0x146>
	} else if (nrf_in->ai_family == NRF_AF_INET6) {
   1cb90:	2b0a      	cmp	r3, #10
   1cb92:	d1b5      	bne.n	1cb00 <nrf91_socket_offload_getaddrinfo+0xf6>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in6));
   1cb94:	2018      	movs	r0, #24
   1cb96:	f7fd fa87 	bl	1a0a8 <k_malloc>
   1cb9a:	4607      	mov	r7, r0
   1cb9c:	61a0      	str	r0, [r4, #24]
		if (z_out->ai_addr == NULL) {
   1cb9e:	b190      	cbz	r0, 1cbc6 <nrf91_socket_offload_getaddrinfo+0x1bc>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   1cba0:	2318      	movs	r3, #24
			(const struct nrf_sockaddr_in6 *)nrf_in->ai_addr);
   1cba2:	f8d6 b014 	ldr.w	fp, [r6, #20]
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   1cba6:	6163      	str	r3, [r4, #20]
	ptr->sin6_port = nrf_in->sin6_port;
   1cba8:	f8bb 3008 	ldrh.w	r3, [fp, #8]
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1cbac:	2210      	movs	r2, #16
	ptr->sin6_port = nrf_in->sin6_port;
   1cbae:	8043      	strh	r3, [r0, #2]
	ptr->sin6_family = AF_INET6;
   1cbb0:	2302      	movs	r3, #2
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1cbb2:	eb0b 0102 	add.w	r1, fp, r2
	ptr->sin6_family = AF_INET6;
   1cbb6:	f820 3b04 	strh.w	r3, [r0], #4
	memcpy(ptr->sin6_addr.s6_addr, nrf_in->sin6_addr.s6_addr,
   1cbba:	f7ff fa13 	bl	1bfe4 <memcpy>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   1cbbe:	f8db 3020 	ldr.w	r3, [fp, #32]
   1cbc2:	753b      	strb	r3, [r7, #20]
		} else if (error == -EAFNOSUPPORT) {
   1cbc4:	e7d5      	b.n	1cb72 <nrf91_socket_offload_getaddrinfo+0x168>
			k_free(next_z_res);
   1cbc6:	4620      	mov	r0, r4
   1cbc8:	f000 fb5b 	bl	1d282 <k_free>
			retval = DNS_EAI_MEMORY;
   1cbcc:	f06f 0509 	mvn.w	r5, #9
		nrf91_socket_offload_freeaddrinfo(*res);
   1cbd0:	f8d8 0000 	ldr.w	r0, [r8]
   1cbd4:	f7ff feb0 	bl	1c938 <nrf91_socket_offload_freeaddrinfo>
		*res = NULL;
   1cbd8:	2300      	movs	r3, #0
   1cbda:	f8c8 3000 	str.w	r3, [r8]
   1cbde:	e75b      	b.n	1ca98 <nrf91_socket_offload_getaddrinfo+0x8e>
			latest_z_res->ai_next = next_z_res;
   1cbe0:	f8c9 4000 	str.w	r4, [r9]
   1cbe4:	e7ca      	b.n	1cb7c <nrf91_socket_offload_getaddrinfo+0x172>
			return DNS_EAI_SOCKTYPE;
   1cbe6:	f06f 0506 	mvn.w	r5, #6
   1cbea:	e744      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>
			return DNS_EAI_ADDRFAMILY;
   1cbec:	f06f 0508 	mvn.w	r5, #8
   1cbf0:	e741      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>
		return DNS_EAI_NONAME;
   1cbf2:	f06f 0501 	mvn.w	r5, #1
   1cbf6:	e73e      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>
		return DNS_EAI_MEMORY;
   1cbf8:	f06f 0509 	mvn.w	r5, #9
   1cbfc:	e73b      	b.n	1ca76 <nrf91_socket_offload_getaddrinfo+0x6c>

0001cbfe <nrf91_socket_offload_sendto>:
{
   1cbfe:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1cc02:	b08d      	sub	sp, #52	; 0x34
   1cc04:	9c14      	ldr	r4, [sp, #80]	; 0x50
   1cc06:	460e      	mov	r6, r1
   1cc08:	4617      	mov	r7, r2
   1cc0a:	4698      	mov	r8, r3
	int sd = OBJ_TO_SD(obj);
   1cc0c:	1e45      	subs	r5, r0, #1
	if (to == NULL) {
   1cc0e:	b96c      	cbnz	r4, 1cc2c <nrf91_socket_offload_sendto+0x2e>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), NULL,
   1cc10:	4618      	mov	r0, r3
   1cc12:	f7ff fd96 	bl	1c742 <z_to_nrf_flags>
   1cc16:	4603      	mov	r3, r0
   1cc18:	e9cd 4400 	strd	r4, r4, [sp]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   1cc1c:	463a      	mov	r2, r7
   1cc1e:	4631      	mov	r1, r6
   1cc20:	4628      	mov	r0, r5
   1cc22:	f7fa fee1 	bl	179e8 <nrf_sendto>
}
   1cc26:	b00d      	add	sp, #52	; 0x34
   1cc28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (to->sa_family == AF_INET) {
   1cc2c:	8823      	ldrh	r3, [r4, #0]
   1cc2e:	2b01      	cmp	r3, #1
   1cc30:	d111      	bne.n	1cc56 <nrf91_socket_offload_sendto+0x58>
	nrf_out->sin_port = ptr->sin_port;
   1cc32:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1cc34:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   1cc36:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin_family = NRF_AF_INET;
   1cc3a:	2302      	movs	r3, #2
   1cc3c:	9304      	str	r3, [sp, #16]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1cc3e:	6863      	ldr	r3, [r4, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   1cc40:	4640      	mov	r0, r8
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1cc42:	9306      	str	r3, [sp, #24]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1cc44:	f88d 200c 	strb.w	r2, [sp, #12]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   1cc48:	f7ff fd7b 	bl	1c742 <z_to_nrf_flags>
   1cc4c:	4603      	mov	r3, r0
   1cc4e:	9201      	str	r2, [sp, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   1cc50:	aa03      	add	r2, sp, #12
   1cc52:	9200      	str	r2, [sp, #0]
   1cc54:	e7e2      	b.n	1cc1c <nrf91_socket_offload_sendto+0x1e>
	} else if (to->sa_family == AF_INET6) {
   1cc56:	2b02      	cmp	r3, #2
   1cc58:	d116      	bne.n	1cc88 <nrf91_socket_offload_sendto+0x8a>
	nrf_out->sin6_port = ptr->sin6_port;
   1cc5a:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1cc5c:	f04f 0924 	mov.w	r9, #36	; 0x24
	nrf_out->sin6_port = ptr->sin6_port;
   1cc60:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin6_family = NRF_AF_INET6;
   1cc64:	230a      	movs	r3, #10
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1cc66:	2210      	movs	r2, #16
   1cc68:	1d21      	adds	r1, r4, #4
   1cc6a:	a807      	add	r0, sp, #28
	nrf_out->sin6_family = NRF_AF_INET6;
   1cc6c:	9304      	str	r3, [sp, #16]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1cc6e:	f88d 900c 	strb.w	r9, [sp, #12]
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1cc72:	f7ff f9b7 	bl	1bfe4 <memcpy>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1cc76:	7d23      	ldrb	r3, [r4, #20]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   1cc78:	4640      	mov	r0, r8
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1cc7a:	930b      	str	r3, [sp, #44]	; 0x2c
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   1cc7c:	f7ff fd61 	bl	1c742 <z_to_nrf_flags>
   1cc80:	f8cd 9004 	str.w	r9, [sp, #4]
   1cc84:	4603      	mov	r3, r0
   1cc86:	e7e3      	b.n	1cc50 <nrf91_socket_offload_sendto+0x52>
	errno = ENOTSUP;
   1cc88:	f7ff fdb2 	bl	1c7f0 <z_errno>
   1cc8c:	2323      	movs	r3, #35	; 0x23
   1cc8e:	6003      	str	r3, [r0, #0]
	return retval;
   1cc90:	f04f 30ff 	mov.w	r0, #4294967295
   1cc94:	e7c7      	b.n	1cc26 <nrf91_socket_offload_sendto+0x28>

0001cc96 <nrf91_socket_offload_write>:
	return nrf91_socket_offload_sendto(obj, buffer, count, 0, NULL, 0);
   1cc96:	2300      	movs	r3, #0
{
   1cc98:	b507      	push	{r0, r1, r2, lr}
	return nrf91_socket_offload_sendto(obj, buffer, count, 0, NULL, 0);
   1cc9a:	e9cd 3300 	strd	r3, r3, [sp]
   1cc9e:	f7ff ffae 	bl	1cbfe <nrf91_socket_offload_sendto>
}
   1cca2:	b003      	add	sp, #12
   1cca4:	f85d fb04 	ldr.w	pc, [sp], #4

0001cca8 <nrf91_socket_offload_setsockopt>:
{
   1cca8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1ccac:	461d      	mov	r5, r3
	switch (z_in_level) {
   1ccae:	f240 2302 	movw	r3, #514	; 0x202
{
   1ccb2:	b086      	sub	sp, #24
	switch (z_in_level) {
   1ccb4:	4299      	cmp	r1, r3
{
   1ccb6:	460c      	mov	r4, r1
   1ccb8:	4616      	mov	r6, r2
   1ccba:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	int sd = OBJ_TO_SD(obj);
   1ccbc:	f100 38ff 	add.w	r8, r0, #4294967295
	switch (z_in_level) {
   1ccc0:	d005      	beq.n	1ccce <nrf91_socket_offload_setsockopt+0x26>
   1ccc2:	dc1f      	bgt.n	1cd04 <nrf91_socket_offload_setsockopt+0x5c>
   1ccc4:	2901      	cmp	r1, #1
   1ccc6:	d002      	beq.n	1ccce <nrf91_socket_offload_setsockopt+0x26>
   1ccc8:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   1cccc:	d125      	bne.n	1cd1a <nrf91_socket_offload_setsockopt+0x72>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   1ccce:	4631      	mov	r1, r6
   1ccd0:	4620      	mov	r0, r4
   1ccd2:	aa03      	add	r2, sp, #12
   1ccd4:	f7f3 fb3c 	bl	10350 <z_to_nrf_optname>
   1ccd8:	2800      	cmp	r0, #0
   1ccda:	db1e      	blt.n	1cd1a <nrf91_socket_offload_setsockopt+0x72>
	if ((level == SOL_SOCKET) && (optname == SO_RCVTIMEO)) {
   1ccdc:	2c01      	cmp	r4, #1
   1ccde:	d115      	bne.n	1cd0c <nrf91_socket_offload_setsockopt+0x64>
   1cce0:	2e14      	cmp	r6, #20
   1cce2:	d105      	bne.n	1ccf0 <nrf91_socket_offload_setsockopt+0x48>
		nrf_optlen = sizeof(struct nrf_timeval);
   1cce4:	2708      	movs	r7, #8
		nrf_rcvtimeo.tv_sec = ((struct timeval *)optval)->tv_sec;
   1cce6:	682b      	ldr	r3, [r5, #0]
   1cce8:	9304      	str	r3, [sp, #16]
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   1ccea:	686b      	ldr	r3, [r5, #4]
		nrf_optval = &nrf_rcvtimeo;
   1ccec:	ad04      	add	r5, sp, #16
		nrf_rcvtimeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   1ccee:	9305      	str	r3, [sp, #20]
	retval = nrf_setsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   1ccf0:	462b      	mov	r3, r5
   1ccf2:	4621      	mov	r1, r4
   1ccf4:	4640      	mov	r0, r8
   1ccf6:	9a03      	ldr	r2, [sp, #12]
   1ccf8:	9700      	str	r7, [sp, #0]
   1ccfa:	f7fa fef7 	bl	17aec <nrf_setsockopt>
}
   1ccfe:	b006      	add	sp, #24
   1cd00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   1cd04:	f240 2303 	movw	r3, #515	; 0x203
   1cd08:	4299      	cmp	r1, r3
   1cd0a:	e7df      	b.n	1cccc <nrf91_socket_offload_setsockopt+0x24>
	} else if ((level == SOL_TLS) && (optname == TLS_SESSION_CACHE)) {
   1cd0c:	f5b4 7f8d 	cmp.w	r4, #282	; 0x11a
   1cd10:	d1ee      	bne.n	1ccf0 <nrf91_socket_offload_setsockopt+0x48>
		nrf_optlen = sizeof(nrf_sec_session_cache_t);
   1cd12:	2e07      	cmp	r6, #7
   1cd14:	bf08      	it	eq
   1cd16:	2701      	moveq	r7, #1
   1cd18:	e7ea      	b.n	1ccf0 <nrf91_socket_offload_setsockopt+0x48>
	errno = ENOPROTOOPT;
   1cd1a:	f7ff fd69 	bl	1c7f0 <z_errno>
   1cd1e:	232a      	movs	r3, #42	; 0x2a
   1cd20:	6003      	str	r3, [r0, #0]
   1cd22:	f04f 30ff 	mov.w	r0, #4294967295
   1cd26:	e7ea      	b.n	1ccfe <nrf91_socket_offload_setsockopt+0x56>

0001cd28 <nrf91_socket_offload_bind>:
{
   1cd28:	b570      	push	{r4, r5, r6, lr}
	if (addr->sa_family == AF_INET) {
   1cd2a:	880b      	ldrh	r3, [r1, #0]
{
   1cd2c:	460c      	mov	r4, r1
	if (addr->sa_family == AF_INET) {
   1cd2e:	2b01      	cmp	r3, #1
{
   1cd30:	b08a      	sub	sp, #40	; 0x28
	int sd = OBJ_TO_SD(obj);
   1cd32:	f100 35ff 	add.w	r5, r0, #4294967295
	if (addr->sa_family == AF_INET) {
   1cd36:	d10f      	bne.n	1cd58 <nrf91_socket_offload_bind+0x30>
	nrf_out->sin_port = ptr->sin_port;
   1cd38:	884b      	ldrh	r3, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1cd3a:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   1cd3c:	f8ad 300c 	strh.w	r3, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   1cd40:	2302      	movs	r3, #2
   1cd42:	9302      	str	r3, [sp, #8]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1cd44:	684b      	ldr	r3, [r1, #4]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   1cd46:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   1cd4a:	9304      	str	r3, [sp, #16]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   1cd4c:	4628      	mov	r0, r5
   1cd4e:	a901      	add	r1, sp, #4
   1cd50:	f7fa feba 	bl	17ac8 <nrf_bind>
}
   1cd54:	b00a      	add	sp, #40	; 0x28
   1cd56:	bd70      	pop	{r4, r5, r6, pc}
	} else if (addr->sa_family == AF_INET6) {
   1cd58:	2b02      	cmp	r3, #2
   1cd5a:	d110      	bne.n	1cd7e <nrf91_socket_offload_bind+0x56>
	nrf_out->sin6_port = ptr->sin6_port;
   1cd5c:	884b      	ldrh	r3, [r1, #2]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1cd5e:	2624      	movs	r6, #36	; 0x24
	nrf_out->sin6_port = ptr->sin6_port;
   1cd60:	f8ad 300c 	strh.w	r3, [sp, #12]
	nrf_out->sin6_family = NRF_AF_INET6;
   1cd64:	230a      	movs	r3, #10
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1cd66:	2210      	movs	r2, #16
   1cd68:	3104      	adds	r1, #4
   1cd6a:	a805      	add	r0, sp, #20
	nrf_out->sin6_family = NRF_AF_INET6;
   1cd6c:	9302      	str	r3, [sp, #8]
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   1cd6e:	f88d 6004 	strb.w	r6, [sp, #4]
	memcpy(nrf_out->sin6_addr.s6_addr, ptr->sin6_addr.s6_addr,
   1cd72:	f7ff f937 	bl	1bfe4 <memcpy>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1cd76:	7d23      	ldrb	r3, [r4, #20]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   1cd78:	4632      	mov	r2, r6
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   1cd7a:	9309      	str	r3, [sp, #36]	; 0x24
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   1cd7c:	e7e6      	b.n	1cd4c <nrf91_socket_offload_bind+0x24>
	errno = ENOTSUP;
   1cd7e:	f7ff fd37 	bl	1c7f0 <z_errno>
   1cd82:	2323      	movs	r3, #35	; 0x23
   1cd84:	6003      	str	r3, [r0, #0]
   1cd86:	f04f 30ff 	mov.w	r0, #4294967295
   1cd8a:	e7e3      	b.n	1cd54 <nrf91_socket_offload_bind+0x2c>

0001cd8c <z_impl_uart_irq_rx_enable>:
	if (api->irq_rx_enable) {
   1cd8c:	6883      	ldr	r3, [r0, #8]
   1cd8e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1cd90:	b103      	cbz	r3, 1cd94 <z_impl_uart_irq_rx_enable+0x8>
		api->irq_rx_enable(dev);
   1cd92:	4718      	bx	r3
}
   1cd94:	4770      	bx	lr

0001cd96 <response_handler>:
	write_uart_string(response);
   1cd96:	4608      	mov	r0, r1
   1cd98:	f7f3 bf32 	b.w	10c00 <write_uart_string>

0001cd9c <is_lfcr>:
	if ((chr == '\r') || (chr == '\n')) {
   1cd9c:	280d      	cmp	r0, #13
   1cd9e:	d004      	beq.n	1cdaa <is_lfcr+0xe>
   1cda0:	f1a0 030a 	sub.w	r3, r0, #10
   1cda4:	4258      	negs	r0, r3
   1cda6:	4158      	adcs	r0, r3
   1cda8:	4770      	bx	lr
		return true;
   1cdaa:	2001      	movs	r0, #1
}
   1cdac:	4770      	bx	lr

0001cdae <skip_command_prefix>:
{
   1cdae:	b510      	push	{r4, lr}
	*cmd += sizeof("AT") - 1;
   1cdb0:	6801      	ldr	r1, [r0, #0]
{
   1cdb2:	4602      	mov	r2, r0
	*cmd += sizeof("AT") - 1;
   1cdb4:	1c8b      	adds	r3, r1, #2
   1cdb6:	6003      	str	r3, [r0, #0]
	if (is_lfcr(**cmd) || is_terminated(**cmd)) {
   1cdb8:	788c      	ldrb	r4, [r1, #2]
   1cdba:	4620      	mov	r0, r4
   1cdbc:	f7ff ffee 	bl	1cd9c <is_lfcr>
   1cdc0:	b910      	cbnz	r0, 1cdc8 <skip_command_prefix+0x1a>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1cdc2:	b10c      	cbz	r4, 1cdc8 <skip_command_prefix+0x1a>
	(*cmd)++;
   1cdc4:	3103      	adds	r1, #3
   1cdc6:	6011      	str	r1, [r2, #0]
}
   1cdc8:	bd10      	pop	{r4, pc}

0001cdca <is_valid_notification_char>:
	return (chr >= (int)'A' && chr <= (int)'Z') ? (chr + 32) : (chr);
}

static inline int toupper(int chr)
{
	return (int)((chr >= (int)'a' && chr <=
   1cdca:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
   1cdce:	2b19      	cmp	r3, #25
   1cdd0:	bf98      	it	ls
   1cdd2:	3820      	subls	r0, #32
	if ((chr >= 'A') && (chr <= 'Z')) {
   1cdd4:	3841      	subs	r0, #65	; 0x41
   1cdd6:	b2c0      	uxtb	r0, r0
}
   1cdd8:	2819      	cmp	r0, #25
   1cdda:	bf8c      	ite	hi
   1cddc:	2000      	movhi	r0, #0
   1cdde:	2001      	movls	r0, #1
   1cde0:	4770      	bx	lr

0001cde2 <is_command>:
 *
 * @retval true  If the string is an AT command
 * @retval false Otherwise
 */
static inline bool is_command(const char *str)
{
   1cde2:	b510      	push	{r4, lr}
   1cde4:	4604      	mov	r4, r0
	if (strlen(str) < 2) {
   1cde6:	f7ff f8cb 	bl	1bf80 <strlen>
   1cdea:	2801      	cmp	r0, #1
   1cdec:	d91e      	bls.n	1ce2c <is_command+0x4a>
		return false;
	}

	if ((toupper((int)str[0]) != 'A') || (toupper((int)str[1]) != 'T')) {
   1cdee:	7823      	ldrb	r3, [r4, #0]
   1cdf0:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
   1cdf4:	2a19      	cmp	r2, #25
   1cdf6:	bf98      	it	ls
   1cdf8:	3b20      	subls	r3, #32
   1cdfa:	2b41      	cmp	r3, #65	; 0x41
   1cdfc:	d116      	bne.n	1ce2c <is_command+0x4a>
   1cdfe:	7863      	ldrb	r3, [r4, #1]
   1ce00:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
   1ce04:	2a19      	cmp	r2, #25
   1ce06:	bf98      	it	ls
   1ce08:	3b20      	subls	r3, #32
   1ce0a:	2b54      	cmp	r3, #84	; 0x54
   1ce0c:	d10e      	bne.n	1ce2c <is_command+0x4a>
	}

	/* Third character has be one of the command special characters.
	 * The special case is a lone "AT" command.
	 */
	if ((str[2] == AT_STANDARD_NOTIFICATION_PREFIX) ||
   1ce0e:	78a2      	ldrb	r2, [r4, #2]
   1ce10:	2a25      	cmp	r2, #37	; 0x25
   1ce12:	d00d      	beq.n	1ce30 <is_command+0x4e>
	    (str[2] == AT_PROP_NOTIFICATION_PREFX) ||
   1ce14:	f002 03f7 	and.w	r3, r2, #247	; 0xf7
   1ce18:	2b23      	cmp	r3, #35	; 0x23
   1ce1a:	d009      	beq.n	1ce30 <is_command+0x4e>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
	    is_lfcr(str[2]) || is_terminated(str[2])) {
   1ce1c:	4610      	mov	r0, r2
   1ce1e:	f7ff ffbd 	bl	1cd9c <is_lfcr>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
   1ce22:	b910      	cbnz	r0, 1ce2a <is_command+0x48>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   1ce24:	fab2 f082 	clz	r0, r2
   1ce28:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
   1ce2a:	bd10      	pop	{r4, pc}
		return false;
   1ce2c:	2000      	movs	r0, #0
   1ce2e:	e7fc      	b.n	1ce2a <is_command+0x48>
		return true;
   1ce30:	2001      	movs	r0, #1
   1ce32:	e7fa      	b.n	1ce2a <is_command+0x48>

0001ce34 <at_parser_params_from_str>:
	return at_parser_max_params_from_str(at_params_str, next_params_str,
   1ce34:	6813      	ldr	r3, [r2, #0]
   1ce36:	f7f4 b971 	b.w	1111c <at_parser_max_params_from_str>

0001ce3a <at_params_get>:
static struct at_param *at_params_get(const struct at_param_list *list,
				      size_t index)
{
	__ASSERT(list != NULL, "Parameter list cannot be NULL.");

	if (index >= list->param_count) {
   1ce3a:	6803      	ldr	r3, [r0, #0]
   1ce3c:	428b      	cmp	r3, r1
		return NULL;
	}

	struct at_param *param = list->params;

	return &param[index];
   1ce3e:	bf83      	ittte	hi
   1ce40:	230c      	movhi	r3, #12
   1ce42:	6840      	ldrhi	r0, [r0, #4]
   1ce44:	fb03 0001 	mlahi	r0, r3, r1, r0
		return NULL;
   1ce48:	2000      	movls	r0, #0
}
   1ce4a:	4770      	bx	lr

0001ce4c <at_param_size>:
/* Internal function. Parameter cannot be null. */
static size_t at_param_size(const struct at_param *param)
{
	__ASSERT(param != NULL, "Parameter cannot be NULL.");

	if (param->type == AT_PARAM_TYPE_NUM_SHORT) {
   1ce4c:	7803      	ldrb	r3, [r0, #0]
   1ce4e:	2b01      	cmp	r3, #1
   1ce50:	d006      	beq.n	1ce60 <at_param_size+0x14>
		return sizeof(u16_t);
	} else if (param->type == AT_PARAM_TYPE_NUM_INT) {
   1ce52:	2b02      	cmp	r3, #2
   1ce54:	d006      	beq.n	1ce64 <at_param_size+0x18>
		return sizeof(u32_t);
	} else if ((param->type == AT_PARAM_TYPE_STRING) ||
   1ce56:	3b03      	subs	r3, #3
   1ce58:	2b01      	cmp	r3, #1
   1ce5a:	d805      	bhi.n	1ce68 <at_param_size+0x1c>
		   (param->type == AT_PARAM_TYPE_ARRAY)) {
		return param->size;
   1ce5c:	6840      	ldr	r0, [r0, #4]
   1ce5e:	4770      	bx	lr
		return sizeof(u16_t);
   1ce60:	2002      	movs	r0, #2
   1ce62:	4770      	bx	lr
		return sizeof(u32_t);
   1ce64:	2004      	movs	r0, #4
   1ce66:	4770      	bx	lr
	}

	return 0;
   1ce68:	2000      	movs	r0, #0
}
   1ce6a:	4770      	bx	lr

0001ce6c <at_param_clear>:
{
   1ce6c:	b510      	push	{r4, lr}
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   1ce6e:	7803      	ldrb	r3, [r0, #0]
{
   1ce70:	4604      	mov	r4, r0
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   1ce72:	3b03      	subs	r3, #3
   1ce74:	2b01      	cmp	r3, #1
   1ce76:	d802      	bhi.n	1ce7e <at_param_clear+0x12>
		k_free(param->value.str_val);
   1ce78:	6880      	ldr	r0, [r0, #8]
   1ce7a:	f000 fa02 	bl	1d282 <k_free>
	param->value.int_val = 0;
   1ce7e:	2300      	movs	r3, #0
   1ce80:	60a3      	str	r3, [r4, #8]
}
   1ce82:	bd10      	pop	{r4, pc}

0001ce84 <at_params_list_init>:

int at_params_list_init(struct at_param_list *list, size_t max_params_count)
{
   1ce84:	b538      	push	{r3, r4, r5, lr}
   1ce86:	460d      	mov	r5, r1
	if (list == NULL) {
   1ce88:	4604      	mov	r4, r0
   1ce8a:	b140      	cbz	r0, 1ce9e <at_params_list_init+0x1a>
		return -EINVAL;
	}

	/* Array initialized with empty parameters. */
	list->params = k_calloc(max_params_count, sizeof(struct at_param));
   1ce8c:	210c      	movs	r1, #12
   1ce8e:	4628      	mov	r0, r5
   1ce90:	f000 f9fc 	bl	1d28c <k_calloc>
   1ce94:	6060      	str	r0, [r4, #4]
	if (list->params == NULL) {
   1ce96:	b128      	cbz	r0, 1cea4 <at_params_list_init+0x20>
		return -ENOMEM;
	}

	list->param_count = max_params_count;
	return 0;
   1ce98:	2000      	movs	r0, #0
	list->param_count = max_params_count;
   1ce9a:	6025      	str	r5, [r4, #0]
}
   1ce9c:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   1ce9e:	f06f 0015 	mvn.w	r0, #21
   1cea2:	e7fb      	b.n	1ce9c <at_params_list_init+0x18>
		return -ENOMEM;
   1cea4:	f06f 000b 	mvn.w	r0, #11
   1cea8:	e7f8      	b.n	1ce9c <at_params_list_init+0x18>

0001ceaa <at_params_list_clear>:

void at_params_list_clear(struct at_param_list *list)
{
   1ceaa:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (list == NULL || list->params == NULL) {
   1ceac:	4604      	mov	r4, r0
   1ceae:	b130      	cbz	r0, 1cebe <at_params_list_clear+0x14>
   1ceb0:	6843      	ldr	r3, [r0, #4]
   1ceb2:	b123      	cbz	r3, 1cebe <at_params_list_clear+0x14>
		return;
	}

	for (size_t i = 0; i < list->param_count; ++i) {
   1ceb4:	2500      	movs	r5, #0
		struct at_param *params = list->params;

		at_param_clear(&params[i]);
   1ceb6:	260c      	movs	r6, #12
	for (size_t i = 0; i < list->param_count; ++i) {
   1ceb8:	6823      	ldr	r3, [r4, #0]
   1ceba:	429d      	cmp	r5, r3
   1cebc:	d301      	bcc.n	1cec2 <at_params_list_clear+0x18>
		at_param_init(&params[i]);
	}
}
   1cebe:	b002      	add	sp, #8
   1cec0:	bd70      	pop	{r4, r5, r6, pc}
		at_param_clear(&params[i]);
   1cec2:	6860      	ldr	r0, [r4, #4]
   1cec4:	fb06 0005 	mla	r0, r6, r5, r0
   1cec8:	9001      	str	r0, [sp, #4]
   1ceca:	f7ff ffcf 	bl	1ce6c <at_param_clear>
	memset(param, 0, sizeof(struct at_param));
   1cece:	220c      	movs	r2, #12
   1ced0:	2100      	movs	r1, #0
   1ced2:	9801      	ldr	r0, [sp, #4]
   1ced4:	f7ff f8b1 	bl	1c03a <memset>
	for (size_t i = 0; i < list->param_count; ++i) {
   1ced8:	3501      	adds	r5, #1
   1ceda:	e7ed      	b.n	1ceb8 <at_params_list_clear+0xe>

0001cedc <at_params_list_free>:

void at_params_list_free(struct at_param_list *list)
{
   1cedc:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   1cede:	4604      	mov	r4, r0
   1cee0:	b148      	cbz	r0, 1cef6 <at_params_list_free+0x1a>
   1cee2:	6843      	ldr	r3, [r0, #4]
   1cee4:	b13b      	cbz	r3, 1cef6 <at_params_list_free+0x1a>
		return;
	}

	at_params_list_clear(list);

	list->param_count = 0;
   1cee6:	2500      	movs	r5, #0
	at_params_list_clear(list);
   1cee8:	f7ff ffdf 	bl	1ceaa <at_params_list_clear>
	k_free(list->params);
   1ceec:	6860      	ldr	r0, [r4, #4]
	list->param_count = 0;
   1ceee:	6025      	str	r5, [r4, #0]
	k_free(list->params);
   1cef0:	f000 f9c7 	bl	1d282 <k_free>
	list->params = NULL;
   1cef4:	6065      	str	r5, [r4, #4]
}
   1cef6:	bd38      	pop	{r3, r4, r5, pc}

0001cef8 <at_params_short_put>:

int at_params_short_put(const struct at_param_list *list, size_t index,
			u16_t value)
{
   1cef8:	b538      	push	{r3, r4, r5, lr}
   1cefa:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   1cefc:	b160      	cbz	r0, 1cf18 <at_params_short_put+0x20>
   1cefe:	6843      	ldr	r3, [r0, #4]
   1cf00:	b153      	cbz	r3, 1cf18 <at_params_short_put+0x20>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cf02:	f7ff ff9a 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1cf06:	4604      	mov	r4, r0
   1cf08:	b130      	cbz	r0, 1cf18 <at_params_short_put+0x20>
		return -EINVAL;
	}

	at_param_clear(param);
   1cf0a:	f7ff ffaf 	bl	1ce6c <at_param_clear>

	param->type = AT_PARAM_TYPE_NUM_SHORT;
   1cf0e:	2301      	movs	r3, #1
	param->value.int_val = (u32_t)(value & USHRT_MAX);
	return 0;
   1cf10:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   1cf12:	7023      	strb	r3, [r4, #0]
	param->value.int_val = (u32_t)(value & USHRT_MAX);
   1cf14:	60a5      	str	r5, [r4, #8]
}
   1cf16:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   1cf18:	f06f 0015 	mvn.w	r0, #21
   1cf1c:	e7fb      	b.n	1cf16 <at_params_short_put+0x1e>

0001cf1e <at_params_empty_put>:

int at_params_empty_put(const struct at_param_list *list, size_t index)
{
   1cf1e:	b510      	push	{r4, lr}
	if (list == NULL || list->params == NULL) {
   1cf20:	b160      	cbz	r0, 1cf3c <at_params_empty_put+0x1e>
   1cf22:	6843      	ldr	r3, [r0, #4]
   1cf24:	b153      	cbz	r3, 1cf3c <at_params_empty_put+0x1e>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cf26:	f7ff ff88 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1cf2a:	4604      	mov	r4, r0
   1cf2c:	b130      	cbz	r0, 1cf3c <at_params_empty_put+0x1e>
		return -EINVAL;
	}

	at_param_clear(param);
   1cf2e:	f7ff ff9d 	bl	1ce6c <at_param_clear>

	param->type = AT_PARAM_TYPE_EMPTY;
   1cf32:	2305      	movs	r3, #5
	param->value.int_val = 0;
   1cf34:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_EMPTY;
   1cf36:	7023      	strb	r3, [r4, #0]
	param->value.int_val = 0;
   1cf38:	60a0      	str	r0, [r4, #8]

	return 0;
}
   1cf3a:	bd10      	pop	{r4, pc}
		return -EINVAL;
   1cf3c:	f06f 0015 	mvn.w	r0, #21
   1cf40:	e7fb      	b.n	1cf3a <at_params_empty_put+0x1c>

0001cf42 <at_params_int_put>:

int at_params_int_put(const struct at_param_list *list, size_t index,
		      u32_t value)
{
   1cf42:	b538      	push	{r3, r4, r5, lr}
   1cf44:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   1cf46:	b160      	cbz	r0, 1cf62 <at_params_int_put+0x20>
   1cf48:	6843      	ldr	r3, [r0, #4]
   1cf4a:	b153      	cbz	r3, 1cf62 <at_params_int_put+0x20>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cf4c:	f7ff ff75 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1cf50:	4604      	mov	r4, r0
   1cf52:	b130      	cbz	r0, 1cf62 <at_params_int_put+0x20>
		return -EINVAL;
	}

	at_param_clear(param);
   1cf54:	f7ff ff8a 	bl	1ce6c <at_param_clear>

	param->type = AT_PARAM_TYPE_NUM_INT;
   1cf58:	2302      	movs	r3, #2
	param->value.int_val = value;
	return 0;
   1cf5a:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_NUM_INT;
   1cf5c:	7023      	strb	r3, [r4, #0]
	param->value.int_val = value;
   1cf5e:	60a5      	str	r5, [r4, #8]
}
   1cf60:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   1cf62:	f06f 0015 	mvn.w	r0, #21
   1cf66:	e7fb      	b.n	1cf60 <at_params_int_put+0x1e>

0001cf68 <at_params_string_put>:

int at_params_string_put(const struct at_param_list *list, size_t index,
			 const char *str, size_t str_len)
{
   1cf68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cf6a:	4617      	mov	r7, r2
   1cf6c:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || str == NULL) {
   1cf6e:	b1c0      	cbz	r0, 1cfa2 <at_params_string_put+0x3a>
   1cf70:	6843      	ldr	r3, [r0, #4]
   1cf72:	b1b3      	cbz	r3, 1cfa2 <at_params_string_put+0x3a>
   1cf74:	b1aa      	cbz	r2, 1cfa2 <at_params_string_put+0x3a>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cf76:	f7ff ff60 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1cf7a:	4604      	mov	r4, r0
   1cf7c:	b188      	cbz	r0, 1cfa2 <at_params_string_put+0x3a>
		return -EINVAL;
	}

	char *param_value = (char *)k_malloc(str_len + 1);
   1cf7e:	1c68      	adds	r0, r5, #1
   1cf80:	f7fd f892 	bl	1a0a8 <k_malloc>

	if (param_value == NULL) {
   1cf84:	4606      	mov	r6, r0
   1cf86:	b178      	cbz	r0, 1cfa8 <at_params_string_put+0x40>
		return -ENOMEM;
	}

	memcpy(param_value, str, str_len);
   1cf88:	462a      	mov	r2, r5
   1cf8a:	4639      	mov	r1, r7
   1cf8c:	f7ff f82a 	bl	1bfe4 <memcpy>

	at_param_clear(param);
   1cf90:	4620      	mov	r0, r4
   1cf92:	f7ff ff6b 	bl	1ce6c <at_param_clear>
	param->size = str_len;
	param->type = AT_PARAM_TYPE_STRING;
   1cf96:	2303      	movs	r3, #3
	param->value.str_val = param_value;

	return 0;
   1cf98:	2000      	movs	r0, #0
	param->size = str_len;
   1cf9a:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_STRING;
   1cf9c:	7023      	strb	r3, [r4, #0]
	param->value.str_val = param_value;
   1cf9e:	60a6      	str	r6, [r4, #8]
}
   1cfa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
   1cfa2:	f06f 0015 	mvn.w	r0, #21
   1cfa6:	e7fb      	b.n	1cfa0 <at_params_string_put+0x38>
		return -ENOMEM;
   1cfa8:	f06f 000b 	mvn.w	r0, #11
   1cfac:	e7f8      	b.n	1cfa0 <at_params_string_put+0x38>

0001cfae <at_params_array_put>:

int at_params_array_put(const struct at_param_list *list, size_t index,
			const u32_t *array, size_t array_len)
{
   1cfae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1cfb0:	4617      	mov	r7, r2
   1cfb2:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || array == NULL) {
   1cfb4:	b1c0      	cbz	r0, 1cfe8 <at_params_array_put+0x3a>
   1cfb6:	6843      	ldr	r3, [r0, #4]
   1cfb8:	b1b3      	cbz	r3, 1cfe8 <at_params_array_put+0x3a>
   1cfba:	b1aa      	cbz	r2, 1cfe8 <at_params_array_put+0x3a>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cfbc:	f7ff ff3d 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1cfc0:	4604      	mov	r4, r0
   1cfc2:	b188      	cbz	r0, 1cfe8 <at_params_array_put+0x3a>
		return -EINVAL;
	}

	u32_t *param_value = (u32_t *)k_malloc(array_len);
   1cfc4:	4628      	mov	r0, r5
   1cfc6:	f7fd f86f 	bl	1a0a8 <k_malloc>

	if (param_value == NULL) {
   1cfca:	4606      	mov	r6, r0
   1cfcc:	b178      	cbz	r0, 1cfee <at_params_array_put+0x40>
		return -ENOMEM;
	}

	memcpy(param_value, array, array_len);
   1cfce:	462a      	mov	r2, r5
   1cfd0:	4639      	mov	r1, r7
   1cfd2:	f7ff f807 	bl	1bfe4 <memcpy>

	at_param_clear(param);
   1cfd6:	4620      	mov	r0, r4
   1cfd8:	f7ff ff48 	bl	1ce6c <at_param_clear>
	param->size = array_len;
	param->type = AT_PARAM_TYPE_ARRAY;
   1cfdc:	2304      	movs	r3, #4
	param->value.array_val = param_value;

	return 0;
   1cfde:	2000      	movs	r0, #0
	param->size = array_len;
   1cfe0:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_ARRAY;
   1cfe2:	7023      	strb	r3, [r4, #0]
	param->value.array_val = param_value;
   1cfe4:	60a6      	str	r6, [r4, #8]
}
   1cfe6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
   1cfe8:	f06f 0015 	mvn.w	r0, #21
   1cfec:	e7fb      	b.n	1cfe6 <at_params_array_put+0x38>
		return -ENOMEM;
   1cfee:	f06f 000b 	mvn.w	r0, #11
   1cff2:	e7f8      	b.n	1cfe6 <at_params_array_put+0x38>

0001cff4 <at_params_int_get>:
	return 0;
}

int at_params_int_get(const struct at_param_list *list, size_t index,
		      u32_t *value)
{
   1cff4:	b508      	push	{r3, lr}
	if (list == NULL || list->params == NULL || value == NULL) {
   1cff6:	b168      	cbz	r0, 1d014 <at_params_int_get+0x20>
   1cff8:	6843      	ldr	r3, [r0, #4]
   1cffa:	b15b      	cbz	r3, 1d014 <at_params_int_get+0x20>
   1cffc:	b152      	cbz	r2, 1d014 <at_params_int_get+0x20>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1cffe:	f7ff ff1c 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1d002:	b138      	cbz	r0, 1d014 <at_params_int_get+0x20>
		return -EINVAL;
	}

	if ((param->type != AT_PARAM_TYPE_NUM_INT) &&
   1d004:	7803      	ldrb	r3, [r0, #0]
   1d006:	3b01      	subs	r3, #1
   1d008:	2b01      	cmp	r3, #1
   1d00a:	d803      	bhi.n	1d014 <at_params_int_get+0x20>
	    (param->type != AT_PARAM_TYPE_NUM_SHORT)) {
		return -EINVAL;
	}

	*value = param->value.int_val;
   1d00c:	6883      	ldr	r3, [r0, #8]
	return 0;
   1d00e:	2000      	movs	r0, #0
	*value = param->value.int_val;
   1d010:	6013      	str	r3, [r2, #0]
}
   1d012:	bd08      	pop	{r3, pc}
		return -EINVAL;
   1d014:	f06f 0015 	mvn.w	r0, #21
   1d018:	e7fb      	b.n	1d012 <at_params_int_get+0x1e>

0001d01a <at_params_string_get>:

int at_params_string_get(const struct at_param_list *list, size_t index,
			 char *value, size_t *len)
{
   1d01a:	b570      	push	{r4, r5, r6, lr}
   1d01c:	4616      	mov	r6, r2
   1d01e:	461c      	mov	r4, r3
	if (list == NULL || list->params == NULL || value == NULL ||
   1d020:	b1c0      	cbz	r0, 1d054 <at_params_string_get+0x3a>
   1d022:	6843      	ldr	r3, [r0, #4]
   1d024:	b1b3      	cbz	r3, 1d054 <at_params_string_get+0x3a>
   1d026:	b1aa      	cbz	r2, 1d054 <at_params_string_get+0x3a>
	    value == NULL || len == NULL) {
   1d028:	b1a4      	cbz	r4, 1d054 <at_params_string_get+0x3a>
		return -EINVAL;
	}

	struct at_param *param = at_params_get(list, index);
   1d02a:	f7ff ff06 	bl	1ce3a <at_params_get>

	if (param == NULL) {
   1d02e:	4601      	mov	r1, r0
   1d030:	b180      	cbz	r0, 1d054 <at_params_string_get+0x3a>
		return -EINVAL;
	}

	if (param->type != AT_PARAM_TYPE_STRING) {
   1d032:	7803      	ldrb	r3, [r0, #0]
   1d034:	2b03      	cmp	r3, #3
   1d036:	d10d      	bne.n	1d054 <at_params_string_get+0x3a>
		return -EINVAL;
	}

	size_t param_len = at_param_size(param);
   1d038:	f7ff ff08 	bl	1ce4c <at_param_size>

	if (*len < param_len) {
   1d03c:	6823      	ldr	r3, [r4, #0]
	size_t param_len = at_param_size(param);
   1d03e:	4605      	mov	r5, r0
	if (*len < param_len) {
   1d040:	4283      	cmp	r3, r0
   1d042:	d30a      	bcc.n	1d05a <at_params_string_get+0x40>
		return -ENOMEM;
	}

	memcpy(value, param->value.str_val, param_len);
   1d044:	4602      	mov	r2, r0
   1d046:	6889      	ldr	r1, [r1, #8]
   1d048:	4630      	mov	r0, r6
   1d04a:	f7fe ffcb 	bl	1bfe4 <memcpy>
	*len = param_len;

	return 0;
   1d04e:	2000      	movs	r0, #0
	*len = param_len;
   1d050:	6025      	str	r5, [r4, #0]
}
   1d052:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   1d054:	f06f 0015 	mvn.w	r0, #21
   1d058:	e7fb      	b.n	1d052 <at_params_string_get+0x38>
		return -ENOMEM;
   1d05a:	f06f 000b 	mvn.w	r0, #11
   1d05e:	e7f8      	b.n	1d052 <at_params_string_get+0x38>

0001d060 <response_is_valid.part.0>:
static bool response_is_valid(const char *response, size_t response_len,
   1d060:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1d062:	4605      	mov	r5, r0
	if ((response_len < strlen(check)) ||
   1d064:	4610      	mov	r0, r2
static bool response_is_valid(const char *response, size_t response_len,
   1d066:	460c      	mov	r4, r1
	if ((response_len < strlen(check)) ||
   1d068:	9201      	str	r2, [sp, #4]
   1d06a:	f7fe ff89 	bl	1bf80 <strlen>
   1d06e:	42a0      	cmp	r0, r4
   1d070:	d809      	bhi.n	1d086 <response_is_valid.part.0+0x26>
	    (memcmp(response, check, response_len) != 0)) {
   1d072:	4622      	mov	r2, r4
   1d074:	4628      	mov	r0, r5
   1d076:	9901      	ldr	r1, [sp, #4]
   1d078:	f7fe ffa4 	bl	1bfc4 <memcmp>
	if ((response_len < strlen(check)) ||
   1d07c:	fab0 f080 	clz	r0, r0
   1d080:	0940      	lsrs	r0, r0, #5
}
   1d082:	b003      	add	sp, #12
   1d084:	bd30      	pop	{r4, r5, pc}
		return false;
   1d086:	2000      	movs	r0, #0
   1d088:	e7fb      	b.n	1d082 <response_is_valid.part.0+0x22>

0001d08a <lte_lc_init_and_connect>:
{
   1d08a:	b508      	push	{r3, lr}
	ret = w_lte_lc_init();
   1d08c:	f7f4 f978 	bl	11380 <w_lte_lc_init>
	if (ret) {
   1d090:	b920      	cbnz	r0, 1d09c <lte_lc_init_and_connect+0x12>
}
   1d092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return w_lte_lc_connect(true);
   1d096:	2001      	movs	r0, #1
   1d098:	f7f4 b9ac 	b.w	113f4 <w_lte_lc_connect>
}
   1d09c:	bd08      	pop	{r3, pc}

0001d09e <k_sys_fatal_error_handler>:
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
	sys_arch_reboot(0);
   1d09e:	2000      	movs	r0, #0
{
   1d0a0:	b508      	push	{r3, lr}
	sys_arch_reboot(0);
   1d0a2:	f7f1 f909 	bl	e2b8 <sys_arch_reboot>

0001d0a6 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   1d0a6:	4700      	bx	r0

0001d0a8 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   1d0a8:	f000 ba99 	b.w	1d5de <z_impl_k_busy_wait>

0001d0ac <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   1d0ac:	7b0b      	ldrb	r3, [r1, #12]
   1d0ae:	2b03      	cmp	r3, #3
   1d0b0:	d82a      	bhi.n	1d108 <xfer_completeness_check+0x5c>
   1d0b2:	e8df f003 	tbb	[pc, r3]
   1d0b6:	2622      	.short	0x2622
   1d0b8:	021a      	.short	0x021a
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1d0ba:	688b      	ldr	r3, [r1, #8]
   1d0bc:	035a      	lsls	r2, r3, #13
   1d0be:	d504      	bpl.n	1d0ca <xfer_completeness_check+0x1e>
    return p_reg->TXD.AMOUNT;
   1d0c0:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
   1d0c4:	690a      	ldr	r2, [r1, #16]
   1d0c6:	429a      	cmp	r2, r3
   1d0c8:	d107      	bne.n	1d0da <xfer_completeness_check+0x2e>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   1d0ca:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   1d0cc:	035b      	lsls	r3, r3, #13
   1d0ce:	d41b      	bmi.n	1d108 <xfer_completeness_check+0x5c>
   1d0d0:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   1d0d4:	694a      	ldr	r2, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   1d0d6:	429a      	cmp	r2, r3
   1d0d8:	d016      	beq.n	1d108 <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   1d0da:	2300      	movs	r3, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   1d0dc:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   1d0de:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   1d0e2:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
}
   1d0e6:	4618      	mov	r0, r3
   1d0e8:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   1d0ea:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   1d0ee:	690a      	ldr	r2, [r1, #16]
   1d0f0:	429a      	cmp	r2, r3
   1d0f2:	d1f2      	bne.n	1d0da <xfer_completeness_check+0x2e>
    return p_reg->RXD.AMOUNT;
   1d0f4:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   1d0f8:	e7ec      	b.n	1d0d4 <xfer_completeness_check+0x28>
    return p_reg->TXD.AMOUNT;
   1d0fa:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   1d0fe:	690a      	ldr	r2, [r1, #16]
   1d100:	e7e9      	b.n	1d0d6 <xfer_completeness_check+0x2a>
    return p_reg->RXD.AMOUNT;
   1d102:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   1d106:	e7fa      	b.n	1d0fe <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   1d108:	2001      	movs	r0, #1
}
   1d10a:	4770      	bx	lr

0001d10c <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   1d10c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1d10e:	4605      	mov	r5, r0
   1d110:	9101      	str	r1, [sp, #4]
	__asm__ volatile(
   1d112:	f04f 0320 	mov.w	r3, #32
   1d116:	f3ef 8611 	mrs	r6, BASEPRI
   1d11a:	f383 8811 	msr	BASEPRI, r3
   1d11e:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   1d122:	f7fd fccf 	bl	1aac4 <z_impl_k_current_get>
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   1d126:	9901      	ldr	r1, [sp, #4]
   1d128:	4604      	mov	r4, r0
   1d12a:	4628      	mov	r0, r5
   1d12c:	f7ff ffb7 	bl	1d09e <k_sys_fatal_error_handler>
	__asm__ volatile(
   1d130:	f386 8811 	msr	BASEPRI, r6
   1d134:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   1d138:	4620      	mov	r0, r4
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   1d13a:	b002      	add	sp, #8
   1d13c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1d140:	f7f1 b8d8 	b.w	e2f4 <z_impl_k_thread_abort>

0001d144 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   1d144:	f7fe bd9d 	b.w	1bc82 <z_clock_idle_exit>

0001d148 <k_heap_init>:
{
   1d148:	b410      	push	{r4}
   1d14a:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   1d14e:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   1d152:	f85d 4b04 	ldr.w	r4, [sp], #4
	sys_heap_init(&h->heap, mem, bytes);
   1d156:	f7fe b9fe 	b.w	1b556 <sys_heap_init>

0001d15a <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   1d15a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d15e:	4605      	mov	r5, r0
   1d160:	b085      	sub	sp, #20
   1d162:	460f      	mov	r7, r1
	s64_t now, end = z_timeout_end_calc(timeout);
   1d164:	4610      	mov	r0, r2
   1d166:	4619      	mov	r1, r3
   1d168:	f000 fa85 	bl	1d676 <z_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   1d16c:	f105 0b14 	add.w	fp, r5, #20
	s64_t now, end = z_timeout_end_calc(timeout);
   1d170:	9002      	str	r0, [sp, #8]
   1d172:	468a      	mov	sl, r1
	__asm__ volatile(
   1d174:	f04f 0320 	mov.w	r3, #32
   1d178:	f3ef 8411 	mrs	r4, BASEPRI
   1d17c:	f383 8811 	msr	BASEPRI, r3
   1d180:	f3bf 8f6f 	isb	sy
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1d184:	f105 060c 	add.w	r6, r5, #12
		ret = sys_heap_alloc(&h->heap, bytes);
   1d188:	4639      	mov	r1, r7
   1d18a:	4628      	mov	r0, r5
   1d18c:	f7fe f98a 	bl	1b4a4 <sys_heap_alloc>
   1d190:	9003      	str	r0, [sp, #12]
		now = z_tick_get();
   1d192:	f7fd fee9 	bl	1af68 <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
   1d196:	9b03      	ldr	r3, [sp, #12]
   1d198:	b13b      	cbz	r3, 1d1aa <k_heap_alloc+0x50>
	__asm__ volatile(
   1d19a:	f384 8811 	msr	BASEPRI, r4
   1d19e:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
   1d1a2:	4618      	mov	r0, r3
   1d1a4:	b005      	add	sp, #20
   1d1a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
   1d1aa:	9a02      	ldr	r2, [sp, #8]
   1d1ac:	ebb2 0800 	subs.w	r8, r2, r0
   1d1b0:	eb6a 0901 	sbc.w	r9, sl, r1
   1d1b4:	f1b8 0f01 	cmp.w	r8, #1
   1d1b8:	f179 0200 	sbcs.w	r2, r9, #0
   1d1bc:	dbed      	blt.n	1d19a <k_heap_alloc+0x40>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   1d1be:	4632      	mov	r2, r6
   1d1c0:	4621      	mov	r1, r4
   1d1c2:	4658      	mov	r0, fp
   1d1c4:	e9cd 8900 	strd	r8, r9, [sp]
   1d1c8:	f7fd fbaa 	bl	1a920 <z_pend_curr>
	__asm__ volatile(
   1d1cc:	f04f 0320 	mov.w	r3, #32
   1d1d0:	f3ef 8411 	mrs	r4, BASEPRI
   1d1d4:	f383 8811 	msr	BASEPRI, r3
   1d1d8:	f3bf 8f6f 	isb	sy
   1d1dc:	e7d4      	b.n	1d188 <k_heap_alloc+0x2e>

0001d1de <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   1d1de:	b538      	push	{r3, r4, r5, lr}
   1d1e0:	4604      	mov	r4, r0
   1d1e2:	f04f 0320 	mov.w	r3, #32
   1d1e6:	f3ef 8511 	mrs	r5, BASEPRI
   1d1ea:	f383 8811 	msr	BASEPRI, r3
   1d1ee:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
   1d1f2:	f7fe f8a1 	bl	1b338 <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
   1d1f6:	f104 000c 	add.w	r0, r4, #12
   1d1fa:	f000 f9ca 	bl	1d592 <z_unpend_all>
   1d1fe:	b130      	cbz	r0, 1d20e <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
   1d200:	4629      	mov	r1, r5
   1d202:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   1d206:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
   1d20a:	f000 b8d7 	b.w	1d3bc <z_reschedule>
	__asm__ volatile(
   1d20e:	f385 8811 	msr	BASEPRI, r5
   1d212:	f3bf 8f6f 	isb	sy
}
   1d216:	bd38      	pop	{r3, r4, r5, pc}

0001d218 <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
   1d218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d21a:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
   1d21e:	4614      	mov	r4, r2
	block->id.heap = p->heap;
   1d220:	6800      	ldr	r0, [r0, #0]
{
   1d222:	460d      	mov	r5, r1
	block->id.heap = p->heap;
   1d224:	6048      	str	r0, [r1, #4]
	block->data = k_heap_alloc(p->heap, size, timeout);
   1d226:	4632      	mov	r2, r6
   1d228:	463b      	mov	r3, r7
   1d22a:	4621      	mov	r1, r4
   1d22c:	f7ff ff95 	bl	1d15a <k_heap_alloc>
   1d230:	6028      	str	r0, [r5, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
   1d232:	b144      	cbz	r4, 1d246 <k_mem_pool_alloc+0x2e>
   1d234:	b938      	cbnz	r0, 1d246 <k_mem_pool_alloc+0x2e>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
   1d236:	ea56 0307 	orrs.w	r3, r6, r7
   1d23a:	bf0c      	ite	eq
   1d23c:	f06f 000b 	mvneq.w	r0, #11
   1d240:	f06f 000a 	mvnne.w	r0, #10
	} else {
		return 0;
	}
}
   1d244:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
   1d246:	2000      	movs	r0, #0
   1d248:	e7fc      	b.n	1d244 <k_mem_pool_alloc+0x2c>

0001d24a <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	k_heap_free(id->heap, id->data);
   1d24a:	e9d0 1000 	ldrd	r1, r0, [r0]
   1d24e:	f7ff bfc6 	b.w	1d1de <k_heap_free>

0001d252 <k_mem_pool_malloc>:
{
   1d252:	b5df      	push	{r0, r1, r2, r3, r4, r6, r7, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
   1d254:	2408      	movs	r4, #8
   1d256:	190a      	adds	r2, r1, r4
   1d258:	d208      	bcs.n	1d26c <k_mem_pool_malloc+0x1a>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   1d25a:	2600      	movs	r6, #0
   1d25c:	2700      	movs	r7, #0
   1d25e:	eb0d 0104 	add.w	r1, sp, r4
   1d262:	e9cd 6700 	strd	r6, r7, [sp]
   1d266:	f7ff ffd7 	bl	1d218 <k_mem_pool_alloc>
   1d26a:	b110      	cbz	r0, 1d272 <k_mem_pool_malloc+0x20>
		return NULL;
   1d26c:	2000      	movs	r0, #0
}
   1d26e:	b004      	add	sp, #16
   1d270:	bdd0      	pop	{r4, r6, r7, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
   1d272:	4622      	mov	r2, r4
   1d274:	9802      	ldr	r0, [sp, #8]
   1d276:	a902      	add	r1, sp, #8
   1d278:	f7fe feb4 	bl	1bfe4 <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   1d27c:	9802      	ldr	r0, [sp, #8]
   1d27e:	3008      	adds	r0, #8
   1d280:	e7f5      	b.n	1d26e <k_mem_pool_malloc+0x1c>

0001d282 <k_free>:
	if (ptr != NULL) {
   1d282:	b110      	cbz	r0, 1d28a <k_free+0x8>
		k_mem_pool_free_id(ptr);
   1d284:	3808      	subs	r0, #8
   1d286:	f7ff bfe0 	b.w	1d24a <k_mem_pool_free_id>
}
   1d28a:	4770      	bx	lr

0001d28c <k_calloc>:
{
   1d28c:	b570      	push	{r4, r5, r6, lr}
	return __builtin_mul_overflow(a, b, result);
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_mul_overflow(a, b, result);
   1d28e:	fba0 4501 	umull	r4, r5, r0, r1
   1d292:	b935      	cbnz	r5, 1d2a2 <k_calloc+0x16>
	ret = k_malloc(bounds);
   1d294:	4620      	mov	r0, r4
   1d296:	f7fc ff07 	bl	1a0a8 <k_malloc>
	if (ret != NULL) {
   1d29a:	4606      	mov	r6, r0
   1d29c:	b918      	cbnz	r0, 1d2a6 <k_calloc+0x1a>
}
   1d29e:	4630      	mov	r0, r6
   1d2a0:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
   1d2a2:	2600      	movs	r6, #0
   1d2a4:	e7fb      	b.n	1d29e <k_calloc+0x12>
		(void)memset(ret, 0, bounds);
   1d2a6:	4622      	mov	r2, r4
   1d2a8:	4629      	mov	r1, r5
   1d2aa:	f7fe fec6 	bl	1c03a <memset>
   1d2ae:	e7f6      	b.n	1d29e <k_calloc+0x12>

0001d2b0 <queue_insert>:
{
   1d2b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1d2b4:	4604      	mov	r4, r0
   1d2b6:	460d      	mov	r5, r1
   1d2b8:	4690      	mov	r8, r2
   1d2ba:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   1d2bc:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
   1d2c0:	f04f 0320 	mov.w	r3, #32
   1d2c4:	f3ef 8711 	mrs	r7, BASEPRI
   1d2c8:	f383 8811 	msr	BASEPRI, r3
   1d2cc:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   1d2d0:	4630      	mov	r0, r6
   1d2d2:	f000 f931 	bl	1d538 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   1d2d6:	b158      	cbz	r0, 1d2f0 <queue_insert+0x40>
   1d2d8:	2400      	movs	r4, #0
   1d2da:	f8c0 8014 	str.w	r8, [r0, #20]
   1d2de:	6704      	str	r4, [r0, #112]	; 0x70
	z_ready_thread(thread);
   1d2e0:	f000 f8b4 	bl	1d44c <z_ready_thread>
	z_reschedule(&queue->lock, key);
   1d2e4:	4630      	mov	r0, r6
   1d2e6:	4639      	mov	r1, r7
   1d2e8:	f000 f868 	bl	1d3bc <z_reschedule>
	return 0;
   1d2ec:	2000      	movs	r0, #0
   1d2ee:	e00c      	b.n	1d30a <queue_insert+0x5a>
	if (alloc) {
   1d2f0:	f1b9 0f00 	cmp.w	r9, #0
   1d2f4:	d01b      	beq.n	1d32e <queue_insert+0x7e>
		anode = z_thread_malloc(sizeof(*anode));
   1d2f6:	2008      	movs	r0, #8
   1d2f8:	f7fc fedc 	bl	1a0b4 <z_thread_malloc>
		if (anode == NULL) {
   1d2fc:	b938      	cbnz	r0, 1d30e <queue_insert+0x5e>
	__asm__ volatile(
   1d2fe:	f387 8811 	msr	BASEPRI, r7
   1d302:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   1d306:	f06f 000b 	mvn.w	r0, #11
}
   1d30a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
   1d30e:	2301      	movs	r3, #1
		anode->data = data;
   1d310:	f8c0 8004 	str.w	r8, [r0, #4]
   1d314:	6003      	str	r3, [r0, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1d316:	6803      	ldr	r3, [r0, #0]
   1d318:	f003 0203 	and.w	r2, r3, #3
   1d31c:	b95d      	cbnz	r5, 1d336 <queue_insert+0x86>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d31e:	6823      	ldr	r3, [r4, #0]
   1d320:	4313      	orrs	r3, r2
   1d322:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1d324:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   1d326:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   1d328:	b973      	cbnz	r3, 1d348 <queue_insert+0x98>
	list->tail = node;
   1d32a:	6060      	str	r0, [r4, #4]
}
   1d32c:	e00c      	b.n	1d348 <queue_insert+0x98>
}
   1d32e:	4640      	mov	r0, r8
	node->next_and_flags = flags;
   1d330:	f8c8 9000 	str.w	r9, [r8]
}
   1d334:	e7ef      	b.n	1d316 <queue_insert+0x66>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   1d336:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   1d338:	f033 0303 	bics.w	r3, r3, #3
   1d33c:	d110      	bne.n	1d360 <queue_insert+0xb0>
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d33e:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   1d340:	6862      	ldr	r2, [r4, #4]
   1d342:	b93a      	cbnz	r2, 1d354 <queue_insert+0xa4>
	list->head = node;
   1d344:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   1d348:	2104      	movs	r1, #4
   1d34a:	f104 0010 	add.w	r0, r4, #16
   1d34e:	f000 fab5 	bl	1d8bc <z_handle_obj_poll_events>
   1d352:	e7c7      	b.n	1d2e4 <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d354:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d356:	f003 0303 	and.w	r3, r3, #3
   1d35a:	4303      	orrs	r3, r0
   1d35c:	6013      	str	r3, [r2, #0]
   1d35e:	e7e4      	b.n	1d32a <queue_insert+0x7a>
   1d360:	4313      	orrs	r3, r2
   1d362:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d364:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   1d366:	f003 0303 	and.w	r3, r3, #3
   1d36a:	4303      	orrs	r3, r0
   1d36c:	602b      	str	r3, [r5, #0]
}
   1d36e:	e7eb      	b.n	1d348 <queue_insert+0x98>

0001d370 <z_queue_node_peek>:
{
   1d370:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   1d372:	4604      	mov	r4, r0
   1d374:	b130      	cbz	r0, 1d384 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   1d376:	6802      	ldr	r2, [r0, #0]
   1d378:	0793      	lsls	r3, r2, #30
   1d37a:	d003      	beq.n	1d384 <z_queue_node_peek+0x14>
		ret = anode->data;
   1d37c:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   1d37e:	b109      	cbz	r1, 1d384 <z_queue_node_peek+0x14>
			k_free(anode);
   1d380:	f7ff ff7f 	bl	1d282 <k_free>
}
   1d384:	4620      	mov	r0, r4
   1d386:	bd10      	pop	{r4, pc}

0001d388 <z_impl_k_queue_init>:
	list->head = NULL;
   1d388:	2300      	movs	r3, #0
	list->tail = NULL;
   1d38a:	e9c0 3300 	strd	r3, r3, [r0]
   1d38e:	f100 0308 	add.w	r3, r0, #8
   1d392:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
   1d396:	f100 0310 	add.w	r3, r0, #16
   1d39a:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
   1d39e:	4770      	bx	lr

0001d3a0 <k_queue_append>:
{
   1d3a0:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   1d3a2:	2300      	movs	r3, #0
   1d3a4:	6841      	ldr	r1, [r0, #4]
   1d3a6:	f7ff bf83 	b.w	1d2b0 <queue_insert>

0001d3aa <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   1d3aa:	f990 000e 	ldrsb.w	r0, [r0, #14]
   1d3ae:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   1d3b2:	4298      	cmp	r0, r3
   1d3b4:	bfac      	ite	ge
   1d3b6:	2000      	movge	r0, #0
   1d3b8:	2001      	movlt	r0, #1
   1d3ba:	4770      	bx	lr

0001d3bc <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1d3bc:	b921      	cbnz	r1, 1d3c8 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1d3be:	f3ef 8005 	mrs	r0, IPSR
   1d3c2:	b908      	cbnz	r0, 1d3c8 <z_reschedule+0xc>
   1d3c4:	f7f0 bd20 	b.w	de08 <arch_swap>
   1d3c8:	f381 8811 	msr	BASEPRI, r1
   1d3cc:	f3bf 8f6f 	isb	sy
}
   1d3d0:	4770      	bx	lr

0001d3d2 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   1d3d2:	4603      	mov	r3, r0
   1d3d4:	b920      	cbnz	r0, 1d3e0 <z_reschedule_irqlock+0xe>
   1d3d6:	f3ef 8205 	mrs	r2, IPSR
   1d3da:	b90a      	cbnz	r2, 1d3e0 <z_reschedule_irqlock+0xe>
   1d3dc:	f7f0 bd14 	b.w	de08 <arch_swap>
   1d3e0:	f383 8811 	msr	BASEPRI, r3
   1d3e4:	f3bf 8f6f 	isb	sy
}
   1d3e8:	4770      	bx	lr

0001d3ea <z_reschedule_unlocked>:
	__asm__ volatile(
   1d3ea:	f04f 0320 	mov.w	r3, #32
   1d3ee:	f3ef 8011 	mrs	r0, BASEPRI
   1d3f2:	f383 8811 	msr	BASEPRI, r3
   1d3f6:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1d3fa:	f7ff bfea 	b.w	1d3d2 <z_reschedule_irqlock>

0001d3fe <z_unpend_thread>:
{
   1d3fe:	b510      	push	{r4, lr}
   1d400:	4601      	mov	r1, r0
   1d402:	f04f 0320 	mov.w	r3, #32
   1d406:	f3ef 8411 	mrs	r4, BASEPRI
   1d40a:	f383 8811 	msr	BASEPRI, r3
   1d40e:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1d412:	6880      	ldr	r0, [r0, #8]
   1d414:	f7fd f862 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1d418:	7b4b      	ldrb	r3, [r1, #13]
   1d41a:	f023 0302 	bic.w	r3, r3, #2
   1d41e:	734b      	strb	r3, [r1, #13]
		thread->base.pended_on = NULL;
   1d420:	2300      	movs	r3, #0
   1d422:	608b      	str	r3, [r1, #8]
	__asm__ volatile(
   1d424:	f384 8811 	msr	BASEPRI, r4
   1d428:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
   1d42c:	f101 0018 	add.w	r0, r1, #24
}
   1d430:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d434:	f000 b8d8 	b.w	1d5e8 <z_abort_timeout>

0001d438 <z_priq_dumb_best>:
	return list->head == list;
   1d438:	6803      	ldr	r3, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d43a:	4298      	cmp	r0, r3
   1d43c:	d004      	beq.n	1d448 <z_priq_dumb_best+0x10>
	if (n != NULL) {
   1d43e:	2b00      	cmp	r3, #0
   1d440:	bf38      	it	cc
   1d442:	2300      	movcc	r3, #0
   1d444:	4618      	mov	r0, r3
   1d446:	4770      	bx	lr
	struct k_thread *thread = NULL;
   1d448:	2000      	movs	r0, #0
}
   1d44a:	4770      	bx	lr

0001d44c <z_ready_thread>:
{
   1d44c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d44e:	f04f 0320 	mov.w	r3, #32
   1d452:	f3ef 8411 	mrs	r4, BASEPRI
   1d456:	f383 8811 	msr	BASEPRI, r3
   1d45a:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
   1d45e:	f7fd f893 	bl	1a588 <ready_thread>
	__asm__ volatile(
   1d462:	f384 8811 	msr	BASEPRI, r4
   1d466:	f3bf 8f6f 	isb	sy
}
   1d46a:	bd10      	pop	{r4, pc}

0001d46c <z_thread_timeout>:
{
   1d46c:	b538      	push	{r3, r4, r5, lr}
	if (thread->base.pended_on != NULL) {
   1d46e:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   1d472:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   1d474:	f1a0 0118 	sub.w	r1, r0, #24
	if (thread->base.pended_on != NULL) {
   1d478:	b1c3      	cbz	r3, 1d4ac <z_thread_timeout+0x40>
	__asm__ volatile(
   1d47a:	f04f 0320 	mov.w	r3, #32
   1d47e:	f3ef 8511 	mrs	r5, BASEPRI
   1d482:	f383 8811 	msr	BASEPRI, r3
   1d486:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1d48a:	f850 0c10 	ldr.w	r0, [r0, #-16]
   1d48e:	f7fd f825 	bl	1a4dc <z_priq_dumb_remove>
   1d492:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
   1d496:	f023 0302 	bic.w	r3, r3, #2
   1d49a:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
   1d49e:	2300      	movs	r3, #0
   1d4a0:	f844 3c10 	str.w	r3, [r4, #-16]
	__asm__ volatile(
   1d4a4:	f385 8811 	msr	BASEPRI, r5
   1d4a8:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   1d4ac:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	z_ready_thread(thread);
   1d4b0:	4608      	mov	r0, r1
   1d4b2:	f023 0314 	bic.w	r3, r3, #20
   1d4b6:	f804 3c0b 	strb.w	r3, [r4, #-11]
}
   1d4ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_ready_thread(thread);
   1d4be:	f7ff bfc5 	b.w	1d44c <z_ready_thread>

0001d4c2 <z_remove_thread_from_ready_q>:
{
   1d4c2:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d4c4:	f04f 0320 	mov.w	r3, #32
   1d4c8:	f3ef 8411 	mrs	r4, BASEPRI
   1d4cc:	f383 8811 	msr	BASEPRI, r3
   1d4d0:	f3bf 8f6f 	isb	sy
		unready_thread(thread);
   1d4d4:	f7fd f9b6 	bl	1a844 <unready_thread>
	__asm__ volatile(
   1d4d8:	f384 8811 	msr	BASEPRI, r4
   1d4dc:	f3bf 8f6f 	isb	sy
}
   1d4e0:	bd10      	pop	{r4, pc}

0001d4e2 <add_to_waitq_locked>:
{
   1d4e2:	b538      	push	{r3, r4, r5, lr}
   1d4e4:	4604      	mov	r4, r0
   1d4e6:	460d      	mov	r5, r1
	unready_thread(thread);
   1d4e8:	f7fd f9ac 	bl	1a844 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   1d4ec:	7b63      	ldrb	r3, [r4, #13]
   1d4ee:	f043 0302 	orr.w	r3, r3, #2
   1d4f2:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   1d4f4:	b1c5      	cbz	r5, 1d528 <add_to_waitq_locked+0x46>
	return list->head == list;
   1d4f6:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   1d4f8:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d4fa:	429d      	cmp	r5, r3
   1d4fc:	bf08      	it	eq
   1d4fe:	2300      	moveq	r3, #0
   1d500:	2b00      	cmp	r3, #0
   1d502:	bf38      	it	cc
   1d504:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   1d506:	b183      	cbz	r3, 1d52a <add_to_waitq_locked+0x48>
	if (thread_1->base.prio < thread_2->base.prio) {
   1d508:	f994 100e 	ldrsb.w	r1, [r4, #14]
   1d50c:	f993 200e 	ldrsb.w	r2, [r3, #14]
   1d510:	4291      	cmp	r1, r2
   1d512:	db04      	blt.n	1d51e <add_to_waitq_locked+0x3c>
	return (node == list->tail) ? NULL : node->next;
   1d514:	686a      	ldr	r2, [r5, #4]
   1d516:	429a      	cmp	r2, r3
   1d518:	d007      	beq.n	1d52a <add_to_waitq_locked+0x48>
   1d51a:	681b      	ldr	r3, [r3, #0]
   1d51c:	e7f3      	b.n	1d506 <add_to_waitq_locked+0x24>
	node->prev = successor->prev;
   1d51e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   1d520:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   1d524:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   1d526:	605c      	str	r4, [r3, #4]
}
   1d528:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
   1d52a:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   1d52c:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   1d52e:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   1d530:	686b      	ldr	r3, [r5, #4]
   1d532:	601c      	str	r4, [r3, #0]
	list->tail = node;
   1d534:	606c      	str	r4, [r5, #4]
   1d536:	e7f7      	b.n	1d528 <add_to_waitq_locked+0x46>

0001d538 <z_unpend_first_thread>:
{
   1d538:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1d53a:	f04f 0320 	mov.w	r3, #32
   1d53e:	f3ef 8211 	mrs	r2, BASEPRI
   1d542:	f383 8811 	msr	BASEPRI, r3
   1d546:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   1d54a:	f7ff ff75 	bl	1d438 <z_priq_dumb_best>
   1d54e:	4604      	mov	r4, r0
	__asm__ volatile(
   1d550:	f382 8811 	msr	BASEPRI, r2
   1d554:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   1d558:	b1c8      	cbz	r0, 1d58e <z_unpend_first_thread+0x56>
	__asm__ volatile(
   1d55a:	f04f 0320 	mov.w	r3, #32
   1d55e:	f3ef 8511 	mrs	r5, BASEPRI
   1d562:	f383 8811 	msr	BASEPRI, r3
   1d566:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   1d56a:	4601      	mov	r1, r0
   1d56c:	6880      	ldr	r0, [r0, #8]
   1d56e:	f7fc ffb5 	bl	1a4dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1d572:	7b63      	ldrb	r3, [r4, #13]
   1d574:	f023 0302 	bic.w	r3, r3, #2
   1d578:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   1d57a:	2300      	movs	r3, #0
   1d57c:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
   1d57e:	f385 8811 	msr	BASEPRI, r5
   1d582:	f3bf 8f6f 	isb	sy
   1d586:	f104 0018 	add.w	r0, r4, #24
   1d58a:	f000 f82d 	bl	1d5e8 <z_abort_timeout>
}
   1d58e:	4620      	mov	r0, r4
   1d590:	bd38      	pop	{r3, r4, r5, pc}

0001d592 <z_unpend_all>:
{
   1d592:	b538      	push	{r3, r4, r5, lr}
   1d594:	4605      	mov	r5, r0
	int need_sched = 0;
   1d596:	2000      	movs	r0, #0
	return list->head == list;
   1d598:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d59a:	42a5      	cmp	r5, r4
   1d59c:	d000      	beq.n	1d5a0 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   1d59e:	b904      	cbnz	r4, 1d5a2 <z_unpend_all+0x10>
}
   1d5a0:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   1d5a2:	4620      	mov	r0, r4
   1d5a4:	f7ff ff2b 	bl	1d3fe <z_unpend_thread>
		z_ready_thread(thread);
   1d5a8:	4620      	mov	r0, r4
   1d5aa:	f7ff ff4f 	bl	1d44c <z_ready_thread>
		need_sched = 1;
   1d5ae:	2001      	movs	r0, #1
   1d5b0:	e7f2      	b.n	1d598 <z_unpend_all+0x6>

0001d5b2 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   1d5b2:	b15a      	cbz	r2, 1d5cc <z_impl_k_sem_init+0x1a>
   1d5b4:	428a      	cmp	r2, r1
   1d5b6:	d309      	bcc.n	1d5cc <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   1d5b8:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   1d5bc:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   1d5c0:	e9c0 0000 	strd	r0, r0, [r0]
   1d5c4:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   1d5c8:	2000      	movs	r0, #0
   1d5ca:	4770      	bx	lr
		return -EINVAL;
   1d5cc:	f06f 0015 	mvn.w	r0, #21
}
   1d5d0:	4770      	bx	lr

0001d5d2 <k_is_in_isr>:
   1d5d2:	f3ef 8005 	mrs	r0, IPSR
}
   1d5d6:	3800      	subs	r0, #0
   1d5d8:	bf18      	it	ne
   1d5da:	2001      	movne	r0, #1
   1d5dc:	4770      	bx	lr

0001d5de <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   1d5de:	f7f0 b8ed 	b.w	d7bc <arch_busy_wait>

0001d5e2 <z_impl_k_thread_name_set>:
}
   1d5e2:	f06f 0046 	mvn.w	r0, #70	; 0x46
   1d5e6:	4770      	bx	lr

0001d5e8 <z_abort_timeout>:
{
   1d5e8:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d5ea:	f04f 0220 	mov.w	r2, #32
   1d5ee:	f3ef 8411 	mrs	r4, BASEPRI
   1d5f2:	f382 8811 	msr	BASEPRI, r2
   1d5f6:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   1d5fa:	6803      	ldr	r3, [r0, #0]
   1d5fc:	b13b      	cbz	r3, 1d60e <z_abort_timeout+0x26>
			remove_timeout(to);
   1d5fe:	f7fd fbb5 	bl	1ad6c <remove_timeout>
			ret = 0;
   1d602:	2000      	movs	r0, #0
	__asm__ volatile(
   1d604:	f384 8811 	msr	BASEPRI, r4
   1d608:	f3bf 8f6f 	isb	sy
}
   1d60c:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   1d60e:	f06f 0015 	mvn.w	r0, #21
   1d612:	e7f7      	b.n	1d604 <z_abort_timeout+0x1c>

0001d614 <z_get_next_timeout_expiry>:
{
   1d614:	b510      	push	{r4, lr}
	__asm__ volatile(
   1d616:	f04f 0320 	mov.w	r3, #32
   1d61a:	f3ef 8411 	mrs	r4, BASEPRI
   1d61e:	f383 8811 	msr	BASEPRI, r3
   1d622:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   1d626:	f7fd fbb5 	bl	1ad94 <next_timeout>
	__asm__ volatile(
   1d62a:	f384 8811 	msr	BASEPRI, r4
   1d62e:	f3bf 8f6f 	isb	sy
}
   1d632:	bd10      	pop	{r4, pc}

0001d634 <z_set_timeout_expiry>:
{
   1d634:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1d636:	4604      	mov	r4, r0
   1d638:	9101      	str	r1, [sp, #4]
	__asm__ volatile(
   1d63a:	f04f 0320 	mov.w	r3, #32
   1d63e:	f3ef 8511 	mrs	r5, BASEPRI
   1d642:	f383 8811 	msr	BASEPRI, r3
   1d646:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
   1d64a:	f7fd fba3 	bl	1ad94 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   1d64e:	2801      	cmp	r0, #1
   1d650:	dd05      	ble.n	1d65e <z_set_timeout_expiry+0x2a>
   1d652:	42a0      	cmp	r0, r4
   1d654:	9901      	ldr	r1, [sp, #4]
   1d656:	dd02      	ble.n	1d65e <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
   1d658:	4620      	mov	r0, r4
   1d65a:	f7f0 fb3d 	bl	dcd8 <z_clock_set_timeout>
	__asm__ volatile(
   1d65e:	f385 8811 	msr	BASEPRI, r5
   1d662:	f3bf 8f6f 	isb	sy
}
   1d666:	b003      	add	sp, #12
   1d668:	bd30      	pop	{r4, r5, pc}

0001d66a <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   1d66a:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   1d66c:	f7fd fc7c 	bl	1af68 <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   1d670:	bd08      	pop	{r3, pc}

0001d672 <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   1d672:	f7fd bc79 	b.w	1af68 <z_tick_get>

0001d676 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
   1d676:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1d678:	1c4b      	adds	r3, r1, #1
   1d67a:	bf08      	it	eq
   1d67c:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
   1d680:	4604      	mov	r4, r0
   1d682:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   1d684:	d013      	beq.n	1d6ae <z_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1d686:	ea54 0105 	orrs.w	r1, r4, r5
   1d68a:	d103      	bne.n	1d694 <z_timeout_end_calc+0x1e>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
   1d68c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
   1d690:	f7fd bc6a 	b.w	1af68 <z_tick_get>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
   1d694:	f06f 0101 	mvn.w	r1, #1
   1d698:	1a0a      	subs	r2, r1, r0
   1d69a:	f04f 31ff 	mov.w	r1, #4294967295
   1d69e:	eb61 0305 	sbc.w	r3, r1, r5
   1d6a2:	2a00      	cmp	r2, #0
   1d6a4:	f173 0100 	sbcs.w	r1, r3, #0
   1d6a8:	db02      	blt.n	1d6b0 <z_timeout_end_calc+0x3a>
		return Z_TICK_ABS(dt);
   1d6aa:	4610      	mov	r0, r2
   1d6ac:	4619      	mov	r1, r3
}
   1d6ae:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
   1d6b0:	f7fd fc5a 	bl	1af68 <z_tick_get>
   1d6b4:	2c01      	cmp	r4, #1
   1d6b6:	f175 0300 	sbcs.w	r3, r5, #0
   1d6ba:	bfbc      	itt	lt
   1d6bc:	2401      	movlt	r4, #1
   1d6be:	2500      	movlt	r5, #0
   1d6c0:	1820      	adds	r0, r4, r0
   1d6c2:	eb45 0101 	adc.w	r1, r5, r1
   1d6c6:	e7f2      	b.n	1d6ae <z_timeout_end_calc+0x38>

0001d6c8 <clear_event_registrations>:
	while (num_events--) {
   1d6c8:	2314      	movs	r3, #20
{
   1d6ca:	b530      	push	{r4, r5, lr}
	event->poller = NULL;
   1d6cc:	2400      	movs	r4, #0
   1d6ce:	fb03 0101 	mla	r1, r3, r1, r0
	while (num_events--) {
   1d6d2:	4281      	cmp	r1, r0
   1d6d4:	d100      	bne.n	1d6d8 <clear_event_registrations+0x10>
}
   1d6d6:	bd30      	pop	{r4, r5, pc}
	switch (event->type) {
   1d6d8:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
   1d6dc:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
   1d6e0:	f003 030f 	and.w	r3, r3, #15
   1d6e4:	2b02      	cmp	r3, #2
   1d6e6:	d80a      	bhi.n	1d6fe <clear_event_registrations+0x36>
   1d6e8:	b15b      	cbz	r3, 1d702 <clear_event_registrations+0x3a>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   1d6ea:	f851 3c14 	ldr.w	r3, [r1, #-20]
   1d6ee:	b143      	cbz	r3, 1d702 <clear_event_registrations+0x3a>
	node->prev->next = node->next;
   1d6f0:	f851 5c10 	ldr.w	r5, [r1, #-16]
   1d6f4:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
   1d6f6:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
   1d6f8:	e941 4405 	strd	r4, r4, [r1, #-20]
	sys_dnode_init(node);
}
   1d6fc:	e001      	b.n	1d702 <clear_event_registrations+0x3a>
	switch (event->type) {
   1d6fe:	2b04      	cmp	r3, #4
   1d700:	d0f3      	beq.n	1d6ea <clear_event_registrations+0x22>
   1d702:	f382 8811 	msr	BASEPRI, r2
   1d706:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1d70a:	f04f 0320 	mov.w	r3, #32
   1d70e:	f3ef 8211 	mrs	r2, BASEPRI
   1d712:	f383 8811 	msr	BASEPRI, r3
   1d716:	f3bf 8f6f 	isb	sy
   1d71a:	3914      	subs	r1, #20
   1d71c:	e7d9      	b.n	1d6d2 <clear_event_registrations+0xa>

0001d71e <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   1d71e:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   1d720:	6884      	ldr	r4, [r0, #8]
{
   1d722:	4605      	mov	r5, r0
   1d724:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   1d726:	b19c      	cbz	r4, 1d750 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   1d728:	68a3      	ldr	r3, [r4, #8]
   1d72a:	b95b      	cbnz	r3, 1d744 <signal_poll_event+0x26>
	int retcode = 0;
   1d72c:	4618      	mov	r0, r3
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   1d72e:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   1d730:	2300      	movs	r3, #0
   1d732:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   1d734:	68eb      	ldr	r3, [r5, #12]
   1d736:	f3c3 3104 	ubfx	r1, r3, #12, #5
   1d73a:	430e      	orrs	r6, r1
   1d73c:	f366 3310 	bfi	r3, r6, #12, #5
   1d740:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   1d742:	e004      	b.n	1d74e <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   1d744:	4798      	blx	r3
		poller->is_polling = false;
   1d746:	2300      	movs	r3, #0
		if (retcode < 0) {
   1d748:	2800      	cmp	r0, #0
		poller->is_polling = false;
   1d74a:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   1d74c:	daf0      	bge.n	1d730 <signal_poll_event+0x12>
}
   1d74e:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   1d750:	4620      	mov	r0, r4
   1d752:	e7ed      	b.n	1d730 <signal_poll_event+0x12>

0001d754 <k_poll_poller_cb>:
{
   1d754:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   1d756:	6883      	ldr	r3, [r0, #8]
{
   1d758:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
   1d75a:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
   1d75c:	7b63      	ldrb	r3, [r4, #13]
   1d75e:	079a      	lsls	r2, r3, #30
   1d760:	d50e      	bpl.n	1d780 <k_poll_poller_cb+0x2c>
	if (z_is_thread_timeout_expired(thread)) {
   1d762:	6a23      	ldr	r3, [r4, #32]
   1d764:	3302      	adds	r3, #2
   1d766:	d014      	beq.n	1d792 <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
   1d768:	4620      	mov	r0, r4
   1d76a:	f7ff fe48 	bl	1d3fe <z_unpend_thread>
	arch_thread_return_value_set(thread,
   1d76e:	2d08      	cmp	r5, #8
   1d770:	bf0c      	ite	eq
   1d772:	f06f 0303 	mvneq.w	r3, #3
   1d776:	2300      	movne	r3, #0
   1d778:	6723      	str	r3, [r4, #112]	; 0x70
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   1d77a:	7b63      	ldrb	r3, [r4, #13]
   1d77c:	06db      	lsls	r3, r3, #27
   1d77e:	d001      	beq.n	1d784 <k_poll_poller_cb+0x30>
		return 0;
   1d780:	2000      	movs	r0, #0
}
   1d782:	bd38      	pop	{r3, r4, r5, pc}
	if (!z_is_thread_ready(thread)) {
   1d784:	69a5      	ldr	r5, [r4, #24]
   1d786:	2d00      	cmp	r5, #0
   1d788:	d1fa      	bne.n	1d780 <k_poll_poller_cb+0x2c>
	z_ready_thread(thread);
   1d78a:	4620      	mov	r0, r4
   1d78c:	f7ff fe5e 	bl	1d44c <z_ready_thread>
	return 0;
   1d790:	e7f6      	b.n	1d780 <k_poll_poller_cb+0x2c>
		return -EAGAIN;
   1d792:	f06f 000a 	mvn.w	r0, #10
   1d796:	e7f4      	b.n	1d782 <k_poll_poller_cb+0x2e>

0001d798 <add_event>:
{
   1d798:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d79a:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   1d79c:	e9d0 2300 	ldrd	r2, r3, [r0]
   1d7a0:	4290      	cmp	r0, r2
   1d7a2:	4604      	mov	r4, r0
   1d7a4:	460d      	mov	r5, r1
   1d7a6:	d106      	bne.n	1d7b6 <add_event+0x1e>
	node->prev = list->tail;
   1d7a8:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   1d7aa:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   1d7ac:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   1d7ae:	6863      	ldr	r3, [r4, #4]
   1d7b0:	601d      	str	r5, [r3, #0]
	list->tail = node;
   1d7b2:	6065      	str	r5, [r4, #4]
}
   1d7b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   1d7b6:	2b00      	cmp	r3, #0
   1d7b8:	d0f6      	beq.n	1d7a8 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   1d7ba:	689b      	ldr	r3, [r3, #8]
   1d7bc:	6879      	ldr	r1, [r7, #4]
   1d7be:	6858      	ldr	r0, [r3, #4]
   1d7c0:	f7ff fdf3 	bl	1d3aa <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   1d7c4:	2800      	cmp	r0, #0
   1d7c6:	d1ef      	bne.n	1d7a8 <add_event+0x10>
	return list->head == list;
   1d7c8:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1d7ca:	42b4      	cmp	r4, r6
   1d7cc:	d0ec      	beq.n	1d7a8 <add_event+0x10>
   1d7ce:	2e00      	cmp	r6, #0
   1d7d0:	bf38      	it	cc
   1d7d2:	2600      	movcc	r6, #0
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   1d7d4:	2e00      	cmp	r6, #0
   1d7d6:	d0e7      	beq.n	1d7a8 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   1d7d8:	68b3      	ldr	r3, [r6, #8]
   1d7da:	6878      	ldr	r0, [r7, #4]
   1d7dc:	6859      	ldr	r1, [r3, #4]
   1d7de:	f7ff fde4 	bl	1d3aa <z_is_t1_higher_prio_than_t2>
   1d7e2:	b128      	cbz	r0, 1d7f0 <add_event+0x58>
	node->prev = successor->prev;
   1d7e4:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   1d7e6:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   1d7ea:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   1d7ec:	6075      	str	r5, [r6, #4]
			return;
   1d7ee:	e7e1      	b.n	1d7b4 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   1d7f0:	6863      	ldr	r3, [r4, #4]
   1d7f2:	42b3      	cmp	r3, r6
   1d7f4:	d0d8      	beq.n	1d7a8 <add_event+0x10>
   1d7f6:	6836      	ldr	r6, [r6, #0]
   1d7f8:	e7ec      	b.n	1d7d4 <add_event+0x3c>

0001d7fa <register_events>:
{
   1d7fa:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   1d7fe:	f04f 0a00 	mov.w	sl, #0
{
   1d802:	460e      	mov	r6, r1
   1d804:	4614      	mov	r4, r2
   1d806:	461f      	mov	r7, r3
   1d808:	4683      	mov	fp, r0
	int events_registered = 0;
   1d80a:	4655      	mov	r5, sl
	event->poller = NULL;
   1d80c:	46d0      	mov	r8, sl
	for (int ii = 0; ii < num_events; ii++) {
   1d80e:	45b2      	cmp	sl, r6
   1d810:	db02      	blt.n	1d818 <register_events+0x1e>
}
   1d812:	4628      	mov	r0, r5
   1d814:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1d818:	f04f 0320 	mov.w	r3, #32
   1d81c:	f3ef 8911 	mrs	r9, BASEPRI
   1d820:	f383 8811 	msr	BASEPRI, r3
   1d824:	f3bf 8f6f 	isb	sy
	switch (event->type) {
   1d828:	f89b 200d 	ldrb.w	r2, [fp, #13]
   1d82c:	f002 020f 	and.w	r2, r2, #15
   1d830:	2a02      	cmp	r2, #2
   1d832:	d006      	beq.n	1d842 <register_events+0x48>
   1d834:	2a04      	cmp	r2, #4
   1d836:	d008      	beq.n	1d84a <register_events+0x50>
   1d838:	2a01      	cmp	r2, #1
   1d83a:	d120      	bne.n	1d87e <register_events+0x84>
		if (event->signal->signaled != 0U) {
   1d83c:	f8db 3010 	ldr.w	r3, [fp, #16]
   1d840:	e001      	b.n	1d846 <register_events+0x4c>
		if (k_sem_count_get(event->sem) > 0) {
   1d842:	f8db 3010 	ldr.w	r3, [fp, #16]
		if (event->signal->signaled != 0U) {
   1d846:	689b      	ldr	r3, [r3, #8]
   1d848:	e002      	b.n	1d850 <register_events+0x56>
		if (!k_queue_is_empty(event->queue)) {
   1d84a:	f8db 3010 	ldr.w	r3, [fp, #16]
   1d84e:	681b      	ldr	r3, [r3, #0]
		if (event->signal->signaled != 0U) {
   1d850:	b1ab      	cbz	r3, 1d87e <register_events+0x84>
	event->state |= state;
   1d852:	f8db 300c 	ldr.w	r3, [fp, #12]
	event->poller = NULL;
   1d856:	f8cb 8008 	str.w	r8, [fp, #8]
	event->state |= state;
   1d85a:	f3c3 3104 	ubfx	r1, r3, #12, #5
   1d85e:	430a      	orrs	r2, r1
   1d860:	f362 3310 	bfi	r3, r2, #12, #5
   1d864:	f8cb 300c 	str.w	r3, [fp, #12]
			poller->is_polling = false;
   1d868:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
   1d86c:	f389 8811 	msr	BASEPRI, r9
   1d870:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   1d874:	f10a 0a01 	add.w	sl, sl, #1
   1d878:	f10b 0b14 	add.w	fp, fp, #20
   1d87c:	e7c7      	b.n	1d80e <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
   1d87e:	2f00      	cmp	r7, #0
   1d880:	d1f4      	bne.n	1d86c <register_events+0x72>
   1d882:	7823      	ldrb	r3, [r4, #0]
   1d884:	2b00      	cmp	r3, #0
   1d886:	d0f1      	beq.n	1d86c <register_events+0x72>
	switch (event->type) {
   1d888:	f89b 300d 	ldrb.w	r3, [fp, #13]
   1d88c:	f003 030f 	and.w	r3, r3, #15
   1d890:	2b02      	cmp	r3, #2
   1d892:	d008      	beq.n	1d8a6 <register_events+0xac>
   1d894:	2b04      	cmp	r3, #4
   1d896:	d006      	beq.n	1d8a6 <register_events+0xac>
   1d898:	2b01      	cmp	r3, #1
   1d89a:	d10b      	bne.n	1d8b4 <register_events+0xba>
		add_event(&event->signal->poll_events, event, poller);
   1d89c:	4622      	mov	r2, r4
   1d89e:	4659      	mov	r1, fp
   1d8a0:	f8db 0010 	ldr.w	r0, [fp, #16]
   1d8a4:	e004      	b.n	1d8b0 <register_events+0xb6>
		add_event(&event->queue->poll_events, event, poller);
   1d8a6:	4622      	mov	r2, r4
   1d8a8:	4659      	mov	r1, fp
   1d8aa:	f8db 0010 	ldr.w	r0, [fp, #16]
   1d8ae:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
   1d8b0:	f7ff ff72 	bl	1d798 <add_event>
	event->poller = poller;
   1d8b4:	f8cb 4008 	str.w	r4, [fp, #8]
				events_registered += 1;
   1d8b8:	3501      	adds	r5, #1
   1d8ba:	e7d7      	b.n	1d86c <register_events+0x72>

0001d8bc <z_handle_obj_poll_events>:

void z_handle_obj_poll_events(sys_dlist_t *events, u32_t state)
{
   1d8bc:	4603      	mov	r3, r0
	return list->head == list;
   1d8be:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   1d8c0:	4283      	cmp	r3, r0
   1d8c2:	d008      	beq.n	1d8d6 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   1d8c4:	e9d0 3200 	ldrd	r3, r2, [r0]
   1d8c8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   1d8ca:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   1d8cc:	2300      	movs	r3, #0
	node->prev = NULL;
   1d8ce:	e9c0 3300 	strd	r3, r3, [r0]
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   1d8d2:	f7ff bf24 	b.w	1d71e <signal_poll_event>
	}
}
   1d8d6:	4770      	bx	lr

0001d8d8 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   1d8d8:	4770      	bx	lr
